"use strict";
(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // node_modules/lang-mini/lang-mini.js
  var require_lang_mini = __commonJS({
    "node_modules/lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              if (ctu == false) break;
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
              if (ctu === false) break;
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "null": "N",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig2 = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          }
          first = false;
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        if (arr.some((subArray) => subArray.length === 0)) {
          return [];
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig2(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else {
              return Object.assign({}, obj2);
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                } else if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return new ctr(input_array);
          } else if (length) {
            return new ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig2(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig2(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig2(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str, 10);
          if (!isNaN(p2) && p2.toString() === str) {
            return p2;
          }
          return void 0;
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig2(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        const t_value = typeof value2;
                        is_valid = data_type.validate(value2);
                        if (t_value === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                        console.log("t_value", t_value);
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    } else {
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig: get_a_sig2,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // node_modules/lang-mini/lib-lang-mini.js
  var require_lib_lang_mini = __commonJS({
    "node_modules/lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // node_modules/lang-tools/collective.js
  var require_collective = __commonJS({
    "node_modules/lang-tools/collective.js"(exports, module) {
      var { each, is_array } = require_lib_lang_mini();
      var collective = (arr) => {
        if (is_array(arr)) {
          const target = {};
          const handler2 = {
            get(target2, prop, receiver) {
              if (arr.hasOwnProperty(prop)) {
                return arr[prop];
              } else {
                if (typeof arr[0][prop] === "function") {
                  return (...a) => {
                    const res2 = [];
                    each(arr, (item2) => {
                      res2.push(item2[prop](...a));
                    });
                    return res2;
                  };
                } else {
                  const res2 = [];
                  each(arr, (item2) => {
                    res2.push(item2[prop]);
                  });
                  return res2;
                }
              }
            }
          };
          const proxy2 = new Proxy(target, handler2);
          return proxy2;
        } else {
          console.trace();
          throw "NYI";
        }
      };
      module.exports = collective;
    }
  });

  // node_modules/lang-tools/Data_Model/Data_Model.js
  var require_Data_Model = __commonJS({
    "node_modules/lang-tools/Data_Model/Data_Model.js"(exports, module) {
      var { Evented_Class } = require_lib_lang_mini();
      var Data_Model = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          this.__data_model = true;
          if (spec && spec.context) {
            this.context = spec.context;
          }
          if (spec && spec.name) {
            this.name = spec.name;
          }
          this.__type = "data_model";
        }
      };
      module.exports = Data_Model;
    }
  });

  // node_modules/lang-tools/Data_Model/new/tools.js
  var require_tools = __commonJS({
    "node_modules/lang-tools/Data_Model/new/tools.js"(exports, module) {
      var Data_Model = require_Data_Model();
      var { tof } = require_lib_lang_mini();
      var more_general_equals = (that2, other) => {
        if (other instanceof Data_Model) {
          const my_json = that2.toJSON();
          const other_json = other.toJSON();
          return my_json === other_json;
        } else {
          if (that2 === other) {
            return true;
          } else {
            if (that2 === void 0) {
              return false;
            } else {
              const { value: value2 } = that2;
              const t_value = tof(value2), t_other = tof(other);
              if (t_value === t_other) {
                if (value2 === other) {
                  return true;
                } else {
                  if (typeof value2.equals === "function" && typeof other.equals === "function") {
                    return value2.equals(other);
                  } else {
                    if (value2 === other) {
                      return true;
                    } else {
                      if (t_value === "number" || t_value === "string" || t_value === "boolean") {
                        return value2 === other;
                      } else {
                        if (t_value === "array") {
                          if (value2.length === other.length) {
                            let res2 = true, c2 = 0, l2 = value2.length;
                            do {
                              res2 = more_general_equals(value2[c2], other[c2]);
                              c2++;
                            } while (res2 === true && c2 < l2);
                            return res2;
                          } else {
                            return false;
                          }
                        } else {
                          console.log("[value, other]", [value2, other]);
                          console.trace();
                          throw "NYI";
                        }
                      }
                    }
                  }
                }
              } else {
                return false;
              }
            }
          }
        }
      };
      module.exports = {
        more_general_equals
      };
    }
  });

  // node_modules/lang-tools/b-plus-tree/stiffarray.js
  var require_stiffarray = __commonJS({
    "node_modules/lang-tools/b-plus-tree/stiffarray.js"(exports, module) {
      var StiffArray = function(capacity) {
        var m_public = {
          items: new Array(capacity),
          // internal storage array
          count: 0,
          // items count
          first: function() {
            if (this.count == 0) throw "StiffArray.first()";
            return this.items[0];
          },
          last: function() {
            if (this.count == 0) throw "StiffArray.last()";
            return this.items[this.count - 1];
          },
          add: function(item2) {
            if (this.count >= capacity) throw "StiffArray.add()";
            this.items[this.count++] = item2;
          },
          add_from: function(source) {
            if (this.count + source.count > capacity) throw "StiffArray.add_from()";
            for (var i = 0; i < source.count; i++) this.items[this.count++] = source.items[i];
          },
          insert: function(index, item2) {
            if (index < 0 || index > this.count) throw "StiffArray.insert(): index";
            if (this.count >= capacity) throw "StiffArray.insert(): overflow";
            for (var i = this.count; i > index; i--) this.items[i] = this.items[i - 1];
            this.items[index] = item2;
            this.count++;
          },
          removeAt: function(index) {
            if (index < 0 || index >= this.count) throw "StiffArray.removeAt()";
            this.count--;
            for (var i = index; i < this.count; i++) this.items[i] = this.items[i + 1];
          },
          removeFirst: function() {
            this.removeAt(0);
          },
          removeLast: function() {
            this.removeAt(this.count - 1);
          },
          copy_from: function(source, index, count) {
            for (var i = 0; i < count; i++) {
              this.items[i] = source.items[i + index];
            }
            this.count = count;
          },
          search_first: function(item2) {
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              if (this.items[index] < item2) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first < this.count) {
              return { found: this.items[first] == item2, index: first };
            }
            return { found: false, index: first };
          },
          search_last: function(item2) {
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              if (item2 >= this.items[index]) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first > 0 && first <= this.count) {
              if (this.items[first - 1] == item2) {
                return { found: true, index: first - 1 };
              }
            }
            return { found: false, index: first };
          },
          search_last_prefix: function(prefix) {
            var prefix_length = prefix.length;
            var check_prefix = function(item3) {
              if (prefix_length > item3.length) return false;
              return item3.substr(0, prefix_length) == prefix;
            };
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              var item2 = this.items[index];
              if (prefix > item2 || check_prefix(item2)) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first > 0 && first <= this.count) {
              if (check_prefix(this.items[first - 1])) {
                return { found: true, index: first - 1 };
              }
            }
            return { found: false, index: first };
          },
          toString: function() {
            return this.items.slice(0, this.count).toString();
          }
        };
        return m_public;
      };
      module.exports = StiffArray;
    }
  });

  // node_modules/lang-tools/b-plus-tree/b-plus-tree.js
  var require_b_plus_tree = __commonJS({
    "node_modules/lang-tools/b-plus-tree/b-plus-tree.js"(exports, module) {
      var StiffArray = require_stiffarray();
      var B_Plus_Node = function(nodeCapacity) {
        var m_public = {
          isLeaf: false,
          parent: null,
          keys: new StiffArray(nodeCapacity + 1),
          // +1: to allow temporary owerflow
          children: new StiffArray(nodeCapacity + 2)
          // +2: children.length == keys.length + 1
        };
        return m_public;
      };
      var B_Plus_Leaf = function(nodeCapacity) {
        var m_public = {
          isLeaf: true,
          parent: null,
          keys: new StiffArray(nodeCapacity + 1),
          values: new StiffArray(nodeCapacity + 1),
          //
          // leafs chain:
          prevLeaf: null,
          nextLeaf: null
        };
        return m_public;
      };
      var FindInfo = (key2, value2, isPrefixSearch) => {
        isPrefixSearch = !!isPrefixSearch;
        var isKeyPresent = key2 != void 0;
        var isValuePresent = value2 != void 0;
        var prefixLength = 0;
        if (isPrefixSearch) {
          if (typeof key2 != "string") {
            isPrefixSearch = false;
          } else {
            prefixLength = key2.length;
          }
        }
        return {
          key: key2,
          // key to find (if present)
          value: value2,
          // value to find (if present)
          isPrefixSearch,
          // prefix search mode
          leaf: null,
          // found leaf
          index: -1,
          // found leaf item index
          isKeyPresent,
          // function () { return this.key !== undefined; }, // is the search criteria contains key
          isValuePresent,
          // function () { return this.value !== undefined; }, // is the search criteria contains value
          foundKey: function() {
            return this.leaf.keys.items[this.index];
          },
          // found items's key
          foundValue: function() {
            return this.leaf.values.items[this.index];
          },
          // found item's value
          //
          prefix_length: prefixLength,
          // prefix length
          check_prefix: function() {
            if (!isPrefixSearch) return false;
            if (this.index >= this.leaf.keys.count) return false;
            var keyToCheck = this.foundKey();
            if (this.prefix_length > keyToCheck.length) return false;
            return keyToCheck.substr(0, this.prefix_length) == this.key;
          }
        };
      };
      var B_Plus_Tree = function(nodeCapacity) {
        if (nodeCapacity === void 0) nodeCapacity = 10;
        if (nodeCapacity < 4) throw "B_Plus_Tree(): node capacity must be >= 4";
        var m_public = {
          // tree root:
          root: new B_Plus_Leaf(nodeCapacity),
          //
          // leafs chain:
          firstLeaf: null,
          //
          lastLeaf: null,
          //
          // ---------------------
          //     editing:
          // ---------------------
          //
          // clear the tree:
          clear: function() {
            p_Clear();
          },
          //
          // insert(key, value)
          // insert([key, value])
          insert: function(key2, value2) {
            if (arguments.length == 2) {
              return p_Insert(key2, value2);
            } else {
              return p_Insert(key2[0], key2[1]);
            }
          },
          //
          // remove(key) - remove all values with given key
          // remove(key, value) - remove one value occurrence
          remove: function(key2, value2) {
            if (arguments.length == 2) {
              return p_Remove(key2, value2);
            } else {
              p_RemoveKey(key2);
            }
          },
          //
          // ---------------------
          //       finding:
          // ---------------------
          //
          // findFirst() - find the very first item
          // findFirst(key) - find the first item for the given key
          // findFirst(key, value) - find the first key+value occurrence
          //
          // returns the FindInfo object:
          //    key: key,     // key to find (if present)
          //    value: value, // value to find (if present)
          //
          //    leaf: null,   // the current found leaf
          //    index: -1,    // the current found index
          //
          //    foundKey():   // the current found key
          //    foundValue(): // the current found value
          //
          findFirst: function(key2, value2) {
            return p_FindFirst(key2, value2);
          },
          //
          // find first key matching the prefix:
          findFirstPrefix: function(prefix) {
            return p_FindFirst(prefix, void 0, true);
          },
          //
          // find next search conditions occurence
          findNext: function(findInfo) {
            return p_FindNext(findInfo);
          },
          //
          // findLast() - find the very last item
          // findLast(key) - find the last item for the given key
          // findLast(key, value) - find the last key+value occurrence
          findLast: function(key2, value2) {
            return p_FindLast(key2, value2);
          },
          //
          // find last key matching the prefix:
          findLastPrefix: function(prefix) {
            return p_FindLast(prefix, void 0, true);
          },
          //
          // find previous search conditions occurence
          findPrevious: function(findInfo) {
            return p_FindPrev(findInfo);
          },
          //
          // ---------------------
          // dictionary-like usage:
          // ---------------------
          //
          // get one value by key (or null):
          getValue: function(key2) {
            return p_GetValue(key2);
          },
          // set one value by key (insert or update):
          setValue: function(key2, value2) {
            p_SetValue(key2, value2);
          },
          //
          //
          // ---------------------
          //   other functions:
          // ---------------------
          //
          // count() - count all values
          // count(key) - count values with the given key
          count: function(key2) {
            if (arguments.length == 1) {
              return p_CountKey(key2);
            } else {
              return p_Count();
            }
          },
          //
          // tree capacity:
          getCapacity: function() {
            return m_nodeMaxCount;
          },
          //
          // ---------------------
          // additional functions:
          // ---------------------
          //
          // iterate through each key + value pair
          // callback is function(key, value)
          "each": function(callback2) {
            return p_each(callback2);
          },
          //
          // get all keys
          "keys": function() {
            return p_keys();
          },
          //
          // get all [key, value] pairs
          "keys_and_values": function() {
            return p_keys_and_values();
          },
          //
          //
          // get keys and values by prefix
          "get_by_prefix": function(prefix) {
            return p_get_by_prefix(prefix);
          },
          //
          // get keys by prefix
          "get_keys_by_prefix": function(prefix) {
            return p_get_keys_by_prefix(prefix);
          },
          //
          // get values at key...
          "get_values_by_key": function(key2) {
            return p_get_values_by_key(key2);
          }
        };
        m_public.firstLeaf = m_public.root;
        m_public.lastLeaf = m_public.root;
        var m_nodeMaxCount = nodeCapacity;
        var m_nodeMinCount = Math.floor(m_nodeMaxCount / 2);
        var p_Clear = function() {
          m_public.root = new B_Plus_Leaf(m_nodeMaxCount);
          m_public.firstLeaf = m_public.root;
          m_public.lastLeaf = m_public.root;
        };
        var p_keys = function() {
          var res2 = [];
          _p_each_key(function(key2) {
            res2.push(key2);
          });
          return res2;
        };
        var p_keys_and_values = function() {
          var res2 = [];
          p_each(function(key2, value2) {
            res2.push([key2, value2]);
          });
          return res2;
        };
        var _p_each_key = function(callback2) {
          var findInfo = p_FindFirst();
          while (findInfo != null) {
            var fk = findInfo.foundKey();
            callback2(fk);
            findInfo = p_FindNext(findInfo);
          }
        };
        var p_each = function(callback2) {
          var findInfo = p_FindFirst();
          var doStop = false;
          while (findInfo != null) {
            var fk = findInfo.foundKey();
            var fv = findInfo.foundValue();
            callback2(fk, fv, function() {
              doStop = true;
            });
            if (doStop) {
              findInfo = null;
            } else {
              findInfo = p_FindNext(findInfo);
            }
          }
        };
        var p_Insert = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          var leaf = searchResult.node;
          leaf.keys.insert(searchResult.index, key2);
          leaf.values.insert(searchResult.index, value2);
          if (leaf.keys.count > m_nodeMaxCount) {
            if (leaf.prevLeaf != null && leaf.prevLeaf.keys.count < m_nodeMaxCount && leaf.prevLeaf.parent == leaf.parent) {
              rotateAmongLeavesToLeft(leaf.prevLeaf, leaf);
            } else if (leaf.nextLeaf != null && leaf.nextLeaf.keys.count < m_nodeMaxCount && leaf.nextLeaf.parent == leaf.parent) {
              rotateAmongLeavesToRight(leaf, leaf.nextLeaf);
            } else {
              splitLeaf(leaf);
            }
          }
        };
        var splitLeaf = function(leaf) {
          var leftCount = m_nodeMinCount;
          var rightCount = leaf.keys.count - leftCount;
          var newRightLeaf = new B_Plus_Leaf(m_nodeMaxCount);
          newRightLeaf.parent = leaf.parent;
          newRightLeaf.keys.copy_from(leaf.keys, leftCount, rightCount);
          newRightLeaf.values.copy_from(leaf.values, leftCount, rightCount);
          leaf.keys.count = leftCount;
          leaf.values.count = leftCount;
          newRightLeaf.nextLeaf = leaf.nextLeaf;
          if (newRightLeaf.nextLeaf != null) newRightLeaf.nextLeaf.prevLeaf = newRightLeaf;
          newRightLeaf.prevLeaf = leaf;
          leaf.nextLeaf = newRightLeaf;
          if (m_public.lastLeaf == leaf) m_public.lastLeaf = newRightLeaf;
          if (leaf.parent != null) {
            var leafIndex = calcChildIndex(leaf.parent, leaf);
            insertToParent(leaf.parent, newRightLeaf, newRightLeaf.keys.first(), leafIndex + 1);
          } else {
            createNewRoot(leaf, newRightLeaf, newRightLeaf.keys.first());
          }
        };
        var createNewRoot = function(nodeLeft, nodeRight, key2) {
          var newRoot = new B_Plus_Node(m_nodeMaxCount);
          newRoot.keys.add(key2);
          newRoot.children.add(nodeLeft);
          newRoot.children.add(nodeRight);
          nodeLeft.parent = newRoot;
          nodeRight.parent = newRoot;
          m_public.root = newRoot;
        };
        var insertToParent = function(parentNode, newChildNode, newChildFirstKey, newChildIndex) {
          parentNode.keys.insert(newChildIndex - 1, newChildFirstKey);
          parentNode.children.insert(newChildIndex, newChildNode);
          newChildNode.parent = parentNode;
          if (parentNode.keys.count > m_nodeMaxCount) {
            splitNode(parentNode);
          }
        };
        var splitNode = function(node) {
          var newLeftCount = m_nodeMinCount;
          var newRightCount = m_nodeMaxCount - newLeftCount;
          var middleKey = node.keys.items[newLeftCount];
          var newRightNode = new B_Plus_Node(m_nodeMaxCount);
          newRightNode.keys.copy_from(node.keys, newLeftCount + 1, newRightCount);
          newRightNode.children.copy_from(node.children, newLeftCount + 1, newRightCount + 1);
          node.keys.count = newLeftCount;
          node.children.count = newLeftCount + 1;
          for (var i = 0; i < newRightNode.children.count; i++) newRightNode.children.items[i].parent = newRightNode;
          if (node.parent == null) {
            createNewRoot(node, newRightNode, middleKey);
          } else {
            var nodeIndex = calcChildIndex(node.parent, node);
            insertToParent(node.parent, newRightNode, middleKey, nodeIndex + 1);
          }
        };
        var p_Remove = function(key2, value2) {
          var searchResult = searchLeafValue(key2, value2);
          if (!searchResult.found) return false;
          removeFromLeaf(searchResult.node, searchResult.index);
          return true;
        };
        var p_RemoveKey = function(key2) {
          while (true) {
            var searchResult = searchLeaf(key2);
            if (!searchResult.found) break;
            removeFromLeaf(searchResult.node, searchResult.index);
          }
        };
        var removeFromLeaf = function(leaf, index) {
          leaf.keys.removeAt(index);
          leaf.values.removeAt(index);
          if (leaf.keys.count < m_nodeMinCount) {
            if (leaf.prevLeaf != null && leaf.parent == leaf.prevLeaf.parent && leaf.prevLeaf.keys.count > m_nodeMinCount) {
              rotateAmongLeavesToRight(leaf.prevLeaf, leaf);
            } else if (leaf.nextLeaf != null && leaf.parent == leaf.nextLeaf.parent && leaf.nextLeaf.keys.count > m_nodeMinCount) {
              rotateAmongLeavesToLeft(leaf, leaf.nextLeaf);
            } else {
              mergeLeaf(leaf);
            }
          }
          return true;
        };
        var mergeLeaf = function(leaf) {
          if (leaf.parent == null) {
            return;
          }
          var leftCount = m_nodeMaxCount + 1;
          var rightCount = m_nodeMaxCount + 1;
          if (leaf.prevLeaf != null && leaf.prevLeaf.parent == leaf.parent) {
            leftCount = leaf.prevLeaf.keys.count;
          }
          if (leaf.nextLeaf != null && leaf.nextLeaf.parent == leaf.parent) {
            rightCount = leaf.nextLeaf.keys.count;
          }
          if (leftCount < rightCount) {
            if (leftCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): leftCount";
            mergeLeaves(leaf.prevLeaf, leaf);
          } else {
            if (rightCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): rightCount";
            mergeLeaves(leaf, leaf.nextLeaf);
          }
        };
        var mergeLeaves = function(leafLeft, leafRight) {
          leafLeft.keys.add_from(leafRight.keys);
          leafLeft.values.add_from(leafRight.values);
          leafLeft.nextLeaf = leafRight.nextLeaf;
          if (leafLeft.nextLeaf != null) leafLeft.nextLeaf.prevLeaf = leafLeft;
          if (m_public.lastLeaf == leafRight) m_public.lastLeaf = leafLeft;
          var parent = leafRight.parent;
          var leafRightIndex = calcChildIndex(parent, leafRight);
          parent.keys.removeAt(leafRightIndex - 1);
          parent.children.removeAt(leafRightIndex);
          if (parent.keys.count < m_nodeMinCount) {
            mergeNode(parent);
          }
          ;
        };
        var mergeNode = function(node) {
          var parent = node.parent;
          if (node.parent == null) {
            if (node.keys.count == 0) {
              m_public.root = node.children.items[0];
              m_public.root.parent = null;
            }
            return;
          }
          var nodeIndex = calcChildIndex(parent, node);
          var leftSibling = nodeIndex > 0 ? parent.children.items[nodeIndex - 1] : null;
          var rightSibling = nodeIndex + 1 < parent.children.count ? parent.children.items[nodeIndex + 1] : null;
          if (leftSibling != null && leftSibling.keys.count > m_nodeMinCount) {
            rotateAmongNodesToRight(leftSibling, node);
            return;
          }
          if (rightSibling != null && rightSibling.keys.count > m_nodeMinCount) {
            rotateAmongNodesToLeft(node, rightSibling);
            return;
          }
          var leftCount = m_nodeMaxCount + 1;
          var rightCount = m_nodeMaxCount + 1;
          if (leftSibling != null) {
            leftCount = leftSibling.keys.count;
          }
          if (rightSibling != null) {
            rightCount = rightSibling.keys.count;
          }
          if (leftCount < rightCount) {
            if (leftSibling == null) throw "B_Plus_Tree.mergeNode(): leftSibling";
            mergeNodes(leftSibling, node, nodeIndex);
          } else {
            if (rightSibling == null) throw "B_Plus_Tree.mergeNode(): rightSibling";
            mergeNodes(node, rightSibling, nodeIndex + 1);
          }
        };
        var mergeNodes = function(nodeLeft, nodeRight, nodeRightIndex) {
          var parent = nodeLeft.parent;
          for (var i = 0; i < nodeRight.children.count; i++) nodeRight.children.items[i].parent = nodeLeft;
          nodeLeft.keys.add(nodeLeft.parent.keys.items[nodeRightIndex - 1]);
          nodeLeft.keys.add_from(nodeRight.keys);
          nodeLeft.children.add_from(nodeRight.children);
          parent.keys.removeAt(nodeRightIndex - 1);
          parent.children.removeAt(nodeRightIndex);
          if (parent.keys.count < m_nodeMinCount) {
            mergeNode(parent);
          }
          ;
        };
        var p_FindFirst = function(key2, value2, isPrefixSearch) {
          var findInfo = FindInfo(key2, value2, isPrefixSearch);
          if (findInfo.isKeyPresent) {
            if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindFirst(): arguments error: isPrefixSearch, but value is present";
            var searchResult = findInfo.isValuePresent ? searchLeafValue(key2, value2) : searchLeaf(key2);
            findInfo.leaf = searchResult.node;
            findInfo.index = searchResult.index;
            if (!searchResult.found) {
              if (!findInfo.check_prefix()) {
                return null;
              }
            }
          } else {
            if (findInfo.isValuePresent) throw "B_Plus_Tree.findFirst(): arguments error: key is not present, but value is present";
            findInfo.leaf = m_public.firstLeaf;
            findInfo.index = 0;
            if (findInfo.leaf.keys.count <= 0) return null;
          }
          return findInfo;
        };
        var p_FindLast = function(key2, value2, isPrefixSearch) {
          var findInfo = new FindInfo(key2, value2, isPrefixSearch);
          if (findInfo.isKeyPresent) {
            if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindLast(): arguments error: isPrefixSearch, but value is present";
            if (findInfo.isPrefixSearch) {
              var searchResult = searchLastLeafByPrefix(key2);
              findInfo.leaf = searchResult.node;
              findInfo.index = searchResult.index;
              if (!searchResult.found) {
                return null;
              }
            } else {
              var searchResult = findInfo.isValuePresent ? searchLastLeafValue(key2, value2) : searchLastLeaf(key2);
              findInfo.leaf = searchResult.node;
              findInfo.index = searchResult.index;
              if (!searchResult.found) {
                return null;
              }
            }
          } else {
            if (findInfo.isValuePresent) throw "B_Plus_Tree.findLast(): arguments error: key is not present, but value is present";
            findInfo.leaf = m_public.lastLeaf;
            findInfo.index = findInfo.leaf.keys.count - 1;
            if (findInfo.index < 0) return null;
          }
          return findInfo;
        };
        var findGoToNext = function(findInfo) {
          findInfo.index++;
          if (findInfo.index >= findInfo.leaf.keys.count) {
            findInfo.leaf = findInfo.leaf.nextLeaf;
            findInfo.index = 0;
          }
          return findInfo.leaf != null;
        };
        var findGoToPrev = function(findInfo) {
          findInfo.index--;
          if (findInfo.index < 0) {
            findInfo.leaf = findInfo.leaf.prevLeaf;
            if (findInfo.leaf == null) return false;
            findInfo.index = findInfo.leaf.keys.count - 1;
          }
          return true;
        };
        var p_FindNext = function(findInfo) {
          while (true) {
            if (!findGoToNext(findInfo)) return null;
            if (findInfo.isPrefixSearch) {
              if (!findInfo.check_prefix()) return null;
            } else {
              if (findInfo.isKeyPresent && findInfo.key != findInfo.foundKey()) return null;
            }
            if (findInfo.isValuePresent) {
              if (findInfo.value == findInfo.foundValue()) return findInfo;
            } else {
              return findInfo;
            }
          }
        };
        var p_FindPrev = function(findInfo) {
          while (true) {
            if (!findGoToPrev(findInfo)) return null;
            if (findInfo.isPrefixSearch) {
              if (!findInfo.check_prefix()) return null;
            } else {
              if (findInfo.isKeyPresent && findInfo.key != findInfo.foundKey()) return null;
            }
            if (findInfo.isValuePresent) {
              if (findInfo.value == findInfo.foundValue()) return findInfo;
            } else {
              return findInfo;
            }
          }
        };
        var p_get_values_by_key = function(key2) {
          var res2 = [];
          var findInfo = p_FindFirst(key2);
          while (findInfo != null) {
            res2.push(findInfo.foundValue());
            findInfo = p_FindNext(findInfo);
          }
          return res2;
        };
        var p_get_by_prefix = function(prefix) {
          var res2 = [];
          var findInfo = m_public.findFirstPrefix(prefix);
          while (findInfo != null) {
            res2.push([findInfo.foundKey(), findInfo.foundValue()]);
            findInfo = m_public.findNext(findInfo);
          }
          return res2;
        };
        var p_get_keys_by_prefix = function(prefix) {
          var res2 = [];
          var findInfo = m_public.findFirstPrefix(prefix);
          while (findInfo != null) {
            res2.push(findInfo.foundKey());
            findInfo = m_public.findNext(findInfo);
          }
          return res2;
        };
        var p_GetValue = function(key2) {
          var searchResult = searchLeaf(key2);
          if (!searchResult.found) return null;
          return searchResult.node.values.items[searchResult.index];
        };
        var p_SetValue = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          if (searchResult.found) {
            removeFromLeaf(searchResult.node, searchResult.index);
          }
          p_Insert(key2, value2);
        };
        var p_Count = function() {
          var result = 0;
          var leaf = m_public.firstLeaf;
          while (leaf != null) {
            result += leaf.keys.count;
            leaf = leaf.nextLeaf;
          }
          return result;
        };
        var p_CountKey = function(key2) {
          var result = 0;
          var findInfo = m_public.findFirst(key2);
          while (findInfo != null) {
            result++;
            findInfo = m_public.findNext(findInfo);
          }
          return result;
        };
        var rotateAmongNodesToLeft = function(leftNode, rightNode) {
          var parent = rightNode.parent;
          var rightIndex = calcChildIndex(parent, rightNode);
          leftNode.keys.add(parent.keys.items[rightIndex - 1]);
          parent.keys.items[rightIndex - 1] = rightNode.keys.first();
          rightNode.keys.removeFirst();
          rightNode.children.first().parent = leftNode;
          leftNode.children.add(rightNode.children.first());
          rightNode.children.removeFirst();
        };
        var rotateAmongNodesToRight = function(leftNode, rightNode) {
          var parent = rightNode.parent;
          var rightIndex = calcChildIndex(parent, rightNode);
          rightNode.keys.insert(0, parent.keys.items[rightIndex - 1]);
          parent.keys.items[rightIndex - 1] = leftNode.keys.last();
          leftNode.keys.removeLast();
          rightNode.children.insert(0, leftNode.children.last());
          rightNode.children.first().parent = rightNode;
          leftNode.children.removeLast();
        };
        var rotateAmongLeavesToLeft = function(leftLeaf, rightLeaf) {
          var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
          leftLeaf.keys.add(rightLeaf.keys.first());
          leftLeaf.values.add(rightLeaf.values.first());
          rightLeaf.keys.removeFirst();
          rightLeaf.values.removeFirst();
          rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
        };
        var rotateAmongLeavesToRight = function(leftLeaf, rightLeaf) {
          var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
          rightLeaf.keys.insert(0, leftLeaf.keys.last());
          rightLeaf.values.insert(0, leftLeaf.values.last());
          leftLeaf.keys.removeLast();
          leftLeaf.values.removeLast();
          rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
        };
        var calcChildIndex = function(node, child) {
          var key2 = child.keys.first();
          var searchResult = node.keys.search_first(key2);
          if (!searchResult.found) {
            if (node.children.items[searchResult.index] != child) throw "B_PlusTree.calcChildIndex(): 1";
            return searchResult.index;
          }
          var index = searchResult.index;
          for (; ; ) {
            if (node.children.items[index] == child) return index;
            index++;
            if (index >= node.children.count) break;
            if (node.keys.items[index - 1] != key2) break;
          }
          throw "B_PlusTree.calcChildIndex(): 2";
        };
        var searchLeaf = function(key2) {
          var doSearchLeaf = function(node, key3) {
            var searchResult = node.keys.search_first(key3);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultLeft = doSearchLeaf(node.children.items[searchResult.index], key3);
              if (resultLeft.found) return resultLeft;
              return doSearchLeaf(node.children.items[searchResult.index + 1], key3);
            } else {
              return doSearchLeaf(node.children.items[searchResult.index], key3);
            }
          };
          return doSearchLeaf(m_public.root, key2);
        };
        var searchLastLeaf = function(key2) {
          var doSearchLastLeaf = function(node, key3) {
            var searchResult = node.keys.search_last(key3);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultRight = doSearchLastLeaf(node.children.items[searchResult.index + 1], key3);
              if (resultRight.found) return resultRight;
              return doSearchLastLeaf(node.children.items[searchResult.index], key3);
            } else {
              return doSearchLastLeaf(node.children.items[searchResult.index], key3);
            }
          };
          return doSearchLastLeaf(m_public.root, key2);
        };
        var searchLastLeafByPrefix = function(prefix) {
          var doSearchLastLeafByPrefix = function(node, prefix2) {
            var searchResult = node.keys.search_last_prefix(prefix2);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultRight = doSearchLastLeafByPrefix(node.children.items[searchResult.index + 1], prefix2);
              if (resultRight.found) return resultRight;
              return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix2);
            } else {
              return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix2);
            }
          };
          return doSearchLastLeafByPrefix(m_public.root, prefix);
        };
        var searchLeafValue = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          if (!searchResult.found) return searchResult;
          var valueFound = false;
          var leaf = searchResult.node;
          var index = searchResult.index;
          for (; ; ) {
            if (index >= leaf.values.count) {
              leaf = leaf.nextLeaf;
              if (leaf == null) break;
              index = 0;
            }
            if (leaf.keys.items[index] != key2) break;
            if (leaf.values.items[index] == value2) {
              valueFound = true;
              break;
            }
            index++;
          }
          return { node: leaf, found: valueFound, index };
        };
        var searchLastLeafValue = function(key2, value2) {
          var searchResult = searchLastLeaf(key2);
          if (!searchResult.found) return searchResult;
          var valueFound = false;
          var leaf = searchResult.node;
          var index = searchResult.index;
          for (; ; ) {
            if (index < 0) {
              leaf = leaf.prevLeaf;
              if (leaf == null) break;
              index = leaf.values.count - 1;
            }
            if (leaf.keys.items[index] != key2) break;
            if (leaf.values.items[index] == value2) {
              valueFound = true;
              break;
            }
            index--;
          }
          return { node: leaf, found: valueFound, index };
        };
        return m_public;
      };
      B_Plus_Tree.FindInfo = FindInfo;
      module.exports = B_Plus_Tree;
    }
  });

  // node_modules/lang-tools/Data_Model/old/Data_Value.js
  var require_Data_Value = __commonJS({
    "node_modules/lang-tools/Data_Model/old/Data_Value.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var Data_Model = require_Data_Model();
      var j = jsgui2;
      var Evented_Class = j.Evented_Class;
      var each = j.each;
      var is_array = j.is_array;
      var is_dom_node = j.is_dom_node;
      var is_ctrl = j.is_ctrl;
      var extend = j.extend;
      var get_truth_map_from_arr = j.get_truth_map_from_arr;
      var get_map_from_arr = j.get_map_from_arr;
      var arr_like_to_arr = j.arr_like_to_arr;
      var tof = j.tof;
      var is_defined = j.is_defined;
      var stringify = j.stringify;
      var functional_polymorphism = j.functional_polymorphism;
      var fp = j.fp;
      var arrayify = j.arrayify;
      var mapify = j.mapify;
      var are_equal = j.are_equal;
      var get_item_sig = j.get_item_sig;
      var set_vals = j.set_vals;
      var truth = j.truth;
      var trim_sig_brackets = j.trim_sig_brackets;
      var ll_set = j.ll_set;
      var ll_get = j.ll_get;
      var input_processors = j.input_processors;
      var iterate_ancestor_classes = j.iterate_ancestor_classes;
      var is_arr_of_arrs = j.is_arr_of_arrs;
      var is_arr_of_strs = j.is_arr_of_strs;
      var is_arr_of_t = j.is_arr_of_t;
      var clone = jsgui2.clone;
      var input_processors = jsgui2.input_processors;
      var Data_Value2 = class _Data_Value extends Data_Model {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          if (spec.context) {
            this.context = spec.context;
          }
          if (is_defined(spec.value)) {
            this._ = spec.value;
          }
          this.__type = "data_value";
          this._relationships = {};
        }
        // Get but with a format change?
        //   Get and validate???
        "get"() {
          return this._;
        }
        // get value and set value.
        "value"() {
          return this._;
        }
        "toObject"() {
          return this._;
        }
        // .value =
        //   Though .set could have more input, eg a format shifter????
        "set"(val) {
          var input_processor = input_processors[this.__type_name];
          if (input_processor) {
            val = input_processor(val);
          }
          var old_val = this._;
          this._ = val;
          this.raise("change", {
            "old": old_val,
            "value": val
          });
          return val;
        }
        "toString"() {
          return this.get();
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          var val = this.get();
          var tval = typeof val;
          if (tval == "string") {
            return '"' + val + '"';
          } else {
            return val;
          }
        }
        // Need to copy / clone the ._ value
        "clone"() {
          var res2 = new _Data_Value({
            "value": this._
          });
          return res2;
        }
        // This is important to the running of jsgui3.
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "DataValue should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
        "parent"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          var obj2, index;
          if (a.l == 0) {
            return this._parent;
          } else if (a.l == 1) {
            obj2 = a[0];
            if (!this.context && obj2.context) {
              this.context = obj2.context;
            }
            var relate_by_id = function(that2) {
              var obj_id = obj2._id();
              that2._relationships[obj_id] = true;
            };
            var relate_by_ref = function(that2) {
              that2._parent = obj2;
            };
            relate_by_ref(this);
          } else if (a.l == 2) {
            obj2 = a[0];
            index = a[1];
            if (!this.context && obj2.context) {
              this.context = obj2.context;
            }
            this._parent = obj2;
            this._index = index;
          }
        }
      };
      module.exports = Data_Value2;
    }
  });

  // node_modules/lang-tools/Data_Model/Mini_Context.js
  var require_Mini_Context = __commonJS({
    "node_modules/lang-tools/Data_Model/Mini_Context.js"(exports, module) {
      var Mini_Context = class {
        // Need quite a simple mechanism to get IDs for objects.
        // They will be typed objects/
        constructor(spec) {
          var map_typed_counts = {};
          var typed_id = function(str_type) {
            throw "stop Mini_Context typed id";
            var res2;
            if (!map_typed_counts[str_type]) {
              res2 = str_type + "_0";
              map_typed_counts[str_type] = 1;
            } else {
              res2 = str_type + "_" + map_typed_counts[str_type];
              map_typed_counts[str_type]++;
            }
            return res2;
          };
          this.new_id = typed_id;
        }
        "make"(abstract_object) {
          if (abstract_object._abstract) {
            var constructor = abstract_object.constructor;
            var aos = abstract_object._spec;
            aos.abstract = null;
            aos.context = this;
            var res2 = new constructor(aos);
            return res2;
          } else {
            throw "Object must be abstract, having ._abstract == true";
          }
        }
      };
      module.exports = Mini_Context;
    }
  });

  // node_modules/lang-tools/Data_Model/old/Data_Object.js
  var require_Data_Object = __commonJS({
    "node_modules/lang-tools/Data_Model/old/Data_Object.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var Data_Value2 = require_Data_Value();
      var j = jsgui2;
      var Evented_Class = j.Evented_Class;
      var Class = j.Class;
      var each = j.each;
      var is_array = j.is_array;
      var is_dom_node = j.is_dom_node;
      var is_ctrl = j.is_ctrl;
      var extend = j.extend;
      var get_truth_map_from_arr = j.get_truth_map_from_arr;
      var get_map_from_arr = j.get_map_from_arr;
      var arr_like_to_arr = j.arr_like_to_arr;
      var tof = j.tof;
      var is_defined = j.is_defined;
      var stringify = j.stringify;
      var functional_polymorphism = j.functional_polymorphism;
      var fp = j.fp;
      var arrayify = j.arrayify;
      var mapify = j.mapify;
      var are_equal = j.are_equal;
      var get_item_sig = j.get_item_sig;
      var get_a_sig2 = j.get_a_sig;
      var set_vals = j.set_vals;
      var truth = j.truth;
      var trim_sig_brackets = j.trim_sig_brackets;
      var ll_set = j.ll_set;
      var ll_get = j.ll_get;
      var input_processors = j.input_processors;
      var iterate_ancestor_classes = j.iterate_ancestor_classes;
      var is_arr_of_arrs = j.is_arr_of_arrs;
      var is_arr_of_strs = j.is_arr_of_strs;
      var is_arr_of_t = j.is_arr_of_t;
      var clone = jsgui2.clone;
      jsgui2.__data_id_method = "init";
      var Mini_Context = require_Mini_Context();
      var Data_Model = require_Data_Model();
      var is_js_native = function(obj2) {
        var t = tof(obj2);
        return t == "number" || t == "string" || t == "boolean" || t == "array";
      };
      var Data_Object = class extends Data_Model {
        constructor(spec = {}, fields) {
          super(spec);
          if (spec.id) {
            this.__id = spec.id;
          }
          if (spec.__id) {
            this.__id = spec.__id;
          }
          this.__type_name = spec.__type_name || "data_object";
          if (fields) this.set_fields_from_spec(fields, spec);
          this.__data_object = true;
          if (spec.abstract === true) {
            this._abstract = true;
            var tSpec = tof(spec);
            if (tSpec == "function") {
              this._type_constructor = spec;
            } else if (tSpec == "object") {
              this._spec = spec;
            }
          } else {
            var t_spec = tof(spec);
            if (!this.__type) {
              this.__type = "data_object";
            }
            if (t_spec === "object" || t_spec === "control") {
              if (spec.context) {
                this.context = spec.context;
              }
              if (spec.id) {
                this.__id = spec.id;
              }
              if (spec._id) {
                this.__id = spec._id;
              }
              if (spec.__id) {
                this.__id = spec.__id;
              }
            } else if (t_spec == "data_object") {
              if (spec.context) this.context = spec.context;
            }
            if (is_defined(spec.parent)) {
              this.parent = spec.parent;
            }
            if (this.context) {
              this.init_default_events();
            }
          }
        }
        "set_fields_from_spec"(fields, spec) {
          each(fields, (field) => {
            if (typeof spec[field[0]] !== "undefined") {
              this[field[0]] = spec[field[0]];
            } else {
              this[field[0]] = field[2];
            }
          });
        }
        "init_default_events"() {
        }
        /*
             'data_def': fp(function(a, sig) {
             if (sig == '[o]') {
             // create the new data_def constraint.
        
        
             }
             }),
             */
        "keys"() {
          return Object.keys(this._);
        }
        "toJSON"() {
          var res2 = [];
          res2.push("Data_Object(" + JSON.stringify(this._) + ")");
          return res2.join("");
        }
        // using_fields_connection()
        //  will search up the object heirachy, to see if the Data_Objects fields need to be connected through the use of functions.
        //  that will make the fields easy to change by calling a function. Should make things much faster to access than when programming with Backbone.
        // then will connect the fields with connect_fields()
        /*
        'using_fields_connection'() {
            var res = false;
            iterate_ancestor_classes(this.constructor, function (a_class, stop) {
                if (is_defined(a_class._connect_fields)) {
                    res = a_class._connect_fields;
                    stop();
                }
            });
            return res;
        }
        */
        get parent() {
          return this._parent;
        }
        set parent(value2) {
          return this._parent = value2;
        }
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (this._abstract) {
              return void 0;
            } else if (!is_defined(this.__id)) {
              return void 0;
            }
          }
          return this.__id;
        }
        // Problems with name (fields).
        //  Fields are given as a description of the fields.
        //   Gets more complicated when we have a function to access the fields as well.
        //   What if we want to override that function?
        // Will call it field
        //  18/12/2016 - Getting rid of this confusion, will mostly remove / greatly simplify field functionality.
        //  Just need to know which fields any class has, keeping track of this will use some data structures like Sorted_KVS,
        //   but not much complex code within this part.
        // Not so sure what a field function will do right now.
        //  Does not seem like such an essential part of the API.
        //   Can just define the fields, then they act a bit differently.
        //   Have field handling in Data_Object.
        //   Collection would have the same field capabilities. Fields should not be so important anyway.
        // 18/12/2016 Will remove constraints, then make them much more functional.
        "each"(callback2) {
          each(this._, callback2);
        }
        // could make this polymorphic so that it
        "position_within"(parent) {
          var p_id = parent._id();
          if (this._parents && is_defined(this._parents[p_id])) {
            var parent_rel_info = this._parents[p_id];
            var pos_within = parent_rel_info[1];
            return pos_within;
          }
        }
        // Maybe just 'remove' function.
        //  This may be needed with multiple parents, which are not being used at the moment.
        "remove_from"(parent) {
          var p_id = parent._id();
          if (this._parents && is_defined(this._parents[p_id])) {
            var parent = this._parents[p_id][0];
            var pos_within = this._parents[p_id][1];
            var item2 = parent._arr[pos_within];
            parent.remove(pos_within);
            delete this._parents[p_id];
          }
        }
        //  
        // Maybe only do this with the fields anyway
        "load_from_spec"(spec, arr_item_names) {
          each(arr_item_names, (v) => {
            var spec_item = spec[v];
            if (is_defined(spec_item)) {
              this.set(v, spec_item);
            }
          });
        }
        // They will be treated as values in many cases anyway.
        //  Will turn them to different types of object where possible.
        /*
            'value'() {
                var a = arguments; a.l = arguments.length; var sig = get_a_sig(a, 1);
                // could operate like both get and set, but does not return data_objects, returns the value itself.
                var name;
                //var res;
                if (sig === '[s]') {
                    name = a[0];
                    var possibly_dobj = this.get(name);
                    //var t_obj = tof(possibly_dobj);
        
                    if (possibly_dobj) {
                        if (possibly_dobj.value && typeof possibly_dobj.value === 'function') {
                            return possibly_dobj.value();
                        } else {
                            return possibly_dobj;
                        }
                    }
                }
            }
            */
        // Get could be greatly simplified as well.
        //  Input and output processing will be more streamlined in a functional way.
        // 19/12/2016 - Not using get or set nearly as much anyway.
        "get"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          var do_typed_processing = false;
          if (do_typed_processing) {
            if (a.l === 0) {
              var output_obj = jsgui2.output_processors[this.__type_name](this._);
              return output_obj;
            } else {
              console.log("a", a);
              console.trace();
              throw "not yet implemented";
            }
          } else {
            if (sig == "[s,f]") {
              throw "Asyncronous access not allowed on Data_Object get.";
              var res2 = this.get(a[0]);
              var callback2 = a[1];
              if (typeof res2 == "function") {
                res2(callback2);
              } else {
                return res2;
              }
            } else if (sig == "[s]") {
              var res2 = ll_get(this, a[0]);
              return res2;
            } else if (a.l === 0) {
              return this._;
            }
          }
        }
        // Or don't use / support get and set for the moment?
        //   Only use property / field access?
        //   Define property, with getter and setter, seems like a more cleanly defined system.
        // May see about making a new simplified implementation of this and running it through tests.
        //   Though the new Data_Value seems like the more appropriate way for the moment.
        // May look into seeing where Data_Value is used in the current system too.
        //   Could see about further incorportating its use (in places).
        //'set': fp(function(a, sig) {
        "set"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (this._abstract) return false;
          var that2 = this, res2;
          var input_processors2 = jsgui2.input_processors;
          if (a.l == 2 || a.l == 3) {
            var property_name = a[0], value2 = a[1];
            var ta2 = tof(a[2]);
            var silent = false;
            var source;
            if (ta2 == "string" || ta2 == "boolean") {
              silent = a[2];
            }
            if (ta2 == "control") {
              source = a[2];
            }
            if (!this._initializing && this._map_read_only && this._map_read_only[property_name]) {
              throw 'Property "' + property_name + '" is read-only.';
            } else {
              var split_pn = property_name.split(".");
              if (split_pn.length > 1 && property_name != ".") {
                var spn_first = split_pn[0];
                var spn_arr_next = split_pn.slice(1);
                var data_object_next = this.get(spn_first);
                if (data_object_next) {
                  res2 = data_object_next.set(spn_arr_next.join("."), value2);
                  if (!silent) {
                    var e_change = {
                      "name": property_name,
                      "value": value2,
                      "bubbled": true
                    };
                    if (source) {
                      e_change.source = source;
                    }
                    this.raise_event("change", e_change);
                  }
                } else {
                  throw "No data object at this level.";
                }
              } else {
                var data_object_next = this.get(property_name);
                if (data_object_next) {
                  var field = this[property_name];
                  if (field) {
                    data_object_next.__type_name = field[1] || data_object_next.__type_name;
                  }
                  data_object_next.set(value2);
                }
                if (!is_defined(data_object_next)) {
                  var tv = typeof value2;
                  var dv;
                  if (tv === "string" || tv === "number" || tv === "boolean" || tv === "date") {
                    dv = new Data_Value2({
                      "value": value2
                    });
                  } else {
                    if (tv === "array") {
                      dv = new Data_Value2({
                        "value": value2
                      });
                    } else {
                      if (tv === "object") {
                        if (value2.__data_object || value2.__data_value || value2.__data_grid) {
                          dv = value2;
                        } else {
                          dv = new Data_Value2({
                            "value": value2
                          });
                        }
                      } else {
                        dv = value2;
                      }
                    }
                  }
                  this[property_name] = dv;
                  if (!silent) {
                    e_change = {
                      "name": property_name,
                      "value": dv
                    };
                    if (source) {
                      e_change.source = source;
                    }
                    this.raise_event("change", e_change);
                  }
                  return value2;
                } else {
                  var next_is_js_native = is_js_native(data_object_next);
                  if (next_is_js_native) {
                    this[property_name] = value2;
                    res2 = value2;
                  } else {
                    res2 = data_object_next;
                    this[property_name] = data_object_next;
                  }
                  if (!silent) {
                    var e_change = {
                      "name": property_name,
                      "value": data_object_next.value()
                    };
                    if (source) {
                      e_change.source = source;
                    }
                    this.trigger("change", e_change);
                  }
                  return res2;
                }
              }
            }
          } else {
            var value2 = a[0];
            var property_name = a[1];
            var input_processor = input_processors2[this.__type_name];
            if (input_processor) {
              var processed_input = input_processor(value2);
              value2 = processed_input;
              this._[property_name] = value2;
              this.raise_event("change", {
                "value": value2
              });
              return value2;
            } else {
              if (sig === "[D]") {
                this._[property_name] = value2;
                this.raise_event("change", [property_name, value2]);
                return value2;
              } else if (sig === "[o]") {
                res2 = {};
                each(a[0], function(v, i) {
                  res2[i] = that2.set(i, v);
                });
                return res2;
              }
              if (sig === "[c]") {
                this._[property_name] = value2;
                this.raise_event("change", [property_name, value2]);
                return value2;
              }
            }
          }
        }
        "has"(property_name) {
          return is_defined(this.get(property_name));
        }
      };
      jsgui2.map_classes = jsgui2.map_classes || {};
      var dobj = (obj2, data_def) => {
        var cstr = Data_Object;
        var res2;
        if (data_def) {
          res2 = new cstr({
            "data_def": data_def
          });
        } else {
          res2 = new cstr({});
        }
        var tobj = tof(obj2);
        if (tobj == "object") {
          var res_set = res2.set;
          each(obj2, (v, i) => {
            res_set.call(res2, i, v);
          });
        }
        return res2;
      };
      Data_Object.dobj = dobj;
      Data_Object.Mini_Context = Mini_Context;
      module.exports = Data_Object;
    }
  });

  // node_modules/lang-tools/sorted-kvs.js
  var require_sorted_kvs = __commonJS({
    "node_modules/lang-tools/sorted-kvs.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var mapify = jsgui2.mapify;
      var B_Plus_Tree = require_b_plus_tree();
      var Sorted_KVS = class {
        constructor(spec) {
          spec = spec || {};
          if (typeof spec.unique_keys !== "undefined") this.unique_keys = spec.unique_keys;
          this.tree = B_Plus_Tree(12);
        }
        "clear"() {
          this.tree.clear();
        }
        /*
        	'put': mapify(function (key, value) {
        		// inserting a bunch of things at once... could that be done more efficiently, such as in one traversal?
        		//  sort the items, then can skip through the tree a bit quicker?
        
        
        		var insert_res = this.tree.insert(key, value);
        		// with tree.insert - nice if we can keep the treenode as a result.
        		//  the tree does not store objects in the node.
        		//   could make the tree node hold a reference to the object?
        
        		//console.log('put insert_res ' + insert_res);
        		//this.dict[key] = value;
        	}),
        	*/
        "out"(key2) {
          this.tree.remove(key2);
        }
        "get"(key2) {
          return this.tree.get_values_by_key(key2);
        }
        "has"(key2) {
          return this.key_count(key2) > 0;
        }
        "get_cursor"() {
        }
        "keys"() {
          return this.tree.keys();
        }
        "keys_and_values"() {
          return this.tree.keys_and_values();
        }
        /*
        	 'values': function() {
        	 var keys = this.keys();
        	 var res = [];
        	 var that = this;
        	 console.log('keys.length ' + keys.length );
        	 console.log('keys ' + jsgui.stringify(keys));
        
        	 each(keys, function(i, v) {
        	 res.push(that.dict[v]);
        	 });
        	 return res;
        	 },
        	 */
        "key_count"(key2) {
          if (typeof key2 !== "undefined") {
            return this.tree.count(key2);
          } else {
            return this.tree.count();
          }
        }
        "get_keys_by_prefix"(prefix) {
          return this.tree.get_keys_by_prefix(prefix);
        }
        "each"(callback2) {
          return this.tree.each(callback2);
        }
        "get_by_prefix"(prefix) {
          return this.tree.get_by_prefix(prefix);
        }
      };
      Sorted_KVS.prototype.put = mapify(function(key2, value2) {
        var insert_res = this.tree.insert(key2, value2);
      });
      module.exports = Sorted_KVS;
    }
  });

  // node_modules/lang-tools/Data_Model/old/Collection.js
  var require_Collection = __commonJS({
    "node_modules/lang-tools/Data_Model/old/Collection.js"(exports, module) {
      var lang = require_lib_lang_mini();
      var Data_Value2 = require_Data_Value();
      var Data_Object = require_Data_Object();
      var Sorted_KVS = require_sorted_kvs();
      var dobj = Data_Object.dobj;
      var Constraint = Data_Object.Constraint;
      var each = lang.each;
      var tof = lang.tof;
      var is_defined = lang.is_defined;
      var stringify = lang.stringify;
      var get_a_sig2 = lang.get_a_sig;
      var native_constructor_tof = lang.native_constructor_tof;
      var dop = Data_Object.prototype;
      var Collection = class _Collection extends Data_Object {
        constructor(spec = {}, arr_values) {
          super(spec);
          this.__type = "collection";
          this.__type_name = "collection";
          var t_spec = tof(spec);
          if (spec.abstract === true) {
            if (t_spec === "function") {
              this.constraint(spec);
            }
          } else {
            this._relationships = this._relationships || {};
            this._arr_idx = 0;
            this._arr = [];
            this.index = new Sorted_KVS();
            this.fn_index = spec.fn_index;
            if (t_spec === "array") {
              spec = {
                "load_array": spec
              };
            } else {
              if (t_spec === "function") {
                if (spec.abstract === true) {
                  this._abstract = true;
                } else {
                }
              } else if (t_spec === "string") {
                var map_native_constructors = {
                  "array": Array,
                  "boolean": Boolean,
                  "number": Number,
                  "string": String,
                  "object": Object
                };
                var nc = map_native_constructors[spec];
                if (nc) {
                  spec = {
                    "constraint": nc
                  };
                  if (nc == String) {
                    spec.index_by = "value";
                  }
                }
              }
            }
            if (is_defined(spec.items)) {
              spec.load_array = spec.load_array || spec.items;
            }
            if (arr_values) {
              spec.load_array = arr_values;
            }
            if (is_defined(spec.accepts)) {
              this._accepts = spec.accepts;
            }
            if (lang.__data_id_method === "init") {
              if (this.context) {
                this.__id = this.context.new_id(this.__type_name || this.__type);
                this.context.map_objects[this.__id] = this;
              } else {
              }
            }
            if (!this.__type) {
            }
            if (spec.load_array) {
              this.load_array(spec.load_array);
            }
          }
        }
        // maybe use fp, and otherwise apply with the same params and context.
        "set"(value2) {
          var tval = tof(value2);
          if (tval === "data_object" || tval === "data_value") {
            this.clear();
            return this.push(value2);
          } else if (tval === "array") {
            this.clear();
            each(value2, (v, i) => {
              this.push(v);
            });
          } else {
            if (tval === "collection") {
              throw "stop";
              this.clear();
              value2.each(function(v, i) {
                that.push(v);
              });
            } else if (tval === "string" || tval === "number" || tval === "boolean" || tval === "null" || tval === "undefined") {
              this.clear();
              return this.push(value2);
            } else {
              const Data_Object2 = require_Data_Object();
              return Data_Object2.prototype.set.call(this, value2);
            }
          }
        }
        "clear"() {
          this._arr_idx = 0;
          this._arr = [];
          this.index.clear();
          this.raise("change", {
            "name": "clear"
          });
        }
        "stringify"() {
          var res2 = [];
          if (this._abstract) {
            var ncto = native_constructor_tof(this._type_constructor);
            res2.push("~Collection(");
            if (ncto) {
              res2.push(ncto);
            } else {
            }
            res2.push(")");
          } else {
            res2.push("Collection(");
            var first = true;
            this.each(function(v, i) {
              if (!first) {
                res2.push(", ");
              } else {
                first = false;
              }
              res2.push(stringify(v));
            });
            res2.push(")");
          }
          return res2.join("");
        }
        "toString"() {
          return stringify(this._arr);
        }
        "toObject"() {
          var res2 = [];
          this.each(function(v, i) {
            res2.push(v.toObject());
          });
          return res2;
        }
        "each"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig == "[f]") {
            return each(this._arr, a[0]);
          } else {
            if (sig == "[X,f]") {
              var index = a[0];
              var callback2 = a[1];
              return index.each(callback2);
            } else {
              if (a.l == 2) {
                return each(this._arr, a[0], a[1]);
              }
            }
          }
        }
        "_id"() {
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
          }
          return this.__id;
        }
        "length"() {
          return this._arr.length;
        }
        get len() {
          return this._arr.length;
        }
        "find"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (a.l == 1) {
            var pos = this.index.get(a[0])[0];
            var item2 = this._arr[pos];
            return item2;
          }
          if (sig == "[o,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[s,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[a,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[s,o]") {
            var propertyName = a[0];
            var query = a[1];
            var foundItems = [];
            each(this, (item3, index) => {
              if (item3.get) {
                var itemProperty = item3.get(propertyName);
              } else {
                var itemProperty = item3[propertyName];
              }
              var tip = tof(itemProperty);
              var tip2;
              var ip2;
              if (tip === "data_value") {
                var ip2 = itemProperty.value();
                tip2 = tof(ip2);
              } else {
                ip2 = itemProperty;
                tip2 = tip;
              }
              if (tip2 === "array") {
                each(ip2, (v, i) => {
                  var matches = obj_matches_query_obj(v, query);
                  if (matches) {
                    foundItems.push(v);
                  }
                });
              }
              ;
            });
            var res2 = new _Collection(foundItems);
            return res2;
          }
        }
        // get seems like the way to get unique values.
        "get"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig == "[n]" || sig == "[i]") {
            return this._arr[a[0]];
          }
          if (sig == "[s]") {
            var ix_sys = this.index_system;
            var res2;
            if (ix_sys) {
              var pui = ix_sys._primary_unique_index;
              res2 = pui.get(a[0])[0];
            }
            if (res2) {
              return res2;
            }
            return Data_Object.prototype.get.apply(this, a);
          }
        }
        "insert"(item2, pos) {
          this._arr.splice(pos, 0, item2);
          this.raise("change", {
            "name": "insert",
            "item": item2,
            "value": item2,
            "pos": pos
          });
        }
        swap(item2, replacement) {
          let r_parent = replacement.parent;
          let repl_pos = replacement.parent.content.remove(replacement);
          let i_parent = item2.parent;
          let item_pos = item2.parent.content.remove(item2);
          let item_index;
          i_parent.content.insert(replacement, item_pos);
          r_parent.content.insert(item2, repl_pos);
        }
        // may have efficiencies for adding and removing multiple items at once.
        //  can be sorted for insertion into index with more rapid algorithmic time.
        "remove"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig === "[n]") {
            var pos = a[0];
            var item2 = this._arr[pos];
            var spliced_pos = pos;
            this._arr.splice(pos, 1);
            this._arr_idx--;
            var e = {
              "target": this,
              "value": item2,
              "position": spliced_pos,
              "name": "remove"
            };
            this.raise("change", e);
            return pos;
          } else if (sig === "[s]") {
            var key2 = a[0];
            var obj2 = this.index_system.find([
              ["value", key2]
            ]);
            var my_id = this.__id;
            var item_pos_within_this = obj2[0]._relationships[my_id];
            this._arr.splice(item_pos_within_this, 1);
            for (var c2 = item_pos_within_this, l2 = this._arr.length; c2 < l2; c2++) {
              var item2 = this._arr[c2];
              item2._relationships[my_id]--;
            }
            var e = {
              "target": this,
              "value": obj2[0],
              "position": item_pos_within_this,
              "name": "remove"
            };
            this.raise("change", e);
          } else {
            let item_index;
            const item3 = a[0];
            let arr = this._arr, l3 = arr.length;
            if (typeof item3 === "number") {
              item_index = item3;
            } else {
              let found = false, c3 = 0;
              while (!found && c3 < l3) {
                found = arr[c3] === item3;
                if (found) {
                  item_index = c3;
                }
                c3++;
              }
              if (is_defined(item_index)) {
                return this.remove(item_index);
              }
            }
          }
        }
        "has"(obj_key) {
          if (this.get_index(obj_key) === void 0) {
            return false;
          } else {
            return true;
          }
        }
        "get_index"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig === "[s]") {
            if (this.index_system) {
              return this.index_system.search(a[0]);
            } else {
              if (this._arr.length === 0) {
                return void 0;
              } else {
                for (let c2 = 0; c2 < this._arr.length; c2++) {
                  const item2 = this._arr[c2];
                  if (item2?.name === a[0]) {
                    return c2;
                  }
                }
                return void 0;
              }
            }
          } else {
            console.trace();
            throw "Expected [s]";
          }
        }
        // More fp way of indexing.
        "index_by"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          console.log("Indexing not implemented (like this)");
          console.trace();
        }
        "push"(value2) {
          const { silent } = this;
          let tv = tof(value2);
          let fn_index = this.fn_index;
          let idx_key, has_idx_key = false, pos;
          if (fn_index) {
            idx_key = fn_index(value2);
            has_idx_key = true;
          }
          if (tv === "object" || tv === "function") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "collection") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "data_object" || tv === "control") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "array") {
            const new_coll = new _Collection(value2);
            pos = this._arr.length;
            this._arr.push(new_coll);
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          }
          if (tv === "string" || tv === "number" || tv === "boolean" || tv === "null" || tv === "undefined") {
            const dv = new Data_Value2({
              "value": value2
            });
            pos = this._arr.length;
            this._arr.push(dv);
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          }
          if (has_idx_key) {
            this.index.put(idx_key, pos);
          }
          return value2;
        }
        "load_array"(arr) {
          for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
            this.push(arr[c2]);
          }
          this.raise("load");
        }
        "values"() {
          var a = arguments;
          a.l = a.length;
          if (a.l === 0) {
            return this._arr;
          } else {
            var stack = new Error().stack;
            throw "not yet implemented";
          }
        }
        "value"() {
          const res2 = [];
          this.each((v, i) => {
            if (typeof v.value == "function") {
              res2.push(v.value());
            } else {
              res2.push(v);
            }
          });
          return res2;
        }
      };
      var p = Collection.prototype;
      p.add = p.push;
      module.exports = Collection;
    }
  });

  // node_modules/lang-tools/Data_Model/Data_Object.js
  var require_Data_Object2 = __commonJS({
    "node_modules/lang-tools/Data_Model/Data_Object.js"(exports, module) {
      module.exports = require_Data_Object();
    }
  });

  // node_modules/lang-tools/Data_Model/new/Immutable_Data_Model.js
  var require_Immutable_Data_Model = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Immutable_Data_Model.js"(exports, module) {
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = class extends Data_Model {
        constructor(...a) {
          super(...a);
        }
      };
      module.exports = Immutable_Data_Model;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Validation_Result.js
  var require_Validation_Result = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Validation_Result.js"(exports, module) {
      var Validation_Result = class {
      };
      module.exports = Validation_Result;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Validation_Success.js
  var require_Validation_Success = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Validation_Success.js"(exports, module) {
      var Validation_Result = require_Validation_Result();
      var Validation_Success = class extends Validation_Result {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Validation_Success;
    }
  });

  // node_modules/lang-tools/Data_Model/new/setup_base_data_value_value_property.js
  var require_setup_base_data_value_value_property = __commonJS({
    "node_modules/lang-tools/Data_Model/new/setup_base_data_value_value_property.js"(exports, module) {
      var Validation_Success = require_Validation_Success();
      var setup_base_data_value_value_property = (data_value) => {
        let local_js_value2;
        const set_value_with_valid_and_changed_value = (valid_and_changed_value) => {
          const old = local_js_value2;
          local_js_value2 = valid_and_changed_value;
          data_value.raise("change", {
            name: "value",
            old,
            value: local_js_value2
          });
        };
        Object.defineProperty(data_value, "value", {
          get() {
            return local_js_value2;
          },
          set(value2) {
            if (data_value.transform_validate_value) {
              const obj_transform_and_validate_value_results = data_value.transform_validate_value(value2);
              if (obj_transform_and_validate_value_results.validation instanceof Validation_Success) {
                if (obj_transform_and_validate_value_results.transformed_value !== void 0) {
                  const value_has_changed = local_js_value2 !== obj_transform_and_validate_value_results.transformed_value;
                  if (value_has_changed) {
                    set_value_with_valid_and_changed_value(obj_transform_and_validate_value_results.transformed_value);
                  } else {
                  }
                } else {
                  const value_has_changed = local_js_value2 !== obj_transform_and_validate_value_results.value;
                  if (value_has_changed) {
                    set_value_with_valid_and_changed_value(obj_transform_and_validate_value_results.value);
                  } else {
                  }
                }
              }
            } else {
              set_value_with_valid_and_changed_value(value2);
            }
          }
        });
      };
      module.exports = setup_base_data_value_value_property;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Base_Data_Value.js
  var require_Base_Data_Value = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Base_Data_Value.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var { is_defined, input_processors, field, tof, each } = jsgui2;
      var setup_base_data_value_value_property = require_setup_base_data_value_value_property();
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var Base_Data_Value = class extends Data_Model {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          this.__type = "data_value";
          this._relationships = {};
          const { data_type, context: context2 } = this;
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        // Maybe see about immutable mode Data_Values / Data_Models.
        //   Or do make the immutable versions of all of them!!!
        //     And could make core functionality for both the immutable and mutable versions.
        //       Mutability Independent Code.
        // Immutable_Data_Integer does seem like it would in principle be (really?) simple.
        /*
            toImmutable() {
                // May be slightly difficult / tricky / complex.
                const {context, data_type, value} = this;
        
                // Create the new item...
                // Needs to copy the inner value....?
        
                const res = new Immutable_Data_Value({
                    context, data_type, value
                });
                return res;
            }
            */
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          return JSON.stringify(this.get());
        }
        // Need to copy / clone the ._ value
        /*
            'clone'() {
        
                //return this.toImmutable();
            }
            */
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "Data_Value should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
      };
      module.exports = Base_Data_Value;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Value_Set_Attempt.js
  var require_Value_Set_Attempt = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Value_Set_Attempt.js"(exports, module) {
      var Value_Set_Attempt = class {
        constructor(spec = {}) {
          Object.assign(this, spec);
        }
      };
      module.exports = Value_Set_Attempt;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Immutable_Base_Data_Value.js
  var require_Immutable_Base_Data_Value = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Immutable_Base_Data_Value.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var { is_defined, input_processors, field, tof, each } = jsgui2;
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var Immutable_Base_Data_Value = class extends Immutable_Data_Model {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          this.__type = "data_value";
          this._relationships = {};
          const { data_type, context: context2 } = this;
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        // Maybe see about immutable mode Data_Values / Data_Models.
        //   Or do make the immutable versions of all of them!!!
        //     And could make core functionality for both the immutable and mutable versions.
        //       Mutability Independent Code.
        // Immutable_Data_Integer does seem like it would in principle be (really?) simple.
        /*
            toImmutable() {
                // May be slightly difficult / tricky / complex.
                const {context, data_type, value} = this;
        
                // Create the new item...
                // Needs to copy the inner value....?
        
                const res = new Immutable_Data_Value({
                    context, data_type, value
                });
                return res;
            }
            */
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          return JSON.stringify(this.get());
        }
        // Need to copy / clone the ._ value
        /*
            'clone'() {
        
                //return this.toImmutable();
            }
            */
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "Immutable_Base_Data_Value should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
      };
      module.exports = Immutable_Base_Data_Value;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Immutable_Data_Value.js
  var require_Immutable_Data_Value = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Immutable_Data_Value.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var Immutable_Base_Data_Value = require_Immutable_Base_Data_Value();
      var { is_defined, input_processors, field, tof, each } = jsgui2;
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var ldarkPurple = (x) => `\x1B[38;5;54m${x}\x1B[0m`;
      var Immutable_Data_Value = class _Immutable_Data_Value extends Immutable_Base_Data_Value {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          this.__immutable = true;
          this.__type_name = "data_value";
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          const { data_type, context: context2 } = this;
          if (data_type) {
            const to_local_js_value = (value2) => {
              if (value2 !== void 0) {
                const t = tof(value2);
                if (t === "number" || t === "string" || t === "boolean") {
                  return value2;
                } else {
                  if (t === "array") {
                    const l2 = value2.length;
                    const res2 = new Array(l2);
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = to_local_js_value(value2[c2]);
                    }
                    return res2;
                  } else if (t === "data_value") {
                    return value2.toImmutable();
                  } else {
                    console.log("to_local_js_value value", value2);
                    console.log("t", t);
                    console.trace();
                    throw "NYI";
                  }
                }
              }
            };
            const local_js_value2 = to_local_js_value(spec.value);
            Object.defineProperty(this, "value", {
              get() {
                return local_js_value2;
              }
              // MISSING: set() { throw new TypeError('Cannot modify immutable Data_Value'); }
            });
          } else {
            let value2;
            if (spec.value instanceof Array) {
              value2 = spec.value.map((x) => {
                if (x instanceof Data_Model) {
                  return x.toImmutable();
                } else {
                  return x;
                }
              });
            } else {
              value2 = spec.value;
            }
            Object.defineProperty(this, "value", {
              get() {
                return value2;
              }
              // MISSING: set() { throw new TypeError('Cannot modify immutable Data_Value'); }
            });
          }
          this.__type = "data_value";
          this._relationships = {};
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        toImmutable() {
          const { context: context2, data_type, value: value2 } = this;
          const res2 = new _Immutable_Data_Value({
            context: context2,
            data_type,
            value: value2
          });
          return res2;
        }
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          const t_value = tof(this.value);
          if (t_value === "string") {
            return JSON.stringify(this.value);
          } else if (t_value === "number") {
            return this.value + "";
          } else if (t_value === "boolean") {
            this.value ? "true" : "false";
          } else if (t_value === "array") {
            let res2 = "[";
            const l2 = this.value.length;
            for (let c2 = 0; c2 < l2; c2++) {
              const item2 = this.value[c2];
              if (c2 > 0) res2 += ",";
              if (item2.toJSON) {
                res2 += item2.toJSON();
              } else {
                res2 += JSON.stringify(item2);
              }
            }
            res2 = res2 + "]";
            return res2;
          } else if (t_value === "data_value") {
            return this.value.toJSON();
          } else if (t_value === "undefined") {
            return "null";
          } else if (t_value === "null") {
            return "null";
          } else {
            console.log("toJSON this.value", this.value);
            console.log("t_value", t_value);
            console.trace();
            throw "NYI";
          }
        }
        // Need to copy / clone the ._ value
        "clone"() {
          return this.toImmutable();
        }
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "Data_Value should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
        "toObject"() {
          return this._;
        }
      };
      if (util) {
        Immutable_Data_Value.prototype[util.inspect.custom] = function(depth, opts) {
          const { value: value2 } = this;
          if (value2 instanceof Array) {
            let res2 = ldarkPurple("[ ");
            let first = true;
            each(value2, (item2) => {
              if (!first) {
                res2 = res2 + ldarkPurple(", ");
              } else {
                first = false;
              }
              if (item2 instanceof Data_Model) {
                const item_value = item2.value;
                res2 = res2 + ldarkPurple(item_value);
              } else [
                res2 = res2 + ldarkPurple(item2)
              ];
            });
            res2 = res2 + ldarkPurple(" ]");
            return res2;
          } else {
            return ldarkPurple(this.value);
          }
        };
      }
      module.exports = Immutable_Data_Value;
    }
  });

  // node_modules/lang-tools/Data_Model/new/setup_data_value_data_type_set.js
  var require_setup_data_value_data_type_set = __commonJS({
    "node_modules/lang-tools/Data_Model/new/setup_data_value_data_type_set.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Base_Data_Value = require_Base_Data_Value();
      var Value_Set_Attempt = require_Value_Set_Attempt();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var Immutable_Data_Value = require_Immutable_Data_Value();
      var { is_defined, input_processors, field, tof, each, is_array, Data_Type } = jsgui2;
      var setup_data_value_data_type_set = (data_value, data_type) => {
        let local_js_value2;
        const define_string_value_property = () => {
          Object.defineProperty(data_value, "value", {
            get() {
              return local_js_value2;
            },
            set(value2) {
              const old_value = local_js_value2;
              const immu = data_value.toImmutable();
              const value_equals_current = immu.equals(value2);
              if (!value_equals_current) {
                const t_value = tof(value2);
                let made_change = false;
                if (t_value === "string") {
                  if (local_js_value2 instanceof Base_Data_Value) {
                    console.log("existing local_js_value instanceof Data_Value");
                    console.log("local_js_value.value", local_js_value2.value);
                    console.log("local_js_value.data_type.name", local_js_value2.data_type.name);
                    console.trace();
                    throw "NYI";
                  } else if (local_js_value2 === void 0) {
                    local_js_value2 = value2;
                    made_change = true;
                  } else if (typeof local_js_value2 === "string") {
                    local_js_value2 = value2;
                    made_change = true;
                  } else {
                    console.trace();
                    throw "stop";
                  }
                } else {
                  if (value2 instanceof Base_Data_Value) {
                    console.log("t_value", t_value);
                    console.log("value", value2);
                    console.trace();
                    throw "stop";
                  } else {
                    const tval = tof(value2);
                    if (tval === "number") {
                      local_js_value2 = value2 + "";
                      made_change = true;
                    } else {
                      console.log("-- INVALID TYPE --");
                      console.log("tof(old_value)", tof(old_value));
                      console.log("tof(value)", tof(value2));
                      data_value.raise("validate", {
                        valid: false,
                        reason: "Invalid Type",
                        value: value2,
                        old: local_js_value2
                      });
                    }
                  }
                }
                if (made_change) {
                  const my_e = {
                    name: "value",
                    old: old_value,
                    value: local_js_value2
                  };
                  data_value.raise("change", my_e);
                }
              }
            }
          });
        };
        const define_data_type_typed_value_property = () => {
          const {
            wrap_properties,
            property_names,
            property_data_types,
            wrap_value_inner_values,
            value_js_type,
            abbreviated_property_names,
            named_property_access,
            numbered_property_access,
            parse_string
          } = data_type;
          let num_properties;
          if (property_names && property_data_types) {
            if (property_names.length === property_data_types.length) {
              num_properties = property_names.length;
              if (numbered_property_access) {
              }
            }
          } else if (property_names) {
            num_properties = property_names.length;
          }
          let _current_immutable_value, _previous_immutable_value;
          let prev_outer_value, current_outer_value;
          let _numbered_property_access_has_been_set_up = false, _named_property_access_has_been_set_up = false;
          Object.defineProperty(data_value, "value", {
            get() {
              return local_js_value2;
            },
            set(value2) {
              const immu = data_value.toImmutable();
              const value_equals_current = immu.equals(value2);
              if (value_equals_current) {
              } else {
                const passed_first_validation = data_type.validate(value2);
                let passed_validation = passed_first_validation;
                if (!passed_first_validation) {
                  const t_value = tof(value2);
                  if (t_value === "string" && data_type.parse_string) {
                    const parsed_value = data_type.parse_string(value2);
                    if (parsed_value !== void 0) {
                      if (data_type.validate(parsed_value)) {
                        if (!immu.equals(parsed_value)) {
                          value2 = parsed_value;
                          passed_validation = true;
                        }
                      }
                    }
                  }
                }
                if (passed_validation) {
                  data_value.raise("validate", {
                    valid: true,
                    value: value2
                  });
                } else {
                  data_value.raise("validate", {
                    valid: false,
                    value: value2
                  });
                }
                if (passed_validation) {
                  const do_actual_set = (value3) => {
                    const array_specific_value_processing = () => {
                      if (value_js_type === Array) {
                        let t = tof(local_js_value2);
                        if (t === "undefined") {
                          const create_array_with_wrapped_items = () => {
                            if (num_properties) {
                              if (wrap_value_inner_values) {
                                if (property_data_types) {
                                  let i = 0;
                                  if (value3.__immutable) {
                                    const l2 = value3.length;
                                    const arr_wrapped_value_values = new Array(l2);
                                    const value_value = value3.value;
                                    do_actual_set(value_value);
                                  } else {
                                    if (value3 instanceof Data_Value) {
                                      const arr_wrapped_value_values = new Array(num_properties);
                                      const arr_dv_value = value3.value;
                                      console.log("arr_dv_value", arr_dv_value);
                                      console.trace();
                                      throw "stop";
                                    } else if (is_array(value3)) {
                                      const arr_wrapped_value_values = value3.map((value4) => {
                                        const property_index = i;
                                        let property_name;
                                        if (property_names) {
                                          property_name = property_names[property_index];
                                        }
                                        const wrapped_value = new Data_Value({ context, value: value4, data_type: property_data_types[i] });
                                        wrapped_value.on("change", (e) => {
                                          const { name } = e;
                                          if (name === "value") {
                                            current_outer_value = data_value.toImmutable();
                                            const my_e2 = {
                                              name,
                                              event_originator: wrapped_value,
                                              parent_event: e,
                                              value: current_outer_value
                                            };
                                            if (property_name) {
                                              my_e2.property_name = property_name;
                                            }
                                            my_e2.property_index = property_index;
                                            data_value.raise("change", my_e2);
                                            prev_outer_value = current_outer_value;
                                          }
                                        });
                                        i++;
                                        return wrapped_value;
                                      });
                                      local_js_value2 = arr_wrapped_value_values;
                                      const my_e = {
                                        name: "value",
                                        old: _previous_immutable_value,
                                        value: data_value.toImmutable()
                                      };
                                      data_value.raise("change", my_e);
                                    }
                                  }
                                } else {
                                  let i = 0;
                                  const arr_wrapped_value_values = value3.map((value4) => {
                                    const property_index = i;
                                    let property_name;
                                    if (property_names) {
                                      property_name = property_names[property_index];
                                    }
                                    const wrapped_value = new Data_Value({ context, value: value4 });
                                    wrapped_value.on("change", (e) => {
                                      const { name } = e;
                                      if (name === "value") {
                                        const my_e = {
                                          name,
                                          event_originator: wrapped_value,
                                          parent_event: e,
                                          value: data_value.toImmutable()
                                        };
                                        if (property_name) {
                                          my_e.property_name = property_name;
                                        }
                                        my_e.property_index = property_index;
                                        data_value.raise("change", my_e);
                                      }
                                    });
                                    i++;
                                    return wrapped_value;
                                  });
                                  local_js_value2 = arr_wrapped_value_values;
                                }
                              } else {
                                local_js_value2 = value3;
                              }
                            } else {
                              console.trace();
                              throw "stop - number of properties not found";
                            }
                          };
                          create_array_with_wrapped_items();
                        } else if (t === "array") {
                          const t_value = tof(value3);
                          if (t_value === "data_value") {
                            if (is_array(value3.value)) {
                              if (value3.value.length === local_js_value2.length) {
                                each(value3.value, (inner_value, idx) => {
                                  if (inner_value instanceof Data_Model) {
                                    const matching_local_inner_value = local_js_value2[idx];
                                    if (inner_value.equals(matching_local_inner_value)) {
                                    } else {
                                      matching_local_inner_value.value = inner_value;
                                    }
                                  } else {
                                    console.trace();
                                    throw "NYI";
                                  }
                                });
                              } else {
                                console.trace();
                                throw "NYI";
                              }
                            } else {
                              console.trace();
                              throw "NYI";
                            }
                          } else {
                            if (t_value === "array") {
                              if (local_js_value2.length === value3.length) {
                                const l2 = value3.length;
                                let all_local_js_items_are_data_model = true, c2 = 0;
                                do {
                                  const local_item = local_js_value2[c2];
                                  if (!(local_item instanceof Data_Model)) {
                                    all_local_js_items_are_data_model = false;
                                  }
                                  c2++;
                                } while (all_local_js_items_are_data_model && c2 < l2);
                                if (all_local_js_items_are_data_model) {
                                  let c3 = 0;
                                  do {
                                    const local_item = local_js_value2[c3];
                                    local_item.value = value3[c3];
                                    c3++;
                                  } while (c3 < l2);
                                } else {
                                  console.trace();
                                  throw "NYI";
                                }
                              } else {
                                console.trace();
                                throw "NYI";
                              }
                            } else {
                              console.log("value", value3);
                              console.trace();
                              throw "NYI";
                            }
                          }
                        } else {
                        }
                      } else {
                      }
                    };
                    array_specific_value_processing();
                    const general_value_processing = () => {
                      if (local_js_value2 instanceof Base_Data_Value) {
                        console.log("existing local_js_value instanceof Data_Value");
                        console.log("local_js_value.value", local_js_value2.value);
                        console.log("local_js_value.data_type.name", local_js_value2.data_type.name);
                        console.trace();
                        throw "NYI";
                      } else if (local_js_value2 instanceof Array) {
                        if (value3 instanceof Data_Model) {
                          if (value3.equals(local_js_value2)) {
                          } else {
                            console.log("value", value3);
                            console.log("local_js_value", local_js_value2);
                            console.trace();
                            throw "NYI";
                          }
                        } else if (value3 instanceof Array) {
                          if (property_names.length === value3.length) {
                            if (property_data_types) {
                              const num_properties2 = property_names.length;
                              for (let i_property = 0; i_property < num_properties2; i_property++) {
                                const name = property_names[i_property];
                                const data_type2 = property_data_types[i_property];
                                if (local_js_value2[i_property] instanceof Data_Value) {
                                  local_js_value2[i_property].value = value3[i_property];
                                } else {
                                  console.trace();
                                  throw "NYI";
                                }
                              }
                              if (numbered_property_access && !_numbered_property_access_has_been_set_up) {
                                for (let i_property = 0; i_property < num_properties2; i_property++) {
                                  const name = property_names[i_property];
                                  const data_type2 = property_data_types[i_property];
                                  Object.defineProperty(data_value, i_property, {
                                    get() {
                                      return local_js_value2[i_property];
                                    },
                                    set(value4) {
                                      const item_already_there = local_js_value2[i_property];
                                      if (item_already_there instanceof Data_Model) {
                                        item_already_there.value = value4;
                                      } else {
                                        console.log("item_already_there", item_already_there);
                                        console.trace();
                                        throw "stop";
                                      }
                                      if (value4 instanceof Data_Model) {
                                      } else {
                                      }
                                    }
                                  });
                                }
                                Object.defineProperty(data_value, "length", {
                                  get() {
                                    return local_js_value2.length;
                                  }
                                });
                                _numbered_property_access_has_been_set_up = true;
                              }
                              if (named_property_access && !_named_property_access_has_been_set_up) {
                                if (numbered_property_access) {
                                  if (property_names) {
                                    for (let i_property = 0; i_property < num_properties2; i_property++) {
                                      const name = property_names[i_property];
                                      const data_type2 = property_data_types[i_property];
                                      Object.defineProperty(data_value, name, {
                                        get() {
                                          return local_js_value2[i_property];
                                        },
                                        set(value4) {
                                          const item_already_there = local_js_value2[i_property];
                                          if (item_already_there instanceof Data_Model) {
                                            item_already_there.value = value4;
                                          } else {
                                            console.log("item_already_there", item_already_there);
                                            console.trace();
                                            throw "stop";
                                          }
                                        }
                                      });
                                    }
                                  }
                                  if (abbreviated_property_names) {
                                    for (let i_property = 0; i_property < num_properties2; i_property++) {
                                      const name = abbreviated_property_names[i_property];
                                      const data_type2 = property_data_types[i_property];
                                      Object.defineProperty(data_value, name, {
                                        get() {
                                          return local_js_value2[i_property];
                                        },
                                        set(value4) {
                                          const item_already_there = local_js_value2[i_property];
                                          if (item_already_there instanceof Data_Model) {
                                            item_already_there.value = value4;
                                          } else {
                                            console.log("item_already_there", item_already_there);
                                            console.trace();
                                            throw "stop";
                                          }
                                          if (value4 instanceof Data_Model) {
                                          } else {
                                          }
                                        }
                                      });
                                    }
                                  }
                                }
                                _named_property_access_has_been_set_up = true;
                              }
                            }
                          } else {
                            console.trace();
                            throw "NYI";
                          }
                        } else {
                          console.log("value", value3);
                          console.log("local_js_value", local_js_value2);
                          console.log("value_equals_current", value_equals_current);
                          console.log("immu", immu);
                          console.trace();
                          throw "NYI";
                        }
                      } else {
                        if (value3 instanceof Data_Model) {
                          if (value3.data_type === data_value.data_type) {
                            const tvv = tof(value3.value);
                            if (tvv === "number" || tvv === "string" || tvv === "boolean") {
                              local_js_value2 = value3.value;
                            } else {
                              console.trace();
                              throw "NYI";
                            }
                          } else {
                            console.trace();
                            throw "NYI";
                          }
                        } else {
                          local_js_value2 = value3;
                        }
                        data_value.raise("change", {
                          name: "value",
                          old: immu,
                          value: value3
                        });
                        prev_outer_value = current_outer_value;
                      }
                    };
                    general_value_processing();
                  };
                  do_actual_set(value2);
                } else {
                }
              }
            }
          });
        };
        if (data_type === String) {
          define_string_value_property();
        } else if (data_type instanceof Data_Type) {
          define_data_type_typed_value_property();
        } else {
          console.trace();
          throw "NYI";
        }
      };
      module.exports = setup_data_value_data_type_set;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Data_Value.js
  var require_Data_Value2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Data_Value.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Base_Data_Value = require_Base_Data_Value();
      var Value_Set_Attempt = require_Value_Set_Attempt();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var Immutable_Data_Value = require_Immutable_Data_Value();
      var { is_defined, input_processors, field, tof, each, is_array, Data_Type } = jsgui2;
      var setup_data_value_data_type_set = require_setup_data_value_data_type_set();
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var lpurple = (x) => "\x1B[38;5;129m" + x + "\x1B[0m";
      var Data_Value2 = class _Data_Value extends Base_Data_Value {
        constructor(spec = {}) {
          if (typeof spec !== "object") {
            spec = {
              value: spec
            };
          }
          super(spec);
          this.__data_value = true;
          this.__type_name = "data_value";
          const that2 = this;
          if (spec.data_type) {
            this.data_type = spec.data_type;
          } else if (spec.value?.data_type) {
            this.data_type = spec.value.data_type;
          }
          if (spec.context) {
            this.context = spec.context;
          }
          const { data_type, context: context2 } = this;
          if (data_type) {
            setup_data_value_data_type_set(this, data_type);
            if (spec.value) {
              this.value = spec.value;
            }
          } else {
            field(this, "value", spec.value);
          }
          const attempt_set_value = this.attempt_set_value = (value2) => {
            const get_local_js_value_copy = () => {
              const tljsv = tof(local_js_value);
              if (tljsv === "undefined" || tljsv === "string" || tljsv === "number") {
                return local_js_value;
              } else {
                console.log("local_js_value", local_js_value);
                console.log("tljsv", tljsv);
                console.trace();
                throw "stop";
              }
            };
            const old_local_js_value = get_local_js_value_copy();
            const old_equals_new = more_general_equals(old_local_js_value, value2);
            if (old_equals_new === true) {
              return new Value_Set_Attempt({ success: false, equal_values: true });
            } else {
              if (this.data_type === void 0) {
                local_js_value = value2;
                const o_change = {
                  name: "value",
                  old: old_local_js_value,
                  value: value2
                };
                this.raise("change", o_change);
                return new Value_Set_Attempt({ success: true, value: value2 });
              } else if (this.data_type instanceof Data_Type) {
                const t_value = tof(value2);
                if (t_value === "string") {
                  if (this.data_type.parse_string) {
                    const parsed_value = this.data_type.parse_string(value2);
                    if (parsed_value !== void 0) {
                      const res2 = attempt_set_value(parsed_value);
                      res2.parsed = true;
                      return res2;
                    } else {
                      return new Value_Set_Attempt({ success: false, value: value2 });
                    }
                  } else {
                    console.trace();
                    throw "NYI";
                  }
                } else {
                  if (t_value === "number") {
                    const validation = this.data_type.validate(value2);
                    if (validation === true) {
                      local_js_value = value2;
                      const o_change = {
                        name: "value",
                        old: old_local_js_value,
                        value: value2
                      };
                      this.raise("change", o_change);
                      return new Value_Set_Attempt({ success: true, old: old_local_js_value, value: value2 });
                    } else {
                      return new Value_Set_Attempt({ success: false, value: value2 });
                    }
                  } else {
                    console.log("t_value", t_value);
                    console.trace();
                    throw "NYI";
                  }
                }
              } else if (this.data_type === String) {
                if (typeof value2 === "number") {
                  const res2 = attempt_set_value(value2 + "");
                  res2.data_type_transformation = ["number", "string"];
                  return res2;
                } else if (typeof value2 === "string") {
                  local_js_value = value2;
                  const o_change = {
                    name: "value",
                    old: old_local_js_value,
                    value: value2
                  };
                  this.raise("change", o_change);
                  return new Value_Set_Attempt({ success: true, old: old_local_js_value, value: value2 });
                } else {
                  console.trace();
                  throw "NYI";
                }
              } else {
                console.log("this.data_type", this.data_type);
                console.trace();
                throw "NYI";
              }
            }
          };
          this.__type = "data_value";
          this._relationships = {};
        }
        toImmutable() {
          const { context: context2, data_type, value: value2 } = this;
          const res2 = new Immutable_Data_Value({
            context: context2,
            data_type,
            value: value2
          });
          return res2;
        }
        "toObject"() {
          return this._;
        }
        "set"(val) {
          this.value = val;
        }
        "get"() {
          return this.value;
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        "toString"() {
          return this.get() + "";
        }
        "toJSON"() {
          const t_value = tof(this.value);
          if (t_value === "string") {
            return JSON.stringify(this.value);
          } else if (t_value === "number") {
            return this.value + "";
          } else if (t_value === "boolean") {
            this.value ? "true" : "false";
          } else if (t_value === "array") {
            return JSON.stringify(this.value);
          } else if (t_value === "data_value") {
            return this.value.toJSON();
          } else if (t_value === "undefined") {
            return "null";
          } else if (t_value === "null") {
            return "null";
          } else {
            console.log("toJSON this.value", this.value);
            console.log("t_value", t_value);
            console.trace();
            throw "NYI";
          }
        }
        "clone"() {
          console.trace();
          throw "NYI";
          var res2 = new _Data_Value({
            "value": this._
          });
          return res2;
        }
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "Data_Value should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
      };
      Data_Value2.sync = (a, b) => {
        if (a instanceof Base_Data_Value && b instanceof Base_Data_Value) {
          a.on("change", (e) => {
            const { name, old, value: value2 } = e;
            if (name === "value") {
              b.value = value2;
            }
          });
          b.on("change", (e) => {
            const { name, old, value: value2 } = e;
            if (name === "value") {
              a.value = value2;
            }
          });
        } else {
          console.trace();
          throw "Unexpected types";
        }
      };
      if (util) {
        Data_Value2.prototype[util.inspect.custom] = function(depth, opts) {
          const { value: value2 } = this;
          const tv = tof(value2);
          if (tv === "number" || tv === "string" || tv === "boolean") {
            return lpurple(value2);
          } else {
            if (value2 instanceof Array) {
              let res2 = lpurple("[ ");
              let first = true;
              each(value2, (item2) => {
                if (!first) {
                  res2 = res2 + lpurple(", ");
                } else {
                  first = false;
                }
                if (item2 instanceof Data_Model) {
                  const item_value = item2.value;
                  res2 = res2 + lpurple(item_value);
                } else [
                  res2 = res2 + lpurple(item2)
                ];
              });
              res2 = res2 + lpurple(" ]");
              return res2;
            } else if (value2 instanceof Data_Model) {
              return value2[util.inspect.custom]();
            } else {
              return lpurple(this.value);
            }
          }
        };
      }
      module.exports = Data_Value2;
    }
  });

  // node_modules/lang-tools/Data_Model/Data_Value.js
  var require_Data_Value3 = __commonJS({
    "node_modules/lang-tools/Data_Model/Data_Value.js"(exports, module) {
      module.exports = require_Data_Value2();
    }
  });

  // node_modules/lang-tools/doubly-linked-list.js
  var require_doubly_linked_list = __commonJS({
    "node_modules/lang-tools/doubly-linked-list.js"(exports, module) {
      var Node = class {
        constructor(spec) {
          this.neighbours = spec.neighbours || [];
          this.value = spec.value;
        }
        "previous"() {
          return this.neighbours[0];
        }
        "next"() {
          return this.neighbours[1];
        }
      };
      var Doubly_Linked_List = class {
        constructor(spec) {
          this.first = null;
          this.last = null;
          this.length = 0;
        }
        "each_node"(callback2) {
          var node = this.first;
          var ctu = true;
          var stop = function() {
            ctu = false;
          };
          while (node && ctu) {
            callback2(node, stop);
            node = node.neighbours[1];
          }
        }
        "each"(callback2) {
          this.each_node(function(node, stop) {
            callback2(node.value, stop);
          });
        }
        "remove"(node) {
          if (node.neighbours[0]) {
            node.neighbours[0].neighbours[1] = node.neighbours[1];
          } else {
            this.first = node.neighbours[1];
          }
          if (node.neighbours[1]) {
            node.neighbours[1].neighbours[0] = node.neighbours[0];
          } else {
            this.last = node.neighbours[0];
          }
          node.neighbours = [];
          if (node.parent == this) {
            delete node.parent;
            this.length--;
          }
        }
        // check to see if the item is a 'node' object.
        //  if it is, can insert it as a node, otherwise create the node object and insert it.
        //   a bit like wrapping values in Data_Value.
        "insert_beginning"(val) {
          if (val instanceof Node) {
            if (this.first == null) {
              this.first = val;
              this.last = val;
              val.neighbours = [];
              if (val.parent != this) {
                val.parent = this;
                this.length++;
              }
            } else {
              this.insert_before(val, this.first);
            }
            return val;
          } else {
            var node = new Node({ "value": val });
            return this.insert_beginning(node);
          }
        }
        // could use a nodify function.
        //  or ensure_data_wrapper
        "insert_before"(val, node) {
          if (val instanceof Node) {
            val.neighbours = [node.neighbours[0], node];
            if (node.neighbours[0] == null) {
              this.first = val;
            } else {
              node.neighbours[0].neighbours[1] = val;
            }
            node.neighbours[0] = val;
            if (val.parent != this) {
              val.parent = this;
              this.length++;
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.insert_before(new_node, node);
          }
        }
        "insert_after"(val, node) {
          if (val instanceof Node) {
            val.neighbours = [node, node.neighbours[1]];
            if (node.neighbours[1] == null) {
              this.last = val;
            } else {
              node.neighbours[1].neighbours[0] = val;
            }
            node.neighbours[1] = val;
            if (val.parent != this) {
              val.parent = this;
              this.length++;
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.insert_after(new_node, node);
          }
        }
        // not wrapping the item in a node?
        // want one where we are not pushing nodes, but items stored in nodes.
        //  Perhaps this is a Data_Value?
        // Or a doubly_linked_node.
        // Doubly_Linked_Node could take the form [prev, item, next]
        //  [prev, item, key, next]? probably not
        //  Maybe we could put more private variables, such as 'neighbours' as a var within the init statement.
        "push"(val) {
          if (val instanceof Node) {
            if (this.last == null) {
              this.insert_beginning(val);
            } else {
              return this.insert_after(val, this.last);
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.push(new_node);
          }
        }
      };
      Doubly_Linked_List.Node = Node;
      module.exports = Doubly_Linked_List;
    }
  });

  // node_modules/lang-tools/ordered-kvs.js
  var require_ordered_kvs = __commonJS({
    "node_modules/lang-tools/ordered-kvs.js"(exports, module) {
      var Doubly_Linked_List = require_doubly_linked_list();
      var Ordered_KVS = class {
        constructor() {
          this.dll = new Doubly_Linked_List();
          this.node_map = {};
        }
        "length"() {
          return this.dll.length;
        }
        "put"(key2, value2) {
          return this.push(key2, value2);
        }
        "get"(key2) {
          var kvs_node = this.node_map[key2];
          if (kvs_node) {
            return kvs_node.value;
          } else {
            return void 0;
          }
        }
        "push"(key2, value2) {
          var node = this.dll.push(value2);
          node.key = key2;
          this.node_map[key2] = node;
        }
        "out"(key2) {
          var node = this.node_map[key2];
          delete this.node_map[key2];
          this.dll.remove(node);
        }
        "each"(callback2) {
          this.dll.each_node(function(node, stop) {
            callback2(node.key, node.value, stop);
          });
        }
        "values"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push(value2);
          });
          return res2;
        }
        "keys"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push(key2);
          });
          return res2;
        }
        "keys_and_values"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push([key2, value2]);
          });
          return res2;
        }
        // will not need to deal with nodes on the user level.
        // want to be able to add and remove items, normally items will get pushed to the end of the list.
        // will provide a key and value in order to do this.
      };
      module.exports = Ordered_KVS;
    }
  });

  // node_modules/lang-tools/ordered-string-list.js
  var require_ordered_string_list = __commonJS({
    "node_modules/lang-tools/ordered-string-list.js"(exports, module) {
      var Ordered_String_List = class {
        constructor() {
          var arr = [];
          var dict_indexes = {};
          var reindex_dict_indexes = function() {
            dict_indexes = {};
            for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
              dict_indexes[arr[c2]] = c2;
            }
          };
          this.has = function(value2) {
            return typeof dict_indexes[value2] !== "undefined";
          };
          this.put = function(value2) {
            if (this.has(value2)) {
            } else {
              var index = arr.length;
              arr.push(value2);
              dict_indexes[value2] = index;
            }
          };
          this.out = function(value2) {
            if (this.has(value2)) {
              var idx = dict_indexes[value2];
              arr.splice(idx, 1);
              delete dict_indexes[value2];
              for (var c2 = idx, l2 = arr.length; c2 < l2; c2++) {
                var i = arr[c2];
                dict_indexes[i]--;
              }
            }
          };
          this.toggle = function(value2) {
            if (this.has(value2)) {
              this.out(value2);
            } else {
              this.put(value2);
            }
          };
          this.move_value = function(value2, index) {
            if (this.has(value2) && dict_indexes[value2] != index) {
              var old_index = dict_indexes[value2];
              arr.splice(old_index, 1);
              arr.splice(index, 0, value2);
              if (index < old_index) {
                dict_indexes[arr[index]] = index;
                for (var c2 = index + 1; c2 <= old_index; c2++) {
                  dict_indexes[arr[c2]]++;
                }
              } else if (index > old_index) {
                dict_indexes[arr[index]] = index;
                for (var c2 = old_index; c2 < index; c2++) {
                  dict_indexes[arr[c2]]--;
                }
              }
            }
          };
          this._index_scan = function() {
            for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
              console.log("c " + c2 + " arr[c] " + arr[c2] + " idx " + dict_indexes[arr[c2]]);
            }
            ;
          };
          this.toString = function() {
            var res2 = arr.join(" ");
            return res2;
          };
          this.toString.stringify = true;
          this.set = (function(val) {
            if (typeof val === "string") {
              arr = val.split(" ");
              reindex_dict_indexes();
            }
          });
          var a = arguments;
          if (a.length == 1) {
            var spec = a[0];
            if (typeof spec === "string") {
              this.set(spec);
            }
          }
        }
      };
      module.exports = Ordered_String_List;
    }
  });

  // node_modules/lang-tools/Data_Model/Collection.js
  var require_Collection2 = __commonJS({
    "node_modules/lang-tools/Data_Model/Collection.js"(exports, module) {
      module.exports = require_Collection();
    }
  });

  // node_modules/lang-tools/util.js
  var require_util = __commonJS({
    "node_modules/lang-tools/util.js"(exports, module) {
      var jsgui2 = require_lib_lang_mini();
      var Collection = require_Collection2();
      var j = jsgui2;
      var each = j.each;
      var tof = j.tof;
      var atof = j.atof;
      var is_defined = j.is_defined;
      var fp = j.fp;
      var arrayify = j.arrayify;
      var mapify = j.mapify;
      var get_item_sig = j.get_item_sig;
      var vectorify = function(n_fn) {
        var fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            var res2 = a[0];
            for (var c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig == "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              var ats = atof(a);
              if (ats[0] == "array") {
                if (ats[1] == "number") {
                  var res2 = [], n = a[1];
                  each(a[0], function(v, i) {
                    res2.push(fn_res(v, n));
                  });
                  return res2;
                }
                if (ats[1] == "array") {
                  if (ats[0].length != ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    var res2 = [], arr2 = a[1];
                    each(a[0], function(v, i) {
                      res2.push(fn_res(v, arr2[i]));
                    });
                    return res2;
                  }
                }
              }
            }
          }
        });
        return fn_res;
      };
      var n_add = function(n1, n2) {
        return n1 + n2;
      };
      var n_subtract = function(n1, n2) {
        return n1 - n2;
      };
      var n_multiply = function(n1, n2) {
        return n1 * n2;
      };
      var n_divide = function(n1, n2) {
        return n1 / n2;
      };
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var execute_on_each_simple = function(items, fn) {
        var res2 = [], that2 = this;
        each(items, function(i, v) {
          res2.push(fn.call(that2, i));
        });
        return res2;
      };
      var filter_map_by_regex = function(map, regex) {
        var res2 = {};
        each(map, function(v, i) {
          if (i.match(regex)) {
            res2[i] = v;
          }
        });
        return res2;
      };
      var npx = arrayify(function(value2) {
        var res2, a = arguments, t = tof(a[0]);
        if (t === "string") {
          res2 = a[0];
        } else if (t === "number") {
          res2 = a[0] + "px";
        }
        return res2;
      });
      var no_px = arrayify(fp(function(a, sig) {
        var re = /px$/, res2;
        if (sig == "[s]" && re.test(a[0])) {
          res2 = parseInt(a[0]);
        } else {
          res2 = a[0];
        }
        ;
        return res2;
      }));
      var arr_ltrb = ["left", "top", "right", "bottom"];
      var str_arr_mapify = function(fn) {
        var res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              var s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              var res22 = {}, that2 = this;
              each(a[0], function(i, v) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var arr_hex_chars = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F"
      ];
      var dict_hex_to_bin = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15
      };
      var str_hex_to_int = function(str_hex) {
        str_hex = str_hex.toUpperCase();
        var i = str_hex.length;
        var res2 = 0, exp = 1;
        while (i--) {
          var i_part = dict_hex_to_bin[str_hex.charAt(i)];
          var ip2 = i_part * exp;
          res2 = res2 + ip2;
          exp = exp * 16;
        }
        ;
        return res2;
      };
      var byte_int_to_str_hex_2 = function(byte_int) {
        var a = Math.floor(byte_int / 16), b = byte_int % 16, sa = arr_hex_chars[a], sb = arr_hex_chars[b], res2 = sa + sb;
        return res2;
      };
      var arr_rgb_to_str_hex_6 = function(arr_rgb) {
        var r = byte_int_to_str_hex_2(arr_rgb[0]);
        var res2 = r + byte_int_to_str_hex_2(arr_rgb[1]) + byte_int_to_str_hex_2(arr_rgb[2]);
        return res2;
      };
      var arr_rgb_to_css_hex_6 = function(arr_rgb) {
        return "#" + arr_rgb_to_str_hex_6(arr_rgb);
      };
      var input_processors = {};
      var validators = {
        "number": function(value2) {
          return tof(value2) == "number";
        }
      };
      var extend = jsgui2.extend;
      var fp = jsgui2.fp;
      var stringify = jsgui2.stringify;
      var tof = jsgui2.tof;
      var data_types_info = {
        "color": ["indexed_array", [
          ["red", "number"],
          ["green", "number"],
          ["blue", "number"]
        ]],
        "oltrb": ["optional_array", ["left", "top", "right", "bottom"]]
      };
      jsgui2.data_types_info = data_types_info;
      var color_preprocessor_parser = fp(function(a, sig) {
        if (sig == "[s]") {
          var input = a[0];
          var rx_hex = /(#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2}))/;
          var m = input.match(rx_hex);
          if (m) {
            var r = jsgui2.str_hex_to_int(m[2]);
            var g = jsgui2.str_hex_to_int(m[3]);
            var b = jsgui2.str_hex_to_int(m[4]);
            var res2 = [r, g, b];
            return res2;
          }
        }
      });
      input_processors["optional_array"] = fp(function(a, sig) {
        if (a.l == 2) {
          var oa_params = a[0], input = a[1];
          if (tof(input) == "array") {
            if (input.length <= oa_params.length) {
              return input;
            }
          } else {
            return input;
          }
        }
        if (a.l == 3) {
          var oa_params = a[0], items_data_type_name = a[1], input = a[2];
          var input_processor_for_items = jsgui2.input_processors[items_data_type_name];
          if (tof(input) == "array") {
            if (input.length <= oa_params.length) {
              var res2 = [];
              each(input, function(i, v) {
                res2.push(input_processor_for_items(v));
              });
              return res2;
            }
          } else {
            return input_processor_for_items(input);
          }
        }
      });
      input_processors["indexed_array"] = fp(function(a, sig) {
        console.log("indexed_array sig", sig);
        if (a.l == 2) {
          var ia_params = a[0], input = a[1];
          if (tof(input) == "array") {
            if (input.length <= ia_params.length) {
              return input;
            }
          }
        }
        if (a.l == 3) {
          var ia_params = a[0], items_data_type_name = a[1], input = a[2];
          var input_processor_for_items = jsgui2.input_processors[items_data_type_name];
          if (tof(input) == "array") {
            if (input.length <= ia_params.length) {
              var res2 = [];
              each(input, function(i, v) {
                res2.push(input_processor_for_items(v));
              });
              return res2;
            }
          }
        }
      });
      input_processors["n_units"] = function(str_units, input) {
        if (tof(input) == "number") {
          return [input, str_units];
        }
        if (tof(input) == "string") {
          var rx_n_units = /^(\d+)(\w+)$/;
          var match = input.match(rx_n_units);
          if (match) {
            return [parseInt(match[1]), match[2]];
          }
          rx_n_units = /^(\d*\.\d+)(\w+)$/;
          match = input.match(rx_n_units);
          if (match) {
            return [parseFloat(match[1]), match[2]];
          }
        }
      };
      var dti_color = jsgui2.data_types_info["color"];
      input_processors["color"] = function(input) {
        var res2;
        console.log("processing color input: " + stringify(input));
        var input_sig = get_item_sig(input, 2);
        if (input_sig == "[s]") {
          res2 = color_preprocessor_parser(input[0]);
        }
        if (input_sig == "[n,n,n]") {
          res2 = input;
        }
        console.log("res " + stringify(res2));
        console.log("color input_processors output", res2);
        return res2;
      };
      jsgui2.output_processors["color"] = function(jsgui_color) {
        var res2 = jsgui2.arr_rgb_to_css_hex_6(jsgui_color);
        return res2;
      };
      var group = function() {
        var a = arguments;
        if (a.length == 1 && tof(a[0]) == "array") {
          return group.apply(this, a[0]);
        }
        var res2;
        for (var c2 = 0, l2 = a.length; c2 < l2; c2++) {
          var item2 = a[c2];
          if (c2 == 0) {
            res2 = new Collection({ "context": item2.context });
          }
          res2.push(item2);
        }
        var C = a[0].constructor;
        var p = C.prototype;
        var i;
        for (i in p) {
          var tpi = tof(p[i]);
          if (tpi == "function") {
            (function(i2) {
              if (i2 != "each" && i2 != "get" && i2 != "add_event_listener") {
                res2[i2] = function() {
                  var a2 = arguments;
                  res2.each(function(v, i22) {
                    v[i2].apply(v, a2);
                  });
                };
              }
            })(i);
          }
        }
        return res2;
      };
      var true_vals = function(map) {
        var res2 = [];
        for (var i in map) {
          if (map[i]) res2.push(map[i]);
        }
        return res2;
      };
      var Ui16toUi32 = (ui16) => {
        let res2 = new Uint32Array(ui16.length / 2);
        let dv = new DataView(ui16.buffer);
        let l2 = ui16.length;
        let hl = l2 / 2;
        let resw = 0;
        for (let c2 = 0; c2 < hl; c2++) {
          res2[resw++] = dv.getUint32(c2 * 4);
        }
        return res2;
      };
      var Ui32toUi16 = (ui32) => {
        let res2 = new Uint16Array(ui32.length * 2);
        let dv = new DataView(ui32.buffer);
        let l2 = ui32.length;
        let resw = 0;
        for (let c2 = 0; c2 < l2; c2++) {
          res2[resw++] = dv.getUint16(c2 * 4 + 2);
          res2[resw++] = dv.getUint16(c2 * 4);
        }
        console.log("res", res2);
        return res2;
      };
      var util = {
        "Ui16toUi32": Ui16toUi32,
        "Ui32toUi16": Ui32toUi16,
        "vectorify": vectorify,
        "v_add": v_add,
        "v_subtract": v_subtract2,
        "v_multiply": v_multiply,
        "v_divide": v_divide,
        "vector_magnitude": vector_magnitude,
        "distance_between_points": distance_between_points,
        "execute_on_each_simple": execute_on_each_simple,
        "mapify": mapify,
        "filter_map_by_regex": filter_map_by_regex,
        "atof": atof,
        "npx": npx,
        "no_px": no_px,
        "str_arr_mapify": str_arr_mapify,
        "arr_ltrb": arr_ltrb,
        "true_vals": true_vals,
        "validators": validators,
        "__data_id_method": "lazy",
        "str_hex_to_int": str_hex_to_int,
        "arr_rgb_to_css_hex_6": arr_rgb_to_css_hex_6,
        "group": group
      };
      module.exports = util;
    }
  });

  // node_modules/lang-tools/lang.js
  var require_lang = __commonJS({
    "node_modules/lang-tools/lang.js"(exports, module) {
      var lang_mini = require_lib_lang_mini();
      var collective = require_collective();
      var { more_general_equals } = require_tools();
      lang_mini.equals = more_general_equals;
      lang_mini.collective = collective;
      lang_mini.collect = collective;
      var Evented_Class = lang_mini.Evented_Class;
      var B_Plus_Tree = require_b_plus_tree();
      var Collection = require_Collection();
      var Data_Object = require_Data_Object2();
      var Data_Value2 = require_Data_Value3();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Value = require_Immutable_Data_Value();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var Doubly_Linked_List = require_doubly_linked_list();
      var Ordered_KVS = require_ordered_kvs();
      var Ordered_String_List = require_ordered_string_list();
      var Sorted_KVS = require_sorted_kvs();
      var util = require_util();
      lang_mini.util = util;
      lang_mini.B_Plus_Tree = B_Plus_Tree;
      lang_mini.Collection = Collection;
      lang_mini.Data_Object = Data_Object;
      lang_mini.Data_Value = Data_Value2;
      lang_mini.Immutable_Data_Model = Immutable_Data_Model;
      lang_mini.Immutable_Data_Value = Immutable_Data_Value;
      lang_mini.Data_Model = Data_Model;
      lang_mini.Doubly_Linked_List = Doubly_Linked_List;
      lang_mini.Ordered_KVS = Ordered_KVS;
      lang_mini.Ordered_String_List = Ordered_String_List;
      lang_mini.Sorted_KVS = Sorted_KVS;
      var ec = new Evented_Class();
      Object.assign(ec, lang_mini);
      module.exports = ec;
    }
  });

  // node_modules/jsgui3-html/html-core/text-node.js
  var require_text_node = __commonJS({
    "node_modules/jsgui3-html/html-core/text-node.js"(exports, module) {
      var { tof, Evented_Class } = require_lang();
      var escape_html_replacements = [
        [/&/g, "&amp;"],
        [/</g, "&lt;"],
        [/>/g, "&gt;"],
        [/"/g, "&quot;"],
        //"
        [/'/g, "&#x27;"],
        //'
        [/\//g, "&#x2F;"]
      ];
      var escape_html = (str) => {
        if (tof(str) == "data_value") str = str.get();
        var single_replacement;
        for (var c2 = 0, l2 = escape_html_replacements.length; c2 < l2; c2++) {
          single_replacement = escape_html_replacements[c2];
          str = str.replace(single_replacement[0], single_replacement[1]);
        }
        return str;
      };
      var textNode = class extends Evented_Class {
        //class textNode extends Control {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "text_node";
          super();
          if (typeof spec == "string") {
            spec = {
              "text": spec
            };
          }
          spec.nodeType = 3;
          spec = spec || {};
          if (spec.el) {
            this.dom = {
              el: spec.el
            };
          } else {
            this.dom = {};
          }
          if (spec.sibling_index) this.sibling_index = spec.sibling_index;
          if (typeof spec.text !== "undefined") {
            this._text = spec.text;
          }
          this.on("change", (e_change) => {
            if (this.dom.el) {
              this.dom.el.nodeValue = e_change.value;
            }
          });
        }
        activate() {
          if (!this.__active) {
            this.__active = true;
          }
        }
        get text() {
          return this._text;
        }
        set text(value2) {
          this._text = value2;
          this.raise("change", {
            "name": "text",
            "value": value2
          });
        }
        "all_html_render"() {
          return this.nx ? this._text || "" : escape_html(this._text || "") || "";
        }
        // getter and setter for the text itself?
        //  A variety of properties will use getters and setters so that the updates get noted.
      };
      module.exports = textNode;
    }
  });

  // node_modules/fnl/fn-io-transform.js
  var require_fn_io_transform = __commonJS({
    "node_modules/fnl/fn-io-transform.js"(exports, module) {
      var { deep_sig } = require_lib_lang_mini();
      var isArguments = (item2) => Object.prototype.toString.call(item2) === "[object Arguments]";
      var fn_transformation = (fn, map_transformations) => {
        const input_transformations = map_transformations.i;
        const output_transformations = map_transformations.o;
        const fn_res = function() {
          const args = arguments;
          if (args.length === 2 && typeof args[1] === "function") {
            let [a, cb_transform_exec_events] = args;
            if (isArguments(a)) {
              if (a.length === 1) {
                a = a[0];
              }
            }
            const sig_called_with = deep_sig(a);
            const sig_arguments = deep_sig(arguments);
            const exec_fn = () => {
              cb_transform_exec_events({
                "name": "exec-start"
                //,
                //sig: evt_output_transform.sig,
                //value: evt_output_transform.value
              });
              const fn_res2 = fn.call(null, a);
              cb_transform_exec_events({
                "name": "exec-complete"
                //,
                //sig: evt_output_transform.sig,
                //value: evt_output_transform.value
              });
              const sig_fn_res = deep_sig(fn_res2);
              if (output_transformations) {
                if (output_transformations[sig_fn_res]) {
                  output_transformations[sig_fn_res].call(null, fn_res2, (evt_output_transform) => {
                    cb_transform_exec_events({
                      "name": "complete",
                      sig: evt_output_transform.sig,
                      value: evt_output_transform.value
                    });
                  });
                } else {
                  cb_transform_exec_events({
                    "name": "complete",
                    sig: sig_fn_res,
                    value: fn_res2
                  });
                }
              } else {
                cb_transform_exec_events({
                  "name": "complete",
                  sig: sig_fn_res,
                  value: fn_res2
                });
              }
            };
            const skip_fn = () => {
              cb_transform_exec_events({
                "name": "complete",
                //sig: sig_fn_res,
                value: a,
                skipped: true
              });
            };
            if (input_transformations) {
              let do_skip = false;
              if (fn.skip) {
                do_skip = fn.skip(a);
              }
              if (do_skip) {
                skip_fn();
              } else {
                if (fn.map_sigs && fn.map_sigs[sig_called_with]) {
                  exec_fn();
                } else {
                  if (input_transformations[sig_called_with]) {
                    cb_transform_exec_events({
                      "name": "input-transform-start"
                    });
                    input_transformations[sig_called_with].call(null, a, (evt_input_transform) => {
                      const { name, sig, value: value2, io_sigs } = evt_input_transform;
                      if (name === "complete") {
                        a = value2;
                        evt_input_transform.name = "input-transform-complete";
                        cb_transform_exec_events(evt_input_transform);
                        exec_fn();
                      } else {
                        console.trace();
                        throw "NYI";
                      }
                    });
                  } else {
                    exec_fn();
                  }
                }
              }
            } else {
              exec_fn();
            }
          } else {
            throw "Expected args: normal_args, cb_transform_event";
          }
        };
        if (fn.name) fn_res.name = fn.name;
        if (fn.main) fn_res.main = fn.main;
        if (fn.skip) fn_res.skip = fn.skip;
        return fn_res;
      };
      module.exports = fn_transformation;
    }
  });

  // node_modules/fnl/monitor-item.js
  var require_monitor_item = __commonJS({
    "node_modules/fnl/monitor-item.js"(exports, module) {
      var { tf: tf2, deep_sig, each, def } = require_lib_lang_mini();
      var monitor_item = (item2, cb_evt_monitoring) => {
        const ti = tf2(item2);
        if (ti === "A") {
          const l2 = item2.length;
          for (let c2 = 0; c2 < l2; c2++) {
            const arg = item2[c2];
            ((arg2, c3) => {
              monitor_item(arg2, (evt_arg_monitor) => {
                evt_arg_monitor.arg_index = c3;
                cb_evt_monitoring(evt_arg_monitor);
              });
            })(arg, c2);
          }
        } else if (ti === "s") {
          cb_evt_monitoring({
            name: "complete",
            t: "s",
            bytes: item2.length * 2
          });
        } else if (ti === "o") {
          cb_evt_monitoring({
            name: "complete",
            t: "o"
            //,
            //bytes: item.length * 2
          });
        } else if (ti === "R") {
          const rs = item2;
          let bytes = 0;
          const ms_start = Date.now();
          let content_length, bytes_remaining;
          const { headers } = item2;
          if (headers && headers["content-length"]) {
            content_length = parseInt(headers["content-length"], 10);
            bytes_remaining = content_length;
          }
          const o_evt = {
            name: "available",
            t: "R",
            ms: ms_start,
            headers
            //,
            //bytes: item.length * 2
          };
          if (def(content_length)) {
            o_evt.content_length = content_length;
          }
          cb_evt_monitoring(o_evt);
          rs.on("data", (data) => {
            bytes += data.length;
            bytes_remaining -= data.length;
            const ms = Date.now();
            const ms_taken = ms - ms_start;
            const byte_rate = bytes / (ms_taken / 1e3);
            const est_remaining = bytes_remaining / byte_rate * 1e3;
            const proportion = bytes / content_length;
            const ms_est_complete = ms + est_remaining;
            cb_evt_monitoring({
              name: "data",
              t: "B",
              bytes: data.length,
              bytes_total: bytes,
              byte_rate,
              content_length,
              bytes_remaining,
              ms_est_remaining: est_remaining,
              ms_est_complete,
              ms_taken,
              proportion
            });
          });
          rs.on("end", () => {
            const ms_complete = Date.now();
            const ms_taken = ms_complete - ms_start;
            const byte_rate = bytes / (ms_taken / 1e3);
            cb_evt_monitoring({
              name: "complete",
              ms: ms_complete,
              ms_taken,
              t: "R",
              "bytes": bytes,
              byte_rate
              //,
              //bytes: item.length * 2
            });
          });
          rs.on("error", (err) => {
            cb_evt_monitoring({
              name: "error",
              value: err,
              t: "R"
              //,
              //bytes: item.length * 2
            });
          });
        } else if (ti === "B") {
          cb_evt_monitoring({
            name: "complete",
            t: "B",
            bytes: item2.length
          });
        } else if (ti === "a") {
          cb_evt_monitoring({
            name: "complete",
            t: "a"
          });
        } else {
          console.log("ti", ti);
          console.trace();
          throw "stop";
        }
      };
      module.exports = monitor_item;
    }
  });

  // node_modules/fnl/default-arg-transformations.js
  var require_default_arg_transformations = __commonJS({
    "node_modules/fnl/default-arg-transformations.js"(exports, module) {
      var { deep_sig } = require_lib_lang_mini();
      var transformations = {
        "O": (obs, cb_events) => {
          obs.then((res2) => {
            const sig = deep_sig(res2);
            if (cb_events) cb_events({
              name: "complete",
              io_sigs: ["O", sig],
              sig,
              value: res2
            });
          }, (err) => {
          });
        },
        "p": (p, cb_events) => {
          p.then((res2) => {
            const sig = deep_sig(res2);
            if (cb_events) cb_events({
              name: "complete",
              io_sigs: ["p", sig],
              sig,
              value: res2
            });
          }, (err) => {
          });
        },
        "R": (input_readable_stream, cb_events) => {
          const chunks = [];
          const ms_start = Date.now();
          input_readable_stream.on("data", (data) => {
            chunks.push(data);
          });
          input_readable_stream.on("end", () => {
            const ms_complete = Date.now();
            const buf = Buffer.concat(chunks);
            const ms_taken = ms_complete - ms_start;
            const byte_rate = buf.length / (ms_taken / 1e3);
            if (cb_events) cb_events({
              name: "complete",
              sig: "B",
              io_sigs: ["R", "B"],
              value: buf,
              bytes: buf.length,
              ms: ms_complete,
              ms_taken,
              byte_rate
            });
          });
          input_readable_stream.on("error", (err) => {
            console.log("error reading stream for param transformation in stages()");
            error(err);
          });
        }
        // this level: param sig required
        // this level: param sig given: function to transform
        // promise resolution here?
      };
      module.exports = transformations;
    }
  });

  // node_modules/fnl/fnl.js
  var require_fnl = __commonJS({
    "node_modules/fnl/fnl.js"(exports, module) {
      var { each, Evented_Class, get_a_sig: get_a_sig2, get_truth_map_from_arr, tof, tf: tf2, mfp, deep_sig, clone, def, is_array } = require_lib_lang_mini();
      var fn_io_transform = require_fn_io_transform();
      var log = () => {
      };
      var nce = (obs, next, complete, error2) => {
        obs.on("next", next);
        obs.on("complete", complete);
        obs.on("error", error2);
        return obs;
      };
      var monitor_item = require_monitor_item();
      var tm_status_strings = {
        "init": true,
        "ok": true,
        "complete": true,
        "error": true,
        "paused": true
      };
      var observable = function(fn_inner, opts) {
        const a = arguments;
        const l2 = a.length;
        const sig = get_a_sig2(a);
        let _opts, _fn_inner;
        if (sig === "[f]" || sig === "[f,u]") {
          _opts = {};
          _fn_inner = a[0];
        } else if (sig === "[f,o]") {
          _fn_inner = a[0];
          _opts = a[1];
        } else if (sig === "[o,f]") {
          _opts = a[0];
          _fn_inner = a[1];
        } else {
          if (sig === "[O]" || sig === "[O,u]") {
            return a[0];
          } else {
            console.log("sig", sig);
            console.trace();
            throw "NYI";
          }
        }
        const obs_res = ((opts2, fn_inner2) => {
          const ms_start = Date.now();
          const ms_since_start = () => Date.now() - ms_start;
          const res2 = new Evented_Class();
          const io = res2.io = new Evented_Class();
          let llog = [];
          let _status = "init";
          Object.defineProperty(res2, "ms_start", {
            value: ms_start,
            writable: false
          });
          let ms_ok, ms_complete, ms_error;
          let ms_to_ok, ms_to_complete, ms_to_error;
          const map_status_data = {};
          const map_ms_reached_status = {};
          let stage_number = -1;
          let stage_name = "init";
          const log2 = (data) => {
            const log_item = [Date.now(), data];
            llog.push(log_item);
            res2.raise("log", log_item);
          };
          const status = (str_status, data) => {
            if (tm_status_strings[str_status]) {
              const old_status = _status;
              if (!map_ms_reached_status[str_status]) {
                map_ms_reached_status[str_status] = Date.now();
              }
              map_status_data[str_status] = data;
              _status = str_status;
              res2.raise("status", {
                old: old_status,
                value: str_status,
                data
              });
            } else {
              console.trace();
              log2("str_status", str_status);
              throw "invalid str_status " + str_status;
            }
          };
          let _stage;
          let current_stage_info;
          Object.defineProperty(res2, "log", {
            get() {
              return llog;
            }
          });
          Object.defineProperty(res2, "status", {
            get() {
              return _status;
            }
          });
          let had_next = false, had_complete = false, had_error = false;
          setTimeout(() => {
            const res_fn_inner = fn_inner2((data) => {
              let passes = true;
              had_next = true;
              if (!had_complete && !had_error) {
                if (this.filters) {
                  for (let filter of this.filters) {
                    passes = filter(data);
                    if (!passes) break;
                  }
                }
              } else {
                if (had_complete) {
                  console.warn('Observable can not raise "next" event after having raised its "complete" event.');
                }
                if (had_error) {
                  console.warn('Observable can not raise "next" event after having raised its "error" event.');
                }
              }
              if (passes) {
                res2.raise("next", data);
                res2.raise("data", data);
              }
            }, (last_data) => {
              if (!had_complete && !had_error) {
                had_complete = true;
                const tld = tf2(last_data);
                const ms_complete2 = Date.now();
                res2.ms_complete = ms_complete2;
                res2.ms_taken = ms_complete2 - ms_start;
                if (tld !== "u") {
                  if (tld === "R") {
                    io.ongoing = true;
                    last_data.on("complete", () => {
                      io.ongoing = false;
                      io.raise("complete");
                    });
                  } else {
                    res2.raise("complete", last_data);
                    io.raise("complete");
                  }
                } else {
                  res2.raise("complete");
                }
              } else {
                if (had_complete) {
                  console.warn('WARNING: Observable can not raise "complete" event after having raised it already.');
                }
                if (had_error) {
                  console.warn('WARNING: Observable can not raise "complete" event after having raised its "error" event.');
                }
              }
            }, (error2) => {
              if (!had_complete && !had_error) {
                had_error = true;
                res2.raise("error", error2);
              } else {
                if (had_complete) {
                  console.warn('WARNING: Observable can not raise "error" event after having raised its "complete" event.');
                }
                if (had_error) {
                  console.warn('WARNING: Observable can not raise "error" event after having raised it already.');
                }
              }
            }, status, log2) || [];
            if (is_array(res_fn_inner)) {
              const [stop, pause, resume] = res_fn_inner;
              if (stop) res2.stop = stop;
              if (pause) res2.pause = pause;
              if (resume) res2.resume = resume;
              if (pause && resume) {
                res2.delay = (ms) => {
                  pause();
                  res2.raise("paused");
                  setTimeout(() => {
                    res2.resume();
                    res2.raise("resumed");
                  }, ms);
                };
              }
            }
          }, 0);
          res2.next = (handler) => {
            res2.on("next", handler);
            return res2;
          };
          res2.data = res2.next;
          res2.complete = (handler) => {
            res2.on("complete", handler);
            return res2;
          };
          res2.on("complete", (data) => {
            status("complete");
            const store_res = () => {
              if (data) {
                if (data.data) {
                  res2.res = data.data;
                } else {
                  res2.res = data;
                }
              }
            };
          });
          res2.done = res2.end = res2.complete;
          res2.error = (handler) => {
            res2.on("error", handler);
            return res2;
          };
          res2.then = (handler) => {
            let res_all = [];
            res2.next((data) => {
              res_all.push(data);
              had_next = true;
            });
            if (res2.completed) {
              if (res2.singular_result) {
                handler(res_all[0]);
              } else {
                handler(res_all);
              }
            } else {
              res2.complete((last) => {
                if (had_next && res_all.length > 0) {
                  if (res2.singular_result) {
                    handler(res_all[0]);
                  } else {
                    handler(res_all);
                  }
                } else {
                  handler(last);
                }
              });
            }
          };
          res2.__type_name = "observable";
          res2._is_obs = res2._is_observable = true;
          res2._ = new Evented_Class();
          res2.meta = (k, v) => {
            if (v === void 0) {
            } else {
              res2._[key] = value;
              res2._.raise("change", {
                key: k,
                value: v
              });
            }
          };
          return res2;
        })(_opts, _fn_inner);
        return obs_res;
      };
      observable._ = {
        name: "observable",
        return_type: "observable",
        async: true
      };
      var obsfilter = (obs, next_filter) => observable((next, complete, error2) => {
        obs.on("next", (data) => {
          if (next_filter(data)) {
            next(data);
          }
        });
        obs.on("complete", (data) => {
          if (data) {
            complete(data);
          } else {
            complete();
          }
        });
        obs.on("error", (err) => {
          error2(err);
        });
      });
      var obsmap = (obs, fn_map) => observable((next, complete, error2) => {
        obs.on("next", (data) => next(fn_map(data)));
        obs.on("complete", complete);
        obs.on("error", error2);
      });
      var obsalias = (obs_like, mapping) => {
        let next, complete, error2;
        const tmapping = tof(mapping);
        if (tmapping === "array") {
          [next, complete, error2] = mapping;
        } else if (tmapping === "object") {
          next = mapping.next;
          complete = mapping.complete;
          error2 = mapping.error;
        }
        return observable((n, c2, e) => {
          if (next) {
            obs_like.on(next, n);
          } else {
            obs_like.on("next", n);
          }
          if (complete) {
            obs_like.on(complete, c2);
          } else {
            obs_like.on("complete", c2);
          }
          if (error2) {
            obs_like.on(error2, e);
          } else {
            obs_like.on("error", e);
          }
        });
      };
      var obscollect = (obs, fn_collect, arr_res) => {
        obs.on("next", (data) => {
          const item_res = fn_collect(data);
          arr_res.push(item_res);
        });
        return obs;
      };
      var obspool = () => {
        console.trace();
        throw "out of order";
      };
      var seq = (q_obs) => {
        return observable((next, complete, error2) => {
          let c2 = 0, obs_q_item;
          let process2 = () => {
            if (c2 < q_obs.length) {
              let q_item = q_obs[c2];
              obs_q_item = q_item[1].apply(q_item[0], q_item[2]);
              obs_q_item.on("next", (data) => {
                next(data);
              });
              obs_q_item.on("error", (error3) => {
                error3(error3);
              });
              obs_q_item.on("complete", (data) => {
                c2++;
                process2();
              });
            } else {
              complete();
            }
          };
          process2();
          let stop = () => {
            obs_q_item.stop();
            complete();
          };
          let pause = () => {
            obs_q_item.pause();
          };
          let resume = () => {
            obs_q_item.resume();
          };
          return [stop, pause, resume];
        });
      };
      var obs_to_cb = (obs, callback2) => {
        let _obs = observable(obs);
        let arr_all = [];
        _obs.on("next", (data) => arr_all.push(data));
        _obs.on("error", (err) => callback2(err));
        _obs.on("complete", (last) => {
          if (typeof last !== "undefined") {
            callback2(null, last, arr_all);
          } else {
            callback2(null, arr_all);
          }
        });
      };
      var unpage = (obs) => {
        return observable((next, complete, error2) => {
          obs.on("next", (arr_data) => {
            if ("unpaged" in arr_data) {
              let unpaged = arr_data.unpaged;
              for (let c2 = 0, l2 = unpaged.length; c2 < l2; c2++) {
                next(unpaged[c2]);
              }
            } else {
              for (let c2 = 0, l2 = arr_data.length; c2 < l2; c2++) {
                next(arr_data[c2]);
              }
            }
          });
          obs.on("complete", () => {
            complete();
          });
          obs.on("error", (err) => error2(err));
          return [];
        });
      };
      var obs_or_cb = (obs, callback2, always_plural) => {
        if (callback2) {
          obs_to_cb(obs, callback2);
        } else {
          return observable(obs, always_plural);
        }
      };
      var sig_obs_or_cb = (a, inner) => {
        let a2;
        let callback2;
        if (typeof a[a.length - 1] === "function") {
          a2 = Array.prototype.slice.call(a, 0, -1);
          callback2 = a[a.length - 1];
        } else if (typeof a[a.length - 1] === "undefined") {
          a2 = Array.prototype.slice.call(a, 0, -1);
        } else {
          a2 = Array.prototype.slice.call(a);
        }
        let sig = get_a_sig2(a2);
        let obs = observable((next, complete, error2) => {
          return inner(a2, sig, next, complete, error2, a2.length);
        });
        return obs_or_cb(obs, callback2);
      };
      var cb_to_prom_or_cb = (inner_with_cb, opt_cb) => {
        if (typeof opt_cb !== "undefined") {
          inner_with_cb(opt_cb);
        } else {
          return new Promise((resolve, reject) => {
            inner_with_cb((err, res2) => {
              if (err) {
                reject(err);
              } else {
                resolve(res2);
              }
            });
          });
        }
      };
      var prom_or_cb = (prom2, opt_cb) => {
        let _prom;
        if (prom2 instanceof Promise) {
          _prom = prom2;
        } else {
          _prom = new Promise(prom2);
        }
        if (opt_cb) {
          _prom.then((res2) => {
            opt_cb(null, res2);
          }, (err) => {
            opt_cb(err);
          });
        } else {
          return _prom;
        }
      };
      var prom = (prom2) => {
        if (prom2 instanceof Promise) {
          return prom2;
        } else {
          return new Promise(prom2);
        }
      };
      var is_obs = (obj2) => {
        return obj2.is_obs === true;
      };
      var is_prom = (obj2) => {
        return obj2 instanceof Promise || obj2.is_obs === true;
      };
      var obs_prom_arr_item = (obj2, obs, prom2, arr, item2) => {
        if (obj2.is_obs === true) {
          return obs(obj2);
        } else {
          if (obj2 instanceof Promise) {
            return prom2(obj2);
          } else {
            if (Array.isArray(obj2)) {
              return arr(obj2);
            } else {
              return item2(obj2);
            }
          }
        }
      };
      var arg_transformation = require_default_arg_transformations();
      var transform_stage_input = {
        "R": arg_transformation.R
      };
      var stages = mfp({
        name: "stages",
        return_type: "function"
        // function that returns an observable.
      }, function() {
        const a = arguments, l2 = a.length;
        const sig = get_a_sig2(a);
        let arr_stages;
        let num_stages;
        let fn_inner;
        const prepare_arr_fns = (ofns) => {
          const input_ofns2 = (ofns2) => {
            const map_stage_reserved_names = {
              _raise_stage_event: true
            };
            const res2 = [];
            const o_filtered_stage_fns = {};
            let num_stages2 = 0;
            let last_stage_name;
            each(ofns2, (fn_stage, stage_name) => {
              if (!map_stage_reserved_names[stage_name]) {
                o_filtered_stage_fns[stage_name] = fn_stage;
                num_stages2++;
                last_stage_name = stage_name;
              }
            });
            each(o_filtered_stage_fns, (fn_stage, stage_name) => {
              const is_last_stage = stage_name === last_stage_name;
              const map_sigs = fn_stage.map_sigs;
              if (Object.keys(fn_stage).length === 0) {
                const io_transform = {};
                if (!is_last_stage) {
                  io_transform.o = {
                    p: arg_transformation.p
                  };
                }
                const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                io_transformed_stage.name = stage_name;
                res2.push([stage_name, io_transformed_stage]);
              } else {
                if (map_sigs) {
                  const io_transform = {
                    i: transform_stage_input
                  };
                  io_transform.o = {
                    "p": arg_transformation.p,
                    "O": arg_transformation.O
                  };
                  const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                  io_transformed_stage.name = stage_name;
                  res2.push([stage_name, io_transformed_stage]);
                } else {
                  const io_transform = {};
                  io_transform.o = {
                    "p": arg_transformation.p,
                    "O": arg_transformation.O
                  };
                  const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                  io_transformed_stage.name = stage_name;
                  res2.push([stage_name, io_transformed_stage]);
                }
              }
            });
            return res2;
          };
          return input_ofns2(ofns);
        };
        const prepare = () => {
          if (sig === "[a]") {
            valid = true;
            each(a[0], (stage) => {
              if (get_a_sig2(stage) === "[s,f]") {
                const [stage_name, fn_stage] = stage;
                if (!fn_stage.name) fn_stage.name = stage_name;
              } else {
                valid = false;
                console.trace();
                throw "expected stage to be specified as an array [s,f]";
              }
            });
            if (valid) {
              arr_stages = prepare_arr_fns(a[0]);
              num_stages = arr_stages.length;
            }
          } else if (sig === "[o]") {
            input_ofns(a[0]);
          } else if (sig === "[f]") {
            arr_stages = prepare_arr_fns(a[0]());
            num_stages = arr_stages.length;
          } else {
            console.trace();
            throw "stages expected an array or object (may become more flexible in the future)";
          }
        };
        const ms_pre_prepare = Date.now();
        let res_prepare = prepare();
        const ms_prep_time = Date.now() - ms_pre_prepare;
        if (res_prepare) {
          log("ms_prep_time", ms_prep_time);
          return res_prepare;
        }
        const arr_stages_info = new Array(arr_stages.length);
        each(arr_stages, (arr_stage, i) => {
          const stage_name = arr_stage[0];
          arr_stages_info[i] = {
            name: stage_name
          };
        });
        const process2 = () => {
          const res2 = function() {
            const a2 = arguments, l22 = a2.length;
            const sig2 = get_a_sig2(a2);
            let next_apply_args = a2.length === 0 ? void 0 : a2;
            const obs_res = observable((next, complete, error2, status, log2, stage) => {
              const log_stage_events = [];
              obs_res.log_stage_events = log_stage_events;
              const map_stage_events_by_name = {};
              let ms_last_stage_event;
              let c2 = 0;
              const cb_stage_event = (name, evt) => {
                evt = evt || {
                  name
                };
                const now = Date.now();
                evt.ms = now;
                evt.i_stage = c2;
                evt.stage_name = arr_stages2[c2][0];
                if (ms_last_stage_event) {
                  evt.ms_since_last = now - ms_last_stage_event;
                }
                ms_last_stage_event = now;
                log_stage_events.push(evt);
                map_stage_events_by_name[name] = evt;
                if (name === "have-response") {
                  obs_res.ms_latency = now - map_stage_events_by_name["make-request"].ms;
                }
                obs_res.raise("stage", evt);
              };
              const t12 = Date.now();
              const new_obj_fns = a[0](cb_stage_event);
              const newly_prepared_stages = prepare_arr_fns(new_obj_fns);
              const arr_stages2 = newly_prepared_stages;
              const reprep_time = Date.now() - t12;
              log2("reprep_time", reprep_time);
              const res_input = obs_res.input = {};
              const res_output = obs_res.output = {};
              const res_stages = obs_res.stages = clone(arr_stages_info);
              monitor_item(a2, (evt_input_args) => {
                const event_name = evt_input_args.name;
              });
              let i_last_unskipped_stage = -1;
              let exec_is_complete = false;
              const process_next = () => {
                const have_next_stage = !!arr_stages2[c2];
                const i_stage = c2;
                log2("have_next_stage", have_next_stage);
                if (have_next_stage) {
                  const stage_name = arr_stages2[c2][0];
                  const fn_stage = arr_stages2[c2][1];
                  const is_main_stage = fn_stage.main === true;
                  const is_last_stage = c2 === arr_stages2.length - 1;
                  const res_stage = res_stages[c2];
                  const res_prev_stage = res_stages[c2 - 1];
                  const res_next_stage = res_stages[c2 + 1];
                  res_stage.ms_start = Date.now();
                  if (is_main_stage) {
                    res_stage.main = true;
                  }
                  let fn_ready_args;
                  const exec_fn = () => {
                    const i_stage2 = c2;
                    console.log("calling exec_fn " + stage_name);
                    console.trace();
                    const stage_res = fn_stage.call(this, fn_ready_args, (transform_call_event) => {
                      const { name, sig: sig3, value: value2 } = transform_call_event;
                      if (name === "complete") {
                        if (transform_call_event.skipped === true) {
                          res_stage.skipped = true;
                        } else {
                          if (i_stage2 > i_last_unskipped_stage) i_last_unskipped_stage = i_stage2;
                          let content_length;
                          monitor_item(value2, (evt_stage_res) => {
                            const cl_evt = clone(evt_stage_res);
                            const event_name = evt_stage_res.name;
                            if (event_name === "complete") {
                              console.log("c", c2);
                              console.log("stage item complete");
                              const ms_output_complete = Date.now();
                              const ms_taken = ms_output_complete - res_stage.ms_start;
                              res_stage.ms_output_complete = ms_output_complete;
                              if (res_stage.ms_output_start) {
                                const ms_output_taken = res_stage.ms_output_taken = ms_output_complete - res_stage.ms_output_start;
                                if (ms_output_taken > 0) {
                                  if (res_stage.bytes_out) {
                                    const output_rate = res_stage.bytes_out / (ms_output_taken / 1e3);
                                    res_stage.output_rate = output_rate;
                                    if (is_main_stage) {
                                      obs_res.main_rate = output_rate;
                                    }
                                  }
                                }
                              }
                              res_stage.ms_taken = ms_taken;
                              console.log("c", c2);
                              console.log("i_stage", i_stage2);
                              console.log("is_last_stage", is_last_stage);
                            } else if (event_name === "available") {
                              if (evt_stage_res.content_length) {
                                res_stage.content_length = evt_stage_res.content_length;
                                if (is_main_stage) {
                                  content_length = obs_res.content_length = evt_stage_res.content_length;
                                }
                              }
                              res_stage.ms_output_start = Date.now();
                            } else if (event_name === "data") {
                              const { bytes, bytes_total, byte_rate, content_length: content_length2, bytes_remaining, ms_est_remaining, ms_est_complete, ms_taken, proportion } = evt_stage_res;
                              const ms_processing_output = ms_taken;
                              const out_rate = byte_rate;
                              res_stage.bytes_out = bytes_total;
                              if (res_stage.bytes_in) {
                                res_stage.bytes_oi_ratio = res_stage.bytes_out / res_stage.bytes_in;
                              }
                              if (is_main_stage) {
                                obs_res.main_bytes_out = bytes_total;
                                obs_res.main_output_rate = out_rate;
                              }
                              if (i_last_unskipped_stage === i_stage2) {
                                obs_res.bytes_out = bytes_total;
                                obs_res.output_rate = out_rate;
                                if (def(proportion)) obs_res.proportion = proportion;
                                if (def(bytes_remaining)) obs_res.bytes_remaining = bytes_remaining;
                                if (def(ms_est_remaining)) obs_res.ms_est_remaining = ms_est_remaining;
                                if (def(ms_est_complete)) obs_res.ms_est_complete = ms_est_complete;
                              }
                              if (res_next_stage) {
                                res_next_stage.bytes_in = res_next_stage.bytes_in || 0;
                                res_next_stage.bytes_in += cl_evt.bytes;
                              }
                            } else {
                              log2("event_name", event_name);
                              console.trace();
                              throw "stop";
                            }
                          });
                        }
                        next_apply_args = value2;
                        c2++;
                        log2("pre process next stage");
                        process_next();
                      } else {
                        log2("transform_call_event", transform_call_event);
                        if (name === "input-transform-complete") {
                          const ms_input_transform_complete = Date.now();
                          res_stage.ms_input_transform_complete = ms_input_transform_complete;
                          res_stage.ms_input_transform_taken = ms_input_transform_complete - res_stage.ms_input_transform_start;
                        } else if (name === "input-transform-start") {
                          res_stage.ms_input_transform_start = Date.now();
                        } else if (name === "exec-start") {
                          res_stage.ms_exec_start = Date.now();
                        } else if (name === "exec-complete") {
                          const ms_exec_complete = Date.now();
                          res_stage.ms_exec_complete = ms_exec_complete;
                          res_stage.ms_exec_taken = ms_exec_complete - res_stage.ms_exec_start;
                        } else {
                          log2("name", name);
                          log2("transform_call_event", transform_call_event);
                          console.trace();
                          throw "stop";
                        }
                      }
                    });
                  };
                  fn_ready_args = next_apply_args;
                  log2("pre exec_fn");
                  exec_fn();
                } else {
                  const tsr = tf2(next_apply_args);
                  c2++;
                  log2("tsr", tsr);
                  console.log("the stages exec is complete");
                  console.log("i_last_unskipped_stage", i_last_unskipped_stage);
                  exec_is_complete = true;
                  complete(next_apply_args);
                }
              };
              process_next();
            });
            return obs_res;
          };
          res2.is_staged = true;
          res2.return_type = "observable";
          return res2;
        };
        return process2();
      });
      module.exports = {
        "observable": observable,
        "nce": nce,
        "obs": observable,
        "obsalias": obsalias,
        "obscollect": obscollect,
        "obsfilter": obsfilter,
        "obspool": obspool,
        "obsmap": obsmap,
        "seq": seq,
        "sequence": seq,
        "sig_obs_or_cb": sig_obs_or_cb,
        "cb_to_prom_or_cb": cb_to_prom_or_cb,
        "prom_or_cb": prom_or_cb,
        "prom": prom,
        "obs_or_cb": obs_or_cb,
        "unpage": unpage,
        "is_obs": is_obs,
        "is_prom": is_prom,
        "obs_prom_arr_item": obs_prom_arr_item,
        "stages": stages
      };
      if (__require.main === module) {
        console.log("running fnl as main");
        const make_timer_obs = () => observable((next, complete, error2) => {
          let c2 = 2;
          let paused = false;
          let cease = () => {
            clearInterval(ivl);
          };
          let stop = () => {
            clearInterval(ivl);
            complete();
          };
          let ivl = setInterval(() => {
            if (!paused) {
              let v = c2 * 2;
              next({
                "v": v
              });
              c2++;
              if (c2 > 6) {
                error2(new Error("A problem"));
                cease();
              }
              if (c2 > 8) {
                stop();
              }
            }
          }, 1e3);
          return [stop, () => {
            paused = true;
          }, () => {
            paused = false;
          }];
        });
        let obs = make_timer_obs();
        let test_obs = () => {
          obs.on("paused", () => log("* paused"));
          obs.on("resumed", () => log("* resumed"));
          obs.on("error", (err) => log("* error", err));
          obs.next((data) => {
            log("data", data);
          });
        };
        test_obs();
        let test_then = () => {
          (async () => {
            let res2 = await obs;
            log("awaited res", res2);
          })();
        };
        log("stages", stages);
        let test_split = () => {
          obs.on("paused", () => log("* paused"));
          obs.on("resumed", () => log("* resumed"));
          let [obs1, obs2] = obs.split((data) => data.v % 3 === 0);
          obs1.on("next", (data) => log("obs1 data", data));
          obs2.on("next", (data) => log("obs2 data", data));
        };
        let test_filter = () => {
          obs.filter((data) => {
            return data.v !== 8;
          }).filter((data) => {
            return data.v % 3 !== 0;
          });
          obs.next((data) => {
            if (data === 8) {
              obs.delay(5e3);
              obs.pause();
              log("paused");
              setTimeout(() => {
                log("wait over");
                obs.resume();
              }, 2e3);
            }
          }).end(() => {
            log("end");
          });
        };
      } else {
      }
    }
  });

  // node_modules/obext/node_modules/lang-mini/lang-mini.js
  var require_lang_mini2 = __commonJS({
    "node_modules/obext/node_modules/lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig2 = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          } else {
            first = false;
          }
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig2(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else {
              return Object.assign({}, obj2);
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                }
                if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return ctr(input_array);
          } else if (length) {
            return ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig2(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig2(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig2(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig2(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        is_valid = data_type.validate(value2);
                        if (typeof value2 === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig: get_a_sig2,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // node_modules/obext/node_modules/lang-mini/lib-lang-mini.js
  var require_lib_lang_mini2 = __commonJS({
    "node_modules/obext/node_modules/lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini2();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // node_modules/obext/oext.js
  var require_oext = __commonJS({
    "node_modules/obext/oext.js"(exports, module) {
      var {
        each,
        get_a_sig: get_a_sig2,
        def,
        is_array,
        tof,
        tf: tf2
      } = require_lib_lang_mini2();
      var ifn = (item2) => typeof item2 === "function";
      var ia2 = is_array;
      var get_instance = function() {
        const opts = {
          raise_change_events: true
        };
        const states = (obj2, states2) => {
        };
        const get_set = (obj2, prop_name2, fn_get, fn_set) => {
          const def2 = {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get: fn_get,
            set: fn_set,
            enumerable: true,
            configurable: false
          };
          const t_prop_name = tf2(prop_name2);
          if (t_prop_name === "a") {
            each(prop_name2, (name) => Object.defineProperty(obj2, name, def2));
          } else if (t_prop_name === "s") {
            Object.defineProperty(obj2, prop_name2, def2);
          } else {
            console.trace();
            throw "Unexpected prop_name, must be array or string";
          }
        };
        const read_only = (obj2, prop_name2, fn_get) => {
          Object.defineProperty(obj2, prop_name2, {
            enumerable: true,
            get: fn_get
          });
        };
        const prop = (...a) => {
          let s = get_a_sig2(a);
          if (s === "[a]") {
            each(a[0], (item_params2) => {
              prop.apply(this, item_params2);
            });
          } else {
            if (a.length === 2) {
              if (ia2(a[1])) {
                const target = a[0];
                each(a[1], (item2) => {
                  if (ia2(item2)) {
                    throw "NYI 468732";
                  } else {
                    prop(target, item2);
                  }
                });
              } else {
                const ta1 = tof(a[1]);
                if (ta1 === "string") {
                  [obj, prop_name] = a;
                } else {
                  throw "NYI 468732b";
                }
              }
            } else if (a.length > 2) {
              if (ia2(a[0])) {
                throw "stop";
                let objs = a.shift();
                each(objs, (obj2) => {
                  prop.apply(this, [obj2].concat(item_params));
                });
              } else {
                let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
                const load_options = (options2) => {
                  prop_name2 = prop_name2 || options2.name || options2.prop_name;
                  fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                  fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                  fn_on_ready = options2.ready || options2.on_ready;
                  default_value = default_value || options2.default_value || options2.default;
                };
                if (a.length === 2) {
                  [obj2, options] = a;
                  load_options(options);
                } else if (a.length === 3) {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_onchange] = a;
                  } else {
                    if (a[2] !== void 0 && (a[2].change || a[2].ready)) {
                      load_options(a[2]);
                      [obj2, prop_name2] = a;
                    } else {
                      [obj2, prop_name2, default_value] = a;
                    }
                  }
                } else if (a.length === 4) {
                  if (ifn(a[2]) && ifn(a[3])) {
                    [obj2, prop_name2, fn_transform, fn_onchange] = a;
                  } else if (ifn(a[3])) {
                    [obj2, prop_name2, default_value, fn_onchange] = a;
                  } else {
                    [obj2, prop_name2, default_value, options] = a;
                    load_options(options);
                  }
                } else if (a.length === 5) {
                  [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
                }
                let _prop_value;
                if (typeof default_value !== "undefined") _prop_value = default_value;
                const _silent_set = (value2) => {
                  let _value;
                  if (fn_transform) {
                    _value = fn_transform(value2);
                  } else {
                    _value = value2;
                  }
                  _prop_value = _value;
                };
                const _set = (value2) => {
                  let _value;
                  if (fn_transform) {
                    _value = fn_transform(value2);
                  } else {
                    _value = value2;
                  }
                  let old = _prop_value;
                  _prop_value = _value;
                  if (fn_onchange) {
                    fn_onchange({
                      old,
                      value: _prop_value
                    });
                  }
                  if (obj2.raise && opts.raise_change_events) {
                    obj2.raise("change", {
                      name: prop_name2,
                      old,
                      value: _prop_value
                    });
                  }
                };
                if (def(default_value)) {
                  _prop_value = default_value;
                }
                const t_prop_name = tf2(prop_name2);
                if (t_prop_name === "s") {
                  Object.defineProperty(obj2, prop_name2, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                } else if (t_prop_name === "a") {
                  const l2 = prop_name2.length;
                  let item_prop_name;
                  for (let c2 = 0; c2 < l2; c2++) {
                    item_prop_name = prop_name2[c2];
                    Object.defineProperty(obj2, item_prop_name, {
                      get() {
                        return _prop_value;
                      },
                      set(value2) {
                        _set(value2);
                      }
                    });
                  }
                } else {
                  throw "Unexpected name type: " + t_prop_name;
                }
                if (fn_on_ready) {
                  fn_on_ready({
                    silent_set: _silent_set
                  });
                }
              }
            }
          }
        };
        const field = (...a) => {
          let s = get_a_sig2(a);
          if (s === "[a]") {
            each(a[0], (item_params2) => {
              prop.apply(this, item_params2);
            });
          } else {
            if (a.length > 1) {
              if (ia2(a[0])) {
                let objs = a.shift();
                each(objs, (obj2) => {
                  prop.apply(this, [obj2].concat(item_params));
                });
              } else {
                let obj2, prop_name2, default_value, fn_transform;
                let raise_change_events = opts.raise_change_events;
                if (a.length === 2) {
                  [obj2, prop_name2] = a;
                } else if (a.length === 3) {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                } else if (a.length === 4) {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
                if (obj2 !== void 0) {
                  Object.defineProperty(obj2, prop_name2, {
                    get() {
                      if (def(obj2._)) {
                        return obj2._[prop_name2];
                      } else {
                        return void 0;
                      }
                    },
                    set(value2) {
                      let old = (obj2._ = obj2._ || {})[prop_name2];
                      let _value;
                      if (fn_transform) {
                        _value = fn_transform(value2);
                      } else {
                        _value = value2;
                      }
                      obj2._[prop_name2] = _value;
                      if (raise_change_events) {
                        obj2.raise("change", {
                          name: prop_name2,
                          old,
                          value: _value
                        });
                      }
                    }
                  });
                  if (def(default_value)) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                } else {
                  throw "stop";
                }
              }
            }
          }
        };
        return {
          opts,
          // module level options
          prop,
          field,
          read_only,
          ro: read_only,
          get_set,
          gs: get_set
        };
      };
      module.exports = get_instance();
    }
  });

  // node_modules/jsgui3-html/html-core/control-core.js
  var require_control_core = __commonJS({
    "node_modules/jsgui3-html/html-core/control-core.js"(exports, module) {
      var jsgui2 = require_lang();
      var oext = require_oext();
      var { Data_Model, Data_Object, Collection, tof, stringify, get_a_sig: get_a_sig2, each, Evented_Class } = jsgui2;
      var Text_Node = require_text_node();
      var {
        prop,
        field
      } = require_oext();
      var px_handler = (target, property, value2, receiver) => {
        let res2;
        var t_val = tof(value2);
        if (t_val === "number") {
          res2 = value2 + "px";
        } else if (t_val === "string") {
          var match = value2.match(/(\d*\.?\d*)(.*)/);
          if (match.length === 2) {
            res2 = value2 + "px";
          } else {
            res2 = value2;
          }
        }
        return res2;
      };
      var style_input_handlers = {
        "width": px_handler,
        "height": px_handler,
        "left": px_handler,
        "top": px_handler
      };
      var new_obj_style = () => {
        let style = new Evented_Class({});
        style.__empty = true;
        style.toString = () => {
          var res3 = [];
          var first = true;
          each(style, (value2, key2) => {
            const tval = typeof value2;
            if (tval !== "function" && key2 !== "toString" && key2 !== "__empty" && key2 !== "_bound_events" && key2 !== "on" && key2 !== "subscribe" && key2 !== "raise" && key2 !== "trigger") {
              if (first) {
                first = false;
              } else {
                res3.push(" ");
              }
              res3.push(key2 + ": " + value2 + ";");
            }
          });
          return res3.join("");
        };
        const res2 = new Proxy(style, {
          set: (target, property, value2, receiver) => {
            let res3;
            target["__empty"] = false;
            var old_value = target[property];
            if (style_input_handlers[property]) {
              res3 = target[property] = style_input_handlers[property](target, property, value2, receiver);
            } else {
              res3 = target[property] = value2;
            }
            style.raise("change", {
              "key": property,
              "name": property,
              "old": old_value,
              "new": value2,
              "value": value2
            });
            return res3;
          },
          get: (target, property, receiver) => {
            if (property === "toString") {
              return () => target + "";
            } else {
              return target[property];
            }
          }
        });
        return res2;
      };
      var DOM_Attributes = class extends Evented_Class {
        constructor(spec) {
          super(spec);
          this.style = new_obj_style();
          this.style.on("change", (e_change) => {
            this.raise("change", {
              "property": "style",
              "key": "style",
              "name": "style",
              "value": this.style.toString()
            });
          });
        }
      };
      var Control_DOM = class extends Evented_Class {
        constructor() {
          super();
          var dom_attributes = new DOM_Attributes();
          var attrs = this.attrs = this.attributes = new Proxy(dom_attributes, {
            "set": (target, property, value2, receiver) => {
              if (property === "style") {
                var t_value = tof(value2);
                if (t_value === "string") {
                  var s_values = value2.trim().split(";");
                  var kv;
                  each(s_values, (s_value) => {
                    kv = s_value.split(":");
                    if (kv.length === 2) {
                      kv[0] = kv[0].trim();
                      kv[1] = kv[1].trim();
                      target.style[kv[0]] = kv[1];
                    }
                  });
                  dom_attributes.raise("change", {
                    "property": property
                  });
                }
              } else {
                var old_value = target[property];
                target[property] = value2;
                dom_attributes.raise("change", {
                  "key": property,
                  "name": property,
                  "old": old_value,
                  "new": value2,
                  "value": value2
                });
              }
              return true;
            },
            get: (target, property, receiver) => {
              return target[property];
            }
          });
        }
      };
      var Control_Background = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          let _color, _opacity;
          Object.defineProperty(this, "color", {
            get() {
              return _color;
            },
            set(value2) {
              const old = _color;
              _color = value2;
              this.raise("change", {
                "name": "color",
                "old": old,
                "new": _color,
                "value": _color
              });
            },
            enumerable: true,
            configurable: true
          });
        }
        set(val) {
        }
      };
      var Control_Core = class _Control_Core extends Data_Object {
        constructor(spec = {}, fields) {
          spec.__type_name = spec.__type_name || "control";
          super(spec, fields);
          if (spec.id) {
            this.__id = spec.id;
          }
          if (spec.__id) {
            this.__id = spec.__id;
          }
          this.mapListeners = {};
          this.__type = "control";
          var spec_content;
          let d = this.dom = new Control_DOM();
          prop(this, "background", new Control_Background(), (e_change) => {
            let {
              value: value2
            } = e_change;
          });
          this.background.on("change", (evt) => {
            if (evt.name === "color") {
              d.attributes.style["background-color"] = evt.value;
            }
          });
          prop(this, "disabled", false);
          prop(this, "size", spec.size, (e_change) => {
            let {
              value: value2,
              old
            } = e_change;
            let [width, height2] = value2;
            const s = this.dom.attrs.style;
            s.width = width;
            s.height = height2;
            this.raise("resize", {
              "value": value2
            });
          });
          prop(this, "pos", void 0, (e_change) => {
            let {
              value: value2,
              old
            } = e_change;
            if (value2.length === 2) {
            }
            let [left, top] = value2;
            let o_style = {
              "left": left,
              "top": top
            };
            this.style(o_style);
            this.raise("move", {
              "value": value2
            });
          });
          if (spec.pos) this.pos = spec.pos;
          this.on("change", (e) => {
            if (e.name === "disabled") {
              if (e.value === true) {
                this.add_class("disabled");
              } else {
                this.remove_class("disabled");
              }
            }
          });
          let tagName = spec.tagName || spec.tag_name || "div";
          d.tagName = tagName;
          var content = this.content = new Collection({});
          spec_content = spec.content;
          if (spec_content) {
            var tsc = tof(spec_content);
            if (tsc === "array") {
              each(spec.content, (item2) => {
                content.add(item2);
              });
            } else if (tsc === "string" || tsc === "control") {
              content.add(spec_content);
            }
          }
          if (spec.el) {
            d.el = spec.el;
            if (spec.el.tagName) d.tagName = spec.el.tagName.toLowerCase();
          }
          var context2 = this.context || spec.context;
          if (context2) {
            if (context2.register_control) context2.register_control(this);
          } else {
          }
          if (spec["class"]) {
            this.add_class(spec["class"]);
          }
          if (spec["css_class"]) {
            this.add_class(spec["css_class"]);
          }
          if (spec["cssClass"]) {
            this.add_class(spec["cssClass"]);
          }
          if (spec.hide) {
            this.hide();
          }
          if (spec.add) {
            this.add(spec.add);
          }
          if (spec.attrs) {
            this.dom.attributes = spec.attrs;
          }
        }
        get left() {
          const sl = this.dom.attributes.style.left;
          if (sl) {
            return parseInt(sl) + this.ta[6];
          }
        }
        get top() {
          const st = this.dom.attributes.style.top;
          if (st) {
            return parseInt(st) + this.ta[7];
          }
        }
        set top(value2) {
          if (typeof value2 === "number") {
            const measured_current_top = this.top;
            const diff = Math.round(value2 - measured_current_top);
            this.ta[7] += diff;
          }
        }
        "hide"() {
          let e = {
            cancelDefault: false
          };
          this.raise("hide", e);
          if (!e.cancelDefault) {
            this.add_class("hidden");
          }
        }
        "show"() {
          let e = {
            cancelDefault: false
          };
          this.raise("show", e);
          if (!e.cancelDefault) {
            this.remove_class("hidden");
          }
        }
        get html() {
          return this.all_html_render();
        }
        get internal_relative_div() {
          return this._internal_relative_div || false;
        }
        set internal_relative_div(value2) {
          var old_value = this._internal_relative_div;
          this._internal_relative_div = value2;
          if (value2 === true) {
          }
        }
        get color() {
          return this.background.color;
        }
        set color(value2) {
          this.background.color = value2;
        }
        "post_init"(spec) {
          if (spec && spec.id === true) {
            this.dom.attrs.id = this._id();
          }
        }
        "has"(item_name) {
          var arr = item_name.split(".");
          var c2 = 0, l2 = arr.length;
          var i = this;
          var s;
          while (c2 < l2) {
            s = arr[c2];
            if (typeof i[s] == "undefined") {
              return false;
            }
            i = i[s];
            c2++;
          }
          ;
          return i;
        }
        "renderDomAttributes"() {
          if (this.beforeRenderDomAttributes) {
            this.beforeRenderDomAttributes();
          }
          var dom_attrs = this.dom.attributes;
          if (!dom_attrs) {
            throw "expecting dom_attrs";
          } else {
            if (this._) {
              var keys = Object.keys(this._);
              var key2;
              for (var c2 = 0, l2 = keys.length; c2 < l2; c2++) {
                key2 = keys[c2];
                if (key2 !== "_bound_events") {
                  if (key2 instanceof _Control_Core) {
                    (this._ctrl_fields = this._ctrl_fields || {})[key2] = this._[key2];
                  } else {
                    this._fields = this._fields || {};
                    this._fields[key2] = this._[key2];
                  }
                }
              }
            }
            if (this._ctrl_fields) {
              var obj_ctrl_fields = {};
              var keys = Object.keys(this._ctrl_fields);
              var key2;
              for (var c2 = 0, l2 = keys.length; c2 < l2; c2++) {
                key2 = keys[c2];
                if (key2 !== "_bound_events") {
                  obj_ctrl_fields[key2] = this._ctrl_fields[key2]._id();
                }
              }
              let scf = stringify(obj_ctrl_fields).replace(/"/g, "'");
              if (scf.length > 2) {
                dom_attrs["data-jsgui-ctrl-fields"] = scf;
              }
            }
            if (this._fields) {
              let sf = stringify(this._fields).replace(/"/g, "'");
              if (sf.length > 2) {
                dom_attrs["data-jsgui-fields"] = sf;
              }
            }
            if (this.view.data.model.mixins) {
              let smxs = "[";
              let first = true;
              this.view?.data?.model?.mixins?.each((mx) => {
                if (!first) {
                  smxs += ",";
                } else {
                  first = false;
                }
                const smx = JSON.stringify(mx);
                smxs += smx;
              });
              smxs += "]";
              smxs = smxs.replace(/"/g, "'");
              if (smxs.length > 2) {
                dom_attrs["data-jsgui-mixins"] = smxs;
              }
            }
            const arr = [];
            const id = this._id();
            if (id !== void 0) {
              arr.push(' data-jsgui-id="' + this._id() + '"');
            }
            if (this.data && this.data._model instanceof Data_Model) {
              const dmid = this.data._model.__id;
              if (dmid) {
                arr.push(' data-jsgui-data-model-id="' + dmid + '"');
              }
            }
            const exempt_types = {
              html: true,
              head: true,
              body: true
            };
            if (this.context && this.__type_name) {
              if (!exempt_types[this.__type_name] && this.__type_name !== void 0) {
                arr.push(' data-jsgui-type="' + this.__type_name + '"');
              }
            }
            var dom_attrs_keys = Object.keys(dom_attrs);
            var key2, item2;
            for (var c2 = 0, l2 = dom_attrs_keys.length; c2 < l2; c2++) {
              key2 = dom_attrs_keys[c2];
              if (key2 == "_bound_events") {
              } else if (key2 === "style") {
                item2 = dom_attrs[key2];
                if (typeof item2 !== "function") {
                  if (typeof item2 === "object") {
                    if (key2 === "style") {
                      const sprops = [];
                      each(item2, (v, k) => {
                        const tval = typeof v;
                        if (tval !== "function") {
                          if (k !== "__empty") {
                            const sprop = k + ":" + v;
                            sprops.push(sprop);
                          }
                        }
                      });
                      if (sprops.length > 0) arr.push(" ", key2, '="', sprops.join(";"), '"');
                    } else {
                      console.trace();
                      throw "NYI";
                    }
                  } else {
                    let is = item2.toString();
                    if (!item2.__empty && is.length > 0) {
                      arr.push(" ", key2, '="', is, '"');
                    }
                  }
                }
              } else {
                item2 = dom_attrs[key2];
                if (item2 && item2.toString) {
                  arr.push(" ", key2, '="', item2.toString(), '"');
                }
              }
            }
            return arr.join("");
          }
        }
        "renderBeginTagToHtml"() {
          const tagName = this.dom.tagName;
          var res2;
          if (tagName === false) {
            res2 = "";
          } else {
            res2 = ["<", tagName, this.renderDomAttributes(), ">"].join("");
          }
          return res2;
        }
        "renderEndTagToHtml"() {
          var res2;
          const tagName = this.dom.tagName;
          const noClosingTag = this.dom.noClosingTag;
          if (tagName === false || noClosingTag) {
            res2 = "";
          } else {
            res2 = ["</", tagName, ">"].join("");
          }
          return res2;
        }
        "renderHtmlAppendment"() {
          return this.htmlAppendment || "";
        }
        "renderEmptyNodeJqo"() {
          return [this.renderBeginTagToHtml(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join("");
        }
        "register_this_and_subcontrols"() {
          const context2 = this.context;
          this.iterate_this_and_subcontrols((ctrl2) => {
            context2.register_control(ctrl2);
          });
        }
        "iterate_subcontrols"(ctrl_callback) {
          const content = this.content;
          content.each((v) => {
            ctrl_callback(v);
            if (v && v.iterate_subcontrols) {
              v.iterate_subcontrols(ctrl_callback);
            }
          });
        }
        "iterate_this_and_subcontrols"(ctrl_callback) {
          ctrl_callback(this);
          const content = this.content;
          let tv;
          if (typeof content !== "string") {
            content.each((v) => {
              tv = tof(v);
              if (tv == "string") {
              } else if (tv == "data_value") {
              } else {
                if (v && v.iterate_this_and_subcontrols) {
                  v.iterate_this_and_subcontrols(ctrl_callback);
                }
              }
            });
          }
        }
        "all_html_render"(callback2) {
          if (callback2) {
            var arr_waiting_controls = [];
            this.iterate_this_and_subcontrols((control) => {
              if (control.__status == "waiting") arr_waiting_controls.push(control);
            });
            if (arr_waiting_controls.length == 0) {
              callback2(null, this.all_html_render());
            } else {
              var c2 = arr_waiting_controls.length;
              var complete = () => {
                this.pre_all_html_render();
                var dom2 = this.dom;
                if (dom2) {
                  callback2(null, [this.renderBeginTagToHtml(), this.all_html_render_internal_controls(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join(""));
                }
              };
              each(arr_waiting_controls, (control, i) => {
                control.on("ready", (e_ready) => {
                  c2--;
                  if (c2 == 0) {
                    complete();
                  }
                });
              });
            }
          } else {
            this.pre_all_html_render();
            var dom = this.dom;
            if (dom) {
              return [this.renderBeginTagToHtml(), this.all_html_render_internal_controls(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join("");
            }
          }
        }
        "render_content"() {
          var content = this.content;
          if (tof(content) === "string") {
            return content;
          } else {
            var contentLength = content.length();
            var res2 = new Array(contentLength);
            var tn, output;
            var arr = content._arr;
            var c2, l2 = arr.length, n;
            for (c2 = 0; c2 < l2; c2++) {
              n = arr[c2];
              tn = tof(n);
              if (tn === "string") {
                res2.push(jsgui2.output_processors["string"](n));
              } else if (tn === "data_value") {
                res2.push(n._);
              } else {
                if (tn === "data_object") {
                  throw "stop";
                } else {
                  res2.push(n.all_html_render());
                }
              }
            }
            return res2.join("");
          }
        }
        "all_html_render_internal_controls"() {
          return this.render_content();
        }
        "render"() {
          return this.all_html_render();
        }
        "pre_all_html_render"() {
          if (typeof document === "undefined") {
            this.raise("server-pre-render");
          }
        }
        "compose"() {
        }
        "visible"(callback2) {
          this.style("display", "block", callback2);
        }
        "transparent"(callback2) {
          this.style("opacity", 0, callback2);
        }
        "opaque"(callback2) {
          return this.style({
            "opacity": 1
          }, callback2);
        }
        "remove"() {
          return this.parent.content.remove(this);
        }
        "add"(new_content) {
          const tnc = tof(new_content);
          let res2;
          if (tnc === "array") {
            let res3 = [];
            each(new_content, (v) => {
              res3.push(this.add(v));
            });
          } else {
            if (new_content) {
              if (tnc === "string") {
                new_content = new Text_Node({
                  "text": new_content,
                  "context": this.context
                });
              } else {
                if (!new_content.context) {
                  if (this.context) {
                    new_content.context = this.context;
                  }
                }
              }
              var inner_control = this.inner_control;
              if (inner_control) {
                res2 = inner_control.content.add(new_content);
              } else {
                res2 = this.content.add(new_content);
              }
              new_content.parent = this;
            }
          }
          return res2;
        }
        "insert_before"(target) {
          const target_parent = target.parent;
          const target_index = target._index;
          const content = target_parent.content;
          content.insert(this, target_index);
        }
        "style"() {
          const a = arguments, sig = get_a_sig2(a, 1), d = this.dom, da = d.attrs;
          a.l = a.length;
          let style_name, style_value, modify_dom = true;
          if (sig == "[s]") {
            style_name = a[0];
            const res2 = getComputedStyle(d.el)[style_name];
            return res2;
          } else if (sig == "[s,s,b]") {
            [style_name, style_value, modify_dom] = a;
          } else if (sig == "[s,s]" || sig == "[s,n]") {
            [style_name, style_value] = a;
          }
          ;
          if (style_name && typeof style_value !== "undefined") {
            if (da.style) {
              da.style[style_name] = style_value;
              da.raise("change", {
                "property": "style",
                "name": "style",
                "value": da.style + ""
              });
            } else {
            }
          }
          if (sig == "[o]") {
            each(a[0], (v, i) => {
              this.style(i, v);
            });
          }
        }
        "active"() {
        }
        "find_selection_scope"() {
          var res2 = this.selection_scope;
          if (res2) return res2;
          if (this.parent && this.parent.find_selection_scope) return this.parent.find_selection_scope();
        }
        "click"(handler) {
          this.on("click", handler);
        }
        "add_class"(class_name) {
          let da = this.dom.attrs, cls = da["class"];
          if (!cls) {
            da["class"] = class_name;
          } else {
            const tCls = tof(cls);
            if (tCls == "object") {
              throw "removed";
            } else if (tCls == "string") {
              let arr_classes = cls.split(" "), already_has_class = false, l2 = arr_classes.length, c2 = 0;
              while (c2 < l2 && !already_has_class) {
                if (arr_classes[c2] === class_name) {
                  already_has_class = true;
                }
                c2++;
              }
              if (!already_has_class) {
                arr_classes.push(class_name);
              }
              da["class"] = arr_classes.join(" ");
            }
          }
        }
        "has_class"(class_name) {
          let da = this.dom.attrs, cls = da["class"];
          if (cls) {
            var tCls = tof(cls);
            if (tCls == "object") {
              throw "removed";
            }
            if (tCls == "string") {
              var arr_classes = cls.split(" ");
              var arr_res = [];
              var l2 = arr_classes.length, c2 = 0;
              while (c2 < l2) {
                if (arr_classes[c2] === class_name) {
                  return true;
                }
                c2++;
              }
            }
          }
        }
        "remove_class"(class_name) {
          let da = this.dom.attrs, cls = da["class"];
          if (cls) {
            var tCls = tof(cls);
            if (tCls == "object") {
              throw "removed";
            }
            if (tCls == "string") {
              var arr_classes = cls.split(" ");
              var arr_res = [];
              var l2 = arr_classes.length, c2 = 0;
              while (c2 < l2) {
                if (arr_classes[c2] != class_name) {
                  arr_res.push(arr_classes[c2]);
                }
                c2++;
              }
              da["class"] = arr_res.join(" ");
            }
          }
        }
        "is_ancestor_of"(target) {
          var t_target = tof(target);
          var el = this.dom.el;
          var inner = (target2) => {
            if (target2 == el) {
              return true;
            }
            var parent2 = target2.parentNode;
            if (!parent2) {
              return false;
            } else {
              return inner(parent2);
            }
          };
          if (t_target === "object") {
            if (el !== target) {
              var parent = target.parentNode;
              if (parent) {
                return inner(parent);
              }
            }
          } else {
            if (t_target === "control") {
            }
          }
        }
        "find_selected_ancestor_in_scope"() {
          var s = this.selection_scope;
          var ps = this.parent.selection_scope;
          if (s === ps) {
            var psel = this.parent.selected;
            if (psel && psel.value && psel.value() == true) {
              return this.parent;
            } else {
              return this.parent.find_selected_ancestor_in_scope();
            }
          }
        }
        "closest"(match) {
          let tmatch = tof(match);
          if (tmatch === "string") {
          }
          if (tmatch === "function") {
            let search = (ctrl2) => {
              if (match(ctrl2)) {
                return ctrl2;
              } else {
                if (ctrl2.parent) {
                  return search(ctrl2.parent);
                } else {
                  return void 0;
                }
              }
            };
            return search(this);
          }
        }
        "shallow_copy"() {
          var res2 = new Control({
            "context": this.context
          });
          var da = this.dom.attributes;
          var cl = da.class;
          var map_class_exclude = {
            "selected": true
          };
          each(cl.split(" "), (v, i) => {
            if (i && !map_class_exclude[i]) res2.add_class(i);
          });
          var res_content = res2.content;
          this.content.each((v, i) => {
            if (tof(v) == "data_value") {
              res_content.add(v.value());
            } else {
              res_content.add(v.shallow_copy());
            }
          });
          return res2;
        }
        "matches_selector"(selector) {
          throw "NYI";
        }
        "find"(selector) {
          const res2 = [];
          const desc = (node, callback2) => {
            if (node.$match(selector)) {
              callback2(node);
            }
            node.content.each((child) => {
              desc(child, callback2);
            });
          };
          desc(this, ((node) => res2.push(node)));
          return res2;
        }
        "$match"(selector) {
          if (typeof selector === "function") {
            return selector(this);
          } else {
            let parse_word = (word) => {
              if (word[0] === ".") {
                return () => this.has_class(word.substr(1));
              } else {
                return () => this.__type_name === word;
              }
            };
            let parse_selector = (selector2) => {
              let words = selector2.split(" ");
              let res3 = words.map((x) => parse_word(x));
              return res3;
            };
            let parsed = parse_selector(selector);
            if (parsed.length === 1) {
              return parsed[0]();
            } else {
              console.trace();
              throw "NYI";
            }
          }
          let res2 = false;
          let tn = this.__type_name;
          if (tn) {
            if (tn === selector) res2 = true;
          }
          return res2;
        }
        "$"(selector, handler) {
          let match = this.$match(selector);
          let res2 = [];
          if (match) {
            if (handler) handler(this);
            res2.push(this);
          }
          this.content.each((item2) => {
            if (item2.$) {
              let nested_res = item2.$(selector, handler);
              Array.prototype.push.apply(res2, nested_res);
            }
          });
          return res2;
        }
        "clear"() {
          this.content.clear();
        }
        "activate"() {
        }
        get this_and_descendents() {
          const res2 = [];
          this.iterate_this_and_subcontrols((ctrl2) => res2.push(ctrl2));
          return res2;
        }
        get descendents() {
          const res2 = [];
          this.iterate_subcontrols((ctrl2) => res2.push(ctrl2));
          return res2;
        }
        get siblings() {
          const res2 = [];
          if (this.parent) {
            const _ = this.parent.content._arr;
            _.forEach((x) => {
              if (x !== this) res2.push(x);
            });
          }
          return res2;
        }
      };
      var p = Control_Core.prototype;
      p.connect_fields = true;
      var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
      if (jsgui2.custom_rendering === "very-simple") {
        p[customInspectSymbol] = function(depth, inspectOptions, inspect) {
          return "< " + this.dom.tagName + " " + this.__type_name + " >";
        };
      }
      module.exports = Control_Core;
      if (__require.main === module) {
        let test_svg2 = function() {
          const passed = [];
          const failed = [];
          let svg;
          try {
            svg = new Control2({
              tagName: "svg"
            });
            passed.push("Create SVG control");
          } catch (error2) {
            failed.push("Create SVG control");
          }
          try {
            const circle = new Control2({
              tagName: "circle",
              attrs: {
                cx: 100,
                cy: 100,
                r: 50
              }
            });
            svg.add(circle);
            passed.push("Add circle to SVG control");
          } catch (error2) {
            console.log("error", error2);
            failed.push("Add circle to SVG control");
          }
          try {
            const rect = new Control2({
              tagName: "rect",
              attrs: {
                x: 150,
                y: 150,
                width: 100,
                height: 100
              }
            });
            svg.add(rect);
            passed.push("Add rectangle to SVG control");
          } catch (error2) {
            console.log("error", error2);
            failed.push("Add rectangle to SVG control");
          }
          try {
            const expected = '<svg><circle cx="100" cy="100" r="50"></circle><rect x="150" y="150" width="100" height="100"></rect></svg>';
            const actual = svg.all_html_render();
            console.log("actual", actual);
            if (expected === actual) {
              passed.push("Check rendering of SVG control");
            } else {
              failed.push("Check rendering of SVG control");
            }
          } catch (error2) {
            console.log("error", error2);
            failed.push("Check rendering of SVG control");
          }
          return {
            passed,
            failed
          };
        };
        test_svg = test_svg2;
        const Control2 = Control_Core;
        console.log(test_svg2());
        const test_background_color = () => {
          const expectedColor = "#ff0000";
          const passed = [];
          const failed = [];
          let div;
          try {
            div = new Control2({
              tagName: "div"
            });
            passed.push("Create div control");
          } catch (error2) {
            failed.push(["Create div control", error2]);
          }
          try {
            div.background.color = expectedColor;
            passed.push("Set background color of div control");
          } catch (error2) {
            failed.push(["Set background color of div control", error2]);
          }
          try {
            const validationColor = div.background.color;
            if (validationColor === expectedColor) {
              passed.push("Validate background color of div control");
            } else {
              failed.push(["Validate background color of div control", "Background color is not as expected"]);
            }
          } catch (error2) {
            failed.push(["Validate background color of div control", error2]);
          }
          try {
            const expected = `<div style="background-color:${expectedColor}"></div>`;
            const actual = div.all_html_render();
            if (expected === actual) {
              passed.push("Check rendering of div control");
            } else {
              failed.push(["Check rendering of div control", "Rendering does not match expected output", {
                expected,
                actual
              }]);
            }
          } catch (error2) {
            failed.push(["Check rendering of div control", error2]);
          }
          return {
            passed,
            failed
          };
        };
        const rtest = test_background_color();
        console.log(rtest);
        console.log(rtest.failed);
      }
      var test_svg;
    }
  });

  // node_modules/jsgui3-gfx-core/core/shapes/Shape.js
  var require_Shape = __commonJS({
    "node_modules/jsgui3-gfx-core/core/shapes/Shape.js"(exports, module) {
      var Shape = class {
      };
      module.exports = Shape;
    }
  });

  // node_modules/jsgui3-gfx-core/node_modules/lang-mini/lang-mini.js
  var require_lang_mini3 = __commonJS({
    "node_modules/jsgui3-gfx-core/node_modules/lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              if (ctu == false) break;
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
              if (ctu === false) break;
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "null": "N",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig2 = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          }
          first = false;
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        if (arr.some((subArray) => subArray.length === 0)) {
          return [];
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig2(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else {
              return Object.assign({}, obj2);
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                } else if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return new ctr(input_array);
          } else if (length) {
            return new ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig2(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig2(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig2(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str, 10);
          if (!isNaN(p2) && p2.toString() === str) {
            return p2;
          }
          return void 0;
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig2(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        const t_value = typeof value2;
                        is_valid = data_type.validate(value2);
                        if (t_value === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                        console.log("t_value", t_value);
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    } else {
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var KEYWORD_LITERALS = /* @__PURE__ */ new Set(["true", "false", "null", "undefined"]);
      var KEYWORD_OPERATORS = /* @__PURE__ */ new Set(["typeof", "void", "delete", "in", "instanceof"]);
      var MULTI_CHAR_OPERATORS = [
        "===",
        "!==",
        "==",
        "!=",
        "<=",
        ">=",
        "&&",
        "||",
        "??",
        "++",
        "--",
        "+=",
        "-=",
        "*=",
        "/=",
        "%=",
        "&=",
        "|=",
        "^=",
        "<<",
        ">>",
        ">>>",
        "**"
      ];
      var SINGLE_CHAR_OPERATORS = /* @__PURE__ */ new Set(["+", "-", "*", "/", "%", "=", "!", "<", ">", "&", "|", "^", "~"]);
      var PUNCTUATION_CHARS = /* @__PURE__ */ new Set(["(", ")", "{", "}", "[", "]", ",", ":", "?", "."]);
      var GLOBAL_SCOPE = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var Tokenizer = class {
        constructor(expression) {
          this.expression = expression || "";
          this.length = this.expression.length;
          this.position = 0;
        }
        tokenize() {
          const tokens = [];
          if (!this.expression.trim()) {
            return tokens;
          }
          while (!this.isAtEnd()) {
            this.skipWhitespace();
            if (this.isAtEnd()) break;
            const ch = this.peek();
            if (this.isIdentifierStart(ch)) {
              tokens.push(this.tokenizeIdentifier());
            } else if (this.isDigit(ch) || ch === "." && this.isDigit(this.peek(1))) {
              tokens.push(this.tokenizeNumber());
            } else if (ch === '"' || ch === "'") {
              tokens.push(this.tokenizeString());
            } else if (this.isOperatorStart(ch)) {
              tokens.push(this.tokenizeOperator());
            } else if (PUNCTUATION_CHARS.has(ch)) {
              tokens.push(this.tokenizePunctuation());
            } else {
              throw new Error(`Unexpected character: ${ch}`);
            }
          }
          return tokens;
        }
        isAtEnd() {
          return this.position >= this.length;
        }
        peek(offset2 = 0) {
          if (this.position + offset2 >= this.length) return "\0";
          return this.expression[this.position + offset2];
        }
        advance() {
          return this.expression[this.position++];
        }
        skipWhitespace() {
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (/\s/.test(ch)) {
              this.advance();
              continue;
            }
            if (ch === "/" && this.peek(1) === "/") {
              while (!this.isAtEnd() && this.peek() !== "\n") {
                this.advance();
              }
              continue;
            }
            if (ch === "/" && this.peek(1) === "*") {
              this.advance();
              this.advance();
              while (!this.isAtEnd()) {
                if (this.peek() === "*" && this.peek(1) === "/") {
                  this.advance();
                  this.advance();
                  break;
                }
                this.advance();
              }
              continue;
            }
            break;
          }
        }
        isIdentifierStart(ch) {
          return /[A-Za-z_$]/.test(ch);
        }
        isIdentifierPart(ch) {
          return /[A-Za-z0-9_$]/.test(ch);
        }
        isDigit(ch) {
          return /[0-9]/.test(ch);
        }
        isOperatorStart(ch) {
          if (ch === "." && this.peek(1) === "." && this.peek(2) === ".") {
            throw new Error("Spread syntax is not supported");
          }
          if (ch === "?" && this.peek(1) === "?") {
            return true;
          }
          return SINGLE_CHAR_OPERATORS.has(ch);
        }
        tokenizeIdentifier() {
          let value2 = "";
          while (!this.isAtEnd() && this.isIdentifierPart(this.peek())) {
            value2 += this.advance();
          }
          if (KEYWORD_LITERALS.has(value2)) {
            return { type: "KEYWORD", value: value2 };
          }
          if (KEYWORD_OPERATORS.has(value2)) {
            return { type: "OPERATOR", value: value2 };
          }
          return { type: "IDENTIFIER", value: value2 };
        }
        tokenizeNumber() {
          let value2 = "";
          let hasDot = false;
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (this.isDigit(ch)) {
              value2 += this.advance();
            } else if (ch === "." && !hasDot) {
              hasDot = true;
              value2 += this.advance();
            } else {
              break;
            }
          }
          return { type: "NUMBER", value: Number(value2) };
        }
        tokenizeString() {
          const quote = this.advance();
          let value2 = "";
          while (!this.isAtEnd()) {
            const ch = this.advance();
            if (ch === quote) {
              return { type: "STRING", value: value2 };
            }
            if (ch === "\\") {
              const next = this.advance();
              switch (next) {
                case "n":
                  value2 += "\n";
                  break;
                case "r":
                  value2 += "\r";
                  break;
                case "t":
                  value2 += "	";
                  break;
                case "\\":
                  value2 += "\\";
                  break;
                case '"':
                  value2 += '"';
                  break;
                case "'":
                  value2 += "'";
                  break;
                default:
                  value2 += next;
              }
            } else {
              value2 += ch;
            }
          }
          throw new Error("Unterminated string literal");
        }
        tokenizeOperator() {
          const remaining = this.expression.slice(this.position);
          for (const op of MULTI_CHAR_OPERATORS) {
            if (remaining.startsWith(op)) {
              if (op === "=>") {
                throw new Error("Arrow functions are not supported");
              }
              this.position += op.length;
              return { type: "OPERATOR", value: op };
            }
          }
          const ch = this.advance();
          if (ch === "=" && this.peek() === ">") {
            throw new Error("Arrow functions are not supported");
          }
          if (!SINGLE_CHAR_OPERATORS.has(ch) && ch !== "?") {
            throw new Error("Unexpected operator");
          }
          return { type: "OPERATOR", value: ch };
        }
        tokenizePunctuation() {
          const ch = this.advance();
          if (ch === "." && this.peek() === "." && this.peek(1) === ".") {
            throw new Error("Spread syntax is not supported");
          }
          return { type: "PUNCTUATION", value: ch };
        }
      };
      var Parser = class {
        constructor(tokens) {
          this.tokens = tokens;
          this.pos = 0;
        }
        parse() {
          if (!this.tokens.length) {
            throw new Error("Empty expression");
          }
          const ast = this.parseExpression();
          if (!this.isAtEnd()) {
            throw new Error(`Unexpected token: ${this.peek().value}`);
          }
          return ast;
        }
        parseExpression() {
          return this.parseConditionalExpression();
        }
        parseConditionalExpression() {
          let expr = this.parseLogicalOrExpression();
          if (this.matchPunctuation("?")) {
            const consequent = this.parseExpression();
            this.consume("PUNCTUATION", ":");
            const alternate = this.parseExpression();
            expr = {
              type: "ConditionalExpression",
              test: expr,
              consequent,
              alternate
            };
          }
          return expr;
        }
        parseLogicalOrExpression() {
          let expr = this.parseLogicalAndExpression();
          while (this.matchOperator("||")) {
            const operator = this.previous().value;
            const right = this.parseLogicalAndExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseLogicalAndExpression() {
          let expr = this.parseNullishExpression();
          while (this.matchOperator("&&")) {
            const operator = this.previous().value;
            const right = this.parseNullishExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseNullishExpression() {
          let expr = this.parseEqualityExpression();
          while (this.matchOperator("??")) {
            const operator = this.previous().value;
            const right = this.parseEqualityExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseEqualityExpression() {
          let expr = this.parseRelationalExpression();
          while (this.matchOperator("==", "!=", "===", "!==")) {
            const operator = this.previous().value;
            const right = this.parseRelationalExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseRelationalExpression() {
          let expr = this.parseAdditiveExpression();
          while (this.matchOperator("<", ">", "<=", ">=", "in", "instanceof")) {
            const operator = this.previous().value;
            const right = this.parseAdditiveExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseAdditiveExpression() {
          let expr = this.parseMultiplicativeExpression();
          while (this.matchOperator("+", "-")) {
            const operator = this.previous().value;
            const right = this.parseMultiplicativeExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseMultiplicativeExpression() {
          let expr = this.parseUnaryExpression();
          while (this.matchOperator("*", "/", "%")) {
            const operator = this.previous().value;
            const right = this.parseUnaryExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseUnaryExpression() {
          if (this.matchOperator("+", "-", "!", "~", "typeof", "void", "delete")) {
            const operator = this.previous().value;
            const argument = this.parseUnaryExpression();
            return { type: "UnaryExpression", operator, argument };
          }
          return this.parseLeftHandSideExpression();
        }
        parseLeftHandSideExpression() {
          let expr = this.parsePrimaryExpression();
          while (true) {
            if (this.matchPunctuation(".")) {
              const property = this.consumePropertyIdentifier();
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: false
              };
            } else if (this.matchPunctuation("[")) {
              const property = this.parseExpression();
              this.consume("PUNCTUATION", "]");
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: true
              };
            } else if (this.matchPunctuation("(")) {
              const args = this.parseArguments();
              expr = {
                type: "CallExpression",
                callee: expr,
                arguments: args
              };
            } else {
              break;
            }
          }
          return expr;
        }
        parsePrimaryExpression() {
          const token = this.peek();
          if (!token) {
            throw new Error("Unexpected end of expression");
          }
          if (token.type === "NUMBER" || token.type === "STRING") {
            this.advance();
            return { type: "Literal", value: token.value };
          }
          if (token.type === "KEYWORD") {
            this.advance();
            return { type: "Literal", value: this.literalFromKeyword(token.value) };
          }
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (this.matchPunctuation("(")) {
            const expr = this.parseExpression();
            this.consume("PUNCTUATION", ")");
            return expr;
          }
          if (this.matchPunctuation("[")) {
            const elements = [];
            if (!this.check("PUNCTUATION", "]")) {
              do {
                elements.push(this.parseExpression());
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "]");
            return { type: "ArrayExpression", elements };
          }
          if (this.matchPunctuation("{")) {
            const properties = [];
            if (!this.check("PUNCTUATION", "}")) {
              do {
                const key2 = this.parsePropertyKey();
                this.consume("PUNCTUATION", ":");
                const value2 = this.parseExpression();
                properties.push({ key: key2, value: value2 });
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "}");
            return { type: "ObjectExpression", properties };
          }
          throw new Error(`Unexpected token: ${token.value}`);
        }
        parsePropertyKey() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          throw new Error("Invalid object property key");
        }
        parseArguments() {
          const args = [];
          if (!this.check("PUNCTUATION", ")")) {
            do {
              args.push(this.parseExpression());
            } while (this.matchPunctuation(","));
          }
          this.consume("PUNCTUATION", ")");
          return args;
        }
        literalFromKeyword(value2) {
          switch (value2) {
            case "true":
              return true;
            case "false":
              return false;
            case "null":
              return null;
            case "undefined":
              return void 0;
            default:
              return value2;
          }
        }
        consume(type, value2) {
          if (this.check(type, value2)) {
            return this.advance();
          }
          const expected = value2 ? `${type} '${value2}'` : type;
          throw new Error(`Expected ${expected}`);
        }
        check(type, value2) {
          if (this.isAtEnd()) return false;
          const token = this.peek();
          if (token.type !== type) return false;
          if (typeof value2 === "undefined") return true;
          return token.value === value2;
        }
        matchOperator(...operators) {
          if (this.check("OPERATOR") && operators.includes(this.peek().value)) {
            this.advance();
            return true;
          }
          return false;
        }
        matchPunctuation(value2) {
          if (this.check("PUNCTUATION", value2)) {
            this.advance();
            return true;
          }
          return false;
        }
        consumePropertyIdentifier() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          throw new Error("Expected property name");
        }
        buildBinaryExpression(operator, left, right) {
          return { type: "BinaryExpression", operator, left, right };
        }
        buildLogicalExpression(operator, left, right) {
          return { type: "LogicalExpression", operator, left, right };
        }
        advance() {
          if (!this.isAtEnd()) {
            this.pos += 1;
          }
          return this.tokens[this.pos - 1];
        }
        peek() {
          if (this.isAtEnd()) return null;
          return this.tokens[this.pos];
        }
        previous() {
          return this.tokens[this.pos - 1];
        }
        isAtEnd() {
          return this.pos >= this.tokens.length;
        }
      };
      var Evaluator = class {
        constructor(context2 = {}, options = {}) {
          this.context = context2 || {};
          this.helpers = options.helpers || {};
          this.strict = options.strict || false;
          this.allowCall = options.allowCall || null;
          this.allowedFunctions = new Set(options.allowedFunctions || []);
          Object.values(this.helpers).forEach((value2) => {
            if (typeof value2 === "function") {
              this.allowedFunctions.add(value2);
            }
          });
        }
        evaluate(node) {
          switch (node.type) {
            case "Literal":
              return node.value;
            case "Identifier":
              return this.evaluateIdentifier(node);
            case "MemberExpression":
              return this.evaluateMemberExpression(node);
            case "CallExpression":
              return this.evaluateCallExpression(node);
            case "UnaryExpression":
              return this.evaluateUnaryExpression(node);
            case "BinaryExpression":
              return this.evaluateBinaryExpression(node);
            case "LogicalExpression":
              return this.evaluateLogicalExpression(node);
            case "ArrayExpression":
              return node.elements.map((element) => this.evaluate(element));
            case "ObjectExpression":
              return this.evaluateObjectExpression(node);
            case "ConditionalExpression":
              return this.evaluateConditionalExpression(node);
            default:
              throw new Error(`Unsupported AST node type: ${node.type}`);
          }
        }
        evaluateIdentifier(node) {
          const name = node.value;
          if (Object.prototype.hasOwnProperty.call(this.helpers, name)) {
            return this.helpers[name];
          }
          if (this.context && Object.prototype.hasOwnProperty.call(this.context, name)) {
            return this.context[name];
          }
          if (name in GLOBAL_SCOPE) {
            return GLOBAL_SCOPE[name];
          }
          if (this.strict) {
            throw new Error(`Undefined identifier: ${name}`);
          }
          console.error(`Undefined identifier: ${name}`);
          return void 0;
        }
        evaluateMemberExpression(node) {
          const object = this.evaluate(node.object);
          if (object === null || object === void 0) {
            throw new Error("Cannot read property of null or undefined");
          }
          const property = node.computed ? this.evaluate(node.property) : node.property.type === "Identifier" ? node.property.value : node.property.value;
          return object[property];
        }
        evaluateCallExpression(node) {
          let callee;
          let thisArg;
          if (node.callee.type === "MemberExpression") {
            const object = this.evaluate(node.callee.object);
            if (object === null || object === void 0) {
              throw new Error("Cannot call property of null or undefined");
            }
            const property = node.callee.computed ? this.evaluate(node.callee.property) : node.callee.property.type === "Identifier" ? node.callee.property.value : node.callee.property.value;
            callee = object[property];
            thisArg = object;
          } else {
            callee = this.evaluate(node.callee);
            thisArg = void 0;
          }
          if (typeof callee !== "function") {
            throw new Error("Attempted to call a non-function");
          }
          if (!this.isCallAllowed(callee, thisArg)) {
            throw new Error("Function call not allowed by policy");
          }
          const args = node.arguments.map((arg) => this.evaluate(arg));
          return callee.apply(thisArg, args);
        }
        isCallAllowed(fn, thisArg) {
          if (this.allowCall) {
            const decision = this.allowCall(fn, thisArg);
            if (decision === true) return true;
            if (decision === false) return false;
          }
          return this.allowedFunctions.has(fn);
        }
        evaluateUnaryExpression(node) {
          let argumentValue;
          if (node.operator === "delete") {
            argumentValue = node.argument;
          } else if (node.operator === "typeof" && node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
            argumentValue = void 0;
          } else {
            argumentValue = this.evaluate(node.argument);
          }
          switch (node.operator) {
            case "+":
              return +argumentValue;
            case "-":
              return -argumentValue;
            case "!":
              return !argumentValue;
            case "~":
              return ~argumentValue;
            case "typeof":
              if (node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
                return "undefined";
              }
              return typeof argumentValue;
            case "void":
              return void argumentValue;
            case "delete":
              return this.performDelete(node.argument);
            default:
              throw new Error(`Unsupported unary operator: ${node.operator}`);
          }
        }
        isIdentifierDefined(name) {
          return Object.prototype.hasOwnProperty.call(this.helpers, name) || this.context && Object.prototype.hasOwnProperty.call(this.context, name) || name in GLOBAL_SCOPE;
        }
        performDelete(argument) {
          if (argument.type === "Identifier" && this.context && typeof this.context === "object") {
            return delete this.context[argument.value];
          }
          if (argument.type === "MemberExpression") {
            const target = this.evaluate(argument.object);
            if (target === null || target === void 0) {
              return true;
            }
            const property = argument.computed ? this.evaluate(argument.property) : argument.property.type === "Identifier" ? argument.property.value : argument.property.value;
            return delete target[property];
          }
          this.evaluate(argument);
          return true;
        }
        evaluateBinaryExpression(node) {
          const left = this.evaluate(node.left);
          const right = this.evaluate(node.right);
          switch (node.operator) {
            case "+":
              return left + right;
            case "-":
              return left - right;
            case "*":
              return left * right;
            case "/":
              return left / right;
            case "%":
              return left % right;
            case "==":
              return left == right;
            // eslint-disable-line eqeqeq
            case "!=":
              return left != right;
            // eslint-disable-line eqeqeq
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "in":
              return left in right;
            case "instanceof":
              return left instanceof right;
            default:
              throw new Error(`Unsupported binary operator: ${node.operator}`);
          }
        }
        evaluateLogicalExpression(node) {
          switch (node.operator) {
            case "&&": {
              const left = this.evaluate(node.left);
              return left ? this.evaluate(node.right) : left;
            }
            case "||": {
              const left = this.evaluate(node.left);
              return left ? left : this.evaluate(node.right);
            }
            case "??": {
              const left = this.evaluate(node.left);
              return left !== null && left !== void 0 ? left : this.evaluate(node.right);
            }
            default:
              throw new Error(`Unsupported logical operator: ${node.operator}`);
          }
        }
        evaluateObjectExpression(node) {
          const obj2 = {};
          node.properties.forEach((property) => {
            const key2 = this.evaluatePropertyKey(property.key);
            obj2[key2] = this.evaluate(property.value);
          });
          return obj2;
        }
        evaluatePropertyKey(node) {
          if (node.type === "Identifier") {
            return node.value;
          }
          return node.value;
        }
        evaluateConditionalExpression(node) {
          const test = this.evaluate(node.test);
          return test ? this.evaluate(node.consequent) : this.evaluate(node.alternate);
        }
      };
      var ExpressionParser = class {
        constructor(options = {}) {
          this.options = { cache: options.cache !== false, ...options };
          this.astCache = /* @__PURE__ */ new Map();
          this.valueCache = /* @__PURE__ */ new Map();
        }
        tokenize(expression) {
          return new Tokenizer(expression).tokenize();
        }
        parse(expression, options = this.options) {
          const useCache = this.shouldUseCache(options);
          if (useCache && this.astCache.has(expression)) {
            return this.astCache.get(expression);
          }
          const tokens = this.tokenize(expression);
          if (!tokens.length) {
            throw new Error("Empty expression");
          }
          const parser = new Parser(tokens);
          const ast = parser.parse();
          Object.defineProperty(ast, "tokens", {
            value: tokens,
            enumerable: false,
            configurable: true
          });
          if (useCache) {
            this.astCache.set(expression, ast);
          }
          return ast;
        }
        evaluate(expression, context2 = {}, options = {}) {
          const mergedOptions = this.mergeOptions(options);
          const useCache = this.shouldUseCache(mergedOptions);
          if (useCache) {
            const cached = this.getCachedValue(expression, context2, mergedOptions);
            if (cached.hit) {
              return cached.value;
            }
          }
          const ast = this.parse(expression, mergedOptions);
          const evaluator = new Evaluator(context2, mergedOptions);
          const result = evaluator.evaluate(ast);
          if (useCache) {
            this.storeCachedValue(expression, context2, result, mergedOptions);
          }
          return result;
        }
        shouldUseCache(options) {
          return options.cache !== false;
        }
        mergeOptions(override = {}) {
          const base = this.options || {};
          const helpers = { ...base.helpers || {}, ...override.helpers || {} };
          const allowedFunctions = /* @__PURE__ */ new Set([
            ...base.allowedFunctions || [],
            ...override.allowedFunctions || []
          ]);
          return {
            ...base,
            ...override,
            helpers,
            allowedFunctions: Array.from(allowedFunctions)
          };
        }
        getCachedValue(expression, context2, options) {
          const bucket = this.valueCache.get(expression);
          if (!bucket) {
            return { hit: false };
          }
          if (this.isObjectLike(context2)) {
            if (bucket.objectCache && bucket.objectCache.has(context2)) {
              return { hit: true, value: bucket.objectCache.get(context2) };
            }
            return { hit: false };
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return { hit: false };
          }
          if (bucket.primitiveCache && bucket.primitiveCache.has(key2)) {
            return { hit: true, value: bucket.primitiveCache.get(key2) };
          }
          return { hit: false };
        }
        storeCachedValue(expression, context2, value2, options) {
          let bucket = this.valueCache.get(expression);
          if (!bucket) {
            bucket = { objectCache: /* @__PURE__ */ new WeakMap(), primitiveCache: /* @__PURE__ */ new Map() };
            this.valueCache.set(expression, bucket);
          }
          if (this.isObjectLike(context2)) {
            bucket.objectCache.set(context2, value2);
            return;
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return;
          }
          bucket.primitiveCache.set(key2, value2);
        }
        resolvePrimitiveKey(context2, options) {
          if (options.cacheKeyResolver) {
            return options.cacheKeyResolver(context2);
          }
          return context2;
        }
        isObjectLike(value2) {
          return value2 !== null && (typeof value2 === "object" || typeof value2 === "function");
        }
      };
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig: get_a_sig2,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type,
        ExpressionParser
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // node_modules/jsgui3-gfx-core/node_modules/lang-mini/lib-lang-mini.js
  var require_lib_lang_mini3 = __commonJS({
    "node_modules/jsgui3-gfx-core/node_modules/lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini3();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // node_modules/jsgui3-gfx-core/core/shapes/Rectangle.js
  var require_Rectangle = __commonJS({
    "node_modules/jsgui3-gfx-core/core/shapes/Rectangle.js"(exports, module) {
      var Shape = require_Shape();
      var { tof, get_item_sig, is_arr_of_t } = require_lib_lang_mini3();
      var { prop, get_set } = require_oext();
      var Rectangle = class _Rectangle extends Shape {
        // y_axis_up_direction = -1 for example?
        // up property being -1 or 1?
        //. y_axis_scaling_factor = -1 would make sense here.
        // though up_is_negitive would be simpler and quicker logically, could subtract vectors rater than multiply them by -1 and
        // then add them.
        // Should hold a typed array to keep a few values.
        //.  Or even be able to be part of a larger typed array holding many rects.
        // up_direction...?
        // up = +1?
        // This constructor system is maybe too slow for when many such rectangles get made.
        constructor(...a) {
          super(...a);
          this.up_is_negitive = true;
          const al = a.length;
          let x, y, w, h;
          const sig = get_item_sig(a, 2);
          if (sig === "[[n,n],[n,n]]") {
            [[w, h], [x, y]] = a;
          }
          get_set(this, "x", () => x, (value2) => x = value2);
          get_set(this, "y", () => y, (value2) => y = value2);
          get_set(this, ["w", "width"], () => w, (value2) => w = value2);
          get_set(this, ["h", "height"], () => h, (value2) => h = value2);
          get_set(this, "size", () => [w, h], (value2) => [w, h] = value2);
          get_set(this, "pos", () => [x, y], (value2) => [x, y] = value2);
          get_set(this, "left", () => x);
          get_set(this, "top", () => this.up_is_negitive ? y : y + h, (value2) => this.up_is_negitive ? y = value2 : y = value2 - height);
          get_set(this, "right", () => x + w);
          get_set(this, "bottom", () => this.up_is_negitive ? y + h : y);
          const using_bcr_interface = true;
          if (using_bcr_interface) {
            get_set(this, "0", () => [x, y]);
            get_set(this, "1", () => [this.right, this.bottom]);
            get_set(this, "2", () => [w, h]);
          }
        }
        extend(direction, px) {
          if (direction === "left" || direction === "l") {
            const cx = this.x, cw = this.width;
            this.x = cx - px;
            this.width = cw + px;
          } else if (direction === "right" || direction === "r") {
            const cx = this.x, cw = this.width;
            this.width = cw + px;
          } else if (direction === "up" || direction === "u") {
            if (this.up_is_negitive) {
              this.y = this.y - px;
              this.h = this.h + px;
            } else {
              this.h = this.h + px;
            }
          } else if (direction === "down" || direction === "d") {
            if (!this.up_is_negitive) {
              this.y = this.y - px;
              this.h = this.h + px;
            } else {
              this.h = this.h + px;
            }
          } else {
            throw "Supported directions: left l right r up u down d";
          }
          return this;
        }
        // Maybe we don't want Control specific things in here???
        //.  Seems OK for now, though maybe should refactor it out later on.
        //.  And this gfx-core is specific to jsgui3 so let's do it.
        overlaps(overlap_target) {
          const a = arguments;
          const al = a.length;
          if (al === 1) {
            const t_overlap_target = tof(overlap_target);
            if (t_overlap_target === "array") {
              if (is_arr_of_t(overlap_target, "control")) {
                const res2 = [];
                for (const target_ctrl of overlap_target) {
                  const target_overlap = this.overlaps(target_ctrl);
                  if (target_overlap) {
                    res2.push(target_overlap);
                  }
                }
                return res2;
              }
            } else if (t_overlap_target === "control") {
              const target_bcr = overlap_target.bcr();
              return this.overlaps(target_bcr);
            } else if (overlap_target instanceof _Rectangle) {
              const calculate_overlap = (box1, box2) => {
                const x = Math.max(box1.x, box2.x);
                const y = Math.max(box1.y, box2.y);
                const w = Math.min(box1.x + box1.w, box2.x + box2.w) - x;
                const h = Math.min(box1.y + box1.h, box2.y + box2.h) - y;
                if (w <= 0 || h <= 0) {
                  return false;
                } else {
                  return new _Rectangle([w, h], [x, y]);
                }
              };
              return calculate_overlap(this, overlap_target);
            }
          } else {
            console.trace();
            throw "NYI";
          }
        }
        // Properties
      };
      if (__require.main === module) {
        const rect = new Rectangle([30, 40], [100, 100]);
        console.log("rect", rect);
        console.log("rect.right", rect.right);
        rect.extend("l", 40);
        rect.extend("u", 40);
        console.log("rect.left", rect.left);
        console.log("rect.top", rect.top);
        console.log("rect.right", rect.right);
      }
      module.exports = Rectangle;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-pos-list.js
  var require_pixel_pos_list = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-pos-list.js"(exports, module) {
      var inspect = Symbol.for("nodejs.util.inspect.custom");
      var Ui16toUi32 = (ui16) => {
        let res2 = new Uint32Array(ui16.length / 2);
        let dv = new DataView(ui16.buffer);
        let l2 = ui16.length;
        let hl = l2 / 2;
        let resw = 0;
        for (let c2 = 0; c2 < hl; c2++) {
          res2[resw++] = dv.getUint32(c2 * 4);
        }
        return res2;
      };
      var Ui32toUi16 = (ui32) => {
        let res2 = new Uint16Array(ui32.length * 2);
        let dv = new DataView(ui32.buffer);
        let l2 = ui32.length;
        let resw = 0;
        for (let c2 = 0; c2 < l2; c2++) {
          res2[resw++] = dv.getUint16(c2 * 4 + 2);
          res2[resw++] = dv.getUint16(c2 * 4);
        }
        return res2;
      };
      var Pixel_Pos_List = class _Pixel_Pos_List {
        [Symbol.iterator]() {
          let index = 0;
          const pixels = [];
          this.each_pixel((pos) => {
            pixels.push([pos[0], pos[1]]);
          });
          return {
            next: () => {
              if (index < pixels.length) {
                return { value: pixels[index++], done: false };
              } else {
                return { done: true };
              }
            }
          };
        }
        [inspect]() {
          return this.toString();
        }
        toString() {
          const res2 = "PPL " + JSON.stringify({
            length: this.length,
            pixels: this.str_pixels
          });
          return res2;
        }
        /**
         * Creates a new Pixel_Pos_List instance.
         * @param {Object} [spec] - Optional specification object.
         */
        constructor(spec) {
          const capacities = new Uint32Array([16, 1024, 1024 * 1024 / 8, 1024 * 1024 / 2, 1024 * 1024 * 2, 1024 * 1024 * 8]);
          let i_capacity = 0;
          let capacity = capacities[i_capacity];
          let max_index = capacity * 2 - 1;
          let i = 0;
          let ta_pixels = new Uint16Array(capacity * 2);
          let read_pos = 0;
          this.sort = () => {
            if (read_pos > 0) {
              const length = i - read_pos;
              for (let idx = 0; idx < length; idx++) {
                ta_pixels[idx] = ta_pixels[idx + read_pos];
              }
              i = length;
              read_pos = 0;
            }
            const activeSlice = ta_pixels.slice(0, i);
            let ui32 = Ui16toUi32(activeSlice);
            ui32.sort();
            const sortedUi16 = Ui32toUi16(ui32);
            for (let idx = 0; idx < i; idx++) {
              ta_pixels[idx] = sortedUi16[idx];
            }
            return this;
          };
          this.shift = () => {
            if (read_pos < i) {
              const res2 = new Uint16Array(2);
              res2[0] = ta_pixels[read_pos];
              res2[1] = ta_pixels[read_pos + 1];
              read_pos += 2;
              if (read_pos >= 1024 && read_pos > i / 2) {
                const newArray = new Uint16Array(i - read_pos);
                for (let idx = 0; idx < i - read_pos; idx++) {
                  newArray[idx] = ta_pixels[idx + read_pos];
                }
                ta_pixels = this.ta = newArray;
                i = i - read_pos;
                read_pos = 0;
                max_index = ta_pixels.length - 1;
              }
              return res2;
            }
            return void 0;
          };
          this.pop = () => {
            if (i > read_pos) {
              const res2 = new Uint16Array(2);
              i -= 2;
              res2[0] = ta_pixels[i];
              res2[1] = ta_pixels[i + 1];
              return res2;
            }
            return void 0;
          };
          this.ta = ta_pixels;
          this.add = (pos) => {
            if (!pos || pos.length < 2) {
              throw new Error("Invalid pixel position. Expected [x, y] array with at least 2 elements.");
            }
            const x = Math.floor(pos[0]);
            const y = Math.floor(pos[1]);
            if (i > max_index) {
              if (read_pos >= 1024) {
                const new_ta = new Uint16Array(capacity * 2);
                const l2 = ta_pixels.length - read_pos;
                for (let c2 = 0; c2 < l2; c2++) {
                  new_ta[c2] = ta_pixels[c2 + read_pos];
                }
                ta_pixels = new_ta;
                i -= read_pos;
                read_pos = 0;
              } else {
                if (i_capacity < capacities.length - 1) {
                  capacity = capacities[++i_capacity];
                } else {
                  capacity *= 2;
                }
                max_index = capacity * 2 - 1;
                const new_ta = new Uint16Array(capacity * 2);
                const l2 = ta_pixels.length;
                for (let c2 = 0; c2 < l2; c2++) {
                  new_ta[c2] = ta_pixels[c2];
                }
                ta_pixels = this.ta = new_ta;
              }
            }
            ta_pixels[i++] = x;
            ta_pixels[i++] = y;
            return this;
          };
          this.each_pixel = (cb) => {
            let count = 0;
            for (let i2 = read_pos; i2 < i; i2 += 2) {
              const pixelPos = new Uint16Array(2);
              pixelPos[0] = ta_pixels[i2];
              pixelPos[1] = ta_pixels[i2 + 1];
              cb(pixelPos, count++);
            }
          };
          this.fix = () => {
            const adjusted = ta_pixels.slice(0, i);
            this.ta = ta_pixels = adjusted;
            max_index = this.ta.length - 1;
            return this;
          };
          this.equals = (pixel_pos_list) => {
            if (this.length !== pixel_pos_list.length) {
              return false;
            }
            const thisList = [];
            const otherList = [];
            this.each_pixel((pos) => {
              thisList.push([pos[0], pos[1]]);
            });
            pixel_pos_list.each_pixel((pos) => {
              otherList.push([pos[0], pos[1]]);
            });
            thisList.sort((a, b) => {
              if (a[0] === b[0]) return a[1] - b[1];
              return a[0] - b[0];
            });
            otherList.sort((a, b) => {
              if (a[0] === b[0]) return a[1] - b[1];
              return a[0] - b[0];
            });
            for (let i2 = 0; i2 < thisList.length; i2++) {
              if (thisList[i2][0] !== otherList[i2][0] || thisList[i2][1] !== otherList[i2][1]) {
                return false;
              }
            }
            return true;
          };
          this.map = (mapFn) => {
            const result = [];
            this.each_pixel((pos, idx) => {
              result.push(mapFn(pos, idx));
            });
            return result;
          };
          this.filter = (predicate) => {
            const result = new _Pixel_Pos_List();
            this.each_pixel((pos, idx) => {
              if (predicate(pos, idx)) {
                result.add([pos[0], pos[1]]);
              }
            });
            return result;
          };
          this.forEach = (callback2) => {
            this.each_pixel(callback2);
          };
          const str_pixels = () => {
            let res2 = "";
            let first = true;
            this.each_pixel((pos) => {
              if (first) {
                first = false;
              } else {
                res2 = res2 + ", ";
              }
              res2 = res2 + "[" + pos[0] + ", " + pos[1] + "]";
            });
            return res2;
          };
          Object.defineProperty(this, "str_pixels", {
            get: () => str_pixels(),
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(this, "length", {
            get: () => (i - read_pos) / 2,
            enumerable: true,
            configurable: false
          });
          let _bounds;
          Object.defineProperty(this, "bounds", {
            get: () => {
              _bounds = new Uint16Array(4);
              if (this.length > 0) {
                _bounds[0] = Number.MAX_SAFE_INTEGER;
                _bounds[1] = Number.MAX_SAFE_INTEGER;
                _bounds[2] = 0;
                _bounds[3] = 0;
                this.each_pixel((pos) => {
                  if (pos[0] < _bounds[0]) _bounds[0] = pos[0];
                  if (pos[0] > _bounds[2]) _bounds[2] = pos[0];
                  if (pos[1] < _bounds[1]) _bounds[1] = pos[1];
                  if (pos[1] > _bounds[3]) _bounds[3] = pos[1];
                });
              } else {
                _bounds[0] = 0;
                _bounds[1] = 0;
                _bounds[2] = 0;
                _bounds[3] = 0;
              }
              return _bounds;
            },
            enumerable: true,
            configurable: false
          });
          let _pos;
          Object.defineProperty(this, "pos", {
            get: () => {
              _pos = new Uint16Array(2);
              if (this.length > 0) {
                _pos[0] = Number.MAX_SAFE_INTEGER;
                _pos[1] = Number.MAX_SAFE_INTEGER;
                this.each_pixel((pos) => {
                  if (pos[0] < _pos[0]) _pos[0] = pos[0];
                  if (pos[1] < _pos[1]) _pos[1] = pos[1];
                });
              } else {
                _pos[0] = 0;
                _pos[1] = 0;
              }
              return _pos;
            },
            enumerable: true,
            configurable: false
          });
          this.clear = () => {
            i = 0;
            read_pos = 0;
            return this;
          };
          this.contains = (pos) => {
            if (!pos || pos.length < 2) return false;
            const isXInteger = Number.isInteger(pos[0]);
            const isYInteger = Number.isInteger(pos[1]);
            if (!isXInteger && !isYInteger) {
              return false;
            }
            const x = Math.floor(pos[0]);
            const y = Math.floor(pos[1]);
            let found = false;
            this.each_pixel((pixel) => {
              if (pixel[0] === x && pixel[1] === y) {
                if (!isXInteger && Math.floor(pos[0]) !== pos[0] || !isYInteger && Math.floor(pos[1]) !== pos[1]) {
                  return;
                }
                found = true;
              }
            });
            return found;
          };
          this.toArray = () => {
            const result = [];
            this.each_pixel((pos) => {
              result.push([pos[0], pos[1]]);
            });
            return result;
          };
        }
        /**
         * Creates a Pixel_Pos_List from an array of positions.
         * @param {Array} positions - Array of [x,y] positions
         * @returns {Pixel_Pos_List} A new Pixel_Pos_List
         * @static
         */
        static fromArray(positions) {
          const ppl = new _Pixel_Pos_List();
          if (Array.isArray(positions)) {
            positions.forEach((pos) => {
              if (Array.isArray(pos) && pos.length >= 2) {
                ppl.add(pos);
              }
            });
          }
          return ppl;
        }
      };
      if (__require.main === module) {
        const test1 = () => {
          let ppl = new Pixel_Pos_List();
          ppl.add([2, 2]);
          ppl.add([2, 3]);
          ppl.add([8, 4]);
          ppl.add([8, 3]);
          ppl.add([3, 3]);
          ppl.add([1, 2]);
          ppl.add([1, 3]);
          ppl.add([3, 2]);
          ppl.fix();
          console.log("Pixels using for...of:");
          for (const pos of ppl) {
            console.log(`  [${pos[0]}, ${pos[1]}]`);
          }
          console.log("\nFiltered pixels (x > 2):");
          const filtered = ppl.filter((pos) => pos[0] > 2);
          filtered.forEach((pos) => {
            console.log(`  [${pos[0]}, ${pos[1]}]`);
          });
          console.log("\nMapped pixels (x+y):");
          const sums = ppl.map((pos) => pos[0] + pos[1]);
          console.log(sums);
          console.log("\nSorted pixels:");
          ppl = ppl.sort();
          let item2;
          while (item2 = ppl.shift()) {
            console.log(`  [${item2[0]}, ${item2[1]}]`);
          }
        };
        test1();
      } else {
      }
      module.exports = Pixel_Pos_List;
    }
  });

  // node_modules/jsgui3-gfx-core/core/Typed_Array_Binary_Read_Write.js
  var require_Typed_Array_Binary_Read_Write = __commonJS({
    "node_modules/jsgui3-gfx-core/core/Typed_Array_Binary_Read_Write.js"(exports, module) {
      var Typed_Array_Binary_Read_Write = class {
        constructor(ta2) {
          this.ta = ta2;
          this.dv = new DataView(ta2.buffer, ta2.byteOffset, ta2.byteLength);
          this.byl = ta2.byteLength;
          this.bil = this.byl << 3;
        }
        get_bit(idx_bit) {
          const idx_byte_bit = idx_bit & 7;
          return (this.dv.getUint8(idx_bit >>> 3) & 1 << idx_byte_bit) >> idx_byte_bit;
        }
        set_bit(idx_bit, value2) {
          value2 = value2 ? 1 : 0;
          const { dv } = this;
          const idx_byte = idx_bit >>> 3;
          const idx_byte_bit = idx_bit & 7;
          const byte_mask = 1 << idx_byte_bit;
          const read_byte = dv.getUint8(idx_byte);
          const updated_byte = read_byte & ~byte_mask | value2 << idx_byte_bit;
          dv.setUint8(idx_byte, updated_byte);
        }
      };
      module.exports = Typed_Array_Binary_Read_Write;
    }
  });

  // node_modules/jsgui3-gfx-core/core/ta-math/copy.js
  var require_copy = __commonJS({
    "node_modules/jsgui3-gfx-core/core/ta-math/copy.js"(exports, module) {
      var get_instance = () => {
        const copy_ta_byte_range = (ta_source2, ta_dest, byte_idx_source_start, byte_idx_dest_start, length) => {
          ta_dest.set(ta_source2.subarray(byte_idx_source_start, byte_idx_source_start + length), byte_idx_dest_start);
        };
        const copy_rect_to_same_size_8bipp = (xy, bounds2, ta2, ta_res, ta_byte_indexes, bytes_read_row_end_jump) => {
          for (xy[1] = bounds2[1]; xy[1] < bounds2[3]; xy[1]++) {
            for (xy[0] = bounds2[0]; xy[0] < bounds2[2]; xy[0]++) {
              ta_res[ta_byte_indexes[1]++] = ta2[ta_byte_indexes[0]++];
            }
            ta_byte_indexes[0] += bytes_read_row_end_jump;
          }
        };
        const copy_rect_to_same_size_24bipp = (xy, bounds2, ta2, ta_res, ta_byte_indexes, bytes_read_row_end_jump) => {
          for (xy[1] = bounds2[1]; xy[1] < bounds2[3]; xy[1]++) {
            for (xy[0] = bounds2[0]; xy[0] < bounds2[2]; xy[0]++) {
              ta_res[ta_byte_indexes[1]++] = ta2[ta_byte_indexes[0]++];
              ta_res[ta_byte_indexes[1]++] = ta2[ta_byte_indexes[0]++];
              ta_res[ta_byte_indexes[1]++] = ta2[ta_byte_indexes[0]++];
            }
            ta_byte_indexes[0] += bytes_read_row_end_jump;
          }
        };
        const dest_aligned_copy_rect_1to4bypp = (ta_source2, ta_dest, bypr_source, bytes_per_pixel, ta_source_bounds) => {
          let y;
          const bounds_row_width = ta_source_bounds[2] - ta_source_bounds[0];
          const bypr_dest = bounds_row_width * bytes_per_pixel;
          const bytes_per_bounds_row = bytes_per_pixel * bounds_row_width;
          const byi_read_start = ta_source_bounds[0] * bytes_per_pixel + ta_source_bounds[1] * bypr_source;
          const byi_dest_start = 0;
          let byi_read = byi_read_start, byi_write = byi_dest_start;
          for (y = ta_source_bounds[1]; y < ta_source_bounds[3]; y++) {
            copy_ta_byte_range(ta_source2, ta_dest, byi_read, byi_write, bytes_per_bounds_row);
            byi_read += bypr_source;
            byi_write += bypr_dest;
          }
        };
        const unaligned_copy_rect_1to4bypp = (ta_source2, ta_dest, bypr_source, bypr_dest, bytes_per_pixel, ta_source_bounds, ta_dest_pos) => {
          let y;
          const bounds_row_width = ta_source_bounds[2] - ta_source_bounds[0];
          const bytes_per_bounds_row = bytes_per_pixel * bounds_row_width;
          const byi_read_start = ta_source_bounds[0] * bytes_per_pixel + ta_source_bounds[1] * bypr_source;
          const byi_dest_start = ta_dest_pos[0] * bytes_per_pixel + ta_dest_pos[1] * bypr_dest;
          let byi_read = byi_read_start, byi_write = byi_dest_start;
          for (y = ta_source_bounds[1]; y < ta_source_bounds[3]; y++) {
            copy_ta_byte_range(ta_source2, ta_dest, byi_read, byi_write, bytes_per_bounds_row);
            byi_read += bypr_source;
            byi_write += bypr_dest;
          }
        };
        const copy_px_to_ta_dest_byi = (ta_source2, source_colorspace, source_xy, ta_dest, byi_dest) => {
          const [width, height2, bypp2, bypr2, bipp, bipr] = source_colorspace;
          if (bipp === 24) {
            let byi_read = source_xy[0] * bypp2 + source_xy[1] * bypr2;
            ta_dest[byi_dest] = ta_source2[byi_read++];
            ta_dest[byi_dest + 1] = ta_source2[byi_read++];
            ta_dest[byi_dest + 2] = ta_source2[byi_read++];
          } else {
            console.trace();
            throw "NYI";
          }
        };
        const copy_px_24bipp = (ta_source2, byi_read, ta_dest, byi_write) => {
          ta_dest[byi_write] = ta_source2[byi_read++];
          ta_dest[byi_write + 1] = ta_source2[byi_read++];
          ta_dest[byi_write + 2] = ta_source2[byi_read++];
        };
        return {
          unaligned_copy_rect_1to4bypp,
          dest_aligned_copy_rect_1to4bypp,
          copy_rect_to_same_size_24bipp,
          copy_rect_to_same_size_8bipp,
          copy_ta_byte_range,
          get_instance,
          copy_px_to_ta_dest_byi,
          copy_px_24bipp
        };
      };
      module.exports = get_instance();
    }
  });

  // node_modules/jsgui3-gfx-core/core/ta-math/info.js
  var require_info = __commonJS({
    "node_modules/jsgui3-gfx-core/core/ta-math/info.js"(exports, module) {
      var get_instance = () => {
        const byi_from_cs_pos2 = (colorspace, pos) => {
          const [width, height2, bypp2, bypr2, bipp, bipr] = colorspace;
          return pos[0] * bypp2 + pos[1] * bypr2;
        };
        const overlapping_bounds = (bounds_1, bounds_2, res_bounds = new Int16Array(4)) => {
          res_bounds[0] = bounds_1[0] < bounds_2[0] ? bounds_2[0] : bounds_1[0];
          res_bounds[1] = bounds_1[1] < bounds_2[1] ? bounds_2[1] : bounds_1[1];
          res_bounds[2] = bounds_1[2] > bounds_2[2] ? bounds_2[2] : bounds_1[2];
          res_bounds[3] = bounds_1[3] > bounds_2[3] ? bounds_2[3] : bounds_1[3];
          return res_bounds;
        };
        return {
          overlapping_bounds,
          byi_from_cs_pos: byi_from_cs_pos2,
          get_instance
        };
      };
      module.exports = get_instance();
    }
  });

  // node_modules/jsgui3-gfx-core/core/ta-math/read.js
  var require_read = __commonJS({
    "node_modules/jsgui3-gfx-core/core/ta-math/read.js"(exports, module) {
      var get_instance = () => {
        const read_px = (ta_source2, ta_colorspace, ta_pos) => {
          const bipp = ta_colorspace[4];
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);
            return ta_source2[byi];
          } else if (bipp === 24) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);
            return ta_source2.subarray(byi, byi + 3);
          } else if (bipp === 32) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);
            return ta_source2.subarray(byi, byi + 4);
          }
        };
        const read_2x1_rect = (ta_source2, ta_colorspace, ta_pos) => {
          const [x, y] = ta_pos;
          const [width, height2, bypp2, bypr2, bipp, bipr] = ta_colorspace;
          if (x < 0) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (x > width - 1) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (y < 0) {
            throw "y position must be between 0 and height";
          }
          if (y > height2) {
            throw "y position must be between 0 and height";
          }
          let byi_read = x * bypp2 + y * bypr2;
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            const res2 = new Uint8ClampedArray(2);
            res2[0] = ta_source2[byi_read];
            res2[1] = ta_source2[byi_read + 1];
            return res2;
          } else if (bipp === 24) {
            const res2 = new Uint8ClampedArray(6);
            res2.set(ta_source2.subarray(byi_read, byi_read + 6), 0);
            return res2;
          } else if (bipp === 32) {
            const res2 = new Uint8ClampedArray(8);
            res2.set(ta_source2.subarray(byi_read, byi_read + 8), 0);
            return res2;
          }
        };
        const read_1x2_rect = (ta_source2, ta_colorspace, ta_pos) => {
          const [x, y] = ta_pos;
          const [width, height2, bypp2, bypr2, bipp, bipr] = ta_colorspace;
          if (x < 0) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (x > width - 1) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (y < 0) {
            throw "y position must be between 0 and height";
          }
          if (y > height2) {
            throw "y position must be between 0 and height";
          }
          let byi_read = x * bypp2 + y * bypr2;
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            const res2 = new Uint8ClampedArray(2);
            res2[0] = ta_source2[byi_read];
            res2[1] = ta_source2[byi_read + bypr2];
            return res2;
          } else if (bipp === 24) {
            const res2 = new Uint8ClampedArray(6);
            res2.set(ta_source2.subarray(byi_read, byi_read + 3), 0);
            byi_read += bypr2;
            res2.set(ta_source2.subarray(byi_read, byi_read + 3), 3);
            return res2;
          } else if (bipp === 32) {
            const res2 = new Uint8ClampedArray(8);
            res2.set(ta_source2.subarray(byi_read, byi_read + 4), 0);
            byi_read += bypr2;
            res2.set(ta_source2.subarray(byi_read, byi_read + 4), 4);
            return res2;
          }
        };
        const read_2x2_rect = (ta_source2, ta_colorspace, ta_pos) => {
          const [x, y] = ta_pos;
          const [width, height2, bypp2, bypr2, bipp, bipr] = ta_colorspace;
          if (x < 0) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (x > width - 1) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (y < 0) {
            throw "y position must be between 0 and (height - 1)";
          }
          if (y > height2 - 1) {
            throw "y position must be between 0 and (height - 1)";
          }
          let byi_read = x * bypp2 + y * bypr2;
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            const res2 = new Uint8ClampedArray(4);
            res2[0] = ta_source2[byi_read];
            res2[1] = ta_source2[byi_read + 1];
            res2[2] = ta_source2[byi_read + bypr2];
            res2[3] = ta_source2[byi_read + bypr2 + 1];
            return res2;
          } else if (bipp === 24) {
            const res2 = new Uint8ClampedArray(12);
            res2.set(ta_source2.subarray(byi_read, byi_read + 6), 0);
            byi_read += bypr2;
            res2.set(ta_source2.subarray(byi_read, byi_read + 6), 6);
            return res2;
          } else if (bipp === 32) {
            const res2 = new Uint8ClampedArray(16);
            res2.set(ta_source2.subarray(byi_read, byi_read + 8), 0);
            byi_read += bypr2;
            res2.set(ta_source2.subarray(byi_read, byi_read + 8), 8);
            return res2;
          }
        };
        const read_merged_vfpx_24bipp = (ta_source2, colorspace, vfpx) => {
          const [width, height2, bypp2, bypr2, bipp, bipr] = colorspace;
          const { weights, i_any_coverage_bounds } = vfpx;
          const xy = new Int16Array(2);
          let byi_read = 3 * i_any_coverage_bounds[0] + bypr2 * i_any_coverage_bounds[1];
          let byi_weight = 0;
          const iw = i_any_coverage_bounds[2] - i_any_coverage_bounds[0];
          const bytes_read_row_end_jump = bypr2 - iw * 3;
          const acc_rgb = new Float32Array(3);
          for (xy[1] = i_any_coverage_bounds[1]; xy[1] < i_any_coverage_bounds[3]; xy[1]++) {
            for (xy[0] = i_any_coverage_bounds[0]; xy[0] < i_any_coverage_bounds[2]; xy[0]++) {
              acc_rgb[0] += ta_source2[byi_read++] * weights[byi_weight];
              acc_rgb[1] += ta_source2[byi_read++] * weights[byi_weight];
              acc_rgb[2] += ta_source2[byi_read++] * weights[byi_weight++];
            }
            byi_read += bytes_read_row_end_jump;
          }
          const res2 = new Uint8ClampedArray(acc_rgb);
          return res2;
        };
        const read_merged_vfpx = (ta_source2, colorspace, vfpx) => {
          const bipp = colorspace[4];
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            console.trace();
            throw "NYI";
          } else if (bipp === 24) {
            return read_merged_vfpx_24bipp(ta_source2, colorspace, vfpx);
          } else if (bipp === 32) {
            console.trace();
            throw "NYI";
          }
        };
        const each_pixel_in_colorspace = (colorspace, callback2) => {
          const [width, height2, bypp2, bypr2, bipp, bipr] = colorspace;
          let byi = 0;
          const xy = new Int16Array(2);
          for (xy[1] = 0; xy[1] < height2; xy[1]++) {
            for (xy[0] = 0; xy[0] < width; xy[0]++) {
              callback2(xy, byi);
              byi += bypp2;
            }
          }
        };
        return {
          read_2x2_rect,
          read_1x2_rect,
          read_2x1_rect,
          read_merged_vfpx_24bipp,
          read_merged_vfpx,
          get_instance,
          each_pixel_in_colorspace
        };
      };
      module.exports = get_instance();
    }
  });

  // node_modules/jsgui3-gfx-core/core/ta-math/transform.js
  var require_transform = __commonJS({
    "node_modules/jsgui3-gfx-core/core/ta-math/transform.js"(exports, module) {
      var each_source_dest_pixels_resized_limited_further_info$inline = (source_colorspace, dest_size, callback2) => {
        const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
        const source_edge_distances = new Float32Array(4);
        const edge_distances_proportions_of_total = new Float32Array(4);
        const corner_areas_proportions_of_total = new Float32Array(4);
        const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
        let [width, height2, bypp2, bypr2, bipp, bipr] = source_colorspace;
        const source_bypr = bypr2;
        const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], bypp2, bypp2 * dest_size[0], bipp, bipp * dest_size[0]]);
        const source_fbounds = new Float32Array(4);
        const source_ibounds = new Int16Array(4);
        const source_i_any_coverage_size = new Int16Array(2);
        const source_total_coverage_ibounds = new Int16Array(4);
        let byi_read;
        let dest_byi = 0;
        [width, height2, bypp2, bypr2, bipp, bipr] = dest_colorspace;
        let x, y;
        for (y = 0; y < height2; y++) {
          source_fbounds[1] = y * dest_to_source_ratio[1];
          source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
          source_ibounds[1] = source_fbounds[1];
          source_ibounds[3] = Math.ceil(source_fbounds[3]);
          source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
          source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
          source_total_coverage_ibounds[3] = source_fbounds[3];
          source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
          source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
          if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
          if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
          edge_distances_proportions_of_total[1] = source_edge_distances[1] / fpx_area;
          edge_distances_proportions_of_total[3] = source_edge_distances[3] / fpx_area;
          for (x = 0; x < width; x++) {
            source_fbounds[0] = x * dest_to_source_ratio[0];
            source_fbounds[2] = source_fbounds[0] + dest_to_source_ratio[0];
            source_ibounds[0] = source_fbounds[0];
            source_ibounds[2] = Math.ceil(source_fbounds[2]);
            source_i_any_coverage_size[0] = source_ibounds[2] - source_ibounds[0];
            byi_read = source_ibounds[0] * bypp2 + source_ibounds[1] * source_bypr;
            if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 1) {
              callback2(dest_byi, source_i_any_coverage_size, void 0, void 0, byi_read);
            } else {
              source_total_coverage_ibounds[0] = Math.ceil(source_fbounds[0]);
              source_total_coverage_ibounds[2] = source_fbounds[2];
              if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 2) {
                callback2(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, void 0, byi_read);
              } else {
                source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
                source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
                if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
                if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
                if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 1) {
                  edge_distances_proportions_of_total[0] = source_edge_distances[0] / dest_to_source_ratio[0];
                  edge_distances_proportions_of_total[2] = source_edge_distances[2] / dest_to_source_ratio[0];
                  callback2(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, void 0, byi_read);
                } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
                  corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
                  corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
                  corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
                  corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
                  callback2(dest_byi, source_i_any_coverage_size, void 0, corner_areas_proportions_of_total, byi_read);
                } else {
                  edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
                  edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
                  corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
                  corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
                  corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
                  corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
                  callback2(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read);
                }
              }
            }
            dest_byi += bypp2;
          }
        }
      };
      var each_source_dest_pixels_resized_limited_further_info = each_source_dest_pixels_resized_limited_further_info$inline;
      var copy_px_24bipp = (ta_source2, byi_read, ta_dest, byi_write) => {
        ta_dest[byi_write] = ta_source2[byi_read++];
        ta_dest[byi_write + 1] = ta_source2[byi_read++];
        ta_dest[byi_write + 2] = ta_source2[byi_read++];
      };
      var read_1x2_weight_write_24bipp = (ta_source2, bypr2, byi_read, ta_dest, byi_write, weight_t, weight_b) => {
        let byi_read_below2 = byi_read + bypr2;
        ta_dest[byi_write] = weight_t * ta_source2[byi_read++] + weight_b * ta_source2[byi_read_below2++];
        ta_dest[byi_write + 1] = weight_t * ta_source2[byi_read++] + weight_b * ta_source2[byi_read_below2++];
        ta_dest[byi_write + 2] = weight_t * ta_source2[byi_read++] + weight_b * ta_source2[byi_read_below2++];
      };
      var read_2x1_weight_write_24bipp = (ta_source2, byi_read, ta_dest, byi_write, weight_l, weight_r) => {
        let byi_read_right2 = byi_read + 3;
        ta_dest[byi_write] = weight_l * ta_source2[byi_read++] + weight_r * ta_source2[byi_read_right2++];
        ta_dest[byi_write + 1] = weight_l * ta_source2[byi_read++] + weight_r * ta_source2[byi_read_right2++];
        ta_dest[byi_write + 2] = weight_l * ta_source2[byi_read++] + weight_r * ta_source2[byi_read_right2++];
      };
      var read_2x2_weight_write_24bipp = (ta_source2, bypr2, byi_read, ta_dest, byi_write, corner_weights_ltrb) => {
        let byi_read_right2 = byi_read + 3;
        let byi_read_below2 = byi_read + bypr2;
        let byi_read_below_right2 = byi_read_below2 + 3;
        ta_dest[byi_write] = corner_weights_ltrb[0] * ta_source2[byi_read++] + corner_weights_ltrb[1] * ta_source2[byi_read_right2++] + corner_weights_ltrb[2] * ta_source2[byi_read_below2++] + corner_weights_ltrb[3] * ta_source2[byi_read_below_right2++];
        ta_dest[byi_write + 1] = corner_weights_ltrb[0] * ta_source2[byi_read++] + corner_weights_ltrb[1] * ta_source2[byi_read_right2++] + corner_weights_ltrb[2] * ta_source2[byi_read_below2++] + corner_weights_ltrb[3] * ta_source2[byi_read_below_right2++];
        ta_dest[byi_write + 2] = corner_weights_ltrb[0] * ta_source2[byi_read++] + corner_weights_ltrb[1] * ta_source2[byi_read_right2++] + corner_weights_ltrb[2] * ta_source2[byi_read_below2++] + corner_weights_ltrb[3] * ta_source2[byi_read_below_right2++];
      };
      var read_3x2_weight_write_24bipp = (ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_weights_ltrb, ta_dest, dest_byi) => {
        const bypp2 = 3;
        let byi_tl = byi_read;
        let byi_tm = byi_tl + bypp2, byi_tr = byi_tm + bypp2;
        let byi_bl = byi_tm + bypr2, byi_bm = byi_bl + bypp2, byi_br = byi_bm + bypp2;
        ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
      };
      var read_2x3_weight_write_24bipp = (ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_weights_ltrb, ta_dest, dest_byi) => {
        const bypp2 = 3;
        let byi_tl = byi_read, byi_tr = byi_tl + bypp2;
        let byi_ml = byi_tl + bypr2, byi_mr = byi_ml + bypp2;
        let byi_bl = byi_ml + bypr2, byi_br = byi_bl + bypp2;
        ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source2[byi_mr++] * edge_distances_proportions_of_total[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source2[byi_mr++] * edge_distances_proportions_of_total[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source2[byi_mr++] * edge_distances_proportions_of_total[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_br++] * corner_weights_ltrb[3];
      };
      var read_3x3_weight_write_24bipp = (ta_source2, bypr2, byi_read, edge_weights, corner_weights_ltrb, fpx_area_recip2, ta_dest, dest_byi) => {
        const bypp2 = 3;
        let byi_tl = byi_read, byi_tm = byi_tl + bypp2, byi_tr = byi_tm + bypp2;
        let byi_ml = byi_tl + bypr2, byi_mm = byi_ml + bypp2, byi_mr = byi_mm + bypp2;
        let byi_bl = byi_ml + bypr2, byi_bm = byi_bl + bypp2, byi_br = byi_bm + bypp2;
        ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_weights[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_weights[0] + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_weights[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_weights[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_weights[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_weights[0] + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_weights[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_weights[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_weights[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_weights[0] + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_weights[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_weights[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
      };
      var read_gt3x3_weight_write_24bipp = (ta_source2, bypr2, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_weights_ltrb, fpx_area_recip2, ta_dest, dest_byi) => {
        const byi_tl = byi_read;
        let r = 0, g = 0, b = 0;
        let x, y;
        const end_hmiddle = source_i_any_coverage_size[0] - 1, end_vmiddle = source_i_any_coverage_size[1] - 1;
        r += ta_source2[byi_read++] * corner_weights_ltrb[0];
        g += ta_source2[byi_read++] * corner_weights_ltrb[0];
        b += ta_source2[byi_read++] * corner_weights_ltrb[0];
        for (x = 1; x < end_hmiddle; x++) {
          r += ta_source2[byi_read++] * edge_distances_proportions_of_total[1];
          g += ta_source2[byi_read++] * edge_distances_proportions_of_total[1];
          b += ta_source2[byi_read++] * edge_distances_proportions_of_total[1];
        }
        r += ta_source2[byi_read++] * corner_weights_ltrb[1];
        g += ta_source2[byi_read++] * corner_weights_ltrb[1];
        b += ta_source2[byi_read++] * corner_weights_ltrb[1];
        for (y = 1; y < end_vmiddle; y++) {
          byi_read = byi_tl + y * bypr2;
          r += ta_source2[byi_read++] * edge_distances_proportions_of_total[0];
          g += ta_source2[byi_read++] * edge_distances_proportions_of_total[0];
          b += ta_source2[byi_read++] * edge_distances_proportions_of_total[0];
          for (x = 1; x < end_hmiddle; x++) {
            r += ta_source2[byi_read++] * fpx_area_recip2;
            g += ta_source2[byi_read++] * fpx_area_recip2;
            b += ta_source2[byi_read++] * fpx_area_recip2;
          }
          r += ta_source2[byi_read++] * edge_distances_proportions_of_total[2];
          g += ta_source2[byi_read++] * edge_distances_proportions_of_total[2];
          b += ta_source2[byi_read++] * edge_distances_proportions_of_total[2];
        }
        byi_read = byi_tl + end_vmiddle * bypr2;
        r += ta_source2[byi_read++] * corner_weights_ltrb[2];
        g += ta_source2[byi_read++] * corner_weights_ltrb[2];
        b += ta_source2[byi_read++] * corner_weights_ltrb[2];
        for (x = 1; x < end_hmiddle; x++) {
          r += ta_source2[byi_read++] * edge_distances_proportions_of_total[3];
          g += ta_source2[byi_read++] * edge_distances_proportions_of_total[3];
          b += ta_source2[byi_read++] * edge_distances_proportions_of_total[3];
        }
        r += ta_source2[byi_read++] * corner_weights_ltrb[3];
        g += ta_source2[byi_read++] * corner_weights_ltrb[3];
        b += ta_source2[byi_read++] * corner_weights_ltrb[3];
        ta_dest[dest_byi] = Math.round(r);
        ta_dest[dest_byi + 1] = Math.round(g);
        ta_dest[dest_byi + 2] = Math.round(b);
      };
      var resize_ta_colorspace_24bipp$subpixel$inline = (ta_source2, source_colorspace, dest_size, ta_dest) => {
        const source_bypp = source_colorspace[2];
        const source_bypr = source_colorspace[3];
        const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
        let f_source_x, f_source_r;
        let i_source_l, i_source_lr_crossover;
        let f_source_y, f_source_b;
        let i_source_t, i_source_tb_crossover;
        let i_dest_x, i_dest_y;
        const ta_left_proportions = new Float32Array(dest_size[0]);
        const ta_top_proportions = new Float32Array(dest_size[1]);
        const ta_source_x_byi_component = new Int32Array(dest_size[0]);
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
          f_source_x = i_dest_x * f_px_w;
          f_source_r = f_source_x + f_px_w;
          i_source_l = Math.floor(f_source_x);
          i_source_lr_crossover = i_source_l + 1;
          ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
          if (f_source_r < i_source_lr_crossover || i_source_l === f_source_x) {
            ta_left_proportions[i_dest_x] = 1;
          } else {
            ta_left_proportions[i_dest_x] = (i_source_lr_crossover - f_source_x) / f_px_w;
          }
        }
        let byi_source;
        let byi_write = 0;
        let byi_read_below2, byi_read_right2, byi_read_below_right2;
        let edge_l, edge_t, edge_r;
        let corner_tl, corner_tr, corner_bl, corner_br;
        let y_byi;
        for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
          f_source_y = i_dest_y * f_px_h;
          f_source_b = f_source_y + f_px_h;
          i_source_t = Math.floor(f_source_y);
          i_source_tb_crossover = i_source_t + 1;
          y_byi = i_source_t * source_bypr;
          if (f_source_b < i_source_tb_crossover || i_source_t === f_source_y) {
            ta_top_proportions[i_dest_y] = 1;
          } else {
            ta_top_proportions[i_dest_y] = (i_source_tb_crossover - f_source_y) / f_px_h;
          }
          edge_t = ta_top_proportions[i_dest_y];
          if (edge_t === 1) {
            for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
              edge_l = ta_left_proportions[i_dest_x];
              edge_r = 1 - ta_left_proportions[i_dest_x];
              byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
              if (edge_l === 1) {
                ta_dest[byi_write++] = ta_source2[byi_source++];
                ta_dest[byi_write++] = ta_source2[byi_source++];
                ta_dest[byi_write++] = ta_source2[byi_source++];
              } else {
                byi_read_right2 = byi_source + 3;
                ta_dest[byi_write++] = edge_l * ta_source2[byi_source++] + edge_r * ta_source2[byi_read_right2++];
                ta_dest[byi_write++] = edge_l * ta_source2[byi_source++] + edge_r * ta_source2[byi_read_right2++];
                ta_dest[byi_write++] = edge_l * ta_source2[byi_source++] + edge_r * ta_source2[byi_read_right2++];
              }
            }
          } else {
            const edge_b = 1 - ta_top_proportions[i_dest_y];
            for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
              edge_l = ta_left_proportions[i_dest_x];
              edge_r = 1 - ta_left_proportions[i_dest_x];
              byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
              if (edge_l === 1) {
                byi_read_below2 = byi_source + source_bypr;
                ta_dest[byi_write++] = edge_t * ta_source2[byi_source++] + edge_b * ta_source2[byi_read_below2++];
                ta_dest[byi_write++] = edge_t * ta_source2[byi_source++] + edge_b * ta_source2[byi_read_below2++];
                ta_dest[byi_write++] = edge_t * ta_source2[byi_source++] + edge_b * ta_source2[byi_read_below2++];
              } else {
                corner_tl = edge_l * edge_t;
                corner_tr = edge_r * edge_t;
                corner_bl = edge_l * edge_b;
                corner_br = edge_r * edge_b;
                byi_read_right2 = byi_source + 3;
                byi_read_below2 = byi_source + source_bypr;
                byi_read_below_right2 = byi_read_below2 + 3;
                ta_dest[byi_write++] = corner_tl * ta_source2[byi_source++] + corner_tr * ta_source2[byi_read_right2++] + corner_bl * ta_source2[byi_read_below2++] + corner_br * ta_source2[byi_read_below_right2++];
                ta_dest[byi_write++] = corner_tl * ta_source2[byi_source++] + corner_tr * ta_source2[byi_read_right2++] + corner_bl * ta_source2[byi_read_below2++] + corner_br * ta_source2[byi_read_below_right2++];
                ta_dest[byi_write++] = corner_tl * ta_source2[byi_source++] + corner_tr * ta_source2[byi_read_right2++] + corner_bl * ta_source2[byi_read_below2++] + corner_br * ta_source2[byi_read_below_right2++];
              }
            }
          }
        }
      };
      var resize_ta_colorspace_24bipp$subpixel = resize_ta_colorspace_24bipp$subpixel$inline;
      var resize_ta_colorspace_24bipp$superpixel$inline$locals$inline = (ta_source2, source_colorspace, dest_size, opt_ta_dest2) => {
        const ta_dest = opt_ta_dest2;
        const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
        const fpx_area_recip2 = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
        const [fpxw, fpxh] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
        let edge_l, edge_t, edge_r, edge_b;
        let edge_p_l, edge_p_t, edge_p_r, edge_p_b;
        let corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br;
        const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
        const source_bypp = source_colorspace[2];
        const source_bypr = source_colorspace[3];
        const source_bipp = source_colorspace[4];
        const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], source_bypp, source_bypp * dest_size[0], source_bipp, source_bipp * dest_size[0]]);
        let fbounds_l, fbounds_t, fbounds_r, fbounds_b;
        let ibounds_l, ibounds_t, ibounds_r, ibounds_b;
        let any_coverage_w, any_coverage_h;
        let total_coverage_l, total_coverage_t, total_coverage_r, total_coverage_b;
        let byi_read;
        let dest_byi = 0;
        const width = dest_colorspace[0], height2 = dest_colorspace[1];
        let x, y;
        let r = 0, g = 0, b = 0;
        let x_inner, y_inner;
        let byi_read_right2, byi_read_below2, byi_read_below_right2;
        let byi_tl, byi_tm, byi_tr;
        let byi_ml, byi_mm, byi_mr;
        let byi_bl, byi_bm, byi_br;
        let end_hmiddle, end_vmiddle;
        for (y = 0; y < height2; y++) {
          fbounds_t = y * fpxh;
          fbounds_b = fbounds_t + fpxh;
          ibounds_t = Math.floor(fbounds_t);
          ibounds_b = Math.ceil(fbounds_b);
          any_coverage_h = ibounds_b - ibounds_t;
          total_coverage_t = Math.ceil(fbounds_t);
          total_coverage_b = Math.floor(fbounds_b);
          edge_t = total_coverage_t - fbounds_t;
          edge_b = fbounds_b - total_coverage_b;
          if (edge_t === 0) edge_t = 1;
          if (edge_b === 0) edge_b = 1;
          edge_p_t = edge_t / fpx_area;
          edge_p_b = edge_b / fpx_area;
          fbounds_l = 0;
          fbounds_r = fpxw;
          for (x = 0; x < width; x++) {
            fbounds_l = x * fpxw;
            fbounds_r = (x + 1) * fpxw;
            ibounds_l = Math.floor(fbounds_l);
            ibounds_r = Math.ceil(fbounds_r);
            any_coverage_w = ibounds_r - ibounds_l;
            byi_read = ibounds_l * source_bypp + ibounds_t * source_bypr;
            total_coverage_l = Math.ceil(fbounds_l);
            total_coverage_r = Math.floor(fbounds_r);
            edge_l = total_coverage_l - fbounds_l;
            edge_r = fbounds_r - total_coverage_r;
            if (edge_l === 0) edge_l = 1;
            if (edge_r === 0) edge_r = 1;
            corner_p_tl = edge_l * edge_p_t;
            corner_p_tr = edge_r * edge_p_t;
            corner_p_bl = edge_l * edge_p_b;
            corner_p_br = edge_r * edge_p_b;
            if (any_coverage_w > 3 || any_coverage_h > 3) {
              edge_p_l = edge_l / fpx_area;
              edge_p_r = edge_r / fpx_area;
              byi_tl = byi_read;
              end_hmiddle = any_coverage_w - 1;
              end_vmiddle = any_coverage_h - 1;
              r = g = b = 0;
              r += ta_source2[byi_read++] * corner_p_tl;
              g += ta_source2[byi_read++] * corner_p_tl;
              b += ta_source2[byi_read++] * corner_p_tl;
              for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                r += ta_source2[byi_read++] * edge_p_t;
                g += ta_source2[byi_read++] * edge_p_t;
                b += ta_source2[byi_read++] * edge_p_t;
              }
              r += ta_source2[byi_read++] * corner_p_tr;
              g += ta_source2[byi_read++] * corner_p_tr;
              b += ta_source2[byi_read++] * corner_p_tr;
              for (y_inner = 1; y_inner < end_vmiddle; y_inner++) {
                byi_read = byi_tl + y_inner * source_bypr;
                r += ta_source2[byi_read++] * edge_p_l;
                g += ta_source2[byi_read++] * edge_p_l;
                b += ta_source2[byi_read++] * edge_p_l;
                for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                  r += ta_source2[byi_read++] * fpx_area_recip2;
                  g += ta_source2[byi_read++] * fpx_area_recip2;
                  b += ta_source2[byi_read++] * fpx_area_recip2;
                }
                r += ta_source2[byi_read++] * edge_p_r;
                g += ta_source2[byi_read++] * edge_p_r;
                b += ta_source2[byi_read++] * edge_p_r;
              }
              byi_read = byi_tl + end_vmiddle * source_bypr;
              r += ta_source2[byi_read++] * corner_p_bl;
              g += ta_source2[byi_read++] * corner_p_bl;
              b += ta_source2[byi_read++] * corner_p_bl;
              for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                r += ta_source2[byi_read++] * edge_p_b;
                g += ta_source2[byi_read++] * edge_p_b;
                b += ta_source2[byi_read++] * edge_p_b;
              }
              r += ta_source2[byi_read++] * corner_p_br;
              g += ta_source2[byi_read++] * corner_p_br;
              b += ta_source2[byi_read++] * corner_p_br;
              ta_dest[dest_byi] = Math.round(r);
              ta_dest[dest_byi + 1] = Math.round(g);
              ta_dest[dest_byi + 2] = Math.round(b);
            } else {
              if (any_coverage_w === 2 && any_coverage_h === 2) {
                byi_read_right2 = byi_read + 3;
                byi_read_below2 = byi_read + source_bypr;
                byi_read_below_right2 = byi_read_below2 + 3;
                ta_dest[dest_byi] = corner_p_tl * ta_source2[byi_read++] + corner_p_tr * ta_source2[byi_read_right2++] + corner_p_bl * ta_source2[byi_read_below2++] + corner_p_br * ta_source2[byi_read_below_right2++];
                ta_dest[dest_byi + 1] = corner_p_tl * ta_source2[byi_read++] + corner_p_tr * ta_source2[byi_read_right2++] + corner_p_bl * ta_source2[byi_read_below2++] + corner_p_br * ta_source2[byi_read_below_right2++];
                ta_dest[dest_byi + 2] = corner_p_tl * ta_source2[byi_read++] + corner_p_tr * ta_source2[byi_read_right2++] + corner_p_bl * ta_source2[byi_read_below2++] + corner_p_br * ta_source2[byi_read_below_right2++];
              } else {
                edge_p_l = edge_l / fpx_area;
                edge_p_r = edge_r / fpx_area;
                if (any_coverage_w === 2 && any_coverage_h === 3) {
                  byi_tl = byi_read;
                  byi_tr = byi_tl + 3;
                  byi_ml = byi_tl + source_bypr;
                  byi_mr = byi_ml + 3;
                  byi_bl = byi_ml + source_bypr;
                  byi_br = byi_bl + 3;
                  ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_br++] * corner_p_br;
                } else if (any_coverage_w === 3 && any_coverage_h === 2) {
                  byi_tl = byi_read;
                  byi_tm = byi_tl + 3;
                  byi_tr = byi_tm + 3;
                  byi_bl = byi_tm + source_bypr;
                  byi_bm = byi_bl + 3;
                  byi_br = byi_bm + 3;
                  ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                } else if (any_coverage_w === 3 && any_coverage_h === 3) {
                  byi_tl = byi_read;
                  byi_tm = byi_tl + source_bypp;
                  byi_tr = byi_tm + source_bypp;
                  byi_ml = byi_tl + source_bypr;
                  byi_mm = byi_ml + source_bypp;
                  byi_mr = byi_mm + source_bypp;
                  byi_bl = byi_ml + source_bypr;
                  byi_bm = byi_bl + source_bypp;
                  byi_br = byi_bm + source_bypp;
                  ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                } else {
                  console.trace();
                  throw "stop";
                }
              }
            }
            dest_byi += source_bypp;
          }
        }
      };
      var resize_ta_colorspace_24bipp$superpixel = resize_ta_colorspace_24bipp$superpixel$inline$locals$inline;
      var resize_ta_colorspace_24bipp$general = (ta_source2, source_colorspace, dest_size, opt_ta_dest2) => {
        const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
        const [width, height2, bypp2, bypr2, bipp, bipr] = source_colorspace;
        const fpx_area_recip2 = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
        each_source_dest_pixels_resized_limited_further_info(source_colorspace, dest_size, (dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read) => {
          if (source_i_any_coverage_size[0] === 1) {
            if (source_i_any_coverage_size[1] === 1) {
              copy_px_24bipp(ta_source2, byi_read, opt_ta_dest2, dest_byi);
            } else if (source_i_any_coverage_size[1] === 2) {
              read_1x2_weight_write_24bipp(ta_source2, bypr2, byi_read, opt_ta_dest2, dest_byi, edge_distances_proportions_of_total[1], edge_distances_proportions_of_total[3]);
            } else {
              console.log("source_i_any_coverage_size", source_i_any_coverage_size);
              console.trace();
              throw "NYI";
            }
          } else if (source_i_any_coverage_size[0] === 2) {
            if (source_i_any_coverage_size[1] === 1) {
              read_2x1_weight_write_24bipp(ta_source2, byi_read, opt_ta_dest2, dest_byi, edge_distances_proportions_of_total[0], edge_distances_proportions_of_total[2]);
            } else if (source_i_any_coverage_size[1] === 2) {
              read_2x2_weight_write_24bipp(ta_source2, bypr2, byi_read, opt_ta_dest2, dest_byi, corner_areas_proportions_of_total);
            } else {
              read_2x3_weight_write_24bipp(ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest2, dest_byi);
            }
          } else if (source_i_any_coverage_size[0] === 3) {
            if (source_i_any_coverage_size[1] === 1) {
              console.log("source_i_any_coverage_size", source_i_any_coverage_size);
              console.trace();
              throw "NYI";
            } else if (source_i_any_coverage_size[1] === 2) {
              read_3x2_weight_write_24bipp(ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest2, dest_byi);
            } else if (source_i_any_coverage_size[1] === 3) {
              read_3x3_weight_write_24bipp(ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip2, opt_ta_dest2, dest_byi);
            } else {
              read_gt3x3_weight_write_24bipp(ta_source2, bypr2, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip2, opt_ta_dest2, dest_byi);
            }
          } else {
            read_gt3x3_weight_write_24bipp(ta_source2, bypr2, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip2, opt_ta_dest2, dest_byi);
          }
        });
      };
      var resize_ta_colorspace_24bipp = (ta_source2, source_colorspace, dest_size, opt_ta_dest2) => {
        const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
        if (dest_to_source_ratio[0] < 1 && dest_to_source_ratio[1] < 1) {
          return resize_ta_colorspace_24bipp$subpixel(ta_source2, source_colorspace, dest_size, opt_ta_dest2);
        } else if (dest_to_source_ratio[0] > 1 && dest_to_source_ratio[1] > 1) {
          return resize_ta_colorspace_24bipp$superpixel(ta_source2, source_colorspace, dest_size, opt_ta_dest2);
        } else {
          return resize_ta_colorspace_24bipp$general(ta_source2, source_colorspace, dest_size, opt_ta_dest2);
        }
      };
      var resize_ta_colorspace = (ta_source2, source_colorspace, dest_size, opt_ta_dest2) => {
        const bipp = source_colorspace[4];
        if (bipp === 1) {
          console.trace();
          throw "NYI";
        } else if (bipp === 8) {
          console.trace();
          throw "NYI";
        } else if (bipp === 24) {
          return resize_ta_colorspace_24bipp(ta_source2, source_colorspace, dest_size, opt_ta_dest2);
        } else if (bipp === 32) {
          console.trace();
          throw "NYI";
        } else {
          console.trace();
          throw "unsupported bipp: " + bipp;
        }
      };
      module.exports = {
        resize_ta_colorspace,
        resize_ta_colorspace_24bipp,
        resize_ta_colorspace_24bipp$subpixel
      };
    }
  });

  // node_modules/jsgui3-gfx-core/core/ta-math/write.js
  var require_write = __commonJS({
    "node_modules/jsgui3-gfx-core/core/ta-math/write.js"(exports, module) {
      var get_instance = () => {
        const fill_solid_rect_by_bounds_8bipp = (ta_dest, bypr_dest, ta_bounds, ui8_color) => {
          const row_width = ta_bounds[2] - ta_bounds[0];
          const bytes_per_row = row_width;
          const ta_write_row = new Uint8ClampedArray(bytes_per_row).fill(ui8_color);
          const byi_dest_start = ta_bounds[0] + ta_bounds[1] * bypr_dest;
          let byi_write = byi_dest_start;
          for (let y = ta_bounds[1]; y < ta_bounds[3]; y++) {
            ta_dest.set(ta_write_row, byi_write);
            byi_write += bypr_dest;
          }
        };
        const fill_solid_rect_by_bounds_24bipp = (ta_dest, bypr_dest, ta_bounds, ta_rgb) => {
          const row_width = ta_bounds[2] - ta_bounds[0];
          const bytes_per_row = row_width * 3;
          const ta_write_row = new Uint8ClampedArray(bytes_per_row);
          let cc = 0, c2 = 0;
          while (c2 < bytes_per_row) {
            ta_write_row[c2++] = ta_rgb[cc++];
            if (cc === 3) cc = 0;
          }
          const byi_dest_start = ta_bounds[0] * 3 + ta_bounds[1] * bypr_dest;
          let byi_write = byi_dest_start;
          for (let y = ta_bounds[1]; y < ta_bounds[3]; y++) {
            ta_dest.set(ta_write_row, byi_write);
            byi_write += bypr_dest;
          }
        };
        const fill_solid_rect_by_bounds = (ta_dest, bypr_dest, ta_bounds, bipp, color) => {
          if (bipp === 8) {
            return fill_solid_rect_by_bounds_8bipp(ta_dest, bypr_dest, ta_bounds, color);
          } else if (bipp === 24) {
            return fill_solid_rect_by_bounds_24bipp(ta_dest, bypr_dest, ta_bounds, color);
          } else if (bipp === 32) {
            console.trace();
            throw "NYI";
          } else {
            console.trace();
            throw "Unsupported bipp: " + bipp;
          }
        };
        return {
          fill_solid_rect_by_bounds,
          fill_solid_rect_by_bounds_24bipp,
          fill_solid_rect_by_bounds_8bipp,
          get_instance
        };
      };
      module.exports = get_instance();
    }
  });

  // node_modules/jsgui3-gfx-core/core/ta-math/bitwise.js
  var require_bitwise = __commonJS({
    "node_modules/jsgui3-gfx-core/core/ta-math/bitwise.js"(exports, module) {
      var to_binary_string = (uint8Array) => {
        return Array.from(uint8Array).map((byte) => byte.toString(2).padStart(8, "0")).join("");
      };
      var right_shift_32bit_with_carry2 = (image) => {
        const length = image.length;
        const shifted_result = new Uint8Array(length);
        const dataView = new DataView(image.buffer);
        const resultView = new DataView(shifted_result.buffer);
        const chunks = length >> 2;
        const remainder = length & 3;
        let carry = 0;
        for (let i = 0; i < chunks; i++) {
          const original = dataView.getUint32(i * 4);
          const shifted = carry << 31 | original >>> 1;
          resultView.setUint32(i * 4, shifted);
          carry = original & 1;
        }
        if (remainder > 0) {
          const lastIndex = chunks * 4;
          const lastChunk = new Uint8Array(4);
          lastChunk.set(image.slice(lastIndex));
          const lastOriginal = new DataView(lastChunk.buffer).getUint32(0);
          const lastShifted = carry << 31 | lastOriginal >>> 1;
          for (let j = 0; j < remainder; j++) {
            resultView.setUint8(lastIndex + j, lastShifted >>> 8 * (3 - j) & 255);
          }
        }
        return shifted_result;
      };
      var xor_typed_arrays2 = (original_image, shifted_image, res2) => {
        const length = original_image.length;
        if (length !== shifted_image.length) {
          throw new Error("Typed arrays must be of the same length.");
        }
        const xor_result = res2 || new Uint8Array(length);
        const originalView = new DataView(original_image.buffer);
        const shiftedView = new DataView(shifted_image.buffer);
        const resultView = new DataView(xor_result.buffer);
        const chunks = length >>> 2;
        const remaining_start_index = chunks << 2;
        for (let i = 0; i < chunks; i++) {
          const byteOffset = i << 2;
          const original = originalView.getUint32(byteOffset, false);
          const shifted = shiftedView.getUint32(byteOffset, false);
          const xor_result_chunk = original ^ shifted;
          resultView.setUint32(byteOffset, xor_result_chunk, false);
        }
        for (let i = remaining_start_index; i < length; i++) {
          const originalByte = originalView.getUint8(i);
          const shiftedByte = shiftedView.getUint8(i);
          resultView.setUint8(i, originalByte ^ shiftedByte);
        }
        return xor_result;
      };
      var copy_row_beginning_bits = (ta_source2, row_width, ta_dest) => {
        if (ta_source2.length !== ta_dest.length) {
          throw new Error("Source and destination arrays must be the same length.");
        }
        const total_bits = ta_source2.length * 8;
        const dataViewSource = new DataView(ta_source2.buffer, ta_source2.byteOffset);
        const dataViewDest = new DataView(ta_dest.buffer, ta_dest.byteOffset);
        const height2 = Math.floor(total_bits / row_width);
        let bit_index = 0;
        for (let y = 0; y < height2; y++) {
          const byte_index = Math.floor(bit_index / 8);
          const bit_in_byte = bit_index % 8;
          const source_byte = dataViewSource.getUint8(byte_index);
          const first_bit = source_byte >> 7 - bit_in_byte & 1;
          const dest_byte = dataViewDest.getUint8(byte_index);
          const updated_dest_byte = dest_byte & ~(1 << 7 - bit_in_byte) | first_bit << 7 - bit_in_byte;
          dataViewDest.setUint8(byte_index, updated_dest_byte);
          bit_index += row_width;
        }
      };
      var set_row_beginning_bits_to_0 = (ta2, row_width) => {
        const total_bits = ta2.length * 8;
        const dataView = new DataView(ta2.buffer, ta2.byteOffset);
        const height2 = Math.floor(total_bits / row_width);
        let bit_index = 0;
        for (let y = 0; y < height2; y++) {
          const byte_index = Math.floor(bit_index / 8);
          const bit_in_byte = bit_index % 8;
          const byte = dataView.getUint8(byte_index);
          const updated_byte = byte & ~(1 << 7 - bit_in_byte);
          dataView.setUint8(byte_index, updated_byte);
          bit_index += row_width;
        }
      };
      var fast_find_next_set_bit = (num, start_index) => {
        if (start_index < -1 || start_index > 31) return false;
        if (start_index === 31) return false;
        if (start_index >= 0) {
          num = num & (1 << 31 - start_index) - 1;
        }
        if (num === 0) return false;
        const next_set_bit = Math.clz32(num);
        return next_set_bit < 32 ? next_set_bit : false;
      };
      var fast_find_next_set_ta_bit = (ta2, start_index = 0, limit = ta2.length * 8) => {
        const total_bits = ta2.length * 8;
        const end_index = Math.min(start_index + limit, total_bits);
        for (let bit_index = start_index + 1; bit_index < end_index; bit_index++) {
          const byte_index = bit_index >>> 3;
          const bit_in_byte = bit_index & 7;
          if ((ta2[byte_index] & 1 << 7 - bit_in_byte) !== 0) {
            return bit_index;
          }
        }
        return false;
      };
      var each_1_index2 = (ta2, cb) => {
        const length = ta2.length;
        if (length === 0) return;
        const view = new DataView(ta2.buffer, ta2.byteOffset);
        const chunks = length >>> 2;
        const remaining_start_index = chunks << 2;
        const remaining_length = length % 4;
        for (let i = 0; i < chunks; i++) {
          const value2 = view.getUint32(i << 2, false);
          let bit_index = fast_find_next_set_bit(value2, -1);
          while (bit_index !== false) {
            cb((i << 5) + bit_index);
            bit_index = fast_find_next_set_bit(value2, bit_index);
          }
        }
        for (let i = 0; i < remaining_length; i++) {
          const byte = view.getUint8(remaining_start_index + i);
          for (let bit = 0; bit < 8; bit++) {
            if (byte & 1 << 7 - bit) {
              const absolute_index = remaining_start_index * 8 + i * 8 + bit;
              cb(absolute_index);
            }
          }
        }
      };
      var pop_cnt = (n) => {
        n = n - (n >> 1 & 1431655765);
        n = (n & 858993459) + (n >> 2 & 858993459);
        n = n + (n >> 4) & 252645135;
        n = n + (n >> 8);
        n = n + (n >> 16);
        return n & 63;
      };
      var pop_cnt_typed_array = (typedArray, is_little_endian = true) => {
        let total_count = 0;
        const length = typedArray.length;
        if (length === 0) return total_count;
        const view = new DataView(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
        const chunks = length >>> 2;
        for (let i = 0; i < chunks; i++) {
          const value2 = view.getUint32(i << 2, is_little_endian);
          total_count += pop_cnt(value2);
        }
        const remaining_start_index = chunks << 2;
        const remaining_length = length - remaining_start_index;
        for (let i = 0; i < remaining_length; i++) {
          const byte = view.getUint8(remaining_start_index + i);
          total_count += (byte & 1) + (byte >> 1 & 1) + (byte >> 2 & 1) + (byte >> 3 & 1) + (byte >> 4 & 1) + (byte >> 5 & 1) + (byte >> 6 & 1) + (byte >> 7 & 1);
        }
        return total_count;
      };
      var count_1s2 = pop_cnt_typed_array;
      var BitwiseTester = class {
        constructor(ta2 = null) {
          if (ta2) {
            this.ta = ta2;
          } else {
            this.ta = new Uint8Array([0, 1, 1, 2, 3, 5, 8, 13]);
          }
        }
        // Testing shift_typed_array_right using string representation
        test_shift_typed_array_right() {
          const result = right_shift_32bit_with_carry2(this.ta);
          const binary_ta1 = to_binary_string(this.ta);
          const binary_ta2 = to_binary_string(result);
          const expected_shift = "0" + binary_ta1.slice(0, -1);
          if (expected_shift === binary_ta2) {
            return {
              passed: true,
              messages: ["Test Passed: The shift operation works correctly."]
            };
          } else {
            return {
              passed: false,
              messages: [`Test Failed: The shifted result does not match the expected output. Expected: ${expected_shift}, Got: ${binary_ta2}`]
            };
          }
        }
        // Testing xor_typed_arrays (unchanged for context)
        test_xor_typed_arrays() {
          const ta2 = new Uint8Array(this.ta.length).fill(1);
          const result = xor_typed_arrays2(this.ta, ta2);
          let resultBinary = "";
          for (const byte of result) {
            resultBinary += byte.toString(2).padStart(8, "0");
          }
          let expectedBinary = "";
          for (let i = 0; i < this.ta.length; i++) {
            expectedBinary += (this.ta[i] ^ ta2[i]).toString(2).padStart(8, "0");
          }
          const passed = resultBinary === expectedBinary;
          const messages = [];
          if (!passed) {
            messages.push("XOR test failed. Expected: " + expectedBinary + ", Got: " + resultBinary);
          } else {
          }
          return {
            passed,
            messages
          };
        }
        // Method to run all tests (unchanged for context)
        test() {
          const results = [];
          let count_passed = 0;
          let count_failed = 0;
          const shift_test_result = this.test_shift_typed_array_right();
          results.push(shift_test_result);
          if (shift_test_result.passed) count_passed++;
          else count_failed++;
          const xor_test_result = this.test_xor_typed_arrays();
          results.push(xor_test_result);
          if (xor_test_result.passed) count_passed++;
          else count_failed++;
          return {
            passed: count_failed === 0,
            count_passed,
            count_failed,
            results
          };
        }
      };
      if (__require.main === module) {
        const tester = new BitwiseTester();
        const test_res = tester.test();
        console.log("test_res", JSON.stringify(test_res, null, 2));
      }
      var get_ta_bits_that_differ_from_previous_as_1s2 = (ta_source2, bits_per_row, ta_dest = new ta_source2.constructor(ta_source2.length), copy_original_x0_values = false) => {
        const rshifted = right_shift_32bit_with_carry2(ta_source2);
        xor_typed_arrays2(ta_source2, rshifted, ta_dest);
        if (copy_original_x0_values) {
          copy_row_beginning_bits(ta_source2, bits_per_row, ta_dest);
        } else {
          set_row_beginning_bits_to_0(ta_dest);
        }
        return ta_dest;
      };
      var get_bit = (ta2, i) => ta2[i >> 3] >> 7 - (i & 7) & 1;
      module.exports = {
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        pop_cnt,
        pop_cnt_typed_array,
        copy_row_beginning_bits,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        get_bit,
        fast_find_next_set_ta_bit
      };
    }
  });

  // node_modules/jsgui3-gfx-core/core/ta-math/draw.js
  var require_draw = __commonJS({
    "node_modules/jsgui3-gfx-core/core/ta-math/draw.js"(exports, module) {
      var is_integer_typed_array = (obj2) => {
        if (ArrayBuffer.isView(obj2)) {
          return obj2 instanceof Int8Array || obj2 instanceof Uint8Array || obj2 instanceof Int16Array || obj2 instanceof Uint16Array || obj2 instanceof Int32Array || obj2 instanceof Uint32Array || obj2 instanceof BigInt64Array || obj2 instanceof BigUint64Array;
        }
        return false;
      };
      var ensure_polygon_is_ta = (polygon) => {
        if (is_integer_typed_array(polygon)) {
          if (polygon.length % 2 === 0) {
            return polygon;
          } else {
            throw "ta must have even number length, being [x, y] pairs";
          }
        } else {
          return new Uint32Array(polygon.flat());
        }
      };
      var draw_polygon_outline_to_ta_1bipp = (ta2, img_width, polygon) => {
        polygon = ensure_polygon_is_ta(polygon);
        const num_points = polygon.length >>> 1;
        let r = 0, x = polygon[r++], y = polygon[r++], next_x, next_y;
        let dx, dy, sx, sy, err, e2;
        const set_pixel_on = (x2, y2) => {
          const idx_bit = y2 * img_width + x2;
          const byte = idx_bit >> 3;
          const bit = idx_bit & 7;
          ta2[byte] |= 128 >> bit;
        };
        for (let p = 1; p < num_points; p++) {
          next_x = polygon[r++];
          next_y = polygon[r++];
          dx = Math.abs(next_x - x);
          dy = Math.abs(next_y - y);
          sx = x < next_x ? 1 : -1;
          sy = y < next_y ? 1 : -1;
          err = dx - dy;
          while (true) {
            set_pixel_on(x, y);
            if (x === next_x && y === next_y) {
              break;
            }
            e2 = 2 * err;
            if (e2 > -dy) {
              err -= dy;
              x += sx;
            }
            if (e2 < dx) {
              err += dx;
              y += sy;
            }
          }
          x = next_x;
          y = next_y;
        }
        next_x = polygon[0];
        next_y = polygon[1];
        dx = Math.abs(next_x - x);
        dy = Math.abs(next_y - y);
        sx = x < next_x ? 1 : -1;
        sy = y < next_y ? 1 : -1;
        err = dx - dy;
        while (true) {
          set_pixel_on(x, y);
          if (x === next_x && y === next_y) {
            break;
          }
          e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x += sx;
          }
          if (e2 < dx) {
            err += dx;
            y += sy;
          }
        }
        return ta2;
      };
      var remove_duplicates = (ta2) => {
        quicksort_points(ta2);
        const numRecords = ta2.length >>> 1;
        let uniqueCount = 0;
        let prev_x, prev_y;
        for (let i = 0; i < numRecords; i++) {
          const x = ta2[i * 2];
          const y = ta2[i * 2 + 1];
          if (i === 0 || x !== prev_x || y !== prev_y) {
            uniqueCount++;
            prev_x = x;
            prev_y = y;
          }
        }
        const result = new ta2.constructor(uniqueCount * 2);
        let index = 0;
        prev_x = prev_y = void 0;
        for (let i = 0; i < numRecords; i++) {
          const x = ta2[i * 2];
          const y = ta2[i * 2 + 1];
          if (i === 0 || x !== prev_x || y !== prev_y) {
            result[index * 2] = x;
            result[index * 2 + 1] = y;
            index++;
            prev_x = x;
            prev_y = y;
          }
        }
        return result;
      };
      var quicksort_points = (ta2) => {
        const partition = (left, right, pivotIndex) => {
          const pivotY = ta2[pivotIndex * 2 + 1];
          const pivotX = ta2[pivotIndex * 2];
          swap(pivotIndex, right);
          let storeIndex = left;
          for (let i = left; i < right; i++) {
            const currentY = ta2[i * 2 + 1];
            const currentX = ta2[i * 2];
            if (currentY < pivotY || currentY === pivotY && currentX < pivotX) {
              swap(i, storeIndex);
              storeIndex++;
            }
          }
          swap(storeIndex, right);
          return storeIndex;
        };
        const quicksort_recursive = (left, right) => {
          if (left < right) {
            const pivotIndex = Math.floor((left + right) / 2);
            const newPivot = partition(left, right, pivotIndex);
            quicksort_recursive(left, newPivot - 1);
            quicksort_recursive(newPivot + 1, right);
          }
        };
        const swap = (i, j) => {
          if (i === j) return;
          const tempX = ta2[i * 2];
          ta2[i * 2] = ta2[j * 2];
          ta2[j * 2] = tempX;
          const tempY = ta2[i * 2 + 1];
          ta2[i * 2 + 1] = ta2[j * 2 + 1];
          ta2[j * 2 + 1] = tempY;
        };
        const numRecords = ta2.length >>> 1;
        quicksort_recursive(0, numRecords - 1);
        return ta2;
      };
      var calc_polygon_stroke_points_x_y = (polygon) => {
        polygon = ensure_polygon_is_ta(polygon);
        const arr_stroke_points = [];
        const num_points = polygon.length >>> 1;
        let r = 0, x = polygon[r++], y = polygon[r++], next_x, next_y;
        let dx, dy, sx, sy, err, e2;
        let prev_x, prev_y;
        const set_pixel_on = (x2, y2) => {
          if (!(prev_x === x2 && prev_y === y2)) {
            arr_stroke_points.push(x2, y2);
          }
          prev_x = x2;
          prev_y = y2;
        };
        for (let p = 1; p < num_points; p++) {
          next_x = polygon[r++];
          next_y = polygon[r++];
          dx = Math.abs(next_x - x);
          dy = Math.abs(next_y - y);
          sx = x < next_x ? 1 : -1;
          sy = y < next_y ? 1 : -1;
          err = dx - dy;
          while (true) {
            set_pixel_on(x, y);
            if (x === next_x && y === next_y) {
              break;
            }
            e2 = 2 * err;
            if (e2 > -dy) {
              err -= dy;
              x += sx;
            }
            if (e2 < dx) {
              err += dx;
              y += sy;
            }
          }
          x = next_x;
          y = next_y;
        }
        next_x = polygon[0];
        next_y = polygon[1];
        dx = Math.abs(next_x - x);
        dy = Math.abs(next_y - y);
        sx = x < next_x ? 1 : -1;
        sy = y < next_y ? 1 : -1;
        err = dx - dy;
        while (true) {
          set_pixel_on(x, y);
          if (x === next_x && y === next_y) {
            break;
          }
          e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x += sx;
          }
          if (e2 < dx) {
            err += dx;
            y += sy;
          }
        }
        const res2 = remove_duplicates(quicksort_points(new Uint16Array(arr_stroke_points)));
        return res2;
      };
      module.exports = {
        ensure_polygon_is_ta,
        draw_polygon_outline_to_ta_1bipp,
        calc_polygon_stroke_points_x_y
      };
    }
  });

  // node_modules/jsgui3-gfx-core/core/ta-math.js
  var require_ta_math = __commonJS({
    "node_modules/jsgui3-gfx-core/core/ta-math.js"(exports, module) {
      var copy = require_copy();
      var info = require_info();
      var read = require_read();
      var transform = require_transform();
      var write = require_write();
      var bitwise = require_bitwise();
      var {
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        get_bit,
        fast_find_next_set_ta_bit
      } = bitwise;
      var draw = require_draw();
      var { draw_polygon_outline_to_ta_1bipp, ensure_polygon_is_ta, calc_polygon_stroke_points_x_y } = draw;
      var {
        copy_rect_to_same_size_8bipp,
        copy_rect_to_same_size_24bipp,
        copy_ta_byte_range,
        unaligned_copy_rect_1to4bypp,
        dest_aligned_copy_rect_1to4bypp
      } = copy;
      var { overlapping_bounds } = info;
      var { fill_solid_rect_by_bounds } = write;
      var { read_1x2_rect, read_2x1_rect, read_2x2_rect, read_px } = read;
      var { resize_ta_colorspace } = transform;
      module.exports = {
        draw_polygon_outline_to_ta_1bipp,
        ensure_polygon_is_ta,
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        calc_polygon_stroke_points_x_y,
        get_bit,
        fast_find_next_set_ta_bit,
        draw,
        copy,
        info,
        read,
        transform,
        write,
        bitwise,
        overlapping_bounds,
        copy_rect_to_same_size_8bipp,
        copy_rect_to_same_size_24bipp,
        copy_ta_byte_range,
        unaligned_copy_rect_1to4bypp,
        dest_aligned_copy_rect_1to4bypp,
        fill_solid_rect_by_bounds,
        read_1x2_rect,
        read_2x1_rect,
        read_2x2_rect,
        read_px,
        read_pixel: read_px,
        resize_ta_colorspace
        //,
        //override: override,
        //get_instance: get_instance
      };
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-painter.js
  var require_pixel_buffer_painter = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-painter.js"(exports, module) {
      var ta_math2 = require_ta_math();
      var { fill_solid_rect_by_bounds } = ta_math2;
      var Pixel_Buffer_Painter = class {
        constructor(spec) {
          const pb = this.pb = spec.pb || spec.pixel_buffer;
          this.rect = (pos, size, color) => {
            const ta_bounds = new Int16Array(4);
            ta_bounds[0] = pos[0];
            ta_bounds[1] = pos[1];
            ta_bounds[2] = pos[0] + size[0];
            ta_bounds[3] = pos[1] + size[1];
            fill_solid_rect_by_bounds(pb.ta, pb.bypr, ta_bounds, pb.bipp, color);
            return this;
          };
        }
        //rect()
      };
      module.exports = Pixel_Buffer_Painter;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-0-core-inner-structures.js
  var require_pixel_buffer_0_core_inner_structures = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-0-core-inner-structures.js"(exports, module) {
      var lang = require_lib_lang_mini3();
      var {
        each,
        fp,
        tof,
        get_a_sig: get_a_sig2,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~0n;
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Inner_Structures = class _Pixel_Buffer_Core_Inner_Structures {
        constructor(spec) {
          if (spec instanceof _Pixel_Buffer_Core_Inner_Structures) {
            spec = {
              bits_per_pixel: spec.bits_per_pixel,
              size: spec.size,
              ta: spec.ta
            };
          }
          if (spec.window_to) {
            spec.bits_per_pixel = spec.window_to.bits_per_pixel;
          }
          const pos = new Int16Array(2);
          const size = new Int16Array(2);
          let ta2;
          ro(this, "ta", () => {
            return ta2;
          });
          ro(this, "buffer", () => {
            return ta2;
          });
          const ta_bpp = new Uint8Array(2);
          ta_bpp[1] = 8;
          const _24bipp_to_8bipp = () => {
            const old_ta = ta2;
            const new_ta = ta2 = new Uint8Array(this.num_px);
            const l_read = old_ta.length;
            let iby_read = 0, iby_write = 0;
            while (iby_read < l_read) {
              new_ta[iby_write++] = Math.round((old_ta[iby_read++] + old_ta[iby_read++] + old_ta[iby_read++]) / 3);
            }
          };
          const _change_bipp_inner_update = (old_bipp, new_bipp) => {
            if (old_bipp === 24) {
              if (new_bipp === 8) {
                _24bipp_to_8bipp();
              } else {
                console.trace();
                throw "NYI";
              }
            } else {
              console.trace();
              throw "NYI";
            }
          };
          const def_bipp = {
            get() {
              return ta_bpp[0];
            },
            set(value2) {
              console.log("value", value2);
              const old_bipp = ta_bpp[0];
              ta_bpp[0] = value2;
              _change_bipp_inner_update(old_bipp, ta_bpp[0]);
            },
            enumerable: true,
            configurable: false
          };
          Object.defineProperty(this, "bits_per_pixel", def_bipp);
          Object.defineProperty(this, "bipp", def_bipp);
          const def_bypp = {
            get() {
              return ta_bpp[0] / 8;
            },
            set(value2) {
              const old_bipp = ta_bpp[0];
              ta_bpp[0] = value2 * 8;
              _change_bipp_inner_update(old_bipp, ta_bpp[0]);
            },
            enumerable: true,
            configurable: false
          };
          Object.defineProperty(this, "bytes_per_pixel", def_bypp);
          Object.defineProperty(this, "bypp", def_bypp);
          const def_bypr = {
            get() {
              return size[0] * ta_bpp[0] / 8;
            }
          };
          Object.defineProperty(this, "bytes_per_row", def_bypr);
          Object.defineProperty(this, "bypr", def_bypr);
          Object.defineProperty(this, "pos", {
            get() {
              return pos;
            },
            set(value2) {
              if (value2 instanceof Int16Array) {
                if (value2.length === 2) {
                  pos[0] = value2[0];
                  pos[1] = value2[1];
                }
              }
            },
            enumerable: true,
            configurable: false
          });
          const pos_bounds2 = new Int16Array(4);
          const pos_center = new Int16Array(2);
          const edge_offsets_from_center = new Int16Array(4);
          ro(this, "pos_center", () => pos_center);
          ro(this, "edge_offsets_from_center", () => edge_offsets_from_center);
          Object.defineProperty(this, "pos_bounds", {
            get() {
              return pos_bounds2;
            },
            set(value2) {
              const tv = tf2(value2);
              if (tv === "a") {
                if (value2.length === 4) {
                  pos_bounds2.set(value2);
                } else {
                  throw "Expected Array with .length 4, value.length: " + value2.length;
                }
              } else {
                console.trace();
                console.log("pos_bounds set tv", tv);
                throw "Expected Array";
              }
            },
            enumerable: true,
            configurable: false
          });
          const minus_pos = new Int16Array(2);
          Object.defineProperty(this, "minus_pos", {
            get() {
              if (pos) {
                minus_pos[0] = pos[0] * -1;
                minus_pos[1] = pos[1] * -1;
                return minus_pos;
              }
            },
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(this, "size", {
            get() {
              return size;
            },
            set(value2) {
              if (value2 instanceof Int16Array) {
                if (value2.length === 2) {
                  size[0] = value2[0];
                  size[1] = value2[1];
                }
              } else {
                console.trace();
                throw "NYI";
              }
            },
            enumerable: true,
            configurable: false
          });
          if (spec instanceof Pixel_Pos_List) {
            throw "NYI - change to 1bipp";
            const ppl = spec;
            const bounds2 = ppl.bounds;
            const ppl_size = new Uint16Array(2);
            ppl_size[0] = bounds2[2] - bounds2[0];
            ppl_size[1] = bounds2[3] - bounds2[1];
            this.bits_per_pixel = 8;
            const bpp = this.bytes_per_pixel = 1;
            this.size = new Uint16Array([ppl_size[0] + 4, ppl_size[1] + 4]);
            this.pos = new Int16Array([bounds2[0], bounds2[1]]);
            const bpr = this.bytes_per_row = bpp * this.size[0];
            const buf = this.ta = this.buffer = new Uint8ClampedArray(this.size[0] * this.size[1]);
            const l2 = buf.length;
            for (var c2 = 0; c2 < l2; c2++) buf[c2] = 255;
            ppl.each_pixel((pixel_pos) => {
              buf[bpr * (pixel_pos[1] - bounds2[1]) + (pixel_pos[0] - bounds2[0])] = 0;
            });
          } else {
            if (spec.buffer) {
              if (spec.buffer instanceof Buffer) {
                ta2 = new Uint8ClampedArray(spec.buffer.buffer);
              } else {
                ta2 = spec.buffer;
              }
            }
            if (spec.ta) {
              ta2 = spec.ta;
            }
            if (spec.size) {
              size[0] = spec.size[0];
              size[1] = spec.size[1];
            } else {
              throw "Expected: size [x, y] property in the Pixel_Buffer_Core specification";
            }
            if (spec.bytes_per_pixel && !spec.bits_per_pixel) spec.bits_per_pixel = spec.bytes_per_pixel * 8;
            spec.bits_per_pixel = spec.bits_per_pixel || 32;
            if (spec.bits_per_pixel) {
              if (spec.bits_per_pixel != 1 && spec.bits_per_pixel != 8 && spec.bits_per_pixel != 24 && spec.bits_per_pixel != 32) {
                console.log("spec.bits_per_pixel", spec.bits_per_pixel);
                console.trace();
                throw "Invalid bits_per_pixel value of " + spec.bits_per_pixel + ", must be 8, 24 or 32, default is 32.";
              } else {
                ta_bpp[0] = spec.bits_per_pixel;
              }
            }
            let auto_adjust_ta_length_to_multiple_of_8 = true;
            if (size && !this.buffer) {
              this.bits_per_row = size[0] * this.bits_per_pixel;
              let proposed_ta_length = Math.ceil(ta_bpp[0] / 8 * (size[0] * size[1]));
              if (auto_adjust_ta_length_to_multiple_of_8) {
                const r8 = proposed_ta_length % 8;
                if (r8 > 0) {
                  proposed_ta_length += 8 - r8;
                }
              }
              ta2 = new Uint8Array(proposed_ta_length);
            }
            if (spec.color) {
              this.color_whole(spec.color);
            }
          }
          ro(this, "meta", () => {
            return {
              size: this.size,
              bits_per_pixel: this.bits_per_pixel,
              bytes_per_pixel: this.bytes_per_pixel,
              bytes_per_row: this.bytes_per_row
            };
          });
          if (spec.window_to || spec.source || spec.window_to_source) {
            pb_source = spec.window_to || spec.source || spec.window_to_source;
            const log_info = () => {
              console.log("Pixel_Buffer_Core (or subclass) needs to act as a window to another Pixel Buffer.");
              console.log("pb_source", pb_source);
              console.log("pb_source.size", pb_source.size);
              console.log("spec.pos", spec.pos);
              console.log("spec.pos_center", spec.pos_center);
              console.log("this.pos", this.pos);
              console.log("this.pos_my_center_within_source", this.pos_my_center_within_source);
              console.log("spec", spec);
            };
          }
          if (spec.pos_bounds) {
            this.pos_bounds = spec.pos_bounds;
          }
          this.move = (ta_2d_vector) => {
            pos[0] += ta_2d_vector[0];
            pos[1] += ta_2d_vector[1];
            if (this.source) {
              this.copy_from_source();
            }
          };
          this.each_pos_within_bounds = (callback2) => {
            const has_source = !!this.source;
            for (pos[1] = pos_bounds2[1]; pos[1] < pos_bounds2[3]; pos[1]++) {
              for (pos[0] = pos_bounds2[0]; pos[0] < pos_bounds2[2]; pos[0]++) {
                if (has_source) this.copy_from_source();
                callback2();
              }
            }
          };
          this.move_next_px = () => {
            const source_size = this.source.size;
            if (pos[0] + size[0] < source_size[0]) {
              pos[0]++;
            } else {
              if (pos[1] + size[1] < source_size[1]) {
                pos[0] = 0;
                pos[1]++;
              } else {
                return false;
              }
            }
            if (this.source) {
              this.copy_from_source();
            }
            return pos;
          };
          this.tabrw = new Typed_Array_Binary_Read_Write(ta2);
          this.dv = this.tabrw.dv;
        }
        toString() {
          return JSON.stringify({
            buffer: "Uint8ClampedArray length " + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
          });
        }
        /*
        [inspect]() {
            return 'Pixel_Buffer_Core ' + this.toString();
        }
        */
        each_pixel_byte_index(cb) {
          const { bipp } = this;
          let ctu = true;
          const stop = () => ctu = false;
          const [w, h] = this.size;
          const num_pixels = w * h;
          let bit_idx = 0, byte_idx = bit_idx >> 3;
          for (let c2 = 0; c2 < num_pixels; c2++) {
            byte_idx = bit_idx >> 3;
            bc(byte_idx);
          }
        }
        each_px(callback2) {
          const ta_pos = new Int32Array(2);
          const [w, h] = this.size;
          let index = 0;
          for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
              const color = this.get_pixel(ta_pos);
              callback2(ta_pos, color, index++);
            }
          }
        }
        paint_pixel_list(pixel_pos_list, color) {
          pixel_pos_list.each_pixel((pos) => {
            this.set_pixel_ta(pos, color);
          });
        }
        // Maybe a class level that has get and set pixel logic for the different bipps at this level.
        get num_px() {
          return this.size[0] * this.size[1];
        }
        get split_rgb_channels() {
          const [bipp, bypp2] = [this.bits_per_pixel, this.bytes_per_pixel];
          if (bipp === 24 || bipp === 32) {
            const res2 = [new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            })];
            const [r, g, b] = res2;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta2 = this.ta;
            while (i_px < num_px) {
              ta_r[i_px] = ta2[i_byte];
              ta_g[i_px] = ta2[i_byte + 1];
              ta_b[i_px] = ta2[i_byte + 2];
              i_px++;
              i_byte += bypp2;
            }
            return res2;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        process(fn) {
          let res2 = this.clone();
          return fn(this, res2);
        }
        /*
            function typedArraysAreEqual(a, b) {
        if (a.byteLength !== b.byteLength) return false;
        return a.every((val, i) => val === b[i]);
        }
            */
        equals(other_pixel_buffer) {
          let buf1 = this.ta;
          let buf2 = other_pixel_buffer.ta;
          const other_colorspace = other_pixel_buffer.ta_colorspace;
          const my_colorspace = other_pixel_buffer.ta_colorspace;
          if (my_colorspace.length === other_colorspace.length) {
            if (my_colorspace.every((val, i) => val === other_colorspace[i])) {
              if (buf1.length === buf2.length) {
                return buf1.every((val, i) => val === buf2[i]);
              } else {
              }
            } else {
            }
          }
          return false;
        }
        copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
          let bounds2 = pixel_pos_list.bounds;
          let size = new Uint16Array([bounds2[2] - bounds2[0] + 1, bounds2[3] - bounds2[1] + 1]);
          const res2 = new this.constructor({
            size,
            bytes_per_pixel: this.bytes_per_pixel
          });
          if (this.pos) res2.pos = this.pos;
          if (bg_color) {
            res2.color_whole(bg_color);
          }
          res2.pos = new Int16Array([bounds2[0], bounds2[1]]);
          pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([pos[0] - bounds2[0], pos[1] - bounds2[1]]);
            res2.set_pixel_ta(target_pos, color);
          });
          return res2;
        }
        "blank_copy"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel
          });
          res2.buffer.fill(0);
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "clone"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel,
            "buffer": new this.buffer.constructor(this.buffer)
          });
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "add_alpha_channel"() {
          console.log("add_alpha_channel this.bytes_per_pixel", this.bytes_per_pixel);
          if (this.bytes_per_pixel === 3) {
            var res2 = new this.constructor({
              "size": this.size,
              "bytes_per_pixel": 4
            });
            if (this.pos) res2.pos = this.pos;
            const buf = this.buffer, res_buf = res2.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0, ir = 0;
            for (let p = 0; p < px_count; p++) {
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = 255;
            }
            return res2;
          }
          if (this.bytes_per_pixel === 4) {
            return this;
          }
        }
      };
      module.exports = Pixel_Buffer_Core_Inner_Structures;
      if (__require.main === module) {
        const lg = console.log;
        (async () => {
          const run_examples = async () => {
            lg("Begin run examples");
            const examples = [
              async () => {
                lg("Begin example 0");
                const pb = new Pixel_Buffer_Core_Reference_Implementations({
                  bits_per_pixel: 1,
                  size: [8, 8]
                });
                const ta_pos = new Int16Array(2);
                ta_pos[0] = 3;
                ta_pos[1] = 3;
                pb.set_pixel(ta_pos, 1);
                lg("End example 0");
                return pb;
              }
            ];
            const l2 = examples.length;
            for (var c2 = 0; c2 < l2; c2++) {
              const res_eg = await examples[c2]();
              console.log("res_eg " + c2 + ":", res_eg);
            }
            ;
            lg("End run examples");
          };
          await run_examples();
        })();
      }
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-1-core-get-set-pixel.js
  var require_pixel_buffer_1_core_get_set_pixel = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-1-core-get-set-pixel.js"(exports, module) {
      var lang = require_lib_lang_mini3();
      var {
        each,
        fp,
        tof,
        get_a_sig: get_a_sig2,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~0n;
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var Pixel_Buffer_Painter = require_pixel_buffer_painter();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Inner_Structures = require_pixel_buffer_0_core_inner_structures();
      var Pixel_Buffer_Core_Get_Set_Pixels = class _Pixel_Buffer_Core_Get_Set_Pixels extends Pixel_Buffer_Core_Inner_Structures {
        constructor(spec) {
          if (spec instanceof _Pixel_Buffer_Core_Get_Set_Pixels) {
            spec = {
              bits_per_pixel: spec.bits_per_pixel,
              size: spec.size,
              ta: spec.ta
            };
          }
          super(spec);
        }
        "get_pixel_byte_bit_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          const bit = idx & 7;
          return { byte, bit };
        }
        "get_pixel_byte_bit_BE_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          const bit = idx & 7;
          return { byte, bit };
        }
        set_pixel_on_1bipp_by_pixel_index(pixel_index) {
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        "set_pixel_on_1bipp_xy"(x, y) {
          const pixel_index = y * this.size[0] + x;
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        "set_pixel_on_1bipp"(pos) {
          const pixel_index = pos[1] * this.size[0] + pos[0];
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        set_pixel_off_1bipp_by_pixel_index(pixel_index) {
          this.ta[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
        }
        "set_pixel_off_1bipp"(pos) {
          const pixel_idx = pos[1] * this.size[0] + pos[0];
          this.ta[pixel_idx >> 3] &= ~(128 >> (pixel_idx & 7)) & 255;
        }
        "set_pixel_1bipp"(pos, color) {
          const idx_bit = pos[1] * this.size[0] + pos[0];
          const byte = idx_bit >> 3;
          const bit = idx_bit & 7;
          if (color === 1) {
            this.ta[byte] |= 128 >> bit;
          } else {
            this.ta[byte] &= ~(128 >> bit) & 255;
          }
        }
        "set_pixel_8bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          this.ta[idx] = color;
        }
        "set_pixel_24bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          let byte = idx * 3;
          this.ta[byte++] = color[0];
          this.ta[byte++] = color[1];
          this.ta[byte] = color[2];
        }
        "set_pixel_32bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          let byte = idx * 4;
          this.ta[byte++] = color[0];
          this.ta[byte++] = color[1];
          this.ta[byte++] = color[2];
          this.ta[byte] = color[3];
        }
        "set_pixel_by_idx_8bipp"(idx, color) {
          const byte = idx;
          this.ta[byte] = color;
        }
        "set_pixel_by_idx_24bipp"(idx, color) {
          const byte = idx * 3;
          this.ta[byte] = color[0];
          this.ta[byte + 1] = color[1];
          this.ta[byte + 2] = color[2];
        }
        "set_pixel_by_idx_32bipp"(idx, color) {
          const byte = idx * 4;
          this.ta[byte] = color[0];
          this.ta[byte + 1] = color[1];
          this.ta[byte + 2] = color[2];
          this.ta[byte + 3] = color[3];
        }
        "set_pixel_by_idx"(idx, color) {
          const a = arguments;
          const l2 = a.length;
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.set_pixel_by_idx_1bipp(a[0], a[1]);
          } else if (bipp === 8) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_8bipp(a[0], a[1]);
            }
          } else if (bipp === 24) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_24bipp(a[0], a[1]);
            }
          } else if (bipp === 32) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_32bipp(a[0], a[1]);
            }
          }
        }
        "set_pixel"(pos, color) {
          const a = arguments;
          const l2 = a.length;
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.set_pixel_1bipp(a[0], a[1]);
          } else if (bipp === 8) {
            if (l2 === 2) {
              return this.set_pixel_8bipp(a[0], a[1]);
            }
          } else if (bipp === 24) {
            if (l2 === 2) {
              return this.set_pixel_24bipp(a[0], a[1]);
            }
          } else if (bipp === 32) {
            if (l2 === 2) {
              return this.set_pixel_32bipp(a[0], a[1]);
            }
          } else {
            console.trace();
            throw "unsupported bipp: " + bipp;
          }
        }
        "get_pixel_by_idx_1bipp"(idx) {
          const byte = idx >> 3;
          const bit = idx & 7;
          const pow = 128 >> bit;
          return (this.ta[byte] & pow) === pow ? 1 : 0;
        }
        "get_pixel_by_idx_8bipp"(idx) {
          const byte = idx;
          return this.ta[byte];
        }
        "get_pixel_by_idx_24bipp"(idx) {
          const byte = idx * 3;
          return this.ta.slice(byte, byte + 3);
        }
        "get_pixel_by_idx_32bipp"(idx) {
          const byte = idx * 4;
          return this.ta.slice(byte, byte + 4);
        }
        "get_pixel_by_idx"(idx) {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            return this.get_pixel_by_idx_1bipp(idx);
          } else if (bipp === 8) {
            return this.get_pixel_by_idx_8bipp(idx);
          } else if (bipp === 24) {
            return this.get_pixel_by_idx_24bipp(idx);
          } else if (bipp === 32) {
            return this.get_pixel_by_idx_32bipp(idx);
          } else {
            throw "Unsupported bipp";
          }
        }
        "get_pixel_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          return (this.ta[byte] & 128 >> (idx & 7)) !== 0 ? 1 : 0;
        }
        "get_pixel_8bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx;
          return this.ta[byte];
        }
        "get_pixel_24bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx * 3;
          return this.ta.slice(byte, byte + 3);
        }
        "get_pixel_32bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx * 4;
          return this.ta.slice(byte, byte + 4);
        }
        "get_pixel"(pos) {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            return this.get_pixel_1bipp(pos);
          } else if (bipp === 8) {
            return this.get_pixel_8bipp(pos);
          } else if (bipp === 24) {
            return this.get_pixel_24bipp(pos);
          } else if (bipp === 32) {
            return this.get_pixel_32bipp(pos);
          } else {
            console.trace();
            throw "bits per pixels error";
          }
        }
        // Maybe a class level that has get and set pixel logic for the different bipps at this level.
      };
      module.exports = Pixel_Buffer_Core_Get_Set_Pixels;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-1.1-core-draw-line.js
  var require_pixel_buffer_1_1_core_draw_line = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-1.1-core-draw-line.js"(exports, module) {
      var lang = require_lib_lang_mini3();
      var {
        each,
        fp,
        tof,
        get_a_sig: get_a_sig2,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~0n;
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var Pixel_Buffer_Painter = require_pixel_buffer_painter();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Get_Set_Pixels = require_pixel_buffer_1_core_get_set_pixel();
      var Pixel_Buffer_Core_Draw_Lines = class extends Pixel_Buffer_Core_Get_Set_Pixels {
        constructor(spec) {
          super(spec);
        }
        "draw_line"(pos1, pos2, color) {
          if (this.bits_per_pixel === 1) {
            let x0 = pos1[0];
            let y0 = pos1[1];
            let x1 = pos2[0];
            let y1 = pos2[1];
            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
            let sx = x0 < x1 ? 1 : -1;
            let sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            while (true) {
              this.set_pixel_1bipp([x0, y0], color);
              if (x0 === x1 && y0 === y1) {
                break;
              }
              let e2 = 2 * err;
              if (e2 > -dy) {
                err -= dy;
                x0 += sx;
              }
              if (e2 < dx) {
                err += dx;
                y0 += sy;
              }
            }
          } else {
            let x0 = pos1[0];
            let y0 = pos1[1];
            let x1 = pos2[0];
            let y1 = pos2[1];
            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
            let sx = x0 < x1 ? 1 : -1;
            let sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            while (true) {
              this.set_pixel([x0, y0], color);
              if (x0 === x1 && y0 === y1) {
                break;
              }
              let e2 = 2 * err;
              if (e2 > -dy) {
                err -= dy;
                x0 += sx;
              }
              if (e2 < dx) {
                err += dx;
                y0 += sy;
              }
            }
          }
        }
        draw_line_1bipp(ta_pixel_pair, color) {
          const { ta: ta2 } = this;
          let [x0, y0, x1, y1] = ta_pixel_pair, bytes_per_row = this.bytes_per_row, dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0), sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1, err = dx - dy, e2;
          while (true) {
            const byte_index = (x0 >> 3) + y0 * bytes_per_row, bit_position = x0 & 7;
            if (color) {
              ta2[byte_index] |= 1 << 7 - bit_position;
            } else {
              ta2[byte_index] &= ~(1 << 7 - bit_position);
            }
            if (x0 === x1 && y0 === y1) break;
            e2 = err << 1;
            if (e2 > -dy) err -= dy, x0 += sx;
            if (e2 < dx) err += dx, y0 += sy;
          }
        }
        "draw_horizontal_line_off_1bipp_inclusive"([x1, x2], y) {
          const { size, ta: ta2 } = this;
          const number_of_pixels_to_draw = x2 - x1 + 1;
          if (number_of_pixels_to_draw === 1) {
            const pixel_index = y * size[0] + x1;
            ta2[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
          } else if (number_of_pixels_to_draw === 2) {
            let pixel_index = y * size[0] + x1;
            ta2[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
            pixel_index++;
            ta2[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
            pixel_index++;
          } else {
            const [w] = size;
            const starting_pixel_index = y * w + x1 | 0;
            const ending_pixel_index = starting_pixel_index + (number_of_pixels_to_draw - 1);
            const starting_byte_index = starting_pixel_index >> 3;
            const starting_bit_within_byte_index = starting_pixel_index & 7;
            const ending_byte_index = ending_pixel_index >> 3;
            const ending_bit_within_byte_index = ending_pixel_index & 7;
            const bits_from_end_of_byte = 7 - ending_bit_within_byte_index;
            const number_of_bytes_with_any_coverage = ending_byte_index - starting_byte_index + 1;
            if (starting_byte_index === ending_byte_index) {
              ta2[starting_byte_index] &= ~((255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index >> bits_from_end_of_byte << bits_from_end_of_byte) & 255;
            } else if (number_of_bytes_with_any_coverage === 2) {
              ta2[starting_byte_index] &= ~((255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index) & 255;
              ta2[ending_byte_index] &= ~(255 >> bits_from_end_of_byte << bits_from_end_of_byte) & 255;
            } else {
              ta2[starting_byte_index] &= ~((255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index) & 255;
              for (let x = starting_byte_index + 1; x < ending_byte_index; x++) {
                ta2[x] = 0;
              }
              ta2[ending_byte_index] &= ~(255 >> bits_from_end_of_byte << bits_from_end_of_byte) & 255;
            }
          }
        }
        draw_x_span_on_1bipp(x, y, l2) {
          const x2 = x + l2;
          for (let ix = x; ix < x2; ix++) {
            this.set_pixel_on_1bipp_xy(ix, y);
          }
        }
        // May do more lower level / general purpose work on line drawing....
        "draw_horizontal_line_on_1bipp_inclusive"([x1, x2], y) {
          const { size, ta: ta2 } = this;
          const number_of_pixels_to_draw = x2 - x1 + 1;
          if (number_of_pixels_to_draw === 1) {
            const pixel_index = y * size[0] + x1;
            ta2[pixel_index >> 3] |= 128 >> (pixel_index & 7);
          } else if (number_of_pixels_to_draw === 2) {
            let pixel_index = y * size[0] + x1;
            ta2[pixel_index >> 3] |= 128 >> (pixel_index & 7);
            pixel_index++;
            ta2[pixel_index >> 3] |= 128 >> (pixel_index & 7);
            pixel_index++;
          } else {
            const [w, h] = size;
            const starting_pixel_index = y * w + x1 | 0;
            const ending_pixel_index = starting_pixel_index + (number_of_pixels_to_draw - 1);
            const starting_byte_index = starting_pixel_index >> 3;
            const starting_bit_within_byte_index = starting_pixel_index & 7;
            const ending_byte_index = ending_pixel_index >> 3;
            const ending_bit_within_byte_index = ending_pixel_index & 7;
            const bits_from_end_of_byte = 7 - ending_bit_within_byte_index;
            if (starting_byte_index === ending_byte_index) {
              ta2[starting_byte_index] |= (255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index >> bits_from_end_of_byte << bits_from_end_of_byte;
            } else {
              ta2[starting_byte_index] |= (255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index;
              for (let x = starting_byte_index + 1; x < ending_byte_index; x++) {
                ta2[x] = 255;
              }
              ta2[ending_byte_index] |= 255 >> bits_from_end_of_byte << bits_from_end_of_byte;
            }
          }
        }
        "draw_horizontal_line_8bipp"(xspan, y, color) {
          const [x1, x2] = xspan;
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          let w = start_pixel_idx;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = color;
          }
        }
        "draw_horizontal_line_24bipp"(xspan, y, color) {
          const [x1, x2] = xspan;
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          const [r, g, b] = color;
          let w = start_pixel_idx * 3;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
          }
        }
        "draw_horizontal_line_32bipp"(xspan, y, color) {
          const [x1, x2] = xspan;
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          const [r, g, b, a] = color;
          let w = start_pixel_idx * 4;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
            ta2[w++] = a;
          }
        }
        "draw_horizontal_line"(xspan, y, color) {
          const { bipp } = this;
          if (bipp === 1) {
            if (color === 1) {
              return this.draw_horizontal_line_on_1bipp_inclusive(xspan, y);
            } else {
              return this.draw_horizontal_line_off_1bipp_inclusive(xspan, y);
            }
          } else if (bipp === 8) {
            return this.draw_horizontal_line_8bipp(xspan, y, color);
          } else if (bipp === 24) {
            return this.draw_horizontal_line_24bipp(xspan, y, color);
          } else if (bipp === 32) {
            return this.draw_horizontal_line_32bipp(xspan, y, color);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        "draw_horizontal_line_y_x1_x2"(y, x1, x2, color, pre_populated_array, populate_array) {
          const { bipp } = this;
          if (bipp === 1) {
            if (color === 1) {
              return this.draw_horizontal_line_on_1bipp_inclusive_y_x1_x2(y, x1, x2);
            } else {
              return this.draw_horizontal_line_off_1bipp_inclusive_y_x1_x2(y, x1, x2);
            }
          } else if (bipp === 8) {
            return this.draw_horizontal_line_8bipp_y_x1_x2(y, x1, x2, color);
          } else if (bipp === 24) {
            return this.draw_horizontal_line_24bipp_y_x1_x2(y, x1, x2, color, pre_populated_array, populate_array);
          } else if (bipp === 32) {
            return this.draw_horizontal_line_32bipp_y_x1_x2(y, x1, x2, color);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        "draw_horizontal_line_8bipp_y_x1_x2"(y, x1, x2, color) {
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          let w = start_pixel_idx;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = color;
          }
        }
        "_draw_horizontal_line_24bipp_y_x1_x2"(y, x1, x2, color) {
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          const [r, g, b] = color;
          let w = start_pixel_idx * 3;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
          }
        }
        "draw_horizontal_line_24bipp_y_x1_x2"(y, x1, x2, color, pre_populated_array = null, populate_array = true) {
          const { ta: ta2 } = this;
          const [width, height2] = this.size;
          if (y < 0 || y >= height2 || x1 < 0 || x2 >= width || x1 > x2) {
            throw new Error("Coordinates out of bounds");
          }
          const start_pixel_idx = width * y + x1;
          const [r, g, b] = color;
          const pixel_count = x2 - x1 + 1;
          if (pixel_count < 8) {
            let w2 = start_pixel_idx * 3;
            for (let x = x1; x <= x2; x++) {
              ta2[w2++] = r;
              ta2[w2++] = g;
              ta2[w2++] = b;
            }
            return;
          }
          if (!pre_populated_array) {
            pre_populated_array = new Uint8Array(96 * 3);
          }
          if (populate_array) {
            for (let i = 0; i < pre_populated_array.length; i += 3) {
              pre_populated_array[i] = r;
              pre_populated_array[i + 1] = g;
              pre_populated_array[i + 2] = b;
            }
          }
          let w = start_pixel_idx * 3;
          const ppal = pre_populated_array.length;
          const chunk_size = ppal / 3;
          let remaining_pixels = pixel_count;
          while (remaining_pixels >= chunk_size) {
            ta2.set(pre_populated_array, w);
            w += ppal;
            remaining_pixels -= chunk_size;
          }
          for (let i = 0; i < remaining_pixels; i++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
          }
        }
        "draw_horizontal_line_32bipp_y_x1_x2"(y, x1, x2, color) {
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          const [r, g, b, a] = color;
          let w = start_pixel_idx * 4;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
            ta2[w++] = a;
          }
        }
      };
      module.exports = Pixel_Buffer_Core_Draw_Lines;
    }
  });

  // node_modules/jsgui3-gfx-core/core/shapes/is_debug.js
  var require_is_debug = __commonJS({
    "node_modules/jsgui3-gfx-core/core/shapes/is_debug.js"(exports, module) {
      module.exports = false;
    }
  });

  // node_modules/jsgui3-gfx-core/core/shapes/TA_Table_8_Columns.js
  var require_TA_Table_8_Columns = __commonJS({
    "node_modules/jsgui3-gfx-core/core/shapes/TA_Table_8_Columns.js"(exports, module) {
      var TA_Table_8_Columns = class {
        constructor(row_count) {
          this.row_size = 8;
          this.row_count = row_count;
          this.ta = new Float32Array(this.row_size * this.row_count);
          const sorted_indices = this.sorted_indices = new Uint32Array(this.row_count);
          for (let i = 0; i < row_count; i++) {
            sorted_indices[i] = i;
          }
        }
        get(row, col) {
          return this.ta[(row << 3) + col];
        }
        set(row, col, value2) {
          this.ta[(row << 3) + col] = value2;
        }
        sort_indices(comparator) {
          this.sorted_indices.sort((a, b) => comparator(a, b, this));
        }
      };
      module.exports = TA_Table_8_Columns;
    }
  });

  // node_modules/jsgui3-gfx-core/core/shapes/Polygon_Edges.js
  var require_Polygon_Edges = __commonJS({
    "node_modules/jsgui3-gfx-core/core/shapes/Polygon_Edges.js"(exports, module) {
      var DEBUG = require_is_debug();
      var TA_Table_8_Columns = require_TA_Table_8_Columns();
      var Polygon_Edges = class extends TA_Table_8_Columns {
        constructor(polygon) {
          const ptap = polygon.ta_points;
          const num_points = ptap.length >> 1;
          let num_edges = 0;
          for (let i = 0; i < num_points; i++) {
            const y1 = ptap[(i << 1) + 1];
            const y2 = ptap[((i + 1) % num_points << 1) + 1];
            if (y1 !== y2 || y1 === y2) {
              num_edges++;
            }
          }
          super(num_edges);
          this.sorted_indices = new Uint32Array(num_edges);
          this.populate_edges(polygon);
          this.sort_by_y1_then_x1();
        }
        populate_edges(polygon) {
          const ptap = polygon.ta_points;
          const num_points = ptap.length >> 1;
          const { sorted_indices } = this;
          let row = 0;
          for (let i = 0; i < num_points; i++) {
            const ix2 = i << 1;
            const indx2 = (i + 1) % num_points << 1;
            const x1 = ptap[ix2];
            const y1 = ptap[ix2 + 1];
            const x2 = ptap[indx2];
            const y2 = ptap[indx2 + 1];
            if (y1 !== y2 || y1 === y2) {
              const is_horizontal = y1 === y2 ? 1 : 0;
              this.set(row, 0, y1 < y2 ? x1 : x2);
              this.set(row, 1, Math.min(y1, y2));
              this.set(row, 2, y1 < y2 ? x2 : x1);
              this.set(row, 3, Math.max(y1, y2));
              this.set(row, 4, y1 !== y2 ? (x2 - x1) / (y2 - y1) : 0);
              this.set(row, 5, is_horizontal);
              sorted_indices[row] = row;
              row++;
            }
          }
          if (DEBUG) {
            console.log("Edges populated:", Array.from({ length: this.row_count }, (_, i) => ({
              x1: this.get(i, 0),
              y1: this.get(i, 1),
              x2: this.get(i, 2),
              y2: this.get(i, 3),
              slope: this.get(i, 4),
              is_horizontal: this.get(i, 5)
            })));
          }
        }
        sort_by_y1_then_x1() {
          this.sorted_indices.sort((a, b) => {
            const y1A = this.get(a, 1);
            const y1B = this.get(b, 1);
            if (y1A !== y1B) return y1A - y1B;
            const x1A = this.get(a, 0);
            const x1B = this.get(b, 0);
            return x1A - x1B;
          });
          if (DEBUG) {
            console.log(
              "Sorted edges by y1, then x1:",
              this.sorted_indices.map((index) => ({
                x1: this.get(index, 0),
                y1: this.get(index, 1),
                x2: this.get(index, 2),
                y2: this.get(index, 3),
                slope: this.get(index, 4),
                is_horizontal: this.get(index, 5)
              }))
            );
          }
        }
      };
      module.exports = Polygon_Edges;
    }
  });

  // node_modules/jsgui3-gfx-core/core/shapes/Polygon_Scanline_Edges.js
  var require_Polygon_Scanline_Edges = __commonJS({
    "node_modules/jsgui3-gfx-core/core/shapes/Polygon_Scanline_Edges.js"(exports, module) {
      var DEBUG = require_is_debug();
      var Polygon_Edges = require_Polygon_Edges();
      var Scanline_Polygon_Edges = class extends Polygon_Edges {
        constructor(polygon, options = {}) {
          super(polygon);
          this.active_edges = new Uint32Array(this.row_count);
          this.num_active_edges = 0;
          this.allow_horizontal_edges = options.allow_horizontal_edges || false;
        }
        update_active_edges(scanline_y) {
          let write_index = 0;
          const { active_edges, sorted_indices } = this;
          for (let i = 0; i < this.num_active_edges; i++) {
            const edge_index = active_edges[i];
            const y2 = this.get(edge_index, 3);
            if (scanline_y < y2 || this.allow_horizontal_edges && scanline_y === y2) {
              active_edges[write_index++] = edge_index;
            } else if (DEBUG) {
              console.log(`Edge ${edge_index} removed (scanline_y=${scanline_y}, y2=${y2})`);
            }
          }
          this.num_active_edges = write_index;
          const sil = sorted_indices.length;
          for (let i = 0; i < sil; i++) {
            const edge_index = sorted_indices[i];
            const y1 = this.get(edge_index, 1);
            const y2 = this.get(edge_index, 3);
            if (y1 === scanline_y && (scanline_y < y2 || this.allow_horizontal_edges && scanline_y === y2)) {
              active_edges[this.num_active_edges++] = edge_index;
              if (DEBUG) {
                console.log(
                  `Edge ${edge_index} added (scanline_y=${scanline_y}, y1=${y1}, y2=${y2})`
                );
              }
            }
          }
          if (DEBUG) {
            console.log(
              `Updated active edges for scanline ${scanline_y}:`,
              active_edges.slice(0, this.num_active_edges)
            );
          }
        }
        sort_active_edges_by_x() {
          this.active_edges.set(
            this.active_edges.slice(0, this.num_active_edges).sort((edgeA, edgeB) => this.get(edgeA, 0) - this.get(edgeB, 0))
          );
          if (DEBUG) {
            console.log(
              `Sorted active edges by x:`,
              this.active_edges.slice(0, this.num_active_edges)
            );
          }
        }
        get_active_edges() {
          return this.active_edges.slice(0, this.num_active_edges);
        }
      };
      module.exports = Scanline_Polygon_Edges;
    }
  });

  // node_modules/jsgui3-gfx-core/core/shapes/Polygon.js
  var require_Polygon = __commonJS({
    "node_modules/jsgui3-gfx-core/core/shapes/Polygon.js"(exports, module) {
      var Shape = require_Shape();
      var { tof, is_array, get_item_sig, is_arr_of_t } = require_lib_lang_mini3();
      var Rectangle = require_Rectangle();
      var {
        draw_polygon_outline_to_ta_1bipp,
        ensure_polygon_is_ta,
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        fast_find_next_set_ta_bit,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        get_bit,
        calc_polygon_stroke_points_x_y
      } = require_ta_math();
      var is_integer_typed_array = (obj2) => {
        if (ArrayBuffer.isView(obj2)) {
          return obj2 instanceof Int8Array || obj2 instanceof Uint8Array || obj2 instanceof Int16Array || obj2 instanceof Uint16Array || obj2 instanceof Int32Array || obj2 instanceof Uint32Array || obj2 instanceof BigInt64Array || obj2 instanceof BigUint64Array;
        }
        return false;
      };
      var Polygon_Scanline_Edges = require_Polygon_Scanline_Edges();
      var Polygon = class _Polygon extends Shape {
        // Set the points but with an offset too????
        constructor(spec) {
          super(spec);
          if (is_array(spec)) {
            const l2 = spec.length;
            const num_points = l2;
            const ta_points = new Uint32Array(num_points << 1);
            let i = 0;
            for (const [x, y] of spec) {
              ta_points[i++] = x;
              ta_points[i++] = y;
            }
            this.ta_points = ta_points;
          } else {
            if (is_integer_typed_array(spec)) {
              this.ta_points = spec;
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        // Or just as a normal array? Maybe that would be faster.
        get ta_bounding_box() {
          if (!this._ta_bounding_box) {
            const { ta_points } = this, l2 = ta_points.length;
            let min_x = Infinity, min_y = Infinity, max_x = -Infinity, max_y = -Infinity;
            let i = 0;
            let x, y;
            while (i < l2) {
              x = ta_points[i++];
              y = ta_points[i++];
              min_x = Math.min(min_x, x);
              min_y = Math.min(min_y, y);
              max_x = Math.max(max_x, x);
              max_y = Math.max(max_y, y);
            }
            return this._ta_bounding_box = new Uint32Array([min_x, min_y, max_x, max_y]);
          } else {
            return this._ta_bounding_box;
          }
        }
        get ta_xylc_x_spans() {
          const downshifted = this.downshifted();
          const tabb = downshifted.ta_bounding_box;
          const offset2 = this.ta_bounding_box;
          const draw_size = [tabb[2], tabb[3]];
          const [w, h] = draw_size;
          const draw_size_num_pixels = draw_size[0] * draw_size[1];
          const r_from_8 = draw_size_num_pixels % 8;
          const has_remainder_byte = r_from_8 !== 0;
          const ta_draw_num_bytes = (draw_size_num_pixels >>> 3) + (has_remainder_byte ? 1 : 0);
          const ta_draw = new Uint8Array(ta_draw_num_bytes);
          draw_polygon_outline_to_ta_1bipp(ta_draw, draw_size[0], downshifted.ta_points);
          const ta_x_span_toggles = get_ta_bits_that_differ_from_previous_as_1s2(ta_draw, draw_size[0]);
          const num_toggle_bits = count_1s2(ta_x_span_toggles);
          const iterate_to_count_x_spans = () => {
            let i_row_start = 0, i_row_end = w + 1;
            let cx = 0;
            const found_x_span = (x, y, l2, c2) => {
              cx++;
            };
            for (let y = 0; y < h; y++) {
              let i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_row_start, i_row_end - i_row_start - 1);
              if (i_next_set_bit === false) {
                found_x_span(0, y, i_row_end);
              } else {
                found_x_span(0, y, i_next_set_bit - i_row_start);
                let i_last_set_bit = i_next_set_bit;
                while (i_next_set_bit !== false && i_next_set_bit < i_row_end) {
                  i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_next_set_bit, i_row_end - i_next_set_bit - 1);
                  if (i_next_set_bit === false) {
                    found_x_span(i_last_set_bit - i_row_start, y, i_row_end - i_last_set_bit);
                  } else {
                    found_x_span(i_last_set_bit - i_row_start, y, i_next_set_bit - i_last_set_bit);
                    i_last_set_bit = i_next_set_bit;
                  }
                }
              }
              i_row_start += w;
              i_row_end += w;
            }
            return cx;
          };
          const num_x_spans = iterate_to_count_x_spans();
          const num_fields_per_result_item = 4;
          const l_res = num_x_spans * num_fields_per_result_item;
          const res2 = new Uint32Array(l_res);
          const iterate_to_write_result = () => {
            let i_w_res = 0;
            let i_row_start = 0, i_row_end = w + 1;
            let cx = 0;
            const found_x_span = (x, y, l2, c2) => {
              res2[i_w_res++] = x;
              res2[i_w_res++] = y;
              res2[i_w_res++] = l2;
              res2[i_w_res++] = c2;
              cx++;
            };
            for (let y = 0; y < h; y++) {
              const row_x0_value = get_bit(ta_x_span_toggles, i_row_start);
              let color = row_x0_value;
              let i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_row_start, i_row_end - i_row_start - 1);
              if (i_next_set_bit === false) {
                found_x_span(0, y, i_row_end, color);
              } else {
                found_x_span(0, y, i_next_set_bit - i_row_start, color);
                color = ~color & 1;
                let i_last_set_bit = i_next_set_bit;
                while (i_next_set_bit !== false && i_next_set_bit < i_row_end) {
                  i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_next_set_bit, i_row_end - i_next_set_bit - 1);
                  if (i_next_set_bit === false) {
                    found_x_span(i_last_set_bit - i_row_start, y, i_row_end - i_last_set_bit, color);
                  } else {
                    found_x_span(i_last_set_bit - i_row_start, y, i_next_set_bit - i_last_set_bit, color);
                    i_last_set_bit = i_next_set_bit;
                    color = ~color & 1;
                  }
                }
              }
              i_row_start += w;
              i_row_end += w;
            }
          };
          iterate_to_write_result();
          return res2;
        }
        // x, y, l makes the most sense
        get ta_x_spans_filled() {
          const calling_other_fns_attempt = () => {
            const bb = this.ta_bounding_box;
            const offset_width = bb[2] - bb[0];
            const offset_height = bb[3] - bb[1];
            const ohm1 = offset_height - 1;
            const ta_xylc_x_spans = this.ta_xylc_x_spans;
            const iterate_to_count_x_spans_touching_image_border = () => {
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              let i_r = 0;
              let c_touching_image_border2 = 0;
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l2 = ta_xylc_x_spans[i_r++], c2 = ta_xylc_x_spans[i_r++];
                if (x === 0) {
                  c_touching_image_border2++;
                } else if (x + l2 === offset_width) {
                  c_touching_image_border2++;
                } else if (y === 0) {
                  c_touching_image_border2++;
                } else if (y === ohm1) {
                  c_touching_image_border2++;
                }
              }
              return c_touching_image_border2;
            };
            const c_touching_image_border = iterate_to_count_x_spans_touching_image_border();
            const indexes_of_x_spans_touching_image_border = new Uint32Array(c_touching_image_border);
            const iterate_to_populate_indexes_of_x_spans_touching_image_border = () => {
              let i_r = 0, i_w = 0;
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l2 = ta_xylc_x_spans[i_r++], c2 = ta_xylc_x_spans[i_r++];
                if (x === 0) {
                  indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                } else if (x + l2 === offset_width) {
                  indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                } else if (y === 0) {
                  indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                } else if (y === ohm1) {
                  indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                }
              }
            };
            iterate_to_populate_indexes_of_x_spans_touching_image_border();
            const iterate_to_count_color_0_x_spans_touching_image_border = () => {
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              let i_r = 0;
              let c_touching_image_border2 = 0;
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l2 = ta_xylc_x_spans[i_r++], c2 = ta_xylc_x_spans[i_r++];
                if (c2 === 0) {
                  if (x === 0) {
                    c_touching_image_border2++;
                  } else if (x + l2 === offset_width) {
                    c_touching_image_border2++;
                  } else if (y === 0) {
                    c_touching_image_border2++;
                  } else if (y === ohm1) {
                    c_touching_image_border2++;
                  }
                }
              }
              return c_touching_image_border2;
            };
            const c_color_0_touching_image_border = iterate_to_count_color_0_x_spans_touching_image_border();
            const indexes_of_color_0_x_spans_touching_image_border = new Uint32Array(c_color_0_touching_image_border);
            const iterate_to_populate_indexes_of_color_0_x_spans_touching_image_border = () => {
              let i_r = 0, i_w = 0;
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l2 = ta_xylc_x_spans[i_r++], c2 = ta_xylc_x_spans[i_r++];
                if (c2 === 0) {
                  if (x === 0) {
                    indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                  } else if (x + l2 === offset_width) {
                    indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                  } else if (y === 0) {
                    indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                  } else if (y === ohm1) {
                    indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                  }
                }
              }
            };
            iterate_to_populate_indexes_of_color_0_x_spans_touching_image_border();
            const invert_indexes = (indexes) => {
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              let i_idx = 0;
              let res_idx = 0;
              const res3 = new Uint32Array(num_x_spans - indexes.length);
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                if (i_idx < indexes.length && indexes[i_idx] === i_x_span) {
                  i_idx++;
                } else {
                  res3[res_idx++] = i_x_span;
                }
              }
              return res3;
            };
            const assemble_res_from_indexes = (indexes) => {
              const l2 = indexes.length;
              let i_r = 0, i_w = 0;
              const l_res = l2 * 3;
              const res3 = new Uint32Array(l_res);
              for (let i_index = 0; i_index < l2; i_index++) {
                const i_in_main = indexes[i_index];
                const pos_in_main = i_in_main * 4;
                const x = ta_xylc_x_spans[pos_in_main];
                const y = ta_xylc_x_spans[pos_in_main + 1];
                const l3 = ta_xylc_x_spans[pos_in_main + 2];
                res3[i_w++] = x;
                res3[i_w++] = y;
                res3[i_w++] = l3;
              }
              return res3;
            };
            const res2 = assemble_res_from_indexes(invert_indexes(indexes_of_color_0_x_spans_touching_image_border));
            return res2;
          };
          return calling_other_fns_attempt();
        }
        set offset(value2) {
          if (!this._offset) {
            this._offset = new Uint32Array(2);
          }
          if (is_array(value2)) {
            this._offset[0] = value2[0];
            this._offset[1] = value2[1];
          } else {
            console.trace();
            throw "NYI";
          }
        }
        get offset() {
          if (!this._offset) {
            this._offset = new Uint32Array(2);
          }
          return this._offset;
        }
        downshifted() {
          const [x, y] = this.ta_bounding_box;
          const dx = -x, dy = -y;
          const { ta_points } = this, l2 = ta_points.length;
          const ta_downshifted_points = new Uint32Array(l2);
          let i = 0;
          while (i < l2) {
            ta_downshifted_points[i] = ta_points[i++] + dx;
            ta_downshifted_points[i] = ta_points[i++] + dy;
          }
          const res2 = new _Polygon(ta_downshifted_points);
          res2.offset = [x, y];
          return res2;
        }
        get scanline_edges() {
          const res2 = new Polygon_Scanline_Edges(this);
          return res2;
        }
      };
      Polygon.Polygon_Scanline_Edges = Polygon_Scanline_Edges;
      Polygon.ensure_is = (obj2) => {
        if (obj2 instanceof Polygon) {
          return obj2;
        } else {
          return new Polygon(obj2);
        }
      };
      module.exports = Polygon;
      if (__require.main === module) {
        const t0 = process.hrtime();
        const polygon = new Polygon([[900, 900], [200, 200], [1e3, 900], [1600, 200], [1e3, 1e3], [1e3, 1100], [1e3, 1600], [900, 1600]]);
        const ta_l = polygon.ta_points.length;
        const tabb = polygon.ta_bounding_box;
        const ds_pg = polygon.downshifted();
        const xsf = polygon.ta_x_spans_filled;
        const l_xsf = xsf.length;
        const num_x_spans = l / 3;
        let i = 0;
        for (let c2 = 0; c2 < num_x_spans; c2++) {
          const x = xsf[i++], y = xsf[i++], l2 = xsf[i++], x2 = x + l2;
        }
        const tt0 = process.hrtime(t0);
        const ms0 = tt0[0] * 1e3 + tt0[1] / 1e6;
        console.log("ms0", ms0);
        console.log("ta_l", ta_l);
        console.log("tabb", tabb);
        console.log("polygon", polygon);
        console.log("ds_pg", ds_pg);
        console.log("ds_pg.ta_bounding_box", ds_pg.ta_bounding_box);
        console.log("xsf", xsf);
      }
    }
  });

  // node_modules/jsgui3-gfx-core/core/shapes/ScanlineProcessor.js
  var require_ScanlineProcessor = __commonJS({
    "node_modules/jsgui3-gfx-core/core/shapes/ScanlineProcessor.js"(exports, module) {
      var DEBUG = require_is_debug();
      var ScanlineProcessor = class {
        constructor(polygon_scanline_edges, width, height2, bitmap, options = {}) {
          this.edges = polygon_scanline_edges;
          this.width = width;
          this.height = height2;
          this.bitmap = bitmap;
          this.dataView = new DataView(bitmap.buffer, bitmap.byteOffset, bitmap.byteLength);
          this.draw_edges = options.draw_edges || false;
        }
        process_1bipp() {
          if (DEBUG) {
            console.log(`Processing polygon fill: width=${this.width}, height=${this.height}`);
          }
          const h = this.height, edges = this.edges;
          for (let y = 0; y < h; y++) {
            edges.update_active_edges(y);
            edges.sort_active_edges_by_x();
            if (DEBUG) {
              console.log(`Scanline ${y}: Active Edges`, edges.active_edges.slice(0, edges.num_active_edges));
            }
            if (this.draw_edges) {
              this.fill_scanline_with_edges_1bipp(y);
            } else {
              this.fill_scanline_no_edges_1bipp(y);
            }
            this._update_x_intercepts();
          }
        }
        _set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end) {
          const total_pixels = x_end - x_start + 1;
          const start_index = row_offset + x_start;
          const end_index = row_offset + x_end;
          let pixel_index = start_index;
          if (total_pixels < 12) {
            for (; pixel_index <= end_index; pixel_index++) {
              const byte_offset = pixel_index >> 3;
              bitmap[byte_offset] |= 128 >> (pixel_index & 7);
            }
          } else {
            const start_byte = start_index >> 3;
            const start_bit_offset = pixel_index & 7;
            let num_pixels_remaining = total_pixels;
            if (total_pixels < 90) {
              if (start_bit_offset !== 0) {
                const bits_to_set = Math.min(8 - start_bit_offset, num_pixels_remaining);
                bitmap[start_byte] |= 255 >> 8 - bits_to_set << 8 - start_bit_offset - bits_to_set;
                pixel_index += bits_to_set;
                num_pixels_remaining -= bits_to_set;
              }
              while (num_pixels_remaining >= 8) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= 255;
                pixel_index += 8;
                num_pixels_remaining -= 8;
              }
              if (num_pixels_remaining > 0) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= 255 << 8 - num_pixels_remaining;
              }
            } else {
              const dataView = this.dataView;
              if (start_bit_offset !== 0) {
                const bits_to_set = Math.min(8 - start_bit_offset, num_pixels_remaining);
                bitmap[start_byte] |= 255 >> 8 - bits_to_set << 8 - start_bit_offset - bits_to_set;
                pixel_index += bits_to_set;
                num_pixels_remaining -= bits_to_set;
              }
              while (num_pixels_remaining >= 64) {
                const byte_offset = pixel_index >> 3;
                dataView.setBigUint64(byte_offset, 0xFFFFFFFFFFFFFFFFn, false);
                pixel_index += 64;
                num_pixels_remaining -= 64;
              }
              while (num_pixels_remaining >= 8) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= 255;
                pixel_index += 8;
                num_pixels_remaining -= 8;
              }
              if (num_pixels_remaining > 0) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= 255 << 8 - num_pixels_remaining;
              }
            }
          }
        }
        fill_scanline_with_edges_1bipp(scanline_y) {
          const { edges } = this;
          const { active_edges, num_active_edges } = this.edges;
          if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
          }
          const bitmap = this.bitmap;
          const row_offset = scanline_y * this.width;
          const naem1 = num_active_edges - 1;
          for (let i = 0; i < naem1; i += 2) {
            const x_start = Math.round(edges.get(active_edges[i], 0));
            const x_end = Math.round(edges.get(active_edges[i + 1], 0));
            this._set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end);
            if (DEBUG) {
              console.log(`Scanline ${scanline_y}: Processed span from x=${x_start} to x=${x_end}`);
            }
          }
        }
        fill_scanline_no_edges_1bipp(scanline_y) {
          const { edges } = this;
          const { active_edges, num_active_edges } = this.edges;
          if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
          }
          const bitmap = this.bitmap;
          const row_offset = scanline_y * this.width;
          const naem1 = num_active_edges - 1;
          for (let i = 0; i < naem1; i += 2) {
            const x_start = Math.ceil(edges.get(active_edges[i], 0));
            const x_end = Math.floor(edges.get(active_edges[i + 1], 0));
            this._set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end);
            if (DEBUG) {
              console.log(`Scanline ${scanline_y}: Filling span from x=${x_start} to x=${x_end}`);
            }
          }
        }
        *iterate_process() {
          const h = this.height, edges = this.edges;
          for (let y = 0; y < h; y++) {
            edges.update_active_edges(y);
            edges.sort_active_edges_by_x();
            if (DEBUG) {
              console.log(`Scanline ${y}: Active Edges`, edges.active_edges.slice(0, edges.num_active_edges));
            }
            yield* this.iterate_scanline(y);
            this._update_x_intercepts();
          }
        }
        *iterate_scanline(scanline_y) {
          const { edges } = this;
          const { active_edges, num_active_edges } = this.edges;
          if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
          }
          for (let i = 0; i < num_active_edges - 1; i += 2) {
            const x_start = Math.ceil(edges.get(active_edges[i], 0));
            const x_end = Math.floor(edges.get(active_edges[i + 1], 0));
            if (x_start <= x_end) {
              yield [scanline_y, x_start, x_end];
            }
          }
        }
        _update_x_intercepts() {
          const edges = this.edges;
          const { active_edges, num_active_edges } = edges;
          for (let i = 0; i < num_active_edges; i++) {
            const edge_index = active_edges[i];
            edges.set(edge_index, 0, edges.get(edge_index, 0) + edges.get(edge_index, 4));
            if (DEBUG) {
              console.log(`Edge ${edge_index}: Updated x=${edges.get(edge_index, 0)} using slope=${edges.get(edge_index, 4)}`);
            }
          }
        }
      };
      module.exports = ScanlineProcessor;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-1.2-core-draw-polygon.js
  var require_pixel_buffer_1_2_core_draw_polygon = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-1.2-core-draw-polygon.js"(exports, module) {
      var Pixel_Buffer_Core_Draw_Lines = require_pixel_buffer_1_1_core_draw_line();
      var Polygon_Scanline_Edges = require_Polygon_Scanline_Edges();
      var {
        resize_ta_colorspace,
        copy_rect_to_same_size_8bipp,
        copy_rect_to_same_size_24bipp,
        dest_aligned_copy_rect_1to4bypp,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        draw_polygon_outline_to_ta_1bipp,
        ensure_polygon_is_ta,
        calc_polygon_stroke_points_x_y
      } = require_ta_math();
      var Polygon = require_Polygon();
      var ScanlineProcessor = require_ScanlineProcessor();
      var Pixel_Buffer_Core_Draw_Polygons = class extends Pixel_Buffer_Core_Draw_Lines {
        constructor(spec) {
          super(spec);
        }
        gpt_draw_polygon_filling(polygon) {
          const edges = [];
          const num_points = polygon.length / 2;
          const [w, h] = this.size;
          for (let i = 0; i < num_points; i++) {
            const x1 = polygon[i * 2];
            const y1 = polygon[i * 2 + 1];
            const x2 = polygon[(i + 1) % num_points * 2];
            const y2 = polygon[(i + 1) % num_points * 2 + 1];
            if (x1 === x2 && y1 === y2) continue;
            if (y1 !== y2) {
              const is_y1_lower = y1 < y2;
              edges.push({
                x1: is_y1_lower ? x1 : x2,
                y1: Math.min(y1, y2),
                x2: is_y1_lower ? x2 : x1,
                y2: Math.max(y1, y2),
                slope: (x2 - x1) / (y2 - y1)
              });
            }
          }
          edges.sort((a, b) => a.y1 - b.y1 || a.x1 - b.x1);
          let active_edges = [];
          let edge_index = 0;
          for (let y = 0; y < h; y++) {
            while (edge_index < edges.length && edges[edge_index].y1 === y) {
              active_edges.push(edges[edge_index]);
              edge_index++;
            }
            active_edges = active_edges.filter((e) => e.y2 > y);
            active_edges.sort((a, b) => a.x1 - b.x1);
            const aelm1 = active_edges.length - 1;
            for (let i = 0; i < aelm1; i += 2) {
              const x_start = Math.ceil(active_edges[i].x1);
              const x_end = Math.floor(active_edges[i + 1].x1);
              for (let x = x_start; x <= x_end; x++) {
                const pixel_index = y * w + x;
                this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
              }
            }
            for (let edge of active_edges) {
              edge.x1 += edge.slope;
            }
          }
        }
        class_enh_gpt_draw_polygon_filling(polygon) {
          const [w, h] = this.size;
          polygon = Polygon.ensure_is(polygon);
          const polygon_scanline_edges = new Polygon_Scanline_Edges(polygon);
          const processor = new ScanlineProcessor(polygon_scanline_edges, w, h, this.ta);
          processor.process();
        }
        gpt_draw_filled_polygon_1bipp(polygon) {
          polygon = Polygon.ensure_is(ensure_polygon_is_ta(polygon));
          const scanline_processor = new ScanlineProcessor(
            polygon.scanline_edges,
            this.size[0],
            this.size[1],
            this.ta,
            { draw_edges: true }
            // Enable edge drawing
          );
          scanline_processor.process_1bipp();
        }
        draw_color_1_filled_polygon_1bipp(polygon) {
          return this.gpt_draw_filled_polygon_1bipp(polygon);
        }
        draw_polygon_1bipp(polygon, stroke_color, fill_color = false) {
          polygon = ensure_polygon_is_ta(polygon);
          if (fill_color === void 0 || fill_color === false) {
            let x, y;
            let prev_x, prev_y;
            let is_first = true;
            const num_points = polygon.length >>> 1;
            let r = 0;
            for (let c2 = 0; c2 < num_points; c2++) {
              x = polygon[r++];
              y = polygon[r++];
              if (!is_first) {
                this.draw_line([prev_x, prev_y], [x, y], stroke_color);
              }
              [prev_x, prev_y] = [x, y];
              is_first = false;
            }
            this.draw_line([prev_x, prev_y], [polygon[0], polygon[1]], stroke_color);
          } else {
            if (stroke_color === 1) {
              if (fill_color === 1) {
                return this.draw_color_1_filled_polygon_1bipp(polygon);
              } else if (fill_color === 0) {
                console.trace();
                throw "NYI";
              }
            } else {
              if (fill_color === 1) {
                console.trace();
                throw "NYI";
              } else if (fill_color === 0) {
                console.trace();
                throw "NYI";
              }
            }
          }
        }
        "draw_polygon"(arr_points, color, fill = false, stroke_color) {
          const { bits_per_pixel } = this;
          if (bits_per_pixel === 1) {
            if (fill === true) {
              if (stroke_color === void 0) {
                return this.draw_polygon_1bipp(arr_points, color, color);
              } else {
                console.trace();
                throw "NYI";
                if (stroke_color === 1) {
                } else {
                }
              }
            } else {
              return this.draw_polygon_1bipp(arr_points, color);
            }
          } else {
            if (fill === true) {
              const iterate_class_polygon_scanline_spans_implementation = () => {
                const draw_filling = () => {
                  const polygon = Polygon.ensure_is(ensure_polygon_is_ta(arr_points));
                  const polygon_scanline_edges = new Polygon_Scanline_Edges(polygon);
                  const [w, h] = this.size;
                  const processor = new ScanlineProcessor(polygon_scanline_edges, w, h, this.ta, { draw_edges: true });
                  if (bits_per_pixel === 24) {
                    const ppal = 64 * 3;
                    const pre_populated_array = new Uint8Array(ppal);
                    for (let i = 0; i < ppal; ) {
                      pre_populated_array[i++] = color[0];
                      pre_populated_array[i++] = color[1];
                      pre_populated_array[i++] = color[2];
                    }
                    for (const [y, x1, x2] of processor.iterate_process()) {
                      this.draw_horizontal_line_24bipp_y_x1_x2(y, x1, x2, color, pre_populated_array, false);
                    }
                  } else {
                    for (const [y, x1, x2] of processor.iterate_process()) {
                      this.draw_horizontal_line_y_x1_x2(y, x1, x2, color);
                    }
                  }
                };
                draw_filling();
              };
              iterate_class_polygon_scanline_spans_implementation();
            } else {
              let prev_x, prev_y;
              let is_first = true;
              for (const [x, y] of arr_points) {
                if (!is_first) {
                  this.draw_line([prev_x, prev_y], [x, y], color);
                }
                [prev_x, prev_y] = [x, y];
                is_first = false;
              }
              this.draw_line([prev_x, prev_y], arr_points[0], color);
            }
          }
        }
      };
      module.exports = Pixel_Buffer_Core_Draw_Polygons;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-1.5-core-mask.js
  var require_pixel_buffer_1_5_core_mask = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-1.5-core-mask.js"(exports, module) {
      var Pixel_Buffer_Core_Draw_Polygons = require_pixel_buffer_1_2_core_draw_polygon();
      var Polygon_Scanline_Edges = require_Polygon_Scanline_Edges();
      var ScanlineProcessor = require_ScanlineProcessor();
      var Pixel_Buffer_Core_Masks = class extends Pixel_Buffer_Core_Draw_Polygons {
        constructor(spec) {
          super(spec);
        }
        "draw_1bipp_pixel_buffer_mask_1bipp"(pb_1bipp_mask, dest_pos, color) {
          const arr_on_xspans_implementation = () => {
            const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
            const [width, height2] = pb_1bipp_mask.size;
            const [dest_x, dest_y] = dest_pos;
            if (color === 1) {
              for (let y = 0; y < height2; y++) {
                const target_y = y + dest_y;
                for (const xonspan of arr_rows_arr_on_xspans[y]) {
                  xonspan[0] += dest_x;
                  xonspan[1] += dest_x;
                  this.draw_horizontal_line_on_1bipp_inclusive(xonspan, target_y);
                }
              }
            } else {
              for (let y = 0; y < height2; y++) {
                const target_y = y + dest_y;
                for (const xonspan of arr_rows_arr_on_xspans[y]) {
                  xonspan[0] += dest_x;
                  xonspan[1] += dest_x;
                  this.draw_horizontal_line_off_1bipp_inclusive(xonspan, target_y);
                }
              }
            }
          };
          const bit_realigned_64_bit_implementation = () => {
            const pb_source2 = pb_1bipp_mask;
            const pb_dest = this;
            const size_source = pb_source2.size;
            const w_source = size_source[0];
            const h_source = size_source[1];
            const size_dest = pb_dest.size;
            const w_dest = size_dest[0];
            const iterate_dest_shift_reads = () => {
              const dest_start_pxi = dest_pos[1] * pb_dest.size[0] + dest_pos[0];
              const dest_start_row_end_pxi = dest_start_pxi + pb_source2.size[0];
              const num_px_from_dest_row_start_to_draw_box_start = dest_pos[0];
              const num_px_from_draw_box_end_to_dest_row_end = pb_dest.size[0] - pb_source2.size[0] - num_px_from_dest_row_start_to_draw_box_start;
              const num_px_line_jump = num_px_from_draw_box_end_to_dest_row_end + dest_pos[0];
              const num_ui64_line_jump = (num_px_line_jump >>> 6) - 1;
              const dest_start_i64 = dest_start_pxi >>> 6;
              const dest_start_i64_rb = dest_start_pxi % 64;
              const dest_start_row_end_i64 = dest_start_row_end_pxi >>> 6;
              const num_64_bit_at_least_partial_parts_per_row = dest_start_row_end_i64 - dest_start_i64 + 1;
              let i64_dest = dest_start_i64;
              let i64_source = 0;
              const y_top = dest_pos[1], y_bottom = y_top + h_source;
              const sta64 = new BigUint64Array(pb_source2.ta.buffer, pb_source2.ta.byteOffset, pb_source2.ta.byteLength / 8);
              const dta64 = new BigUint64Array(pb_dest.ta.buffer, pb_dest.ta.byteOffset, pb_dest.ta.byteLength / 8);
              const bi_dest_start_i64_rb = BigInt(dest_start_i64_rb);
              const bi_right_right_shift_bits = 64n - bi_dest_start_i64_rb;
              const dest_row_middle_ui64_count = num_64_bit_at_least_partial_parts_per_row - 2;
              for (let y = y_top; y < y_bottom; y++) {
                const process_0th_64bit_part = () => {
                  dta64[i64_dest] = dta64[i64_dest] << bi_right_right_shift_bits >> bi_right_right_shift_bits | sta64[i64_source] << bi_dest_start_i64_rb;
                  i64_dest++;
                };
                const process_middle_64bit_parts = () => {
                  for (let i_mid = 0; i_mid < dest_row_middle_ui64_count; i_mid++) {
                    dta64[i64_dest++] = sta64[i64_source] >> bi_right_right_shift_bits | sta64[i64_source + 1] << bi_dest_start_i64_rb;
                    i64_source++;
                  }
                };
                const process_last_64bit_part = () => {
                  dta64[i64_dest] = dta64[i64_dest] | sta64[i64_source] >> bi_right_right_shift_bits;
                  i64_dest++;
                  i64_source++;
                };
                process_0th_64bit_part();
                process_middle_64bit_parts();
                process_last_64bit_part();
                i64_dest += num_ui64_line_jump;
              }
            };
            iterate_dest_shift_reads();
          };
          const test_can_do_aligned_64_bit = () => this.bits_per_row % 64 === 0 && this.bits_per_row >= 64 && (dest_pos[1] * pb_1bipp_mask.size[0] + dest_pos[0]) % 64 === 0 && pb_1bipp_mask.bits_per_row % 64 === 0 && pb_1bipp_mask.bits_per_row >= 64;
          const test_can_do_bit_realigned_64_bit2 = () => this.bits_per_row % 64 === 0 && this.bits_per_row >= 64 && pb_1bipp_mask.bits_per_row % 64 === 0 && pb_1bipp_mask.bits_per_row >= 64;
          const approach_selecting = () => {
            {
              const can_do_bit_realigned_64_bit = test_can_do_bit_realigned_64_bit2();
              if (can_do_bit_realigned_64_bit) {
                return arr_on_xspans_implementation();
              } else {
                return arr_on_xspans_implementation();
              }
            }
          };
          return approach_selecting();
        }
        "draw_1bipp_pixel_buffer_mask"(pb_1bipp_mask, dest_pos, color) {
          const { bipp } = this;
          if (bipp === 1) {
            return this.draw_1bipp_pixel_buffer_mask_1bipp(pb_1bipp_mask, dest_pos, color);
          } else {
            const arr_on_xspans_implementation = () => {
              const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
              const [width, height2] = pb_1bipp_mask.size;
              let y = 0;
              let [dest_x, dest_y] = dest_pos;
              for (y = 0; y < height2; y++) {
                const arr_row_xspans_on = arr_rows_arr_on_xspans[y];
                if (arr_row_xspans_on.length > 0) {
                  for (const xonspan of arr_row_xspans_on) {
                    xonspan[0] += dest_x;
                    xonspan[1] += dest_x;
                    this.draw_horizontal_line(xonspan, y + dest_y, color);
                  }
                }
              }
            };
            return arr_on_xspans_implementation();
          }
        }
        mask_each_pixel(cb_pixel) {
          const bipp = this.bits_per_pixel;
          let i_byte = 0;
          let i_px = 0;
          const bypp2 = this.bytes_per_pixel;
          const ta2 = this.ta;
          const l2 = ta2.length;
          const res_mask = new this.constructor({
            size: this.size,
            bits_per_pixel: 1
          });
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            console.trace();
            throw "NYI";
          } else if (bipp === 24 || bipp === 32) {
            while (i_byte < l2) {
              const ta_sub = ta2.slice(i_byte, i_byte + bypp2);
              const px_on = cb_pixel(ta_sub) ? 1 : 0;
              res_mask.set_pixel_by_idx(i_px, px_on);
              i_byte += bypp2;
              i_px++;
            }
          }
          return res_mask;
        }
        apply_mask(pb_mask, mr, mg, mb, ma) {
          let res2 = this.blank_copy();
          res2.flood_fill(0, 0, 255, 255, 255, 255);
          let px;
          pb_mask.each_pixel((x, y, r, g, b, a) => {
            if (r === mr && g === mg && b === mb && a === ma) {
              px = this.get_pixel(x, y);
              res2.set_pixel(x, y, px[0], px[1], px[2], px[3]);
            }
          });
          return res2;
        }
        "get_mask_each_px"(fn_mask) {
          const bipp = this.bipp;
          console.log("get_mask_each_px bipp", bipp);
          const res_mask = new this.constructor({
            size: this.size,
            bits_per_pixel: 1
          });
          if (bipp === 1) {
            let byte = 0, bit = 0;
            console.trace();
            throw "NYI";
            const ta2 = this.ta, l2 = ta2.length;
            while (byte < l2) {
            }
          } else if (bipp === 8) {
            console.trace();
            throw "NYI";
          } else if (bipp === 24) {
            let byte_pos = 0, i_px = 0;
            const l2 = this.ta.length;
            while (byte_pos < l2) {
              const ta_px = this.ta.slice(byte_pos, byte_pos + 3);
              const mask_res = fn_mask(ta_px);
              byte_pos += 3;
            }
          } else if (bipp === 32) {
            console.trace();
            throw "NYI";
          }
          return res_mask;
        }
      };
      module.exports = Pixel_Buffer_Core_Masks;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-2-core-reference-implementations.js
  var require_pixel_buffer_2_core_reference_implementations = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-2-core-reference-implementations.js"(exports, module) {
      var lang = require_lib_lang_mini3();
      var {
        each,
        fp,
        tof,
        get_a_sig: get_a_sig2,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~0n;
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var Pixel_Buffer_Painter = require_pixel_buffer_painter();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Masks = require_pixel_buffer_1_5_core_mask();
      var Pixel_Buffer_Core_Reference_Implementations2 = class _Pixel_Buffer_Core_Reference_Implementations extends Pixel_Buffer_Core_Masks {
        constructor(spec) {
          if (spec instanceof _Pixel_Buffer_Core_Reference_Implementations) {
            spec = {
              bits_per_pixel: spec.bits_per_pixel,
              size: spec.size,
              ta: spec.ta
            };
          }
          let silent_update_bits_per_pixel;
          let silent_update_bytes_per_pixel;
          if (spec.window_to) {
            spec.bits_per_pixel = spec.window_to.bits_per_pixel;
          }
          const pos = new Int16Array(2);
          const size = new Int16Array(2);
          let ta2;
          super(spec);
          this.move = (ta_2d_vector) => {
            pos[0] += ta_2d_vector[0];
            pos[1] += ta_2d_vector[1];
            if (this.source) {
              this.copy_from_source();
            }
          };
          this.each_pos_within_bounds = (callback2) => {
            const has_source = !!this.source;
            for (pos[1] = pos_bounds[1]; pos[1] < pos_bounds[3]; pos[1]++) {
              for (pos[0] = pos_bounds[0]; pos[0] < pos_bounds[2]; pos[0]++) {
                if (has_source) this.copy_from_source();
                callback2();
              }
            }
          };
          this.move_next_px = () => {
            const source_size = this.source.size;
            if (pos[0] + size[0] < source_size[0]) {
              pos[0]++;
            } else {
              if (pos[1] + size[1] < source_size[1]) {
                pos[0] = 0;
                pos[1]++;
              } else {
                return false;
              }
            }
            if (this.source) {
              this.copy_from_source();
            }
            return pos;
          };
          this.paint = new Pixel_Buffer_Painter({
            pb: this
          });
        }
        // Some will need to be a bit more optimised for perf rather than readability. Do want clear code though.
        // Not quite sure why this is failing on 1 bipp right now....
        each_pixel(callback2) {
          const { ta_pos_scratch, bipp, bypp: bypp2, size, ta: ta2 } = this;
          if (bipp === 1) {
            const [w, h] = size;
            let i_byte = 0, i_bit = 0;
            const ta_cb_pos = new Uint32Array(2);
            for (let y = 0; y < h; y++) {
              ta_cb_pos[1] = y;
              for (let x = 0; x < w; x++) {
                ta_cb_pos[0] = x;
                const got_px_color = this.get_pixel_1bipp(ta_cb_pos);
                callback2(ta_cb_pos, got_px_color);
                if (i_bit === 8) {
                }
              }
            }
          } else if (bipp === 8) {
            let pixel_idx = 0;
            this.each_pixel_pos((pos, stop) => {
              callback2(pos, ta2[pixel_idx++], stop);
            });
          } else if (bipp === 24) {
            const { ta_24bit_color } = this;
            let byte_idx = 0;
            this.each_pixel_pos((pos, stop) => {
              ta_24bit_color[0] = ta2[byte_idx++];
              ta_24bit_color[1] = ta2[byte_idx++];
              ta_24bit_color[2] = ta2[byte_idx++];
              callback2(pos, ta_24bit_color, stop);
            });
          } else if (bipp === 32) {
            const { ta_32bit_color } = this;
            let byte_idx = 0;
            this.each_pixel_pos((pos, stop) => {
              ta_32bit_color[0] = ta2[byte_idx++];
              ta_32bit_color[1] = ta2[byte_idx++];
              ta_32bit_color[2] = ta2[byte_idx++];
              ta_32bit_color[3] = ta2[byte_idx++];
              callback2(pos, ta_32bit_color, stop);
            });
          }
        }
        "to_8bit_greyscale"() {
          if (this.bytes_per_pixel === 1) {
            return this;
          } else if (this.bytes_per_pixel === 3) {
            const res2 = new this.constructor({
              "size": this.size,
              "bits_per_pixel": 8
            });
            if (this.pos) res2.pos = this.pos;
            const bres = res2.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
              bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res2;
          } else if (this.bytes_per_pixel === 4) {
            const res2 = new this.constructor({
              "size": this.size,
              "bits_per_pixel": 8
            });
            if (this.pos) res2.pos = this.pos;
            const bres = res2.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
              bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res2;
          }
        }
        "to_32bit_rgba"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 32
          });
          if (this.pos) res2.pos = this.pos;
          const bres = res2.buffer;
          if (this.bytes_per_pixel === 1) {
            let i = 0, new_v;
            this.each_pixel((pos, v) => {
              bres[i++] = v;
              bres[i++] = v;
              bres[i++] = v;
              bres[i++] = 255;
            });
          } else {
            console.trace();
            throw "NYI";
          }
          return res2;
        }
        "__invert_greyscale_self"() {
          const bres = this.buffer;
          let i = 0;
          this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
          });
          return this;
        }
        "__invert_greyscale"() {
          let res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 8
          });
          if (this.pos) res2.pos = this.pos;
          const bres = res2.buffer;
          let i = 0;
          this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
          });
          return res2;
        }
        // Could have a 'paint' file / module.
        "paint_solid_border"(thickness, color) {
          return this.process((me, res2) => {
            let x, y;
            const [w, h] = this.size;
            if (this.bytes_per_pixel === 4) {
              for (y = 0; y < thickness; y++) {
                for (x = 0; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                }
              }
              for (y = h - thickness; y < h; y++) {
                for (x = 0; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                }
              }
              for (y = 0; y < h; y++) {
                for (x = 0; x < thickness; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                }
              }
              for (y = 0; y < h; y++) {
                for (x = w - thickness; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                }
              }
            } else if (this.bytes_per_pixel === 3) {
              for (y = 0; y < thickness; y++) {
                for (x = 0; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2]);
                }
              }
              for (y = h - thickness; y < h; y++) {
                for (x = 0; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2]);
                }
              }
              for (y = 0; y < h; y++) {
                for (x = 0; x < thickness; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2]);
                }
              }
              for (y = 0; y < h; y++) {
                for (x = w - thickness; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2]);
                }
              }
            } else {
              console.trace();
              throw "NYI";
            }
            return res2;
          });
        }
        new_convolved(convolution) {
          const res2 = this.blank_copy();
          const xy_conv_center = convolution.xy_center;
          const edge_distances_from_center_px_edge = new Int16Array(4);
          edge_distances_from_center_px_edge[0] = xy_conv_center[0] * -1;
          edge_distances_from_center_px_edge[1] = xy_conv_center[1] * -1;
          edge_distances_from_center_px_edge[2] = edge_distances_from_center_px_edge[0] + convolution.size[0] - 1;
          edge_distances_from_center_px_edge[3] = edge_distances_from_center_px_edge[1] + convolution.size[1] - 1;
          const pb_window = this.new_window({
            size: convolution.size,
            pos_bounds: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1], this.size[0] - edge_distances_from_center_px_edge[2], this.size[1] - edge_distances_from_center_px_edge[3]],
            pos: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1]]
          });
          const pos_window = pb_window.pos;
          const ta_window = pb_window.ta;
          let i_write = 0;
          const ta_conv_res = res2.ta;
          pb_window.each_pos_within_bounds(() => {
            const rgb = convolution.calc_from_24bipp_ta(ta_window);
            ta_conv_res[i_write++] = rgb[0];
            ta_conv_res[i_write++] = rgb[1];
            ta_conv_res[i_write++] = rgb[2];
          });
          return res2;
        }
        new_resized(size) {
          const dest = new this.constructor({
            size,
            bits_per_pixel: this.bipp
          });
          resize_ta_colorspace(this.ta, this.ta_colorspace, dest.size, dest.ta);
          return dest;
        }
        copy_rect_by_bounds_to(ta_bounds, pb_target) {
          console.log("pb.copy_rect_by_bounds_to");
          const bipp = this.bipp;
          if (bipp === 24) {
            return this.copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        each_px_convolution(ta_size, pb_conv_window, ta_pos, callback2) {
          console.trace();
          throw "NYI";
          ta_pos[0] = 0;
          ta_pos[1] = 0;
          if (are_equal(pb_conv_window.size, ta_size)) {
          } else {
          }
        }
        toString() {
          return JSON.stringify({
            buffer: "Uint8ClampedArray length " + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
          });
        }
        /*
        [inspect]() {
            return 'Pixel_Buffer_Core ' + this.toString();
        }
        */
        color_whole(color) {
          this.each_px((pos) => {
            this.set_pixel(pos, color);
          });
          return this;
        }
        crop(size) {
          let new_size = new Uint16Array([this.size[0] - size * 2, this.size[1] - size * 2]);
          let res2 = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new_size
          });
          if (this.pos) {
            res2.pos = new Int16Array([this.pos[0] - size, this.pos[1] - size]);
          }
          this.each_pixel_ta((pos, color) => {
            const new_pos = new Int16Array([pos[0] - size, pos[1] - size]);
            if (new_pos[0] >= 0 && new_pos[0] < new_size[0] && new_pos[1] >= 0 && new_pos[1] < new_size[1]) {
              res2.set_pixel_ta(new_pos, color);
            }
          });
          return res2;
        }
        uncrop(size, color) {
          let res2 = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new Uint16Array([this.size[0] + size * 2, this.size[1] + size * 2])
          });
          if (this.pos) res2.pos = this.pos;
          if (this.pos) {
          }
          res2.color_whole(color);
          console.log("size", size);
          this.each_pixel_ta((pos, color2) => {
            res2.set_pixel_ta(new Uint16Array([pos[0] + size, pos[1] + size]), color2);
          });
          return res2;
        }
        color_rect(bounds2, color) {
          console.trace();
          throw "NYI";
        }
        each_pixel_byte_index(cb) {
          const { bipp } = this;
          let ctu = true;
          const stop = () => ctu = false;
          const [w, h] = this.size;
          const num_pixels = w * h;
          let bit_idx = 0, byte_idx = bit_idx >> 3;
          for (let c2 = 0; c2 < num_pixels; c2++) {
            byte_idx = bit_idx >> 3;
            cb(byte_idx);
          }
        }
        each_px(callback2) {
          const ta_pos = new Int32Array(2);
          const [w, h] = this.size;
          let index = 0;
          for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
              const color = this.get_pixel(ta_pos);
              callback2(ta_pos, color, index++);
            }
          }
        }
        paint_pixel_list(pixel_pos_list, color) {
          pixel_pos_list.each_pixel((pos) => {
            this.set_pixel_ta(pos, color);
          });
        }
        // Maybe a class level that has get and set pixel logic for the different bipps at this level.
        get num_px() {
          return this.size[0] * this.size[1];
        }
        get split_rgb_channels() {
          const [bipp, bypp2] = [this.bits_per_pixel, this.bytes_per_pixel];
          if (bipp === 24 || bipp === 32) {
            const res2 = [new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            })];
            const [r, g, b] = res2;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta2 = this.ta;
            while (i_px < num_px) {
              ta_r[i_px] = ta2[i_byte];
              ta_g[i_px] = ta2[i_byte + 1];
              ta_b[i_px] = ta2[i_byte + 2];
              i_px++;
              i_byte += bypp2;
            }
            return res2;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        process(fn) {
          let res2 = this.clone();
          return fn(this, res2);
        }
        /*
            function typedArraysAreEqual(a, b) {
        if (a.byteLength !== b.byteLength) return false;
        return a.every((val, i) => val === b[i]);
        }
            */
        equals(other_pixel_buffer) {
          let buf1 = this.ta;
          let buf2 = other_pixel_buffer.ta;
          const other_colorspace = other_pixel_buffer.ta_colorspace;
          const my_colorspace = other_pixel_buffer.ta_colorspace;
          if (my_colorspace.length === other_colorspace.length) {
            if (my_colorspace.every((val, i) => val === other_colorspace[i])) {
              if (buf1.length === buf2.length) {
                return buf1.every((val, i) => val === buf2[i]);
              } else {
              }
            } else {
            }
          }
          return false;
        }
        copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
          let bounds2 = pixel_pos_list.bounds;
          let size = new Uint16Array([bounds2[2] - bounds2[0] + 1, bounds2[3] - bounds2[1] + 1]);
          const res2 = new this.constructor({
            size,
            bytes_per_pixel: this.bytes_per_pixel
          });
          if (this.pos) res2.pos = this.pos;
          if (bg_color) {
            res2.color_whole(bg_color);
          }
          res2.pos = new Int16Array([bounds2[0], bounds2[1]]);
          pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([pos[0] - bounds2[0], pos[1] - bounds2[1]]);
            res2.set_pixel_ta(target_pos, color);
          });
          return res2;
        }
        // Pixel_Buffer_Pair_Complex_Operation class possibly?
        //   Or just Operation.
        // get_pre_operation_alignment_info ....
        // And could define such a class which has got requirements / invarients to do with 
        // This is used when drawing filled polygons.
        "blank_copy"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel
          });
          res2.buffer.fill(0);
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "clone"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel,
            "buffer": new this.buffer.constructor(this.buffer)
          });
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "add_alpha_channel"() {
          if (this.bytes_per_pixel === 3) {
            var res2 = new this.constructor({
              "size": this.size,
              "bytes_per_pixel": 4
            });
            if (this.pos) res2.pos = this.pos;
            const buf = this.buffer, res_buf = res2.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0, ir = 0;
            for (let p = 0; p < px_count; p++) {
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = 255;
            }
            return res2;
          }
          if (this.bytes_per_pixel === 4) {
            return this;
          }
        }
        draw_rect(pos_corner, pos_other_corner, color) {
          const l2 = Math.min(pos_corner[0], pos_other_corner[0]);
          const t = Math.min(pos_corner[1], pos_other_corner[1]);
          const r = Math.max(pos_corner[0], pos_other_corner[0]);
          const b = Math.max(pos_corner[1], pos_other_corner[1]);
          const xspan = [l2, r];
          for (let y = t; y <= b; y++) {
            this.draw_horizontal_line(xspan, y, color);
          }
        }
        *"iterate_arr_row_x_on_spans_1bipp"(y) {
        }
        get xspans() {
        }
      };
      module.exports = Pixel_Buffer_Core_Reference_Implementations2;
      if (__require.main === module) {
        const lg = console.log;
        (async () => {
          const run_examples = async () => {
            lg("Begin run examples");
            const examples = [
              async () => {
                lg("Begin example 0");
                const pb = new Pixel_Buffer_Core_Reference_Implementations2({
                  bits_per_pixel: 1,
                  size: [8, 8]
                });
                const ta_pos = new Int16Array(2);
                ta_pos[0] = 3;
                ta_pos[1] = 3;
                pb.set_pixel(ta_pos, 1);
                lg("End example 0");
                return pb;
              }
            ];
            const l2 = examples.length;
            for (var c2 = 0; c2 < l2; c2++) {
              const res_eg = await examples[c2]();
              console.log("res_eg " + c2 + ":", res_eg);
            }
            ;
            lg("End run examples");
          };
          await run_examples();
        })();
      }
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-3-core.js
  var require_pixel_buffer_3_core = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-3-core.js"(exports, module) {
      var lang = require_lib_lang_mini3();
      var {
        each,
        fp,
        tof,
        get_a_sig: get_a_sig2,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~0n;
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var Pixel_Buffer_Painter = require_pixel_buffer_painter();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Reference_Implementations2 = require_pixel_buffer_2_core_reference_implementations();
      var Pixel_Buffer_Core = class extends Pixel_Buffer_Core_Reference_Implementations2 {
        constructor(spec) {
          super(spec);
          const pos = new Int16Array(2);
          const size = new Int16Array(2);
          const ta_bpp = new Uint8Array(2);
          ta_bpp[1] = 8;
          const _24bipp_to_8bipp = () => {
            const old_ta = ta;
            const new_ta = ta = new Uint8Array(this.num_px);
            const l_read = old_ta.length;
            let iby_read = 0, iby_write = 0;
            while (iby_read < l_read) {
              new_ta[iby_write++] = Math.round((old_ta[iby_read++] + old_ta[iby_read++] + old_ta[iby_read++]) / 3);
            }
          };
          const _change_bipp_inner_update = (old_bipp, new_bipp) => {
            if (old_bipp === 24) {
              if (new_bipp === 8) {
                _24bipp_to_8bipp();
              } else {
                console.trace();
                throw "NYI";
              }
            } else {
              console.trace();
              throw "NYI";
            }
          };
          if (spec instanceof Pixel_Pos_List) {
            throw "NYI - change to 1bipp";
            const ppl = spec;
            const bounds2 = ppl.bounds;
            const ppl_size = new Uint16Array(2);
            ppl_size[0] = bounds2[2] - bounds2[0];
            ppl_size[1] = bounds2[3] - bounds2[1];
            this.bits_per_pixel = 8;
            const bpp = this.bytes_per_pixel = 1;
            this.size = new Uint16Array([ppl_size[0] + 4, ppl_size[1] + 4]);
            this.pos = new Int16Array([bounds2[0], bounds2[1]]);
            const bpr = this.bytes_per_row = bpp * this.size[0];
            const buf = this.ta = this.buffer = new Uint8ClampedArray(this.size[0] * this.size[1]);
            const l2 = buf.length;
            for (var c2 = 0; c2 < l2; c2++) buf[c2] = 255;
            ppl.each_pixel((pixel_pos) => {
              buf[bpr * (pixel_pos[1] - bounds2[1]) + (pixel_pos[0] - bounds2[0])] = 0;
            });
          } else {
          }
        }
        new_convolved(convolution) {
          const res2 = this.blank_copy();
          const xy_conv_center = convolution.xy_center;
          const edge_distances_from_center_px_edge = new Int16Array(4);
          edge_distances_from_center_px_edge[0] = xy_conv_center[0] * -1;
          edge_distances_from_center_px_edge[1] = xy_conv_center[1] * -1;
          edge_distances_from_center_px_edge[2] = edge_distances_from_center_px_edge[0] + convolution.size[0] - 1;
          edge_distances_from_center_px_edge[3] = edge_distances_from_center_px_edge[1] + convolution.size[1] - 1;
          const pb_window = this.new_window({
            size: convolution.size,
            pos_bounds: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1], this.size[0] - edge_distances_from_center_px_edge[2], this.size[1] - edge_distances_from_center_px_edge[3]],
            pos: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1]]
          });
          const pos_window = pb_window.pos;
          const ta_window = pb_window.ta;
          let i_write = 0;
          const ta_conv_res = res2.ta;
          pb_window.each_pos_within_bounds(() => {
            const rgb = convolution.calc_from_24bipp_ta(ta_window);
            ta_conv_res[i_write++] = rgb[0];
            ta_conv_res[i_write++] = rgb[1];
            ta_conv_res[i_write++] = rgb[2];
          });
          return res2;
        }
        new_resized(size) {
          const dest = new this.constructor({
            size,
            bits_per_pixel: this.bipp
          });
          resize_ta_colorspace(this.ta, this.ta_colorspace, dest.size, dest.ta);
          return dest;
        }
        copy_rect_by_bounds_to(ta_bounds, pb_target) {
          console.log("pb.copy_rect_by_bounds_to");
          const bipp = this.bipp;
          if (bipp === 24) {
            return this.copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        each_px_convolution(ta_size, pb_conv_window, ta_pos, callback2) {
          console.trace();
          throw "NYI";
          ta_pos[0] = 0;
          ta_pos[1] = 0;
          if (are_equal(pb_conv_window.size, ta_size)) {
          } else {
          }
        }
        get_1bipp_threshold_8bipp(ui8_threshold) {
          const bipp = this.bits_per_pixel;
          if (bipp === 8) {
            const res2 = new this.constructor({
              bits_per_pixel: 1,
              size: this.size
            });
            const rta = res2.ta;
            const ta2 = this.ta;
            const cpx = this.num_px;
            let i_px = 0;
            let i_dest_byte = 0, i_dest_bit = 7;
            let meets_threshold = false;
            let out_byte = 0;
            while (i_px < cpx) {
              meets_threshold = ta2[i_px] >= ui8_threshold;
              if (meets_threshold) {
                out_byte = out_byte | Math.pow(2, i_dest_bit);
              } else {
              }
              i_px++;
              i_dest_bit--;
              if (i_dest_bit === -1) {
                rta[i_dest_byte] = out_byte;
                i_dest_bit = 7;
                i_dest_byte++;
                out_byte = 0;
              }
            }
            return res2;
          } else {
            console.trace();
            throw "get_1bipp_threshold_8bipp: Unsupported bits_per_pixel " + bipp;
          }
        }
        to_8bipp() {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            const res2 = new this.constructor({
              size: this.size,
              bits_per_pixel: 8
            });
            let i_px = 0;
            let i_byte = 0;
            const num_bytes = this.ta.length;
            while (i_byte < num_bytes) {
              for (var b = 0; b < 8; b++) {
                const color = this.get_pixel_by_idx_1bipp(i_px) === 1 ? 255 : 0;
                res2.set_pixel_by_idx_8bipp(i_px++, color);
              }
              i_byte++;
            }
            return res2;
          } else if (bipp === 8) {
            return this.clone();
          } else if (bipp === 24) {
            console.trace();
            throw "NYI";
          } else if (bipp === 32) {
            console.trace();
            throw "NYI";
          }
        }
        to_24bipp() {
          const bipp = this.bits_per_pixel;
          const bypp2 = this.bytes_per_pixel;
          let i_px = 0;
          const num_px = this.size[0] * this.size[1];
          if (bipp === 1) {
            const res2 = new this.constructor({
              size: this.size,
              bits_per_pixel: 24
            });
            let i_byte = 0;
            const num_bytes = this.ta.length;
            while (i_byte < num_bytes) {
              for (var b = 0; b < 8; b++) {
                const color = this.get_pixel_by_idx_1bipp(i_px) === 1 ? new Uint8ClampedArray([255, 255, 255]) : new Uint8ClampedArray([0, 0, 0]);
                res2.set_pixel_by_idx_24bipp(i_px++, color);
              }
              i_byte++;
            }
            return res2;
          } else if (bipp === 8) {
            const res2 = new this.constructor({
              size: this.size,
              bits_per_pixel: 24
            });
            const ta_res = res2.ta;
            const ta2 = this.ta, l2 = ta2.length;
            let pos_w = 0, c2 = 0;
            for (c2 = 0; c2 < l2; c2++) {
              ta_res[pos_w++] = ta2[c2];
              ta_res[pos_w++] = ta2[c2];
              ta_res[pos_w++] = ta2[c2];
            }
            return res2;
          } else if (bipp === 24) {
            return this.clone();
          } else if (bipp === 32) {
            const res2 = new this.constructor({
              size: this.size,
              bits_per_pixel: 24
            });
            console.trace();
            throw "NYI";
            while (i_px < num_px) {
              const col_32 = this.get_pixel_by_idx_32bipp(i_px);
              i_px += bypp2;
            }
            return res2;
          }
        }
        toString() {
          return JSON.stringify({
            buffer: "Uint8ClampedArray length " + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
          });
        }
        /*
        [inspect]() {
            return 'Pixel_Buffer_Core ' + this.toString();
        }
        */
        color_whole(color) {
          if (this.bytes_per_pixel === 1) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1];
            const buf = this.buffer;
            let i;
            for (i = 0; i < ta_32_scratch[0]; i++) {
              buf[i] = color;
            }
          } else if (this.bytes_per_pixel === 3) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1] * 3;
            const buf = this.buffer;
            let i, c2 = 0;
            for (i = 0; i < ta_32_scratch[0]; i++) {
              buf[c2++] = color[0];
              buf[c2++] = color[1];
              buf[c2++] = color[2];
            }
          } else if (this.bytes_per_pixel === 4) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1] * 4;
            const buf = this.buffer;
            let i, c2 = 0;
            for (i = 0; i < ta_32_scratch[0]; i++) {
              buf[c2++] = color[0];
              buf[c2++] = color[1];
              buf[c2++] = color[2];
              buf[c2++] = color[3];
            }
          } else {
            throw "Unsupported this.bytes_per_pixel: " + this.bytes_per_pixel;
          }
          return this;
        }
        crop(size) {
          let new_size = new Uint16Array([this.size[0] - size * 2, this.size[1] - size * 2]);
          let res2 = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new_size
          });
          if (this.pos) {
            res2.pos = new Int16Array([this.pos[0] - size, this.pos[1] - size]);
          }
          this.each_pixel_ta((pos, color) => {
            const new_pos = new Int16Array([pos[0] - size, pos[1] - size]);
            if (new_pos[0] >= 0 && new_pos[0] < new_size[0] && new_pos[1] >= 0 && new_pos[1] < new_size[1]) {
              res2.set_pixel_ta(new_pos, color);
            }
          });
          return res2;
        }
        uncrop(size, color) {
          let res2 = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new Uint16Array([this.size[0] + size * 2, this.size[1] + size * 2])
          });
          if (this.pos) res2.pos = this.pos;
          if (this.pos) {
          }
          res2.color_whole(color);
          console.log("size", size);
          this.each_pixel_ta((pos, color2) => {
            res2.set_pixel_ta(new Uint16Array([pos[0] + size, pos[1] + size]), color2);
          });
          return res2;
        }
        color_rect(bounds2, color) {
          console.trace();
          throw "NYI";
        }
        each_pixel_byte_index(cb) {
          const { bipp } = this;
          let ctu = true;
          const stop = () => ctu = false;
          if (bipp === 8) {
            const buf = this.buffer, l2 = buf.length, bpp = this.bytes_per_pixel;
            for (let c2 = 0; ctu && c2 < l2; c2 += bpp) {
              cb(c2, stop);
            }
          } else if (bipp === 24) {
            const buf = this.buffer, l2 = buf.length, bpp = this.bytes_per_pixel;
            for (let c2 = 0; ctu && c2 < l2; c2 += bpp) {
              cb(c2, stop);
            }
          } else if (bipp === 32) {
            const buf = this.buffer, l2 = buf.length, bpp = this.bytes_per_pixel;
            for (let c2 = 0; ctu && c2 < l2; c2 += bpp) {
              cb(c2, stop);
            }
          } else {
            console.trace();
            throw "NYI";
          }
        }
        /*
        each_pixel_pos(cb) {
            const b = this.size;
            const pos = new Int16Array(2);
            for (pos[1] = 0; pos[1] < b[1]; pos[1]++) {
                for (pos[0] = 0; pos[0] < b[0]; pos[0]++) {
                    cb(pos);
                }
            }
        }
        */
        each_ta_24bipp(ta_pos, ta_px_value, ta_info, callback2) {
          const bipp = this.bipp;
          if (bipp === 24) {
            if (ta_pos instanceof Int16Array || ta_pos instanceof Int32Array && ta_pos.length >= 2) {
              if (ta_px_value instanceof Uint8ClampedArray && ta_px_value.length >= 3) {
                if (ta_info instanceof Uint32Array && ta_info.length >= 4) {
                  const ta2 = this.ta;
                  ta_info[0] = this.size[0];
                  ta_info[1] = this.size[1];
                  ta_info[2] = 0;
                  ta_info[3] = 24;
                  const update = () => {
                    ta2[ta_info[2] * 3] = ta_px_value[0];
                    ta2[ta_info[2] * 3 + 1] = ta_px_value[1];
                    ta2[ta_info[2] * 3 + 2] = ta_px_value[2];
                  };
                  for (ta_pos[1] = 0; ta_pos[1] < ta_info[1]; ta_pos[1]++) {
                    for (ta_pos[0] = 0; ta_pos[0] < ta_info[0]; ta_pos[0]++) {
                      ta_px_value[0] = ta2[ta_info[2] * 3];
                      ta_px_value[1] = ta2[ta_info[2] * 3 + 1];
                      ta_px_value[2] = ta2[ta_info[2] * 3 + 2];
                      callback2(update);
                      ta_info[2]++;
                    }
                  }
                }
              }
            }
          } else {
            throw "each_ta_24bipp error: bipp must be 24, bipp: " + bipp;
          }
        }
        each_ta_1bipp(ta_pos, ta_px_value, ta_info, callback2) {
          const bipp = this.bipp;
          if (bipp === 1) {
            const [w, h] = this.size;
            for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
              for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
                const px = this.get_pixel_1bipp(ta_pos);
                ta_px_value[0] = px;
                callback2(px, ta_pos);
              }
            }
          } else {
            throw "each_ta_1bipp error: bipp must be 1, bipp: " + bipp;
          }
        }
        each_px_on_1bipp(ta_pos, ta_px_value, ta_info, callback2) {
          const bipp = this.bipp;
          if (bipp === 1) {
            const [w, h] = this.size;
            for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
              for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
                if (this.get_pixel_1bipp(ta_pos) === 1 | 0) {
                  callback2(1 | 0, ta_pos);
                }
              }
            }
          } else {
            throw "each_ta_1bipp error: bipp must be 1, bipp: " + bipp;
          }
        }
        each_px(ta_pos, ta_px_value, ta_info, callback2) {
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.each_ta_1bipp(ta_pos, ta_px_value, ta_info, callback2);
          } else if (bipp === 8) {
            return this.each_ta_8bipp(ta_pos, ta_px_value, ta_info, callback2);
          } else if (bipp === 24) {
            return this.each_ta_24bipp(ta_pos, ta_px_value, ta_info, callback2);
          } else if (bipp === 32) {
            return this.each_ta_32bipp(ta_pos, ta_px_value, ta_info, callback2);
          } else {
            console.trace();
            throw "Unsupported bipp: " + bipp;
          }
        }
        paint_pixel_list(pixel_pos_list, color) {
          pixel_pos_list.each_pixel((pos) => {
            this.set_pixel_ta(pos, color);
          });
        }
        "get_pixel_byte_bit_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          const bit = idx & 7;
          return { byte, bit };
        }
        "get_pixel_byte_bit_BE_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          const bit = idx & 7;
          return { byte, bit };
        }
        set_pixel_on_1bipp_by_pixel_index(pixel_index) {
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        "set_pixel_on_1bipp_xy"(x, y) {
          const pixel_index = y * this.size[0] + x;
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        "set_pixel_on_1bipp"(pos) {
          const pixel_index = pos[1] * this.size[0] + pos[0];
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        set_pixel_off_1bipp_by_pixel_index(pixel_index) {
          this.ta[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
        }
        "set_pixel_off_1bipp"(pos) {
          const pixel_idx = pos[1] * this.size[0] + pos[0];
          this.ta[pixel_idx >> 3] &= ~(128 >> (pixel_idx & 7)) & 255;
        }
        "set_pixel_1bipp"(pos, color) {
          const idx_bit = pos[1] * this.size[0] + pos[0];
          const byte = idx_bit >> 3;
          const bit = idx_bit & 7;
          if (color === 1) {
            this.ta[byte] |= 128 >> bit;
          } else {
            this.ta[byte] &= ~(128 >> bit) & 255;
          }
        }
        "set_pixel_8bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          this.ta[idx] = color;
        }
        "set_pixel_24bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          let byte = idx * 3;
          this.ta[byte++] = color[0];
          this.ta[byte++] = color[1];
          this.ta[byte] = color[2];
        }
        "set_pixel_32bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          let byte = idx * 4;
          this.ta[byte++] = color[0];
          this.ta[byte++] = color[1];
          this.ta[byte++] = color[2];
          this.ta[byte] = color[3];
        }
        "set_pixel_by_idx_8bipp"(idx, color) {
          const byte = idx;
          this.ta[byte] = color;
        }
        "set_pixel_by_idx_24bipp"(idx, color) {
          const byte = idx * 3;
          this.ta[byte] = color[0];
          this.ta[byte + 1] = color[1];
          this.ta[byte + 2] = color[2];
        }
        "set_pixel_by_idx_32bipp"(idx, color) {
          const byte = idx * 4;
          this.ta[byte] = color[0];
          this.ta[byte + 1] = color[1];
          this.ta[byte + 2] = color[2];
          this.ta[byte + 3] = color[3];
        }
        "set_pixel_by_idx"(idx, color) {
          const a = arguments;
          const l2 = a.length;
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.set_pixel_by_idx_1bipp(a[0], a[1]);
          } else if (bipp === 8) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_8bipp(a[0], a[1]);
            }
          } else if (bipp === 24) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_24bipp(a[0], a[1]);
            }
          } else if (bipp === 32) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_32bipp(a[0], a[1]);
            }
          }
        }
        "set_pixel"(pos, color) {
          const a = arguments;
          const l2 = a.length;
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.set_pixel_1bipp(a[0], a[1]);
          } else if (bipp === 8) {
            if (l2 === 2) {
              return this.set_pixel_8bipp(a[0], a[1]);
            }
          } else if (bipp === 24) {
            if (l2 === 2) {
              return this.set_pixel_24bipp(a[0], a[1]);
            }
          } else if (bipp === 32) {
            if (l2 === 2) {
              return this.set_pixel_32bipp(a[0], a[1]);
            }
          } else {
            console.trace();
            throw "unsupported bipp: " + bipp;
          }
        }
        "get_pixel_by_idx_1bipp"(idx) {
          const byte = idx >> 3;
          const bit = idx & 7;
          const pow = 128 >> bit;
          return (this.ta[byte] & pow) === pow ? 1 : 0;
        }
        "get_pixel_by_idx_8bipp"(idx) {
          const byte = idx;
          return this.ta[byte];
        }
        "get_pixel_by_idx_24bipp"(idx) {
          const byte = idx * 3;
          return this.ta.slice(byte, byte + 3);
        }
        "get_pixel_by_idx_32bipp"(idx) {
          const byte = idx * 4;
          return this.ta.slice(byte, byte + 4);
        }
        "get_pixel_by_idx"(idx) {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            return this.get_pixel_by_idx_1bipp(idx);
          } else if (bipp === 8) {
            return this.get_pixel_by_idx_8bipp(idx);
          } else if (bipp === 24) {
            return this.get_pixel_by_idx_24bipp(idx);
          } else if (bipp === 32) {
            return this.get_pixel_by_idx_32bipp(idx);
          } else {
            throw "Unsupported bipp";
          }
        }
        "get_pixel_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          return (this.ta[byte] & 128 >> (idx & 7)) !== 0 ? 1 : 0;
        }
        "get_pixel_8bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx;
          return this.ta[byte];
        }
        "get_pixel_24bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx * 3;
          return this.ta.slice(byte, byte + 3);
        }
        "get_pixel_32bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx * 4;
          return this.ta.slice(byte, byte + 4);
        }
        "get_pixel"(pos) {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            return this.get_pixel_1bipp(pos);
          } else if (bipp === 8) {
            return this.get_pixel_8bipp(pos);
          } else if (bipp === 24) {
            return this.get_pixel_24bipp(pos);
          } else if (bipp === 32) {
            return this.get_pixel_32bipp(pos);
          } else {
            console.trace();
            throw "bits per pixels error";
          }
        }
        get num_px() {
          return this.size[0] * this.size[1];
        }
        get split_rgb_channels() {
          const [bipp, bypp2] = [this.bits_per_pixel, this.bytes_per_pixel];
          if (bipp === 24 || bipp === 32) {
            const res2 = [new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            })];
            const [r, g, b] = res2;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta2 = this.ta;
            while (i_px < num_px) {
              ta_r[i_px] = ta2[i_byte];
              ta_g[i_px] = ta2[i_byte + 1];
              ta_b[i_px] = ta2[i_byte + 2];
              i_px++;
              i_byte += bypp2;
            }
            return res2;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        process(fn) {
          let res2 = this.clone();
          return fn(this, res2);
        }
        /*
            function typedArraysAreEqual(a, b) {
        if (a.byteLength !== b.byteLength) return false;
        return a.every((val, i) => val === b[i]);
        }
            */
        equals(other_pixel_buffer) {
          let buf1 = this.ta;
          let buf2 = other_pixel_buffer.ta;
          const other_colorspace = other_pixel_buffer.ta_colorspace;
          const my_colorspace = other_pixel_buffer.ta_colorspace;
          if (my_colorspace.length === other_colorspace.length) {
            if (my_colorspace.every((val, i) => val === other_colorspace[i])) {
              if (buf1.length === buf2.length) {
                return buf1.every((val, i) => val === buf2[i]);
              } else {
              }
            } else {
            }
          }
          return false;
        }
        copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
          let bounds2 = pixel_pos_list.bounds;
          let size = new Uint16Array([bounds2[2] - bounds2[0] + 1, bounds2[3] - bounds2[1] + 1]);
          const res2 = new this.constructor({
            size,
            bytes_per_pixel: this.bytes_per_pixel
          });
          if (this.pos) res2.pos = this.pos;
          if (bg_color) {
            res2.color_whole(bg_color);
          }
          res2.pos = new Int16Array([bounds2[0], bounds2[1]]);
          pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([pos[0] - bounds2[0], pos[1] - bounds2[1]]);
            res2.set_pixel_ta(target_pos, color);
          });
          return res2;
        }
        // Pixel_Buffer_Pair_Complex_Operation class possibly?
        //   Or just Operation.
        // get_pre_operation_alignment_info ....
        // And could define such a class which has got requirements / invarients to do with 
        // This is used when drawing filled polygons.
        "draw_1bipp_pixel_buffer_mask_1bipp"(pb_1bipp_mask, dest_pos, color) {
          function draw_bitmap(target, target_width, source, source_width, source_height, target_x, target_y) {
            const target_bytes_per_row = target_width + 7 >> 3;
            const source_bytes_per_row = source_width + 7 >> 3;
            for (let row = 0; row < source_height; row++) {
              const source_row_start = row * source_bytes_per_row;
              const target_row_start = (target_y + row) * target_bytes_per_row;
              const bit_offset = target_x & 7;
              let target_byte_index = target_row_start + (target_x >> 3);
              for (let col = 0; col < source_bytes_per_row; col++) {
                const source_byte = source[source_row_start + col];
                if (bit_offset === 0) {
                  target[target_byte_index] |= source_byte;
                } else {
                  const next_byte_index = target_byte_index + 1;
                  const shifted_byte = source_byte << bit_offset;
                  const carry_over = source_byte >> 8 - bit_offset;
                  target[target_byte_index] |= shifted_byte;
                  if (next_byte_index < target.length) {
                    target[next_byte_index] |= carry_over;
                  }
                }
                target_byte_index++;
              }
            }
          }
          const chatgpto1_draw_bitmap_implementation = () => {
            draw_bitmap(this.ta, this.size[0], pb_1bipp_mask.ta, pb_1bipp_mask.size[0], pb_1bipp_mask.size[1], dest_pos[0], dest_pos[1]);
          };
          const arr_on_xspans_implementation = () => {
            const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
            const [width, height2] = pb_1bipp_mask.size;
            const [dest_x, dest_y] = dest_pos;
            if (color === 1) {
              for (let y = 0; y < height2; y++) {
                const target_y = y + dest_y;
                for (const xonspan of arr_rows_arr_on_xspans[y]) {
                  xonspan[0] += dest_x;
                  xonspan[1] += dest_x;
                  this.draw_horizontal_line_on_1bipp_inclusive(xonspan, target_y);
                }
              }
            } else {
              for (let y = 0; y < height2; y++) {
                const target_y = y + dest_y;
                for (const xonspan of arr_rows_arr_on_xspans[y]) {
                  xonspan[0] += dest_x;
                  xonspan[1] += dest_x;
                  this.draw_horizontal_line_off_1bipp_inclusive(xonspan, target_y);
                }
              }
            }
          };
          const approach_selecting = () => {
            {
              const can_do_bit_realigned_64_bit = test_can_do_bit_realigned_64_bit();
              if (can_do_bit_realigned_64_bit) {
                return arr_on_xspans_implementation();
              } else {
                return arr_on_xspans_implementation();
              }
            }
          };
          return chatgpto1_draw_bitmap_implementation();
        }
        "draw_1bipp_pixel_buffer_mask"(pb_1bipp_mask, dest_pos, color) {
          const { bipp } = this;
          if (bipp === 1) {
            return this.draw_1bipp_pixel_buffer_mask_1bipp(pb_1bipp_mask, dest_pos, color);
          } else {
            const arr_on_xspans_implementation = () => {
              const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
              const [width, height2] = pb_1bipp_mask.size;
              let y = 0;
              let [dest_x, dest_y] = dest_pos;
              for (y = 0; y < height2; y++) {
                const arr_row_xspans_on = arr_rows_arr_on_xspans[y];
                if (arr_row_xspans_on.length > 0) {
                  for (const xonspan of arr_row_xspans_on) {
                    xonspan[0] += dest_x;
                    xonspan[1] += dest_x;
                    this.draw_horizontal_line(xonspan, y + dest_y, color);
                  }
                }
              }
            };
            return arr_on_xspans_implementation();
          }
        }
        "blank_copy"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel
          });
          res2.buffer.fill(0);
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "clone"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel,
            "buffer": new this.buffer.constructor(this.buffer)
          });
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "add_alpha_channel"() {
          console.log("add_alpha_channel this.bytes_per_pixel", this.bytes_per_pixel);
          if (this.bytes_per_pixel === 3) {
            var res2 = new this.constructor({
              "size": this.size,
              "bytes_per_pixel": 4
            });
            if (this.pos) res2.pos = this.pos;
            const buf = this.buffer, res_buf = res2.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0, ir = 0;
            for (let p = 0; p < px_count; p++) {
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = 255;
            }
            return res2;
          }
          if (this.bytes_per_pixel === 4) {
            return this;
          }
        }
        "to_8bit_greyscale"() {
          if (this.bytes_per_pixel === 1) {
            return this;
          } else if (this.bytes_per_pixel === 3) {
            const res2 = new this.constructor({
              "size": this.size,
              "bits_per_pixel": 8
            });
            if (this.pos) res2.pos = this.pos;
            const bres = res2.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
              bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res2;
          } else if (this.bytes_per_pixel === 4) {
            const res2 = new this.constructor({
              "size": this.size,
              "bits_per_pixel": 8
            });
            if (this.pos) res2.pos = this.pos;
            const bres = res2.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
              bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res2;
          }
        }
        "to_32bit_rgba"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 32
          });
          if (this.pos) res2.pos = this.pos;
          const bres = res2.buffer;
          if (this.bytes_per_pixel === 1) {
            let i = 0, new_v;
            this.each_pixel((pos, v) => {
              bres[i++] = v;
              bres[i++] = v;
              bres[i++] = v;
              bres[i++] = 255;
            });
          } else {
            console.trace();
            throw "NYI";
          }
          return res2;
        }
        "__invert_greyscale_self"() {
          const bres = this.buffer;
          let i = 0;
          this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
          });
          return this;
        }
        "__invert_greyscale"() {
          let res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 8
          });
          if (this.pos) res2.pos = this.pos;
          const bres = res2.buffer;
          let i = 0;
          this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
          });
          return res2;
        }
        draw_rect(pos_corner, pos_other_corner, color) {
          const l2 = Math.min(pos_corner[0], pos_other_corner[0]);
          const t = Math.min(pos_corner[1], pos_other_corner[1]);
          const r = Math.max(pos_corner[0], pos_other_corner[0]);
          const b = Math.max(pos_corner[1], pos_other_corner[1]);
          const xspan = [l2, r];
          for (let y = t; y <= b; y++) {
            this.draw_horizontal_line(xspan, y, color);
          }
        }
        *"iterate_arr_row_x_on_spans_1bipp"(y) {
        }
        get xspans() {
        }
      };
      module.exports = Pixel_Buffer_Core;
      if (__require.main === module) {
        const lg = console.log;
        (async () => {
          const run_examples = async () => {
            lg("Begin run examples");
            const examples = [
              async () => {
                lg("Begin example 0");
                const pb = new Pixel_Buffer_Core({
                  bits_per_pixel: 1,
                  size: [8, 8]
                });
                const ta_pos = new Int16Array(2);
                ta_pos[0] = 3;
                ta_pos[1] = 3;
                pb.set_pixel(ta_pos, 1);
                lg("End example 0");
                return pb;
              }
            ];
            const l2 = examples.length;
            for (var c2 = 0; c2 < l2; c2++) {
              const res_eg = await examples[c2]();
              console.log("res_eg " + c2 + ":", res_eg);
            }
            ;
            lg("End run examples");
          };
          await run_examples();
        })();
      }
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-4-advanced-typedarray-properties.js
  var require_pixel_buffer_4_advanced_typedarray_properties = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-4-advanced-typedarray-properties.js"(exports, module) {
      var lang = require_lib_lang_mini3();
      var {
        each,
        fp,
        tof,
        get_a_sig: get_a_sig2,
        are_equal,
        tf: tf2
      } = lang;
      var oext = require_oext();
      var { ro, prop } = oext;
      var Pixel_Buffer_Core = require_pixel_buffer_3_core();
      var Pixel_Buffer_Advanced_TypedArray_Properties = class extends Pixel_Buffer_Core {
        constructor(...a) {
          super(...a);
          let ta_scratch;
          let ta_pos_scratch;
          let ta_pos_iterator;
          let ta_move_vector;
          let ta_bounds;
          let ta_24bit_color;
          let ta_32bit_color;
          let ta_row_scratch;
          let ta_bounds_scratch;
          let ta_bounds2_scratch;
          let ta_bounds3_scratch;
          let ta_bounds4_scratch;
          let ta_size_scratch;
          let ta_size2_scratch;
          let ta_pointers_scratch;
          let ta_pointers2_scratch;
          let ta_pointerpair_scratch;
          let ta_offsets_scratch;
          let ta_offsets_info_scratch;
          const setup_ta_ro_props = () => {
            ro(this, "ta_scratch", () => {
              if (!ta_scratch) {
                ta_scratch = new this.ta.constructor(this.ta);
              } else {
                if (ta_scratch.length !== this.ta.length) {
                  ta_scratch = new this.ta.constructor(this.ta);
                } else {
                  const l2 = this.ta.length;
                  for (c = 0; c < l2; c++) {
                    ta_scratch[c] = this.ta[c];
                  }
                }
              }
            });
            ro(this, "ta_row_scratch", () => {
              if (!ta_row_scratch) {
                ta_row_scratch = new Uint8ClampedArray(this.bypr);
              } else {
                if (ta_row_scratch.length !== this.bypr) {
                  ta_row_scratch = new Uint8ClampedArray(this.bypr);
                }
                return ta_row_scratch;
              }
            });
            ro(this, "ta_pos_scratch", () => {
              if (!ta_pos_scratch) {
                ta_pos_scratch = new Int16Array(2);
              }
              return ta_pos_scratch;
            });
            ro(this, "ta_pos_iterator", () => {
              if (!ta_pos_iterator) {
                ta_pos_iterator = new Int16Array(2);
              }
              return ta_pos_iterator;
            });
            ro(this, "ta_move_vector", () => {
              if (!ta_move_vector) {
                ta_move_vector = new Int16Array(2);
              }
              return ta_move_vector;
            });
            ro(this, "ta_bounds", () => {
              if (!ta_bounds) {
                ta_bounds = new Int16Array(4);
              }
              return ta_bounds;
            });
            ro(this, "ta_24bit_color", () => {
              if (!ta_24bit_color) {
                ta_24bit_color = new Uint8ClampedArray(3);
              }
              return ta_24bit_color;
            });
            ro(this, "ta_32bit_color", () => {
              if (!ta_32bit_color) {
                ta_32bit_color = new Uint8ClampedArray(4);
              }
              return ta_32bit_color;
            });
            ro(this, "ta_bounds_scratch", () => {
              if (!ta_bounds_scratch) {
                ta_bounds_scratch = new Int16Array(4);
              }
              return ta_bounds_scratch;
            });
            ro(this, "ta_bounds2_scratch", () => {
              if (!ta_bounds2_scratch) {
                ta_bounds2_scratch = new Int16Array(4);
              }
              return ta_bounds2_scratch;
            });
            ro(this, "ta_bounds3_scratch", () => {
              if (!ta_bounds3_scratch) {
                ta_bounds3_scratch = new Int16Array(4);
              }
              return ta_bounds3_scratch;
            });
            ro(this, "ta_bounds4_scratch", () => {
              if (!ta_bounds4_scratch) {
                ta_bounds4_scratch = new Int16Array(4);
              }
              return ta_bounds4_scratch;
            });
            ro(this, "ta_size_scratch", () => {
              if (!ta_size_scratch) {
                ta_size_scratch = new Uint16Array(2);
              }
              return ta_size_scratch;
            });
            ro(this, "ta_size2_scratch", () => {
              if (!ta_size2_scratch) {
                ta_size2_scratch = new Uint16Array(2);
              }
              return ta_size2_scratch;
            });
            ro(this, "ta_pointers_scratch", () => {
              if (!ta_pointers_scratch) {
                ta_pointers_scratch = new Uint32Array(4);
              }
              return ta_pointers_scratch;
            });
            ro(this, "ta_pointers2_scratch", () => {
              if (!ta_pointers2_scratch) {
                ta_pointers2_scratch = new Uint32Array(4);
              }
              return ta_pointers2_scratch;
            });
            ro(this, "ta_pointerpair_scratch", () => {
              if (!ta_pointerpair_scratch) {
                ta_pointerpair_scratch = new Uint32Array(2);
              }
              return ta_pointerpair_scratch;
            });
            ro(this, "ta_offsets_scratch", () => {
              if (!ta_offsets_scratch) {
                ta_offsets_scratch = new Int32Array(4);
              }
              return ta_offsets_scratch;
            });
            ro(this, "ta_offsets_info_scratch", () => {
              if (!ta_offsets_info_scratch) {
                ta_offsets_info_scratch = new Int32Array(8);
              }
              return ta_offsets_info_scratch;
            });
          };
          setup_ta_ro_props();
          const ta_colorspace = new Int16Array(6);
          Object.defineProperty(this, "ta_colorspace", {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
              ta_colorspace[0] = this.size[0];
              ta_colorspace[1] = this.size[1];
              let bpp = 0;
              if (this.ta_bpp && typeof this.ta_bpp[0] === "number") {
                bpp = this.ta_bpp[0];
              } else if (typeof this.bits_per_pixel === "number") {
                bpp = this.bits_per_pixel;
              } else if (typeof this.bytes_per_pixel === "number") {
                bpp = this.bytes_per_pixel * 8;
              }
              ta_colorspace[2] = bpp % 8 === 0 ? bpp / 8 : 0;
              ta_colorspace[3] = ta_colorspace[2] * ta_colorspace[0];
              ta_colorspace[4] = bpp;
              ta_colorspace[5] = ta_colorspace[4] * ta_colorspace[0];
              return ta_colorspace;
            },
            enumerable: true,
            configurable: false
          });
        }
      };
      module.exports = Pixel_Buffer_Advanced_TypedArray_Properties;
    }
  });

  // node_modules/jsgui3-gfx-core/core/convolution-kernels/kernels.js
  var require_kernels = __commonJS({
    "node_modules/jsgui3-gfx-core/core/convolution-kernels/kernels.js"(exports, module) {
      function generateGaussianKernel(dimension, sigma) {
        function hypotenuse(x1, y1, x2, y2) {
          var xSquare = Math.pow(x1 - x2, 2);
          var ySquare = Math.pow(y1 - y2, 2);
          return Math.sqrt(xSquare + ySquare);
        }
        if (!(dimension % 2) || Math.floor(dimension) !== dimension || dimension < 3) {
          throw new Error(
            "The dimension must be an odd integer greater than or equal to 3"
          );
        }
        var kernel = [];
        var twoSigmaSquare = 2 * sigma * sigma;
        var centre = (dimension - 1) / 2;
        for (var i = 0; i < dimension; i++) {
          for (var j = 0; j < dimension; j++) {
            var distance = hypotenuse(i, j, centre, centre);
            var gaussian = 1 / Math.sqrt(
              Math.PI * twoSigmaSquare
            ) * Math.exp(-1 * (Math.pow(distance, 2) / twoSigmaSquare));
            kernel.push(gaussian);
          }
        }
        var sum = kernel.reduce(function(c2, p) {
          return c2 + p;
        });
        return kernel.map(function(e) {
          return e / sum;
        });
      }
      module.exports = {
        "edge": new Float32Array(
          [
            -1,
            -1,
            -1,
            -1,
            8,
            -1,
            -1,
            -1,
            -1
          ]
        ),
        "gauss_blur_5_2": generateGaussianKernel(5, 2),
        "gauss_blur_5_5": generateGaussianKernel(5, 5),
        "get_gauss": (d, sigma) => new Float32Array(generateGaussianKernel(d, sigma)),
        "lap_gauss_5": new Int8Array([
          0,
          0,
          -1,
          0,
          0,
          0,
          -1,
          -2,
          -1,
          0,
          -1,
          -2,
          16,
          -2,
          -1,
          0,
          -1,
          -2,
          -1,
          0,
          0,
          0,
          -1,
          0,
          0
        ]),
        "sobel_x": new Int8Array([
          -1,
          0,
          1,
          -2,
          0,
          2,
          -1,
          0,
          1
        ]),
        "sobel_y": new Int8Array([
          1,
          2,
          1,
          0,
          0,
          0,
          -1,
          -2,
          -1
        ]),
        "sobel_diag_1": new Int8Array([
          0,
          1,
          2,
          -1,
          0,
          1,
          -2,
          -1,
          0
        ]),
        "sobel_diag_2": new Int8Array([
          -2,
          -1,
          0,
          -1,
          0,
          1,
          0,
          1,
          2
        ])
      };
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-5-idiomatic-enh.js
  var require_pixel_buffer_5_idiomatic_enh = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-5-idiomatic-enh.js"(exports, module) {
      var Pixel_Buffer_Advanced_TypedArray_Properties = require_pixel_buffer_4_advanced_typedarray_properties();
      var kernels = require_kernels();
      var Pixel_Buffer_Idiomatic_Enh = class extends Pixel_Buffer_Advanced_TypedArray_Properties {
        constructor(...a) {
          super(...a);
        }
        each_pixel_pos(callback2) {
          const { ta_pos_scratch, size } = this;
          let ctu = true;
          const stop = () => {
            ctu = false;
          };
          for (ta_pos_scratch[1] = 0; ctu === true && ta_pos_scratch[1] < size[1]; ta_pos_scratch[1]++) {
            for (ta_pos_scratch[0] = 0; ctu === true && ta_pos_scratch[0] < size[0]; ta_pos_scratch[0]++) {
              callback2(ta_pos_scratch, stop);
            }
          }
        }
        count_colors() {
          const map_colors = {};
          let res2 = 0;
          this.each_pixel_ta((pos, color) => {
            const colstr = color.toString();
            if (!map_colors[colstr]) {
              map_colors[colstr] = true;
              res2++;
            }
          });
          return res2;
        }
        blur(size = 3, sigma = 2) {
          let kernel = kernels.get_gauss(size, sigma);
          return this.apply_square_convolution(kernel);
        }
        count_pixels_with_color(color) {
          let res2 = 0;
          console.log("idiomatic count_pixels_with_color");
          const { bipp } = this;
          if (bipp <= 8) {
            this.each_pixel((pos, pixel_color) => {
              if (pixel_color === color) res2++;
            });
          } else if (bipp === 24) {
            this.each_pixel((pos, pixel_color) => {
              if (pixel_color[0] === color[0] && pixel_color[1] === color[1] && pixel_color[2] === color[2]) {
                res2++;
              }
            });
          } else if (bipp === 32) {
            this.each_pixel((pos, pixel_color) => {
              if (pixel_color[0] === color[0] && pixel_color[1] === color[1] && pixel_color[2] === color[2] && pixel_color[3] === color[3]) {
                res2++;
              }
            });
          } else {
            console.trace();
            throw "NYI";
          }
          return res2;
        }
      };
      module.exports = Pixel_Buffer_Idiomatic_Enh;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-6-perf-focus-enh.js
  var require_pixel_buffer_6_perf_focus_enh = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-6-perf-focus-enh.js"(exports, module) {
      var Pixel_Buffer_Idiomatic_Enh = require_pixel_buffer_5_idiomatic_enh();
      var Pixel_Pos_List = require_pixel_pos_list();
      var get_idx_movement_vectors = (f32a_convolution, bpp, bpr) => {
        const c_length = f32a_convolution.length;
        const dimension_size = Math.sqrt(c_length);
        const padding = (dimension_size - 1) / 2;
        const movement_vectors = new Int8Array(c_length * 2);
        let x, y, pos = 0;
        const idx_movement_vectors = new Int16Array(c_length);
        for (y = -1 * padding; y <= padding; y++) {
          for (x = -1 * padding; x <= padding; x++) {
            movement_vectors[pos++] = x;
            movement_vectors[pos++] = y;
          }
        }
        pos = 0;
        let ii, i;
        for (i = 0; i < c_length; i++) {
          x = movement_vectors[pos++];
          y = movement_vectors[pos++];
          idx_movement_vectors[i] = x * bpp + y * bpr;
        }
        return idx_movement_vectors;
      };
      var get_points_bounding_box = (points) => {
        let min_x = Number.POSITIVE_INFINITY;
        let min_y = Number.POSITIVE_INFINITY;
        let max_x = Number.NEGATIVE_INFINITY;
        let max_y = Number.NEGATIVE_INFINITY;
        for (const [x, y] of points) {
          if (x < min_x) min_x = x;
          if (x > max_x) max_x = x;
          if (y < min_y) min_y = y;
          if (y > max_y) max_y = y;
        }
        return [
          [min_x, min_y],
          [max_x, max_y]
        ];
      };
      var Pixel_Buffer_Perf_Focus_Enh = class extends Pixel_Buffer_Idiomatic_Enh {
        constructor(spec) {
          super(spec);
        }
        get ta_is_64bit_divisible() {
          return (this.ta.length & 63) === 0;
        }
        get ta_is_32bit_divisible() {
          return (this.ta.length & 31) === 0;
        }
        get ta64() {
          if (this._ta64) {
            return this._ta64;
          } else {
          }
          if (this.ta_is_64bit_divisible) {
            if (this.ta.byteOffset % 8 === 0) {
              this._ta64 = new BigUint64Array(this.ta.buffer, this.ta.byteOffset, this.ta.byteLength / 8);
              return this._ta64;
            } else {
              console.error("The byte offset is not aligned to 8 bytes.");
            }
          } else {
            return false;
          }
        }
        get is_32bit_divisible_image() {
          return (this.ta.length & 31) === 0;
        }
        get is_32_divisible_bits_per_row() {
          return (this.bits_per_row & 31) === 0;
        }
        get number_of_32bit_segments_per_32bit_divisible_row() {
          return this.bits_per_row >> 5;
        }
        get is_64bit_divisible_image() {
          return (this.ta.length & 63) === 0;
        }
        get is_64_divisible_bits_per_row() {
          return (this.bits_per_row & 63) === 0;
        }
        get number_of_64bit_segments_per_64bit_divisible_row() {
          return this.bits_per_row >> 6;
        }
        get bits_per_image_1bipp() {
          return this.size[0] * this.size[1];
        }
        get number_of_64bit_segments_per_64bit_divisible_image() {
          return this.bits_per_image_1bipp >> 6;
        }
        iterate_all_ui32_locations_1bipp(cb) {
          const ui32a_px_range = new Uint32Array(4);
          if (this.ta_is_32bit_divisible) {
            if (this.is_32_divisible_bits_per_row) {
              const number_of_32bit_segments_per_32bit_divisible_row = this.number_of_32bit_segments_per_32bit_divisible_row;
              if (number_of_32bit_segments_per_32bit_divisible_row === 1) {
                const height2 = this.size[1];
                const first_x = 0, last_x = 31;
                ui32a_px_range[0] = first_x;
                ui32a_px_range[2] = last_x;
                let y = 0;
                for (let i = 0; i < height2; i++) {
                  ui32a_px_range[1] = y;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  y++;
                }
              } else if (number_of_32bit_segments_per_32bit_divisible_row === 2) {
                const height2 = this.size[1];
                const number_of_32bit_segments = height2 * number_of_32bit_segments_per_32bit_divisible_row;
                let even = true;
                let y = 0;
                let first_x = 0, last_x = 63;
                for (let i = 0; i < number_of_32bit_segments; i++) {
                  ui32a_px_range[0] = first_x;
                  ui32a_px_range[1] = y;
                  ui32a_px_range[2] = last_x;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  if (!even) {
                    y++;
                    first_x = 0;
                    last_x = 31;
                  } else {
                    first_x = 32;
                    last_x = 63;
                  }
                  even = !even;
                }
              } else {
                const height2 = this.size[1];
                const number_of_32bit_segments = height2 * number_of_32bit_segments_per_32bit_divisible_row;
                let y = 0;
                let first_x = 0, last_x = 31;
                let i_row_segment = 0;
                for (let i = 0; i < number_of_32bit_segments; i++) {
                  ui32a_px_range[0] = first_x;
                  ui32a_px_range[1] = y;
                  ui32a_px_range[2] = last_x;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  i_row_segment++;
                  if (i_row_segment < number_of_32bit_segments_per_32bit_divisible_row) {
                    first_x += 32;
                    last_x += 32;
                  } else {
                    i_row_segment = 0;
                    y++;
                    first_x = 0;
                    last_x = 31;
                  }
                }
              }
            } else {
            }
          } else {
          }
        }
        iterate_all_ui32_locations_values_prev_values_prev_shifted_values_toggle_locations_1bipp(cb) {
          const ui32a_res = new Uint32Array(12);
          if (this.ta_is_32bit_divisible) {
            const { ta: ta2 } = this;
            const dv = new DataView(ta2.buffer, ta2.byteOffset, ta2.byteLength);
            if (this.is_32_divisible_bits_per_row) {
              const number_of_32bit_segments_per_32bit_divisible_row = this.number_of_32bit_segments_per_32bit_divisible_row;
              if (number_of_32bit_segments_per_32bit_divisible_row === 1) {
                const height2 = this.size[1];
                const first_x = 0, last_x = 31;
                ui32a_res[0] = first_x;
                ui32a_res[2] = last_x;
                let y = 0;
                let b = 0;
                for (let i = 0; i < height2; i++) {
                  ui32a_res[1] = y;
                  ui32a_res[3] = y;
                  const ui32_value = dv.getUint32(b);
                  ui32a_res[5] = ui32_value;
                  cb(ui32a_res);
                  y++;
                  b += 4;
                }
              } else if (number_of_32bit_segments_per_32bit_divisible_row === 2) {
                const height2 = this.size[1];
                const number_of_32bit_segments = height2 * number_of_32bit_segments_per_32bit_divisible_row;
                let even = true;
                let y = 0;
                let b = 0;
                let first_x = 0, last_x = 63;
                let ui32_prev_value = 0;
                for (let i = 0; i < number_of_32bit_segments; i++) {
                  ui32a_res[0] = first_x;
                  ui32a_res[1] = y;
                  ui32a_res[2] = last_x;
                  ui32a_res[3] = y;
                  const ui32_value = dv.getUint32(b);
                  ui32a_res[4] = ui32_prev_value;
                  ui32a_res[5] = ui32_value;
                  cb(ui32a_res);
                  if (!even) {
                    y++;
                    first_x = 0;
                    last_x = 31;
                  } else {
                    first_x = 32;
                    last_x = 63;
                  }
                  even = !even;
                  b += 4;
                  ui32_prev_value = ui32_value;
                }
              } else {
                const height2 = this.size[1];
                const number_of_32bit_segments = height2 * number_of_32bit_segments_per_32bit_divisible_row;
                let y = 0;
                let first_x = 0, last_x = 31;
                let i_row_segment = 0;
                let b = 0;
                let ui32_prev_value = 0;
                for (let i = 0; i < number_of_32bit_segments; i++) {
                  ui32a_res[0] = first_x;
                  ui32a_res[1] = y;
                  ui32a_res[2] = last_x;
                  ui32a_res[3] = y;
                  const ui32_value = dv.getUint32(b);
                  ui32a_res[4] = ui32_prev_value;
                  ui32a_res[5] = ui32_value;
                  if (first_x === 0) {
                    ui32a_res[6] = 0;
                  } else {
                    ui32a_res[6] = ui32_prev_value << 31;
                  }
                  ui32a_res[7] = ui32_value >>> 1;
                  ui32a_res[8] = ui32a_res[6] | ui32a_res[7];
                  ui32a_res[9] = ui32_value ^ ui32a_res[8];
                  cb(ui32a_res);
                  i_row_segment++;
                  if (i_row_segment < number_of_32bit_segments_per_32bit_divisible_row) {
                    first_x += 32;
                    last_x += 32;
                  } else {
                    i_row_segment = 0;
                    y++;
                    first_x = 0;
                    last_x = 31;
                  }
                  b += 4;
                  ui32_prev_value = ui32_value;
                }
              }
            } else {
            }
          } else {
          }
        }
        iterate_all_ui64_locations_1bipp(cb) {
          const ui32a_px_range = new Uint32Array(4);
          if (this.ta_is_64bit_divisible) {
            if (this.is_64_divisible_bits_per_row) {
              const number_of_64bit_segments_per_64bit_divisible_row = this.number_of_64bit_segments_per_64bit_divisible_row;
              if (number_of_64bit_segments_per_64bit_divisible_row === 1) {
                const height2 = this.size[1];
                const first_x = 0, last_x = 63;
                ui32a_px_range[0] = first_x;
                ui32a_px_range[2] = last_x;
                let y = 0;
                for (let i = 0; i < height2; i++) {
                  ui32a_px_range[1] = y;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  y++;
                }
              } else if (number_of_64bit_segments_per_64bit_divisible_row === 2) {
                const height2 = this.size[1];
                const number_of_64bit_segments = height2 * number_of_64bit_segments_per_64bit_divisible_row;
                let even = true;
                let y = 0;
                let first_x = 0, last_x = 63;
                for (let i = 0; i < number_of_64bit_segments; i++) {
                  ui32a_px_range[0] = first_x;
                  ui32a_px_range[1] = y;
                  ui32a_px_range[2] = last_x;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  if (!even) {
                    y++;
                    first_x = 0;
                    last_x = 63;
                  } else {
                    first_x = 64;
                    last_x = 127;
                  }
                  even = !even;
                }
              } else {
                const height2 = this.size[1];
                const number_of_64bit_segments = height2 * number_of_64bit_segments_per_64bit_divisible_row;
                let y = 0;
                let first_x = 0, last_x = 63;
                let i_row_segment = 0;
                for (let i = 0; i < number_of_64bit_segments; i++) {
                  ui32a_px_range[0] = first_x;
                  ui32a_px_range[1] = y;
                  ui32a_px_range[2] = last_x;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  i_row_segment++;
                  if (i_row_segment < number_of_64bit_segments_per_64bit_divisible_row) {
                    first_x += 64;
                    last_x += 64;
                  } else {
                    i_row_segment = 0;
                    y++;
                    first_x = 0;
                    last_x = 63;
                  }
                }
              }
            } else {
            }
          } else {
          }
        }
        iterate_all_ui64_values_1bipp() {
        }
        iterate_1bipp_wrapping_x_span_color_toggles(cb) {
          const { ta: ta2 } = this;
          const r1shifted_ta = right_shift_32bit_with_carry(ta2);
          const xored_against_orig = xor_typed_arrays(ta2, r1shifted_ta);
          each_1_index(xored_against_orig, cb);
        }
        count_1bipp_wrapping_x_span_color_toggles() {
          const { ta: ta2 } = this;
          const r1shifted_ta = right_shift_32bit_with_carry(ta2);
          const xored_against_orig = xor_typed_arrays(ta2, r1shifted_ta);
          return count_1s(xored_against_orig);
        }
        "place_image_from_pixel_buffer"(pixel_buffer, dest_pos, options = {}) {
          const { bipp } = this;
          const dest_buffer = this.buffer;
          const source_buffer = pixel_buffer.buffer;
          if (bipp === 32 && pixel_buffer.bits_per_pixel === 32) {
            const dest_w = this.size[0];
            const dest_h = this.size[1];
            const dest_buffer_line_length = dest_w * 4;
            const source_w = pixel_buffer.size[0];
            const source_h = pixel_buffer.size[1];
            const source_buffer_line_length = source_w * 4;
            let source_buffer_line_start_pos, source_buffer_line_end_pos, dest_buffer_subline_start_pos, dest_buffer_start_offset;
            dest_buffer_start_offset = dest_pos[0] * 4;
            for (var y = 0; y < source_h; y++) {
              source_buffer_line_start_pos = y * source_buffer_line_length;
              source_buffer_line_end_pos = source_buffer_line_start_pos + source_buffer_line_length;
              dest_buffer_subline_start_pos = (y + dest_pos[1]) * dest_buffer_line_length;
              source_buffer.copy(dest_buffer, dest_buffer_subline_start_pos + dest_buffer_start_offset, source_buffer_line_start_pos, source_buffer_line_end_pos);
            }
          } else if (bipp === 1) {
            if (pixel_buffer.bipp === 1) {
              if (options.or === true) {
                return this.draw_1bipp_pixel_buffer_mask_1bipp(pixel_buffer, dest_pos);
              } else {
                const pb_source2 = pixel_buffer;
                const ta_pos = new Int16Array(2);
                const ta_px_value = new Uint8ClampedArray(3);
                const ta_info = new Uint32Array(4);
                const px_dest_pos = new Uint16Array(2);
                pb_source2.each_ta_1bipp(ta_pos, ta_px_value, ta_info, (color, pos) => {
                  px_dest_pos[0] = pos[0] + dest_pos[0];
                  px_dest_pos[1] = pos[1] + dest_pos[1];
                  this.set_pixel(px_dest_pos, color);
                });
              }
            } else {
              console.trace();
              throw "must have matching bipp values (expected: 1)";
            }
          } else {
            console.trace();
            console.log("[pixel_buffer, dest_pos, options]", [pixel_buffer, dest_pos, options]);
            throw "not currently supported";
          }
        }
        draw_filled_polygon_to_1bipp_pixel_buffer_mask(arr_points) {
          if (arr_points.length >= 2) {
            const bb_points = get_points_bounding_box(arr_points);
            const offset2 = bb_points[0];
            const polygon_size2 = [
              [bb_points[1][0] - bb_points[0][0] + 1],
              [bb_points[1][1] - bb_points[0][1] + 1]
            ];
            if (polygon_size2[0] === 1 && polygon_size2[1] === 1) {
              const pb_polygon = new this.constructor({
                "bits_per_pixel": 1,
                "size": polygon_size2
              });
              pb_polygon.ta[0] = 128;
              pb_polygon.__offset = offset2;
              return pb_polygon;
            } else if (polygon_size2[0] === 2 && polygon_size2[1] === 1 || polygon_size2[0] === 1 && polygon_size2[1] === 2) {
              const pb_polygon = new this.constructor({
                "bits_per_pixel": 1,
                "size": polygon_size2
              });
              pb_polygon.ta[0] = 192;
              pb_polygon.__offset = offset2;
              return pb_polygon;
            } else {
              const pb_polygon = new this.constructor({
                "bits_per_pixel": 1,
                "size": polygon_size2
              });
              const down_offsetted_points = arr_points.map((point) => [point[0] - offset2[0], point[1] - offset2[1]]);
              pb_polygon.draw_polygon(down_offsetted_points, 1, false);
              pb_polygon.flood_fill_inner_pixels_off_to_on_1bipp();
              pb_polygon.__offset = offset2;
              return pb_polygon;
            }
          } else if (arr_points.length === 1) {
            const pb_polygon = new this.constructor({
              "bits_per_pixel": 1,
              "size": polygon_size
            });
            pb_polygon.ta[0] = 128;
            pb_polygon.__offset = offset;
            return pb_polygon;
          }
        }
        get ta2() {
          if (!this._ta2) {
            this._ta2 = new Uint8Array(this.ta.length);
          }
          return this._ta2;
        }
        apply_square_convolution(f32a_convolution) {
          return this.process((orig, res2) => {
            const c_length = f32a_convolution.length;
            const dimension_size = Math.sqrt(c_length);
            const padding = (dimension_size - 1) / 2;
            let x, y, pos = 0, ii, i;
            const bpp = this.bytes_per_pixel;
            const bpr = this.bytes_per_row;
            const idx_movement_vectors = get_idx_movement_vectors(f32a_convolution, bpp, bpr);
            let cr, cg, cb, ca;
            const buf = this.buffer;
            const buf_res = res2.buffer;
            if (bpp === 3) {
              this.padded_each_pixel_index(padding, (px_idx) => {
                cr = 0;
                cg = 0;
                cb = 0;
                for (ii = 0; ii < c_length; ii++) {
                  i = px_idx + idx_movement_vectors[ii];
                  cr += f32a_convolution[ii] * buf[i++];
                  cg += f32a_convolution[ii] * buf[i++];
                  cb += f32a_convolution[ii] * buf[i++];
                }
                if (cr < 0) cr = 0;
                if (cg < 0) cg = 0;
                if (cb < 0) cb = 0;
                if (cr > 255) cr = 255;
                if (cg > 255) cg = 255;
                if (cb > 255) cb = 255;
                buf_res[px_idx++] = Math.round(cr);
                buf_res[px_idx++] = Math.round(cg);
                buf_res[px_idx++] = Math.round(cb);
              });
            } else if (bpp === 4) {
              this.padded_each_pixel_index(padding, (px_idx) => {
                cr = 0;
                cg = 0;
                cb = 0;
                for (ii = 0; ii < c_length; ii++) {
                  i = px_idx + idx_movement_vectors[ii];
                  cr += f32a_convolution[ii] * buf[i++];
                  cg += f32a_convolution[ii] * buf[i++];
                  cb += f32a_convolution[ii] * buf[i++];
                }
                ca = 255;
                if (cr < 0) cr = 0;
                if (cg < 0) cg = 0;
                if (cb < 0) cb = 0;
                if (cr > 255) cr = 255;
                if (cg > 255) cg = 255;
                if (cb > 255) cb = 255;
                buf_res[px_idx++] = Math.round(cr);
                buf_res[px_idx++] = Math.round(cg);
                buf_res[px_idx++] = Math.round(cb);
                buf_res[px_idx++] = Math.round(ca);
              });
            } else {
              throw "NYI";
            }
            return res2;
          });
        }
        extract_channel(i_channel) {
          const bypp2 = this.bytes_per_pixel;
          const ta2 = this.ta;
          let i_byte = i_channel;
          let i_px = 0;
          const l2 = ta2.length;
          if (bypp2 === 3 || bypp2 === 4) {
            const res_channel_ta = new this.constructor({
              size: this.size,
              bits_per_pixel: 8
            });
            while (i_byte < l2) {
              res_channel_ta.set_pixel_by_idx(i_px, ta2[i_byte]);
              i_byte += bypp2;
              i_px++;
            }
            return res_channel_ta;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        _custom_convolve(dimension_size, cb) {
          if (dimension_size % 2 !== 1) {
            throw "dimension_size must be an odd integer";
          }
          const px = new Uint16Array(2);
          const ta16 = new Int16Array(12);
          [ta16[2], ta16[3]] = this.size;
          ta16[4] = this.bytes_per_pixel;
          ta16[5] = ta16[2] * ta16[4];
          ta16[8] = dimension_size;
          ta16[9] = (ta16[8] - 1) / 2;
          ta16[10] = 0;
          ta16[11] = ta16[8] * ta16[4];
          let ta32 = new Uint32Array(4);
          ta32[0] = 0;
          ta32[1] = 0;
          ta32[2] = ta16[2] * ta16[3] * ta16[4];
          let conv_pixels = new Uint8Array(ta16[8] * ta16[8] * ta16[8]);
          const buffer = this.buffer;
          for (px[1] = 0; px[1] < ta16[3]; px[1]++) {
            for (px[0] = 0; px[0] < ta16[2]; px[0]++) {
              ta16[6] = px[0] - ta16[8];
              if (ta16[6] > 0 && ta16[6] < ta16[2] - ta16[8]) {
                ta16[7] = px[1] - ta16[8];
                if (ta16[7] > 0 && ta16[7] < ta16[3] - ta16[8]) {
                  ta32[1] = ta32[0] - ta16[9] * ta16[4] - ta16[9] * ta16[5];
                  ta16[10] = 0;
                  for (ta16[7] = ta16[1]; ta16[7] < ta16[1] + ta16[8]; ta16[7]++) {
                    let sl = buffer.slice(ta32[1], ta32[1] + ta16[11]);
                    for (let c2 = 0; c2 < ta16[11]; c2++) {
                      conv_pixels[ta16[10] + c2] = sl.readUInt8(c2);
                    }
                    ta16[10] += ta16[11];
                    ta32[1] += ta16[5];
                  }
                  cb(px, conv_pixels);
                }
              }
              ta32[0] += ta16[4];
            }
          }
        }
        get_first_pixel_matching_color(r, g, b, a) {
          let px = 0, py = 0;
          let [w, h] = this.size;
          let found = false;
          let buf = this.buffer;
          let pos_buf = 0;
          for (py = 0; !found && py < h; py++) {
            for (px = 0; !found && px < w; px++) {
              if (buf[pos_buf] === r && buf[pos_buf + 1] === g && buf[pos_buf + 2] === b && buf[pos_buf + 3] === a) {
                found = true;
              }
              pos_buf += 4;
            }
          }
          if (found) {
            return [px, py];
          }
        }
        "flood_fill_small_color_blocks"(max_size, r, g, b, a) {
          this.each_pixel((x, y, pr, pg, pb, pa) => {
            if (r !== pr || g !== pg || b !== pb || a !== pa) {
              let s = this.measure_color_region_size(x, y, max_size);
              if (s < max_size) {
                this.flood_fill(x, y, r, g, b, a);
              }
            }
          });
        }
        self_replace_color(target_color, replacement_color) {
          const bpp = this.bytes_per_pixel;
          const buf = this.buffer;
          const l2 = buf.length;
          if (bpp === 1) {
            for (let c2 = 0; c2 < l2; c2++) {
              if (buf[c2] === target_color) buf[c2] = replacement_color;
            }
          } else {
            throw "NYI";
          }
          return this;
        }
        "_replace_color"(r, g, b, a, tr, tg, tb, ta2) {
          const buf_read = this.buffer;
          let ta_u8 = new Uint8Array(8);
          ta_u8[0] = r;
          ta_u8[1] = g;
          ta_u8[2] = b;
          ta_u8[3] = a;
          ta_u8[4] = tr;
          ta_u8[5] = tg;
          ta_u8[6] = tb;
          ta_u8[7] = ta2;
          const ta_16_scratch = new Uint32Array(8);
          ta_16_scratch[0] = 0;
          ta_16_scratch[2] = buf_read.length;
          while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]] === ta_u8[0] && buf_read[ta_16_scratch[0] + 1] === ta_u8[1] && buf_read[ta_16_scratch[0] + 2] === ta_u8[2] && buf_read[ta_16_scratch[0] + 3] === ta_u8[3]) {
              buf_read[ta_16_scratch[0]] = ta_u8[4];
              buf_read[ta_16_scratch[0] + 1] = ta_u8[5];
              buf_read[ta_16_scratch[0] + 2] = ta_u8[6];
              buf_read[ta_16_scratch[0] + 3] = ta_u8[7];
            } else {
            }
            ta_16_scratch[0] += 4;
          }
        }
        "__get_single_color_mask_32"(r, g, b, a) {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 32
          });
          res2.buffer.fill(0);
          const buf_read = this.buffer;
          const buf_write = res2.buffer;
          const ta_16_scratch = new Uint32Array(8);
          ta_16_scratch[0] = 0;
          ta_16_scratch[1] = 0;
          ta_16_scratch[2] = buf_read.length;
          ta_16_scratch[3] = buf_write.length;
          let ta_u8 = new Uint8Array(4);
          ta_u8[0] = r;
          ta_u8[1] = g;
          ta_u8[2] = b;
          ta_u8[3] = a;
          while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]] === ta_u8[0] && buf_read[ta_16_scratch[0] + 1] === ta_u8[1] && buf_read[ta_16_scratch[0] + 2] === ta_u8[2] && buf_read[ta_16_scratch[0] + 3] === ta_u8[3]) {
              buf_write[ta_16_scratch[1]++] = 0;
              buf_write[ta_16_scratch[1]++] = 0;
              buf_write[ta_16_scratch[1]++] = 0;
              buf_write[ta_16_scratch[1]++] = 255;
            } else {
              buf_write[ta_16_scratch[1]++] = 255;
              buf_write[ta_16_scratch[1]++] = 255;
              buf_write[ta_16_scratch[1]++] = 255;
              buf_write[ta_16_scratch[1]++] = 255;
            }
            ta_16_scratch[0] += 4;
          }
          return res2;
        }
        count_pixels_with_color(...args) {
          const { bipp } = this;
          if (bipp === 32) {
            const [r, g, b, a] = args;
            const buf_read = this.buffer;
            const scratch_32 = new Uint32Array(5);
            scratch_32[0] = 0;
            scratch_32[2] = buf_read.length;
            scratch_32[4] = 0;
            const ta_16_scratch = new Uint16Array(8);
            let ta_u8 = new Uint8Array(4);
            ta_u8[0] = r;
            ta_u8[1] = g;
            ta_u8[2] = b;
            ta_u8[3] = a;
            while (scratch_32[0] < scratch_32[2]) {
              if (buf_read[scratch_32[0]++] === ta_u8[0] && buf_read[scratch_32[0]++] === ta_u8[1] && buf_read[scratch_32[0]++] === ta_u8[2] && buf_read[scratch_32[0]++] === ta_u8[3]) {
                scratch_32[4]++;
              }
            }
            return scratch_32[4];
          } else {
            return super.count_pixels_with_color(...args);
          }
        }
        "__get_single_color_mask"(r, g, b, a) {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 8
          });
          res2.buffer.fill(0);
          const buf_read = this.buffer;
          const buf_write = res2.buffer;
          const ta_16_scratch = new Uint16Array(8);
          ta_16_scratch[0] = 0;
          ta_16_scratch[1] = 0;
          ta_16_scratch[2] = buf_read.length;
          ta_16_scratch[3] = buf_write.length;
          let ta_u8 = new Uint8Array(4);
          ta_u8[0] = r;
          ta_u8[1] = g;
          ta_u8[2] = b;
          ta_u8[3] = a;
          while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]++] === ta_u8[0] && buf_read[ta_16_scratch[0]++] === ta_u8[1] && buf_read[ta_16_scratch[0]++] === ta_u8[2] && buf_read[ta_16_scratch[0]++] === ta_u8[3]) {
              buf_write[ta_16_scratch[1]] = 255;
            }
            ta_16_scratch[1]++;
          }
          return res2;
        }
        "measure_color_region_size"(x, y, max) {
          const buffer = this.buffer;
          if (this.bytes_per_pixel === 4) {
            const scratch_32 = new Uint32Array(16);
            scratch_32[0] = this.size[0];
            scratch_32[1] = this.size[1];
            scratch_32[2] = scratch_32[0] * scratch_32[1];
            scratch_32[3] = this.bytes_per_pixel;
            scratch_32[6] = 0;
            scratch_32[7] = 0;
            scratch_32[8] = 0;
            scratch_32[9] = max;
            const ta8_pixels = new Uint8Array(12);
            scratch_32[10] = 0;
            const ta16_pixels = new Uint8Array(4);
            const ta_pixels_visited = new Uint8Array(scratch_32[2]);
            const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
            scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
            ta8_pixels[0] = buffer[scratch_32[8]++];
            ta8_pixels[1] = buffer[scratch_32[8]++];
            ta8_pixels[2] = buffer[scratch_32[8]++];
            ta8_pixels[3] = buffer[scratch_32[8]++];
            ta_visiting_pixels[0] = x;
            ta_visiting_pixels[1] = y;
            scratch_32[7] = 2;
            while (scratch_32[6] < scratch_32[7] && scratch_32[10] < scratch_32[9]) {
              scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
              scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
              scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
              ta8_pixels[4] = buffer[scratch_32[8]++];
              ta8_pixels[5] = buffer[scratch_32[8]++];
              ta8_pixels[6] = buffer[scratch_32[8]++];
              ta8_pixels[7] = buffer[scratch_32[8]++];
              ta16_pixels[0] = ta8_pixels[4] - ta8_pixels[0];
              ta16_pixels[1] = ta8_pixels[5] - ta8_pixels[1];
              ta16_pixels[2] = ta8_pixels[6] - ta8_pixels[2];
              ta16_pixels[3] = ta8_pixels[7] - ta8_pixels[3];
              if (ta16_pixels[0] === 0 && ta16_pixels[1] === 0 && ta16_pixels[2] === 0 && ta16_pixels[3] === 0) {
                if (scratch_32[4] - 1 >= 0 && scratch_32[4] - 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                  ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                }
                if (scratch_32[5] - 1 >= 0 && scratch_32[5] - 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                  ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                }
                if (scratch_32[4] + 1 >= 0 && scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                  ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                }
                if (scratch_32[5] + 1 >= 0 && scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                  ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                }
              }
              scratch_32[10]++;
            }
            return scratch_32[10];
          } else if (this.bytes_per_pixel === 1) {
            return (() => {
              const scratch_32 = new Uint32Array(16);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              scratch_32[2] = scratch_32[0] * scratch_32[1];
              scratch_32[3] = this.bytes_per_pixel;
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = max;
              const ta8_pixels = new Uint8Array(12);
              scratch_32[10] = 0;
              const ta16_pixels = new Uint8Array(4);
              const ta_pixels_visited = new Uint8Array(scratch_32[2]);
              const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
              scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
              ta8_pixels[0] = buffer[scratch_32[8]++];
              ta_visiting_pixels[0] = x;
              ta_visiting_pixels[1] = y;
              scratch_32[7] = 2;
              while (scratch_32[6] < scratch_32[7] && scratch_32[10] < scratch_32[9]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
                ta8_pixels[4] = buffer[scratch_32[8]++];
                ta16_pixels[0] = ta8_pixels[4] - ta8_pixels[0];
                if (ta16_pixels[0] === 0) {
                  if (scratch_32[4] - 1 >= 0 && scratch_32[4] - 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] - 1 >= 0 && scratch_32[5] - 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                  }
                  if (scratch_32[4] + 1 >= 0 && scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] + 1 >= 0 && scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                  }
                }
                scratch_32[10]++;
              }
              return scratch_32[10];
            })();
          } else {
            throw "unsuppored bytes_per_pixel " + this.bytes_per_pixel;
          }
        }
        "get_pixel_pos_list_of_pixels_with_color"(color) {
          let res2 = new Pixel_Pos_List();
          if (this.pos) {
            console.log("this.pos", this.pos);
            this.each_pixel_ta((pos, px_color) => {
              if (px_color === color) {
                res2.add(new Uint16Array([pos[0] + this.pos[0], pos[1] + this.pos[1]]));
              }
            });
            res2.pos = this.pos;
          } else {
            this.each_pixel_ta((pos, px_color) => {
              if (px_color === color) {
                res2.add(pos);
              }
            });
          }
          res2.fix();
          return res2;
        }
        "get_ppl_color_region"(pos) {
          console.trace();
          throw "NYI";
        }
        "flood_fill_self_get_pixel_pos_list"(pos, color) {
          const size = this.size;
          if (!(pos instanceof Uint16Array || pos instanceof Uint32Array)) {
            throw "Wrong pos data type, pos " + pos;
          }
          if (this.bytes_per_pixel === 4) {
            throw "NYI";
          } else if (this.bytes_per_pixel === 1) {
            const using_ta_pixels_visited = () => {
              const res2 = new Pixel_Pos_List();
              const buffer = this.buffer;
              const scratch_32 = new Uint32Array(10);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              const size2 = scratch_32;
              scratch_32[2] = size2[0] * size2[1];
              scratch_32[3] = this.bytes_per_pixel;
              let cpos = pos.slice();
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = 0;
              const obj_pixels_visited = {};
              const ppl_visiting_pixels = new Pixel_Pos_List();
              const ta_visiting_pixels = ppl_visiting_pixels.ta;
              let ccolor;
              scratch_32[8] = scratch_32[3] * (cpos[0] + cpos[1] * size2[0]);
              ccolor = buffer[scratch_32[8]++];
              ppl_visiting_pixels.add(cpos);
              scratch_32[7] = 2;
              while (scratch_32[9] <= scratch_32[2]) {
                console.log("scratch_32[9]", scratch_32[9]);
                console.log("scratch_32[2]", scratch_32[2]);
                cpos[0] = ta_visiting_pixels[scratch_32[6]++];
                cpos[1] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (cpos[0] + cpos[1] * size2[0]);
                if (buffer[scratch_32[8]++] - ccolor === 0) {
                  buffer[scratch_32[8] - 1] = color;
                  res2.add(cpos);
                  if (cpos[0] - 1 >= 0 && !obj_pixels_visited[cpos[0] - 1 + size2[0] * cpos[1]]) {
                    ppl_visiting_pixels.add(new Uint16Array([cpos[0] - 1, cpos[1]]));
                    scratch_32[7] += 2;
                    obj_pixels_visited[cpos[0] - 1 + size2[0] * cpos[1]] = true;
                  }
                  if (cpos[1] - 1 >= 0 && !obj_pixels_visited[cpos[0] + size2[0] * (cpos[1] - 1)]) {
                    ppl_visiting_pixels.add(new Uint16Array([cpos[0], cpos[1] - 1]));
                    scratch_32[7] += 2;
                    obj_pixels_visited[cpos[0] + size2[0] * (cpos[1] - 1)] = true;
                  }
                  if (cpos[0] + 1 < size2[0] && !obj_pixels_visited[cpos[0] + 1 + size2[0] * cpos[1]]) {
                    ppl_visiting_pixels.add(new Uint16Array([cpos[0] + 1, cpos[1]]));
                    scratch_32[7] += 2;
                    obj_pixels_visited[cpos[0] + 1 + size2[0] * cpos[1]] = true;
                  }
                  if (cpos[1] + 1 < size2[1] && !obj_pixels_visited[cpos[0] + size2[0] * (cpos[1] + 1)]) {
                    ppl_visiting_pixels.add(new Uint16Array([cpos[0], cpos[1] + 1]));
                    scratch_32[7] += 2;
                    obj_pixels_visited[cpos[0] + size2[0] * (cpos[1] + 1)] = true;
                  }
                }
                scratch_32[9]++;
              }
              res2.fix();
              return res2;
            };
            return using_ta_pixels_visited();
          } else {
            console.trace();
            throw "NYI";
          }
        }
        "flood_fill_c1_1bipp"(pos) {
          const target_color = this.get_pixel_1bipp(pos);
          let [x, y] = pos;
          if (target_color === 1) {
            return 0;
          } else {
            const ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation = () => {
              let stack_capacity = 1024 * 1024 * 16;
              let ta_stack = new Uint16Array(stack_capacity);
              let i_stack_pos = 0;
              let stack_length = 0;
              let px_color;
              let ta_pos = new Uint16Array(2);
              let ta_pos2 = new Uint16Array(2);
              ta_pos[0] = pos[0];
              ta_pos[1] = pos[1];
              if (i_stack_pos < stack_capacity) {
                ta_stack[i_stack_pos++] = ta_pos[0];
                ta_stack[i_stack_pos++] = ta_pos[1];
                stack_length++;
              } else {
                console.log("stack_length", stack_length);
                console.log("i_stack_pos", i_stack_pos);
                console.trace();
                throw "NYI - stack exceeded capacity";
              }
              const [width, height2] = this.size;
              const ta_already_visited = new Uint8Array(width * height2);
              while (stack_length > 0) {
                ta_pos[0] = ta_stack[i_stack_pos - 2];
                ta_pos[1] = ta_stack[i_stack_pos - 1];
                i_stack_pos -= 2;
                stack_length--;
                if (i_stack_pos >= stack_capacity - 8) {
                  throw "Not enough stack for positions yet to visit";
                }
                px_color = this.get_pixel_1bipp(ta_pos);
                if (px_color === target_color) {
                  this.set_pixel_on_1bipp(ta_pos);
                  if (ta_pos[0] > 0) {
                    ta_pos2[0] = ta_pos[0] - 1;
                    ta_pos2[1] = ta_pos[1];
                    if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                      ta_stack[i_stack_pos++] = ta_pos2[0];
                      ta_stack[i_stack_pos++] = ta_pos2[1];
                      stack_length++;
                    }
                    ;
                  }
                  if (ta_pos[0] < width - 1) {
                    ta_pos2[0] = ta_pos[0] + 1;
                    ta_pos2[1] = ta_pos[1];
                    if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                      ta_stack[i_stack_pos++] = ta_pos2[0];
                      ta_stack[i_stack_pos++] = ta_pos2[1];
                      stack_length++;
                    }
                    ;
                  }
                  if (ta_pos[1] > 0) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] - 1;
                    if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                      ta_stack[i_stack_pos++] = ta_pos2[0];
                      ta_stack[i_stack_pos++] = ta_pos2[1];
                      stack_length++;
                    }
                    ;
                  }
                  if (ta_pos[1] < height2 - 1) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] + 1;
                    if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                      ta_stack[i_stack_pos++] = ta_pos2[0];
                      ta_stack[i_stack_pos++] = ta_pos2[1];
                      stack_length++;
                    }
                    ;
                  }
                  ta_already_visited[width * ta_pos[1] + ta_pos[0]] = 255;
                }
              }
            };
            const horizontal_line_filling_stack_to_visit_store_already_visited_implementation = () => {
              const { ta: ta2, size } = this;
              const aa_x_off_spans = this.calculate_arr_rows_arr_x_off_spans_1bipp();
              console.log("aa_x_off_spans", aa_x_off_spans);
              const find_connected_x_off_spans_below = (y2, idx_x_off_span) => {
                const res2 = [];
                if (y2 < aa_x_off_spans.length - 1) {
                  const span1 = aa_x_off_spans[y2][idx_x_off_span];
                  console.log("");
                  console.log("span1", span1);
                  const y_below = aa_x_off_spans[y2 + 1];
                  console.log("y_below", y_below);
                  const l_y_below = y_below.length;
                  for (let i_below = 0; i_below < l_y_below; i_below++) {
                    const range_below = y_below[i_below];
                    const has_overlap = range_below[0] >= span1[0] && range_below[0] <= span1[1] || range_below[1] >= span1[0] && range_below[1] <= span1[1];
                    console.log("range_below", range_below);
                    console.log("has_overlap", has_overlap);
                    if (has_overlap) {
                      res2.push(range_below);
                    }
                  }
                }
                return res2;
              };
              for (let y2 = 0; y2 < aa_x_off_spans.length; y2++) {
                const arr_row_x_off_spans = aa_x_off_spans[y2];
                for (let idx_x_off_span = 0; idx_x_off_span < arr_row_x_off_spans.length; idx_x_off_span++) {
                  const x_off_span = arr_row_x_off_spans[idx_x_off_span];
                  const path_xos = [y2, idx_x_off_span];
                  console.log("path_xos", path_xos);
                  const spans_connected_below = find_connected_x_off_spans_below(y2, idx_x_off_span);
                  console.log("spans_connected_below", spans_connected_below);
                }
              }
              const old = () => {
                const calculate_1bipp_row_arr_x_spans_off = (y2) => {
                  const res2 = [];
                  const width = this.size[0];
                  let last_color = 0;
                  let current_color;
                  let ta_pos = new Uint16Array(2);
                  ta_pos[1] = y2;
                  for (let x2 = 0; x2 < width; x2++) {
                    ta_pos[0] = x2;
                    current_color = this.get_pixel_1bipp(ta_pos);
                    if (current_color === last_color) {
                      if (res2.length === 0) {
                        res2.push([0, 1]);
                      } else {
                        res2[res2.length - 1][1]++;
                      }
                    } else {
                      if (res2.length === 0) {
                        res2.push([0, 0]);
                        res2.push([0, 1]);
                      } else {
                        res2.push([x2, x2 + 1]);
                      }
                    }
                    last_color = current_color;
                  }
                  return res2;
                };
                const row_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y);
                console.log("----------------");
                console.log("row_x_off_spans", row_x_off_spans);
                if (y > 0) {
                  const row_above_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y - 1);
                  console.log("row_above_x_off_spans", row_above_x_off_spans);
                }
                if (y < this.size[1] - 1) {
                  const row_below_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y + 1);
                  console.log("row_below_x_off_spans", row_below_x_off_spans);
                }
                console.log("----------------");
              };
            };
            return ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation();
          }
        }
        "flood_fill_1bipp"(x, y, color) {
          const new_color = color;
          const target_color = this.get_pixel_1bipp([x, y]);
          const [width, height2] = this.size;
          if (target_color === new_color) {
            return 0;
          } else {
            const ta_stack_fn_calls_inlined_implementation = () => {
              let stack_capacity = 1024 * 1024 * 8;
              let ta_stack = new Uint16Array(stack_capacity);
              let i_stack_pos = 0;
              let stack_length = 0;
              let px_color;
              let ta_pos = new Uint16Array(2);
              let ta_pos2 = new Uint16Array(2);
              ta_pos[0] = x;
              ta_pos[1] = y;
              if (i_stack_pos < stack_capacity) {
                ta_stack[i_stack_pos++] = ta_pos[0];
                ta_stack[i_stack_pos++] = ta_pos[1];
                stack_length++;
              } else {
                console.log("stack_length", stack_length);
                console.log("i_stack_pos", i_stack_pos);
                console.trace();
                throw "NYI - stack exceeded capacity";
              }
              const pb_already_visited = new Core({
                size: this.size,
                bits_per_pixel: 1
              });
              while (stack_length > 0) {
                ta_pos[0] = ta_stack[i_stack_pos - 2];
                ta_pos[1] = ta_stack[i_stack_pos - 1];
                i_stack_pos -= 2;
                stack_length--;
                px_color = this.get_pixel_1bipp(ta_pos);
                if (px_color === target_color) {
                  this.set_pixel_1bipp(ta_pos, new_color);
                  if (ta_pos[0] > 0) {
                    ta_pos2[0] = ta_pos[0] - 1;
                    ta_pos2[1] = ta_pos[1];
                    if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[0] < width - 1) {
                    ta_pos2[0] = ta_pos[0] + 1;
                    ta_pos2[1] = ta_pos[1];
                    if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[1] > 0) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] - 1;
                    if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[1] < height2 - 1) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] + 1;
                    if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  pb_already_visited.set_pixel_1bipp(ta_pos, 1);
                }
              }
            };
            const ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation = () => {
              let stack_capacity = 1024 * 1024 * 8;
              let ta_stack = new Uint16Array(stack_capacity);
              let i_stack_pos = 0;
              let stack_length = 0;
              let px_color;
              let ta_pos = new Uint16Array(2);
              let ta_pos2 = new Uint16Array(2);
              ta_pos[0] = x;
              ta_pos[1] = y;
              if (i_stack_pos < stack_capacity) {
                ta_stack[i_stack_pos++] = ta_pos[0];
                ta_stack[i_stack_pos++] = ta_pos[1];
                stack_length++;
              } else {
                console.log("stack_length", stack_length);
                console.log("i_stack_pos", i_stack_pos);
                console.trace();
                throw "NYI - stack exceeded capacity";
              }
              const [width2, height3] = this.size;
              const ta_already_visited = new Uint8Array(width2 * height3);
              while (stack_length > 0) {
                ta_pos[0] = ta_stack[i_stack_pos - 2];
                ta_pos[1] = ta_stack[i_stack_pos - 1];
                i_stack_pos -= 2;
                stack_length--;
                px_color = this.get_pixel_1bipp(ta_pos);
                if (px_color === target_color) {
                  this.set_pixel_1bipp(ta_pos, new_color);
                  if (ta_pos[0] > 0) {
                    ta_pos2[0] = ta_pos[0] - 1;
                    ta_pos2[1] = ta_pos[1];
                    if (ta_already_visited[width2 * ta_pos2[1] + ta_pos2[0]] === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[0] < width2 - 1) {
                    ta_pos2[0] = ta_pos[0] + 1;
                    ta_pos2[1] = ta_pos[1];
                    if (ta_already_visited[width2 * ta_pos2[1] + ta_pos2[0]] === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[1] > 0) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] - 1;
                    if (ta_already_visited[width2 * ta_pos2[1] + ta_pos2[0]] === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[1] < height3 - 1) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] + 1;
                    if (ta_already_visited[width2 * ta_pos2[1] + ta_pos2[0]] === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  ta_already_visited[width2 * ta_pos[1] + ta_pos[0]] = 255;
                }
              }
            };
            return ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation();
          }
        }
        "flood_fill"(x, y, r, g, b, a) {
          const {
            bipp
          } = this;
          if (bipp === 24) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
              const buffer = this.buffer;
              const scratch_32 = new Uint32Array(16);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              scratch_32[2] = scratch_32[0] * scratch_32[1];
              scratch_32[3] = this.bytes_per_pixel;
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = 0;
              const ta8_pixels = new Uint8Array(12);
              ta8_pixels[8] = r;
              ta8_pixels[9] = g;
              ta8_pixels[10] = b;
              const ta_pixels_visited = new Uint8Array(scratch_32[2]);
              const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
              scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
              ta8_pixels[0] = buffer[scratch_32[8]++];
              ta8_pixels[1] = buffer[scratch_32[8]++];
              ta8_pixels[2] = buffer[scratch_32[8]++];
              ta_visiting_pixels[0] = x;
              ta_visiting_pixels[1] = y;
              scratch_32[7] = 2;
              while (scratch_32[9] <= scratch_32[2]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
                if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0 && buffer[scratch_32[8]++] - ta8_pixels[1] === 0 && buffer[scratch_32[8]++] - ta8_pixels[2] === 0) {
                  scratch_32[8] -= 3;
                  buffer[scratch_32[8]++] = ta8_pixels[8];
                  buffer[scratch_32[8]++] = ta8_pixels[9];
                  buffer[scratch_32[8]++] = ta8_pixels[10];
                  if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                  }
                  if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                  }
                }
                scratch_32[9]++;
              }
              return this;
            };
            return fast_stacked_mapped_flood_fill();
          } else if (bipp === 32) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
              const buffer = this.buffer;
              const scratch_32 = new Uint32Array(16);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              scratch_32[2] = scratch_32[0] * scratch_32[1];
              scratch_32[3] = this.bytes_per_pixel;
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = 0;
              const ta8_pixels = new Uint8Array(12);
              ta8_pixels[8] = r;
              ta8_pixels[9] = g;
              ta8_pixels[10] = b;
              ta8_pixels[11] = a;
              const ta_pixels_visited = new Uint8Array(scratch_32[2]);
              const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
              scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
              ta8_pixels[0] = buffer[scratch_32[8]++];
              ta8_pixels[1] = buffer[scratch_32[8]++];
              ta8_pixels[2] = buffer[scratch_32[8]++];
              ta8_pixels[3] = buffer[scratch_32[8]++];
              ta_visiting_pixels[0] = x;
              ta_visiting_pixels[1] = y;
              scratch_32[7] = 2;
              while (scratch_32[9] <= scratch_32[2]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
                if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0 && buffer[scratch_32[8]++] - ta8_pixels[1] === 0 && buffer[scratch_32[8]++] - ta8_pixels[2] === 0 && buffer[scratch_32[8]++] - ta8_pixels[3] === 0) {
                  scratch_32[8] -= 4;
                  buffer[scratch_32[8]++] = ta8_pixels[8];
                  buffer[scratch_32[8]++] = ta8_pixels[9];
                  buffer[scratch_32[8]++] = ta8_pixels[10];
                  buffer[scratch_32[8]++] = ta8_pixels[11];
                  if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                  }
                  if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                  }
                }
                scratch_32[9]++;
              }
              return this;
            };
            return fast_stacked_mapped_flood_fill();
          } else if (bipp === 8) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
              const v = r;
              const buffer = this.buffer;
              const scratch_32 = new Uint32Array(16);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              scratch_32[2] = scratch_32[0] * scratch_32[1];
              scratch_32[3] = this.bytes_per_pixel;
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = 0;
              const ta8_pixels = new Uint8Array(12);
              ta8_pixels[8] = v;
              const ta_pixels_visited = new Uint8Array(scratch_32[2]);
              const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
              scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
              ta8_pixels[0] = buffer[scratch_32[8]++];
              ta_visiting_pixels[0] = x;
              ta_visiting_pixels[1] = y;
              scratch_32[7] = 2;
              while (scratch_32[9] <= scratch_32[2]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
                if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0) {
                  scratch_32[8] -= 1;
                  buffer[scratch_32[8]++] = ta8_pixels[8];
                  if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                  }
                  if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                  }
                }
                scratch_32[9]++;
              }
              return this;
            };
            return fast_stacked_mapped_flood_fill();
          } else if (bipp === 1) {
            return this.flood_fill_1bipp(x, y, r);
          } else {
            console.trace();
            throw "Unsupported bipp: " + bipp;
          }
        }
        "invert"() {
          const {
            bipp
          } = this;
          if (bipp === 1) {
            const {
              ta: ta2
            } = this;
            const l2 = ta2.length;
            for (let i = 0; i < l2; i++) {
              ta2[i] = ~ta2[i] & 255;
            }
          } else {
            console.trace();
            throw "NYI (unsupported bipp) " + bipp;
          }
        }
        "or"(other_pb) {
          const {
            bipp
          } = this;
          if (bipp === 1) {
            const other_bipp = other_pb.bipp;
            if (other_bipp === 1) {
              const {
                ta: ta2
              } = this;
              const l_my_ta = ta2.length;
              const other_ta = other_pb.ta;
              const l_other_ta = other_ta.length;
              if (l_other_ta === l_my_ta) {
                for (let i = 0; i < l_my_ta; i++) {
                  ta2[i] = ta2[i] | other_ta[i];
                }
              } else {
                console.trace();
                throw "lengths of pixel buffer typed arrays must match";
              }
            } else {
              console.trace();
              throw "bipp values must match (other_pb expected to have bipp: 1)";
            }
          } else {
            console.trace();
            throw "NYI (unsupported bipp) " + bipp;
          }
        }
        each_outer_boundary_pixel(callback2) {
          let ta_pos = new Uint16Array(2);
          const { size } = this;
          const [w, h] = size;
          ta_pos[0] = 0;
          ta_pos[1] = 0;
          for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
            const px2 = this.get_pixel(ta_pos);
            callback2(px2, ta_pos);
          }
          ta_pos[0]--;
          for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            const px2 = this.get_pixel(ta_pos);
            callback2(px2, ta_pos);
          }
          ta_pos[1]--;
          for (ta_pos[0] = w - 1; ta_pos[0] > 0; ta_pos[0]--) {
            const px2 = this.get_pixel(ta_pos);
            callback2(px2, ta_pos);
          }
          let px = this.get_pixel(ta_pos);
          callback2(px, ta_pos);
          for (ta_pos[1] = h - 1; ta_pos[1] > 0; ta_pos[1]--) {
            const px2 = this.get_pixel(ta_pos);
            callback2(px2, ta_pos);
          }
          px = this.get_pixel(ta_pos);
          callback2(px, ta_pos);
        }
        flood_fill_off_pixels_from_outer_boundary_on_1bipp() {
          this.each_outer_boundary_pixel((b_color, pos) => {
            if (b_color === 0) {
              this.flood_fill_c1_1bipp(pos);
            }
          });
        }
        flood_fill_given_color_pixels_from_outer_boundary(given_color, fill_color) {
          const {
            bits_per_pixel
          } = this;
          if (bits_per_pixel === 24) {
            this.each_outer_boundary_pixel((b_color, pos) => {
              const [r, g, b] = b_color;
              if (r === given_color[0] && g === given_color[1] && b === given_color[2]) {
                this.flood_fill(pos[0], pos[1], fill_color[0], fill_color[1], fill_color[2]);
              }
            });
          } else if (bits_per_pixel === 1) {
            this.each_outer_boundary_pixel((b_color, pos) => {
              if (b_color === given_color) {
                this.flood_fill(pos[0], pos[1], fill_color);
              }
            });
          } else {
            console.log("not flood filling");
            console.log("bits_per_pixel", bits_per_pixel);
            throw "NYI";
            console.trace();
          }
        }
        each_x_span(cb) {
          const [w, h] = this.size;
          const ta_x_span_toggle_bits = get_ta_bits_that_differ_from_previous_as_1s(this.ta);
          let prev_x, prev_y;
          let x_delta, y_delta;
          let color_leading_on_from_current_x_toggle_position;
          const found_empty_rows = (y0, y1_inclusive) => {
          };
          const found_x_span = (x0, x1, y, color) => {
            cb(x0, x1, y, color);
          };
          const complete_previous_row_x_span = () => {
          };
          const complete_any_empty_in_between_rows = () => {
          };
          const complete_current_x_span = (x, y) => {
            found_x_span(prev_x, x - 1, y, color_leading_on_from_current_x_toggle_position);
            color_leading_on_from_current_x_toggle_position ^= 1;
          };
          const found_row_beginning_color_0_x_span = (x_span_end, y) => {
            found_x_span(0, x_span_end, y, 0);
            color_leading_on_from_current_x_toggle_position = 1;
          };
          const found_row_beginning_color_1_x_span_beginning = (y) => {
            color_leading_on_from_current_x_toggle_position = 1;
          };
          const handle_xy_toggle_position = (x, y) => {
            if (prev_x === void 0) {
              if (y > 0) {
                found_empty_rows(0, y - 1);
              }
              if (x > 0) {
                found_row_beginning_color_0_x_span(x, y);
              } else {
                found_row_beginning_color_1_x_span_beginning(y);
              }
            } else {
              if (y > prev_y) {
                complete_previous_row_x_span();
                complete_any_empty_in_between_rows();
                if (x === 0) {
                  found_row_beginning_color_1_x_span_beginning(y);
                } else {
                  found_row_beginning_color_0_x_span(x - 1, y);
                }
              } else {
                complete_current_x_span(x, y);
              }
            }
            prev_x = x;
            prev_y = y;
          };
          each_1_index(ta_x_span_toggle_bits, (i) => {
            const y = Math.floor(i / w);
            const x = i % w;
            handle_xy_toggle_position(x, y);
          });
        }
        not_very_fast_flood_fill_inner_pixels_off_to_on_1bipp() {
          const identify_overlaps = (higher_row_x_spans, lower_row_x_spans) => {
            let i = 0, j = 0;
            const m = higher_row_x_spans.length, n = lower_row_x_spans.length;
            while (i < m && j < n) {
              const a = higher_row_x_spans[i], b = lower_row_x_spans[j];
              if (a.x0_span[1] < b.x0_span[0]) {
                i++;
              } else if (b.x0_span[1] < a.x0_span[0]) {
                j++;
              } else {
                a.connected_below.push(b.idx);
                b.connected_above.push(a.idx);
                if (a.x0_span[1] <= b.x0_span[1]) {
                  i++;
                }
                if (b.x0_span[1] <= a.x0_span[1]) {
                  j++;
                }
              }
            }
          };
          const rows_x0spans = this.calculate_arr_rows_arr_x_off_spans_1bipp();
          const arr_all_x_spans = [];
          const arr_y_indexed = new Array(this.size[1]);
          let i2;
          let idx = 0;
          for (let i = 0; i < rows_x0spans.length; i++) {
            const single_row_x0spans = rows_x0spans[i];
            arr_y_indexed[i] = [];
            for (i2 = 0; i2 < single_row_x0spans.length; i2++) {
              const x0_span = single_row_x0spans[i2];
              const o_x0span = {
                idx: idx++,
                y: i,
                x0_span,
                connected_above: [],
                connected_below: []
              };
              arr_all_x_spans.push(o_x0span);
              arr_y_indexed[i].push(o_x0span);
            }
          }
          let higher_row_y, lower_row_y;
          let span_above, span_below;
          for (higher_row_y = 0; higher_row_y < this.size[1] - 1; higher_row_y++) {
            identify_overlaps(arr_y_indexed[higher_row_y], arr_y_indexed[higher_row_y + 1]);
          }
          const l2 = arr_all_x_spans.length;
          let arr_stack_yet_to_visit = [];
          let ui8a_visited_already = new Uint8Array(l2);
          let i_group = 0;
          let i_current_group;
          const arr_groups = [];
          const arr_o_groups = [];
          let arr_current_group = [];
          let o_current_group;
          let i_xspan_visiting, xspan_visiting;
          const [width, height2] = this.size;
          const hm1 = height2 - 1, wm1 = width - 1;
          const is_xspan_image_boundary_adjacent = (xspan2) => {
            const { x0_span } = xspan2;
            if (xspan2.y === 0) return true;
            if (x0_span[0] === 0) return true;
            if (xspan2.y === hm1) return true;
            if (x0_span[1] === wm1) return true;
            return false;
          };
          let xspan;
          let idx_span_above, idx_span_below;
          for (let c2 = 0; c2 < l2; c2++) {
            if (ui8a_visited_already[c2] === 0) {
              ui8a_visited_already = new Uint8Array(l2);
              xspan = arr_all_x_spans[c2];
              ui8a_visited_already[c2] = 255;
              if (xspan.group === void 0) {
                i_current_group = i_group++;
                arr_current_group = [];
                o_current_group = {
                  index: i_current_group,
                  xspan_indexes: arr_current_group
                };
                arr_o_groups.push(o_current_group);
                arr_groups.push(arr_current_group);
                if (is_xspan_image_boundary_adjacent(xspan)) {
                  o_current_group.is_boundary_adjacent = true;
                }
                xspan.group = i_current_group;
                arr_current_group.push(c2);
                for (idx_span_above of xspan.connected_above) {
                  if (ui8a_visited_already[idx_span_above] === 0) arr_stack_yet_to_visit.push(idx_span_above);
                }
                for (idx_span_below of xspan.connected_below) {
                  if (ui8a_visited_already[idx_span_below] === 0) arr_stack_yet_to_visit.push(idx_span_below);
                }
                while (arr_stack_yet_to_visit.length > 0) {
                  i_xspan_visiting = arr_stack_yet_to_visit.pop();
                  if (ui8a_visited_already[i_xspan_visiting] === 0) {
                    xspan_visiting = arr_all_x_spans[i_xspan_visiting];
                    if (is_xspan_image_boundary_adjacent(xspan_visiting)) {
                      o_current_group.is_boundary_adjacent = true;
                    }
                    xspan_visiting.group = i_current_group;
                    arr_current_group.push(i_xspan_visiting);
                    ui8a_visited_already[i_xspan_visiting] = 255;
                    for (idx_span_above of xspan_visiting.connected_above) {
                      if (ui8a_visited_already[idx_span_above] === 0) arr_stack_yet_to_visit.push(idx_span_above);
                    }
                    for (idx_span_below of xspan_visiting.connected_below) {
                      if (ui8a_visited_already[idx_span_below] === 0) arr_stack_yet_to_visit.push(idx_span_below);
                    }
                  }
                }
              }
            }
          }
          const non_boundary_group_indexes = [];
          for (const g of arr_o_groups) {
            if (!g.is_boundary_adjacent) {
              for (const idx2 of g.xspan_indexes) {
                non_boundary_group_indexes.push(idx2);
              }
            }
          }
          const write_direct = () => {
            let xspan2;
            for (const idx2 of non_boundary_group_indexes) {
              xspan2 = arr_all_x_spans[idx2];
              this.draw_horizontal_line_on_1bipp_inclusive(xspan2.x0_span, xspan2.y);
            }
          };
          write_direct();
        }
        flood_fill_inner_pixels_off_to_on_1bipp() {
          return this.not_very_fast_flood_fill_inner_pixels_off_to_on_1bipp();
        }
      };
      module.exports = Pixel_Buffer_Perf_Focus_Enh;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-7-specialised-enh.js
  var require_pixel_buffer_7_specialised_enh = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-7-specialised-enh.js"(exports, module) {
      var Pixel_Buffer_Perf_Focus_Enh = require_pixel_buffer_6_perf_focus_enh();
      var {
        resize_ta_colorspace,
        copy_rect_to_same_size_8bipp,
        copy_rect_to_same_size_24bipp,
        dest_aligned_copy_rect_1to4bypp,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        each_1_index: each_1_index2
      } = require_ta_math();
      var Pixel_Buffer_Specialised_Enh = class extends Pixel_Buffer_Perf_Focus_Enh {
        constructor(...a) {
          super(...a);
          const bounds_within_source = new Int16Array(4);
          Object.defineProperty(this, "bounds_within_source", {
            get() {
              const size = this.size;
              const pos = this.pos;
              bounds_within_source[0] = pos[0];
              bounds_within_source[1] = pos[1];
              bounds_within_source[2] = pos[0] + size[0];
              bounds_within_source[3] = pos[1] + size[1];
              return bounds_within_source;
            },
            /*
            set(value) {
            },*/
            enumerable: true,
            configurable: false
          });
          const size_bounds = new Int16Array(4);
          Object.defineProperty(this, "size_bounds", {
            get() {
              const size = this.size;
              size_bounds[0] = 0;
              size_bounds[1] = 0;
              size_bounds[2] = size[0];
              size_bounds[3] = size[1];
              return size_bounds;
            },
            enumerable: true,
            configurable: false
          });
          let pb_source2;
          Object.defineProperty(this, "source", {
            get() {
              return pb_source2;
            },
            set(value2) {
              pb_source2 = value2;
            },
            enumerable: true,
            configurable: false
          });
        }
        copy_from_source() {
          const bipp = this.bipp;
          const pb_source2 = this.source;
          const ta_source2 = pb_source2.ta;
          const ta2 = this.ta;
          const my_bounds = this.bounds_within_source;
          const source_size_bounds = pb_source2.size_bounds;
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8 || bipp === 24 || bipp === 32) {
            dest_aligned_copy_rect_1to4bypp(ta_source2, ta2, pb_source2.bytes_per_row, this.bytes_per_pixel, ta_math.overlapping_bounds(my_bounds, source_size_bounds));
          } else {
            console.trace();
            throw "stop";
          }
        }
        threshold_gs(value2) {
          let res2 = this.clone();
          if (this.bytes_per_pixel === 1) {
            this.each_pixel((pos, color) => {
              if (color >= value2) {
                res2.set_pixel(pos[0], pos[1], 255);
              } else {
                res2.set_pixel(pos[0], pos[1], 0);
              }
            });
          }
          return res2;
        }
        padded_each_pixel_index(padding, cb) {
          const ta_32_scratch = new Uint32Array(9);
          ta_32_scratch[0] = this.bytes_per_pixel;
          ta_32_scratch[1] = 0;
          ta_32_scratch[2] = this.size[0] - padding;
          ta_32_scratch[3] = this.size[1] - padding;
          ta_32_scratch[7] = this.size[0];
          const bpp = this.bits_per_pixel;
          if (bpp === 32) {
            ((cb2) => {
              for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                  cb2((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                }
              }
            })(cb);
          } else if (bpp === 24) {
            ((cb2) => {
              for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                  cb2((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                }
              }
            })(cb);
          } else if (bpp === 8) {
            ((cb2) => {
              for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                  cb2((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                }
              }
            })(cb);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        new_window(options) {
          options.window_to = this;
          const res2 = new this.constructor(options);
          res2.copy_from_source();
          return res2;
        }
        new_centered_window(size_or_options) {
          console.trace();
          throw "NYI";
          const t12 = tf(size_or_options);
          console.log("t1", t12);
          let size;
          if (t12 === "a") {
            if (size_or_options.length === 2) {
              size = new Int16Array([size_or_options, size_or_options]);
            } else {
              console.log("size_or_options", size_or_options);
              console.trace();
              throw "Size array expected length: 2";
            }
          } else if (t12 === "n") {
            size = new Int16Array([size_or_options, size_or_options]);
          } else {
            console.trace();
            throw "NYI";
          }
          const res_pb = new this.constructor({
            size,
            bits_per_pixel: this.bits_per_pixel,
            window_to: this
          });
        }
        fill_solid_rect_by_bounds() {
          const bounds2 = this.ta_bounds;
          const bipp = this.bipp;
          if (bipp === 24) {
            const rgb = this.ta_rgb;
            const bytes_per_bounds_row = (bounds2[2] - bounds2[0]) * this.bypp;
            const solid_row = new Uint8ClampedArray(bytes_per_bounds_row);
            let cc = 0;
            for (let c2 = 0; c2 < bytes_per_bounds_row; c2++) {
              solid_row[c2] = rgb[cc];
              cc++;
              if (cc === 3) cc = 0;
            }
            let write_byte_idx = bounds2[0] * this.bypp + bounds2[1] * this.bypr;
            for (let i_row = bounds2[1]; i_row < bounds2[3]; i_row++) {
              this.ta.set(solid_row, write_byte_idx);
              write_byte_idx += this.bypr;
            }
          } else {
            console.trace();
            throw "NYI";
          }
        }
        calc_source_target_valid_bounds_overlap() {
          const source = this.source;
          const my_bounds = this.bounds_within_source;
          const source_size_bounds = source.size_bounds;
          const res2 = this.ta_bounds_scratch;
          if (my_bounds[0] < source_size_bounds[0]) {
            res2[0] = source_size_bounds[0];
          } else {
            res2[0] = my_bounds[0];
          }
          if (my_bounds[1] < source_size_bounds[1]) {
            res2[1] = source_size_bounds[1];
          } else {
            res2[1] = my_bounds[1];
          }
          if (my_bounds[2] > source_size_bounds[2]) {
            res2[2] = source_size_bounds[2];
          } else {
            res2[2] = my_bounds[2];
          }
          if (my_bounds[3] > source_size_bounds[3]) {
            res2[3] = source_size_bounds[3];
          } else {
            res2[3] = my_bounds[3];
          }
          return res2;
        }
        copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target) {
          console.trace();
          throw "NYI";
          const pos = this.ta_pos_scratch;
          const rect_size = this.ta_size_scratch;
          rect_size[0] = ta_bounds[2] - ta_bounds[0];
          rect_size[1] = ta_bounds[3] - ta_bounds[1];
          console.log("rect_size", rect_size);
          const ta_pointers = this.ta_pointers_scratch;
          const ta_target_pointers = pb_target.ta_pointers_scratch;
          console.log("ta_pointers", ta_pointers);
          console.log("ta_target_pointers", ta_target_pointers);
          console.log("pos", pos);
          console.log("ta_bounds", ta_bounds);
          const ta2 = this.ta;
          const ta_target = pb_target.ta;
          console.log("pb_target.pos", pb_target.pos);
          const ta_safe_bounds_limits = this.ta_bounds_scratch;
          ta_safe_bounds_limits[0] = 0;
          ta_safe_bounds_limits[1] = 0;
          ta_safe_bounds_limits[2] = this.size[0];
          ta_safe_bounds_limits[3] = this.size[1];
          const ta_safe_adjusted_bounds = this.ta_bounds2_scratch;
          const ta_bounds_adjustments = this.ta_bounds3_scratch;
          const ta_bounds_byte_offsets = this.ta_bounds3_scratch;
          if (ta_bounds[0] >= ta_safe_bounds_limits[0]) {
            ta_safe_adjusted_bounds[0] = ta_bounds[0];
            ta_bounds_adjustments[0] = 0;
          } else {
            ta_bounds_adjustments[0] = ta_safe_bounds_limits[0] - ta_bounds[0];
            ta_safe_adjusted_bounds[0] = ta_safe_bounds_limits[0];
          }
          if (ta_bounds[1] >= ta_safe_bounds_limits[1]) {
            ta_safe_adjusted_bounds[1] = ta_bounds[1];
            ta_bounds_adjustments[1] = 0;
          } else {
            ta_bounds_adjustments[1] = ta_safe_bounds_limits[1] - ta_bounds[1];
            ta_safe_adjusted_bounds[1] = ta_safe_bounds_limits[1];
          }
          if (ta_bounds[2] <= ta_safe_bounds_limits[2]) {
            ta_safe_adjusted_bounds[2] = ta_bounds[2];
            ta_bounds_adjustments[2] = 0;
          } else {
            ta_bounds_adjustments[2] = ta_safe_bounds_limits[2] - ta_bounds[2];
            ta_safe_adjusted_bounds[2] = ta_safe_bounds_limits[2];
          }
          if (ta_bounds[3] <= ta_safe_bounds_limits[3]) {
            ta_safe_adjusted_bounds[3] = ta_bounds[3];
            ta_bounds_adjustments[3] = 0;
          } else {
            ta_bounds_adjustments[3] = ta_safe_bounds_limits[3] - ta_bounds[3];
            ta_safe_adjusted_bounds[3] = ta_safe_bounds_limits[3];
          }
          console.log("ta_safe_adjusted_bounds", ta_safe_adjusted_bounds);
          console.log("ta_bounds_adjustments", ta_bounds_adjustments);
          console.log("this.bytes_per_row", this.bytes_per_row);
          const source_bytes_per_row = this.bytes_per_row;
          const bypp2 = this.bypp;
          const adjusted_safe_bounds_source_read_byte_offsets = this.ta_offsets_scratch;
          adjusted_safe_bounds_source_read_byte_offsets[0] = ta_bounds_adjustments[0] * bypp2;
          adjusted_safe_bounds_source_read_byte_offsets[1] = ta_bounds_adjustments[1] * source_bytes_per_row;
          adjusted_safe_bounds_source_read_byte_offsets[2] = ta_bounds_adjustments[2] * bypp2;
          adjusted_safe_bounds_source_read_byte_offsets[3] = ta_bounds_adjustments[3] * source_bytes_per_row;
          console.log("adjusted_safe_bounds_source_read_byte_offsets", adjusted_safe_bounds_source_read_byte_offsets);
          const adjusted_safe_bounds_target_write_byte_offsets = pb_target.ta_offsets_scratch;
          const ta_pp_source_read = this.ta_pointerpair_scratch;
          const ta_pp_target_write = pb_target.ta_pointerpair_scratch;
          const bytes_per_row_of_safe_bounds = (ta_safe_adjusted_bounds[2] - ta_safe_adjusted_bounds[0]) * bypp2;
          console.log("bytes_per_row_of_safe_bounds", bytes_per_row_of_safe_bounds);
          ta_pp_source_read[0] = adjusted_safe_bounds_source_read_byte_offsets[0] + adjusted_safe_bounds_source_read_byte_offsets[1];
          ta_pp_source_read[1] = ta_pp_source_read[0] + bytes_per_row_of_safe_bounds;
          ta_pp_target_write[0] = 0;
          ta_pp_target_write[1] = ta_pp_target_write[0] + bytes_per_row_of_safe_bounds;
          console.log("ta_pp_source_read", ta_pp_source_read);
          console.log("ta_pp_target_write", ta_pp_target_write);
          console.log("pb_target.bytes_per_row", pb_target.bytes_per_row);
          const num_rows_to_copy = ta_safe_adjusted_bounds[3] - ta_safe_adjusted_bounds[1];
          console.log("num_rows_to_copy", num_rows_to_copy);
          for (let c2 = 0; c2 < num_rows_to_copy; c2++) {
            const sa_source_row = ta2.subarray(ta_pp_source_read[0], ta_pp_source_read[1]);
            console.log("sa_source_row", sa_source_row);
          }
          for (pos[1] = ta_bounds[1]; pos[1] < ta_bounds[3]; pos[1]++) {
          }
          if (rect_size[0] === pb_target.size[0] && rect_size[1] === pb_target.size[1]) {
            console.log("rect_size matches target size.");
          }
        }
        // And this could be done in a more optimised bitwise way.
        "get_ta_contiguous_spans_1bipp_toggle"() {
          const get_count = () => {
            const initial_color = 0;
            let color = initial_color;
            let count_color_changes = 0;
            this.each_pixel(([x, y], px_color) => {
              if (px_color !== color) {
                count_color_changes++;
              }
              color = px_color;
            });
            count_color_changes++;
            return count_color_changes;
          };
          const get_max_span_length = () => {
            const initial_color = 0;
            let color = initial_color;
            let l2 = 0;
            let max_l = 0;
            this.each_pixel(([x, y], px_color) => {
              if (px_color !== color) {
                l2 = 0;
              } else {
                l2++;
                if (l2 > max_l) max_l = l2;
              }
              color = px_color;
            });
            return max_l + 1;
          };
          const nccs = get_count();
          const max_xpan_l = get_max_span_length();
          if (max_xpan_l <= 255) {
            const res2 = new Uint8Array(nccs);
            const initial_color = 0;
            let color = initial_color;
            let count_color_changes = 0;
            let l2 = -1;
            this.each_pixel(([x, y], px_color) => {
              if (px_color !== color) {
                res2[count_color_changes] = l2 + 1;
                count_color_changes++;
                l2 = 0;
              } else {
                l2++;
              }
              color = px_color;
            });
            res2[count_color_changes] = l2 + 1;
            return res2;
          } else {
            console.trace();
            throw "stop";
          }
        }
        "count_row_on_xspans_1bipp"(y) {
          let res2 = 0;
          const width = this.size[0];
          let last_color = 1;
          let current_color;
          let ta_pos = new Uint16Array(2);
          ta_pos[1] = y;
          for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 1) {
              if (current_color === last_color) {
                if (res2 === 0) {
                  res2++;
                } else {
                }
              } else {
                res2++;
              }
            }
            last_color = current_color;
          }
          return res2;
        }
        "calculate_ta_row_x_off_x2ygbspans_1bipp"(y) {
          const count_xoffspans = this.count_row_off_xspans_1bipp(y);
          const res2 = new Uint16Array(count_xoffspans * 5);
          let i_w = 0;
          const width = this.size[0];
          let last_color = 0;
          let current_color;
          let ta_pos = new Uint16Array(2);
          ta_pos[1] = y;
          for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 0) {
              if (current_color === last_color) {
                if (res2.length === 0) {
                  res2[i_w++] = x;
                  res2[i_w++] = x;
                  res2[i_w++] = y;
                  res2[i_w++] = 0;
                  res2[i_w++] = 0;
                } else {
                  res2[i_w - 4]++;
                }
              } else {
                res2[i_w++] = x;
                res2[i_w++] = x;
                res2[i_w++] = y;
                res2[i_w++] = 0;
                res2[i_w++] = 0;
              }
            }
            last_color = current_color;
          }
          return res2;
        }
        "calculate_arr_row_x_off_spans_1bipp"(y) {
          const res2 = [];
          const width = this.size[0];
          const { ta: ta2 } = this;
          let last_color = 0;
          let current_color;
          const x_start = 0;
          let idx_bit_overall = y * this.size[0] + x_start | 0, idx_bit_within_byte = 0 | 0;
          let arr_last;
          let num_bits_remaining = width;
          let x = 0;
          let has_just_done_multi_read = false;
          let byte_val = 0 | 0;
          while (num_bits_remaining > 0) {
            idx_bit_within_byte = idx_bit_overall & 7;
            has_just_done_multi_read = false;
            if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
              byte_val = ta2[idx_bit_overall >> 3];
              if (byte_val === 255) {
                last_color = 1;
                has_just_done_multi_read = true;
                idx_bit_overall += 8;
                x += 8;
                num_bits_remaining -= 8;
              } else if (byte_val === 0) {
                if (last_color === 0) {
                  if (res2.length === 0) {
                    if (arr_last) res2.push(arr_last);
                    arr_last = [x, x + 7];
                  } else {
                    arr_last[1] += 8;
                  }
                } else {
                  if (arr_last) res2.push(arr_last);
                  arr_last = [x, x + 7];
                }
                x += 8;
                last_color = 0;
                num_bits_remaining -= 8;
                idx_bit_overall += 8;
                has_just_done_multi_read = true;
              } else {
              }
            }
            if (!has_just_done_multi_read) {
              current_color = (ta2[idx_bit_overall >> 3] & 128 >> idx_bit_within_byte) !== 0 ? 1 : 0;
              if (current_color === 0) {
                if (current_color === last_color) {
                  if (res2.length === 0) {
                    if (arr_last) res2.push(arr_last);
                    arr_last = [x, x];
                  } else {
                    arr_last[1]++;
                  }
                } else {
                  if (arr_last) res2.push(arr_last);
                  arr_last = [x, x];
                }
              }
              last_color = current_color;
              idx_bit_overall++;
              x++;
              num_bits_remaining--;
            }
          }
          if (arr_last) res2.push(arr_last);
          return res2;
        }
        // Could see about a more optimised way to do it that does not go row-by-row.
        // Do want a simpler way....
        // Want something with a callback for each y value.....
        // Does seem a bit tricky for the moment.
        // Want to streamline it more!
        "opt_calculate_arr_rows_arr_x_off_spans_1bipp"() {
          const ta_x_span_toggle_bits = get_ta_bits_that_differ_from_previous_as_1s2(this.ta);
          const [w, h] = this.size;
          const get_arr_arr_toggle_positions = () => {
            let prev_y = -1;
            let prev_x = -1;
            let arr_positions_in_row;
            const res2 = new Array(h);
            const handle_row_complete = (y, arr_x_toggle_positions) => {
              res2[y] = arr_x_toggle_positions;
            };
            each_1_index2(ta_x_span_toggle_bits, (i) => {
              const y = Math.floor(i / w);
              const x = i % w;
              if (y !== prev_y) {
                const y_diff = y - prev_y;
                if (arr_positions_in_row) {
                  arr_positions_in_row.push(prev_x);
                  handle_row_complete(prev_y, arr_positions_in_row);
                }
                if (y_diff > 1) {
                  for (let y2 = prev_y + 1; y2 < y; y2++) {
                    handle_row_complete(y2, []);
                  }
                }
                arr_positions_in_row = [x];
              } else {
                arr_positions_in_row.push(x);
              }
              prev_x = x;
              prev_y = y;
            });
            return res2;
          };
          const arr_arr_toggle_positions = get_arr_arr_toggle_positions();
          console.log("arr_arr_toggle_positions.length", arr_arr_toggle_positions.length);
          console.log("h", h);
          throw "stop";
          const _second_attempt = () => {
            let prev_y = -1;
            let current_i = 0;
            let current_color = 0;
            let arr_current_row_arr_off_spans;
            let current_span_start_x, current_span_end_x;
            let is_first_span_in_row = true;
            let res2 = [];
            const handle_row_complete = (arr_row, prev_y2, new_y) => {
              if (arr_row) {
                res2.push(arr_row);
              }
              arr_current_row_arr_off_spans = [];
            };
            const handle_span_off_start = (x, y) => {
              current_span_start_x = x;
            };
            const handle_span_off_end = (x, y) => {
              current_span_end_x = x;
              arr_current_row_arr_off_spans.push([current_span_start_x, current_span_end_x]);
            };
            const place_empty_row = () => {
              res2.push([0, w - 1]);
            };
            const handle_y_change_from_new_toggle_position = (prev_y2, y, x) => {
              handle_row_complete(arr_current_row_arr_off_spans, prev_y2, y);
              prev_y2++;
              while (prev_y2 < y) {
                place_empty_row();
                prev_y2++;
              }
              is_first_span_in_row = true;
              if (x === 0) {
                current_color = 1;
              } else {
                if (current_color === 1) {
                  handle_span_off_start(x, y);
                  current_color = 0;
                } else {
                  handle_span_off_start(0, y);
                  handle_span_off_end(x - 1, y);
                  current_color = 1;
                }
              }
            };
            each_1_index2(ta_x_span_toggle_bits, (i) => {
              const y = Math.floor(i / w);
              const x = i % w;
              if (y !== prev_y) {
                handle_y_change_from_new_toggle_position(prev_y, y, x);
              }
              current_i++;
            });
            return res2;
          };
          const old_attempt = () => {
            let prev_x = 0, prev_y = 0;
            const arr_rows_arr_x_off_spans_1bipp = [];
            let current_row = [];
            let current_color = 0;
            each_1_index2(ta_x_span_toggle_bits, (i) => {
              const y2 = Math.floor(i / w);
              const x = i % w;
              if (y2 > prev_y) {
                if (current_color === 0) {
                  current_row.push([prev_x, w - 1]);
                }
                arr_rows_arr_x_off_spans_1bipp.push(current_row);
                current_row = [];
                prev_y++;
                prev_x = 0;
                while (y2 > prev_y) {
                  current_row.push([0, w - 1]);
                  arr_rows_arr_x_off_spans_1bipp.push(current_row);
                  current_row = [];
                  prev_y++;
                  prev_x = 0;
                }
                current_color = 0;
                current_row = [[0, x]];
                prev_x = x;
              }
              if (x === 0) {
                current_color = 1;
              } else {
                if (current_color === 0) {
                  current_row.push([prev_x + 1, x]);
                }
                current_color ^= 1;
              }
              prev_y = y2;
              prev_x = x;
            });
            if (current_color === 0) {
              current_row.push([prev_x, w - 1]);
              arr_rows_arr_x_off_spans_1bipp.push(current_row);
            }
            const last_row_y = h - 1;
            let y = prev_y;
            y++;
            if (y < h) {
              while (y < h) {
                arr_rows_arr_x_off_spans_1bipp.push([[0, w - 1]]);
                y++;
              }
              arr_rows_arr_x_off_spans_1bipp.push([[0, w - 1]]);
            }
            return arr_rows_arr_x_off_spans_1bipp;
          };
        }
        "simpler_calculate_arr_rows_arr_x_off_spans_1bipp"() {
          const [width, height2] = this.size;
          const res2 = new Array(height2);
          for (let y = 0; y < height2; y++) {
            res2[y] = this.calculate_arr_row_x_off_spans_1bipp(y);
          }
          return res2;
        }
        "calculate_arr_rows_arr_x_off_spans_1bipp"() {
          return this.simpler_calculate_arr_rows_arr_x_off_spans_1bipp();
          const scalc = this.simpler_calculate_arr_rows_arr_x_off_spans_1bipp();
          console.log(JSON.stringify(scalc).slice(0, 2e3).replaceAll(",", ", "));
          const ocalc = this.opt_calculate_arr_rows_arr_x_off_spans_1bipp();
          console.log("\n\n");
          console.log(JSON.stringify(ocalc).slice(0, 2e3).replaceAll(",", ", "));
          return ocalc;
        }
        "calculate_arr_rows_arr_x_on_spans_1bipp"() {
          const [width, height2] = this.size;
          const res2 = new Array(height2);
          for (let y = 0; y < height2; y++) {
            res2[y] = this.calculate_arr_row_x_on_spans_1bipp(y);
          }
          return res2;
        }
        "count_row_off_xspans_1bipp"(y) {
          let res2 = 0;
          const width = this.size[0];
          let last_color = 0;
          let current_color;
          let ta_pos = new Uint16Array(2);
          ta_pos[1] = y;
          for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 0) {
              if (current_color === last_color) {
                if (res2.length === 0) {
                  res2++;
                } else {
                }
              } else {
                res2++;
                if (res2.length === 0) {
                } else {
                }
              }
            }
            last_color = current_color;
          }
          return res2;
        }
        "calculate_ta_row_x_on_x2ygbspans_1bipp"(y) {
          const count_xonspans = this.count_row_on_xspans_1bipp(y);
          const res2 = new Uint16Array(count_xonspans * 5);
          console.log("y, count_xonspans", y, count_xonspans);
          let i_w = 0;
          const width = this.size[0];
          let last_color = 1;
          let current_color;
          let ta_pos = new Uint16Array(2);
          ta_pos[1] = y;
          for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 1) {
              if (current_color === last_color) {
                if (res2.length === 0) {
                  res2[i_w++] = x;
                  res2[i_w++] = x;
                  res2[i_w++] = y;
                  res2[i_w++] = 0;
                  res2[i_w++] = 0;
                } else {
                  res2[i_w - 4]++;
                }
              } else {
                res2[i_w++] = x;
                res2[i_w++] = x;
                res2[i_w++] = y;
                res2[i_w++] = 0;
                res2[i_w++] = 0;
              }
            }
            last_color = current_color;
          }
          return res2;
        }
        "calculate_arr_rows_ta_x_off_x2ygbspans_1bipp"() {
          const [width, height2] = this.size;
          const res2 = new Array(height2);
          for (let y = 0; y < height2; y++) {
            res2[y] = this.calculate_ta_row_x_off_x2ygbspans_1bipp(y);
          }
          return res2;
        }
        "calculate_arr_rows_ta_x_on_x2ygbspans_1bipp"() {
          const [width, height2] = this.size;
          const res2 = new Array(height2);
          for (let y = 0; y < height2; y++) {
            res2[y] = this.calculate_ta_row_x_on_x2ygbspans_1bipp(y);
          }
          console.log("* this.ta", this.ta);
          console.log("this.size", this.size);
          return res2;
        }
        "calculate_arr_row_x_on_spans_1bipp"(y) {
          const initial_implementation = () => {
            const res2 = [];
            const width = this.size[0];
            let last_color = 1;
            let current_color;
            let ta_pos = new Uint16Array(2);
            ta_pos[1] = y;
            for (let x = 0; x < width; x++) {
              ta_pos[0] = x;
              current_color = this.get_pixel_1bipp(ta_pos);
              if (current_color === 1) {
                if (current_color === last_color) {
                  if (res2.length === 0) {
                    res2.push([x, x]);
                  } else {
                    res2[res2.length - 1][1]++;
                  }
                } else {
                  res2.push([x, x]);
                }
              }
              last_color = current_color;
            }
            return res2;
          };
          const _64x0 = BigInt(0);
          const _64x1 = ~_64x0;
          const broken_64bit_optimisation_attempt_inlined_consecutive_value_checking_no_x_loop_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res2 = [];
            const width = this.size[0];
            const { ta: ta2 } = this;
            const ab = ta2.buffer;
            const dv = new DataView(ab);
            let last_color = 1;
            let current_color;
            const x_start = 0;
            let idx_bit_overall = y * this.size[0] + x_start | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0;
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            let _8_byte_val = BigInt(0);
            while (num_bits_remaining > 0) {
              idx_bit_within_byte = idx_bit_overall & 7;
              has_just_done_multi_read = false;
              if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                if (num_bits_remaining >= 64) {
                  _8_byte_val = dv.getBigInt64(idx_bit_overall >> 3);
                  if (_8_byte_val === _64x0) {
                    last_color = 0;
                    has_just_done_multi_read = true;
                    idx_bit_overall += 64;
                    x += 64;
                    num_bits_remaining -= 64;
                  } else if (_8_byte_val === _64x1) {
                    if (last_color === 1) {
                      if (res2.length === 0) {
                        arr_last = [x, x + 63];
                        res2.push(arr_last);
                      } else {
                        arr_last[1] += 64;
                      }
                    } else {
                      arr_last = [x, x + 63];
                      res2.push(arr_last);
                    }
                    x += 8;
                    last_color = 1;
                    num_bits_remaining -= 64;
                    idx_bit_overall += 64;
                    has_just_done_multi_read = true;
                  }
                } else {
                }
                if (!has_just_done_multi_read) {
                  byte_val = ta2[idx_bit_overall >> 3];
                  if (byte_val === 255) {
                    if (last_color === 1) {
                      if (res2.length === 0) {
                        arr_last = [x, x + 7];
                        res2.push(arr_last);
                      } else {
                        arr_last[1] += 8;
                      }
                    } else {
                      arr_last = [x, x + 7];
                      res2.push(arr_last);
                    }
                    x += 8;
                    last_color = 1;
                    num_bits_remaining -= 8;
                    idx_bit_overall += 8;
                    has_just_done_multi_read = true;
                  } else if (byte_val === 0) {
                    last_color = 0;
                    has_just_done_multi_read = true;
                    idx_bit_overall += 8;
                    x += 8;
                    num_bits_remaining -= 8;
                  } else {
                  }
                }
              }
              if (!has_just_done_multi_read) {
                current_color = (ta2[idx_bit_overall >> 3] & 128 >> idx_bit_within_byte) !== 0 ? 1 : 0;
                if (current_color === 1) {
                  if (current_color === last_color) {
                    if (res2.length === 0) {
                      arr_last = [x, x];
                      res2.push(arr_last);
                    } else {
                      arr_last[1]++;
                    }
                  } else {
                    arr_last = [x, x];
                    res2.push(arr_last);
                  }
                }
                last_color = current_color;
                idx_bit_overall++;
                x++;
                num_bits_remaining--;
              }
            }
            return res2;
          };
          const inlined_consecutive_value_checking_no_x_loop_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res2 = [];
            const width = this.size[0];
            const { ta: ta2 } = this;
            const ab = ta2.buffer;
            const dv = new DataView(ab);
            let last_color = 1;
            let current_color;
            const x_start = 0;
            let idx_bit_overall = y * this.size[0] + x_start | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0;
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            while (num_bits_remaining > 0) {
              idx_bit_within_byte = idx_bit_overall & 7;
              has_just_done_multi_read = false;
              if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                byte_val = ta2[idx_bit_overall >> 3];
                if (byte_val === 255) {
                  if (last_color === 1) {
                    if (res2.length === 0) {
                      arr_last = [x, x + 7];
                      res2.push(arr_last);
                    } else {
                      arr_last[1] += 8;
                    }
                  } else {
                    arr_last = [x, x + 7];
                    res2.push(arr_last);
                  }
                  x += 8;
                  last_color = 1;
                  num_bits_remaining -= 8;
                  idx_bit_overall += 8;
                  has_just_done_multi_read = true;
                } else if (byte_val === 0) {
                  last_color = 0;
                  has_just_done_multi_read = true;
                  idx_bit_overall += 8;
                  x += 8;
                  num_bits_remaining -= 8;
                } else {
                }
              }
              if (!has_just_done_multi_read) {
                current_color = (ta2[idx_bit_overall >> 3] & 128 >> idx_bit_within_byte) !== 0 ? 1 : 0;
                if (current_color === 1) {
                  if (current_color === last_color) {
                    if (res2.length === 0) {
                      arr_last = [x, x];
                      res2.push(arr_last);
                    } else {
                      arr_last[1]++;
                    }
                  } else {
                    arr_last = [x, x];
                    res2.push(arr_last);
                  }
                }
                last_color = current_color;
                idx_bit_overall++;
                x++;
                num_bits_remaining--;
              }
            }
            return res2;
          };
          const inlined_consecutive_value_checking_no_x_loop_delayed_push_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res2 = [];
            const width = this.size[0];
            const { ta: ta2 } = this;
            const ab = ta2.buffer;
            const dv = new DataView(ab);
            let last_color = 1;
            let current_color;
            const x_start = 0;
            let idx_bit_overall = y * this.size[0] + x_start | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0;
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            while (num_bits_remaining > 0) {
              idx_bit_within_byte = idx_bit_overall & 7;
              has_just_done_multi_read = false;
              if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                byte_val = ta2[idx_bit_overall >> 3];
                if (byte_val === 255) {
                  if (last_color === 1) {
                    if (res2.length === 0) {
                      if (arr_last) {
                        res2.push(arr_last);
                      }
                      arr_last = [x, x + 7];
                    } else {
                      arr_last[1] += 8;
                    }
                  } else {
                    if (arr_last) {
                      res2.push(arr_last);
                    }
                    arr_last = [x, x + 7];
                  }
                  x += 8;
                  last_color = 1;
                  num_bits_remaining -= 8;
                  idx_bit_overall += 8;
                  has_just_done_multi_read = true;
                } else if (byte_val === 0) {
                  last_color = 0;
                  has_just_done_multi_read = true;
                  idx_bit_overall += 8;
                  x += 8;
                  num_bits_remaining -= 8;
                } else {
                }
              }
              if (!has_just_done_multi_read) {
                current_color = (ta2[idx_bit_overall >> 3] & 128 >> idx_bit_within_byte) !== 0 ? 1 : 0;
                if (current_color === 1) {
                  if (current_color === last_color) {
                    if (res2.length === 0) {
                      if (arr_last) {
                        res2.push(arr_last);
                      }
                      arr_last = [x, x];
                    } else {
                      arr_last[1]++;
                    }
                  } else {
                    if (arr_last) {
                      res2.push(arr_last);
                    }
                    arr_last = [x, x];
                  }
                }
                last_color = current_color;
                idx_bit_overall++;
                x++;
                num_bits_remaining--;
              }
            }
            if (arr_last) {
              res2.push(arr_last);
            }
            return res2;
          };
          return inlined_consecutive_value_checking_no_x_loop_delayed_push_implementation();
        }
      };
      var get_contig_x_spans_AND = (ta_contig_x_spans_1, ta_contig_x_spans_2) => {
        if (true) {
          const parallel_iterate_inputs = () => {
            const starting_color = 0;
            const l1 = ta_contig_x_spans_1.length, l2 = ta_contig_x_spans_2.length;
            let r_pos_in_1 = 0, r_pos_in_2 = 0;
            let px_idx_in_1 = 0, px_idx_in_2 = 0;
            let color_in_1 = starting_color, color_in_2 = starting_color;
            let color_in_output = starting_color;
            let pos_idx_in_output = 0;
            let are_in_sync = true;
            let i_read_step = 0;
            const arr_res = [];
            const read_step = () => {
              const span_length_from_1 = ta_contig_x_spans_1[r_pos_in_1], span_length_from_2 = ta_contig_x_spans_2[r_pos_in_2];
              console.log("");
              console.log("i_read_step", i_read_step);
              console.log("are_in_sync", are_in_sync);
              console.log("span_length_from_1", span_length_from_1);
              console.log("span_length_from_2", span_length_from_2);
              if (are_in_sync) {
                if (px_idx_in_1 === px_idx_in_2) {
                  if (span_length_from_1 === span_length_from_2) {
                    if (are_in_sync) {
                      const same_length_in_sync = span_length_from_1;
                      console.log("same_length_in_sync", same_length_in_sync);
                      px_idx_in_1 += same_length_in_sync;
                      px_idx_in_2 += same_length_in_sync;
                      pos_idx_in_output += same_length_in_sync;
                      r_pos_in_1++;
                      r_pos_in_2++;
                      arr_res.push(same_length_in_sync);
                      color_in_1 = color_in_1 === 1 ? 0 : 1;
                      color_in_2 = color_in_2 === 1 ? 0 : 1;
                      color_in_output = color_in_output === 1 ? 0 : 1;
                    } else {
                      console.trace();
                      throw "NYI";
                    }
                  } else if (span_length_from_1 > span_length_from_2) {
                    if (are_in_sync) {
                      const num_remaining_in_sync = span_length_from_2;
                      arr_res.push(num_remaining_in_sync);
                      console.trace();
                      throw "NYI";
                    } else {
                      console.trace();
                      throw "NYI";
                    }
                  } else {
                    console.trace();
                    throw "NYI";
                  }
                } else {
                  console.trace();
                  throw "NYI";
                }
              } else {
                console.trace();
                throw "NYI";
              }
              i_read_step++;
            };
            read_step();
            console.log("arr_res", arr_res);
            read_step();
          };
          parallel_iterate_inputs();
        } else {
          console.trace();
          throw "Length Mismatch";
        }
      };
      Pixel_Buffer_Specialised_Enh.get_contig_x_spans_AND = get_contig_x_spans_AND;
      module.exports = Pixel_Buffer_Specialised_Enh;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer-8-enh.js
  var require_pixel_buffer_8_enh = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer-8-enh.js"(exports, module) {
      var Pixel_Buffer_Enh = require_pixel_buffer_7_specialised_enh();
      module.exports = Pixel_Buffer_Enh;
    }
  });

  // node_modules/jsgui3-gfx-core/core/pixel-buffer.js
  var require_pixel_buffer = __commonJS({
    "node_modules/jsgui3-gfx-core/core/pixel-buffer.js"(exports, module) {
      module.exports = require_pixel_buffer_8_enh();
    }
  });

  // node_modules/jsgui3-gfx-core/core/gfx-core.js
  var require_gfx_core = __commonJS({
    "node_modules/jsgui3-gfx-core/core/gfx-core.js"(exports, module) {
      var Rectangle = require_Rectangle();
      var gfx_core = {
        Pixel_Pos_List: require_pixel_pos_list(),
        Pixel_Buffer: require_pixel_buffer(),
        Pixel_Buffer_Painter: require_pixel_buffer_painter(),
        convolution_kernels: require_kernels(),
        ta_math: require_ta_math(),
        Rectangle,
        Rect: Rectangle
      };
      module.exports = gfx_core;
    }
  });

  // node_modules/jsgui3-html/html-core/Data.js
  var require_Data = __commonJS({
    "node_modules/jsgui3-html/html-core/Data.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Data_Model, Evented_Class } = require_lang();
      var Data = class extends Evented_Class {
        constructor(...a) {
          super(...a);
          const [spec] = a;
          if (spec.context) this.context = spec.context;
          if (spec.model) {
            if (spec.model instanceof Data_Model) {
              this._model = spec.model;
            } else {
              console.trace();
              throw "stop";
            }
          }
          if (spec.model_constructor) {
            this.model_constructor = spec.model_constructor;
          }
        }
        get model() {
          if (this._model === void 0) {
            if (this.model_constructor) {
              this._model = new this.model_constructor({ context: this.context });
            } else {
              this._model = new Data_Value2({ context: this.context });
            }
          }
          return this._model;
        }
        set model(value2) {
          if (value2 !== this._model) {
            const old = this._model;
            this._model = value2;
            this.raise("change", {
              name: "model",
              old,
              value: value2
            });
          }
        }
      };
      module.exports = Data;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_Data.js
  var require_Control_Data = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_Data.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Data = require_Data();
      var Control_Data = class extends Data {
        constructor(spec = {}) {
          const enriched_spec = Object.assign(
            {
              model_constructor: Data_Object
            },
            spec
          );
          super(enriched_spec);
        }
        // but will have a model on change system of some sort(s).
        // Reassigning events (change event handlers).
        //   So anything listening for change events on the old model instead listens to change events on the new model.
        // so the Control_Data would raise a 'change' event with name 'model'.
        //   maybe worth being clearer about what kinds of changes there are, ie if something's value changes, or of it gets
        //   replaced with another item.
      };
      module.exports = Control_Data;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_View_UI_Low_Level_Data.js
  var require_Control_View_UI_Low_Level_Data = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_View_UI_Low_Level_Data.js"(exports, module) {
      var Control_Data = require_Control_Data();
      var Control_View_UI_Low_Level_Data = class extends Control_Data {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Control_View_UI_Low_Level_Data;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_View_UI_Low_Level.js
  var require_Control_View_UI_Low_Level = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_View_UI_Low_Level.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Control_View_UI_Low_Level_Data = require_Control_View_UI_Low_Level_Data();
      var Control_View_UI_Low_Level = class extends Data_Object {
        constructor(spec = {}) {
          super(spec);
          const { context: context2 } = this;
          if (spec.data) {
            this.data = spec.data;
          } else {
            this.data = new Control_View_UI_Low_Level_Data({ context: context2 });
          }
        }
      };
      module.exports = Control_View_UI_Low_Level;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_View_UI.js
  var require_Control_View_UI = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_View_UI.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Control_View_UI_Low_Level = require_Control_View_UI_Low_Level();
      var Control_View_UI_Compositional = class extends Data_Object {
        constructor(...a) {
          super(...a);
          this.models = [];
          field(this, "model", new Data_Value2());
        }
      };
      var Control_View_UI_Active_Compositional = class extends Control_View_UI_Compositional {
        constructor(...a) {
          super(...a);
        }
      };
      var Control_View_UI_Active = class extends Data_Object {
        constructor(...a) {
          super(...a);
          const compositional = new Control_View_UI_Active_Compositional();
          Object.defineProperty(this, "compositional", { get: () => compositional });
        }
      };
      var Control_View_UI = class extends Data_Object {
        constructor(...a) {
          super(...a);
          const active = new Control_View_UI_Active();
          Object.defineProperty(this, "active", { get: () => active });
          const compositional = new Control_View_UI_Compositional();
          Object.defineProperty(this, "compositional", { get: () => compositional });
        }
      };
      module.exports = Control_View_UI;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_View_Data.js
  var require_Control_View_Data = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_View_Data.js"(exports, module) {
      var Control_Data = require_Control_Data();
      var Control_View_Data = class extends Control_Data {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Control_View_Data;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_View_Low_Level_Data.js
  var require_Control_View_Low_Level_Data = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_View_Low_Level_Data.js"(exports, module) {
      var Control_Data = require_Control_Data();
      var Control_View_Low_Level_Data = class extends Control_Data {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Control_View_Low_Level_Data;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_View_Low_Level.js
  var require_Control_View_Low_Level = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_View_Low_Level.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Control_View_Low_Level_Data = require_Control_View_Low_Level_Data();
      var Control_View_Low_Level = class extends Data_Object {
        constructor(spec = {}) {
          super(spec);
          const { context: context2 } = this;
          const data = (() => {
            if (spec.data) {
              return spec.data;
            } else {
              return new Control_View_Low_Level_Data({ context: context2 });
            }
          })();
          Object.defineProperty(this, "data", { get: () => data });
        }
      };
      module.exports = Control_View_Low_Level;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_View.js
  var require_Control_View = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_View.js"(exports, module) {
      var { field, Data_Object, Evented_Class } = require_lang();
      var Data = require_Data();
      var Control_View_UI = require_Control_View_UI();
      var Control_View_Data = require_Control_View_Data();
      var Control_View_Low_Level = require_Control_View_Low_Level();
      var Control_View = class extends Evented_Class {
        // .data.model
        // .ui.data.model
        constructor(spec = {}) {
          super();
          if (spec.context) this.context = spec.context;
          const { context: context2 } = this;
          const o_data = {};
          if (spec.data) {
            if (spec.data.model) {
              o_data.model = spec.data.model;
            } else {
            }
          }
          this.data = new Control_View_Data(o_data);
          const o_ui = { context: context2 };
          if (spec.ui && spec.ui.data) {
            o_ui.data = spec.ui.data;
          }
          this.ui = new Control_View_UI(o_ui);
          if (spec.data) {
          }
          if (!this.data.model) {
          }
        }
      };
      module.exports = Control_View;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_Validation_Data.js
  var require_Control_Validation_Data = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_Validation_Data.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Data = require_Data();
      var Control_Validation_Data = class extends Data {
        constructor(spec = {}) {
          super(spec);
        }
      };
      module.exports = Control_Validation_Data;
    }
  });

  // node_modules/jsgui3-html/html-core/Validation_State.js
  var require_Validation_State = __commonJS({
    "node_modules/jsgui3-html/html-core/Validation_State.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class, tof } = require_lang();
      var Validation_State = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
        }
        // a set() function????
        //   because a few things at once get set.
        set(value2) {
          if (value2 === true) {
            this._valid = true;
          } else if (value2 === false) {
            this._valid = false;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        get valid() {
          return this._valid;
        }
      };
      module.exports = Validation_State;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_Validation_Target.js
  var require_Control_Validation_Target = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_Validation_Target.js"(exports, module) {
      var { Evented_Class } = require_lang();
      var Control_Validation_Target = class {
        // will target 'data'.
        //  and that will have a .model of course.
        // this.data.model.on change etc.
      };
      module.exports = Control_Validation_Target;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_Validation_Validator.js
  var require_Control_Validation_Validator = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_Validation_Validator.js"(exports, module) {
      var { Evented_Class } = require_lang();
      var Control_Validation_Validator = class extends Evented_Class {
        constructor(spec) {
          super();
        }
        // needs a 'data' property / field.
        // getter and setter in the class may be simplest for the moment....
      };
      module.exports = Control_Validation_Validator;
    }
  });

  // node_modules/jsgui3-html/html-core/Control_Validation.js
  var require_Control_Validation = __commonJS({
    "node_modules/jsgui3-html/html-core/Control_Validation.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Control_Validation_Data = require_Control_Validation_Data();
      var Validation_State = require_Validation_State();
      var Control_Validation_Target = require_Control_Validation_Target();
      var Control_Validation_Validator = require_Control_Validation_Validator();
      var Control_Validation = class extends Evented_Class {
        // Or set up validation on data model states?
        // Control validation will be about if the view.data.model.value is valid according to the data.model.valdate_value
        constructor(spec = {}) {
          super(spec);
          if (spec.data) {
            if (spec.data.model) {
              this.data.model = spec.data.model;
            }
          }
        }
        // and validator too....
        get validator() {
          if (this._validator === void 0) {
            this._validator = new Control_Validation_Validator({ context: this.context });
          }
          return this._validator;
        }
        set validator(value2) {
          if (value2 !== this._validator) {
            const old = this._validator;
            this._validator = value2;
            this.raise("change", {
              name: "validator",
              old,
              value: value2
            });
          }
        }
        get target() {
          if (this._target === void 0) {
            this._target = new Control_Validation_Target({ context: this.context });
          }
          return this._target;
        }
        set target(value2) {
          if (value2 !== this._target) {
            const old = this._target;
            this._target = value2;
            this.raise("change", {
              name: "target",
              old,
              value: value2
            });
          }
        }
        get state() {
          if (this._state === void 0) {
            this._state = new Validation_State();
          }
          return this._state;
        }
        // Need both .data and .view.data
        //   It may validate between them...?
        // validation.validator = ....?
        // validation.validatior.data.model = ...???
        //   Does seem logical!!!
        // Control_Validation_Target
        // validation.target.data.model = ....?
        // Control_Validation_Validator even!!!!
        // A very explicit API would help, will be a bit fiddly to code all the parts.
        // Validator and Target would be explicit names, and will be clear when a view data model is being validated according to the (backing) data model
        get data() {
          if (this._data === void 0) {
            this._data = new Control_Validation_Data({ context: this.context });
          }
          return this._data;
        }
        // And a view property too.
        // Seems somewhat easy to set up like this....
        // Though it's Control_Validation_View
        // Validation View???
        // ctrl.validation.view.data.model = ctrl.view.data.model
        // Validate view agasint non-view.
        set data(value2) {
          if (value2 !== this._data) {
            const old = this._data;
            this._data = value2;
            this.raise("change", {
              name: "data",
              old,
              value: value2
            });
          }
        }
      };
      module.exports = Control_Validation;
    }
  });

  // node_modules/jsgui3-html/html-core/control_model_factory.js
  var require_control_model_factory = __commonJS({
    "node_modules/jsgui3-html/html-core/control_model_factory.js"(exports, module) {
      var { Data_Object } = require_lang();
      var Control_Data = require_Control_Data();
      var Control_View = require_Control_View();
      var Control_View_Data = require_Control_View_Data();
      var Control_View_UI = require_Control_View_UI();
      var ensure_control_models = (ctrl2, spec = {}) => {
        const context2 = ctrl2.context;
        if (!ctrl2.data) {
          ctrl2.data = new Control_Data({
            context: context2,
            model: spec.data && spec.data.model ? spec.data.model : void 0,
            model_constructor: Data_Object
          });
        } else if (!ctrl2.data.model) {
          ctrl2.data.model = spec.data && spec.data.model ? spec.data.model : new Data_Object({ context: context2 });
        }
        if (!ctrl2.view) {
          ctrl2.view = new Control_View({
            context: context2,
            data: spec.view && spec.view.data ? spec.view.data : void 0
          });
        } else {
          if (!ctrl2.view.data) {
            ctrl2.view.data = new Control_View_Data({
              context: context2,
              model: spec.view && spec.view.data ? spec.view.data.model : void 0
            });
          } else if (!ctrl2.view.data.model) {
            ctrl2.view.data.model = spec.view && spec.view.data && spec.view.data.model ? spec.view.data.model : new Data_Object({ context: context2 });
          }
          if (!ctrl2.view.ui) {
            ctrl2.view.ui = new Control_View_UI({ context: context2 });
          }
        }
        return ctrl2;
      };
      module.exports = {
        ensure_control_models
      };
    }
  });

  // node_modules/jsgui3-html/control_mixins/model_data_view_compositional_representation.js
  var require_model_data_view_compositional_representation = __commonJS({
    "node_modules/jsgui3-html/control_mixins/model_data_view_compositional_representation.js"(exports, module) {
      var {
        tof,
        each,
        Data_Model,
        Data_Value: Data_Value2,
        Immutable_Data_Model,
        Immutable_Data_Value,
        Collection
      } = require_lang();
      var Control_Data = require_Control_Data();
      var Control_View = require_Control_View();
      var Control_Validation = require_Control_Validation();
      var { ensure_control_models } = require_control_model_factory();
      var model_data_view_compositional_representation = (ctrl2, options = {}) => {
        const { data } = options;
        ctrl2.using_model_data_view_compositional_representation = true;
        const verify_ctrl_conditions = (ctrl3) => {
          if (ctrl3.data !== void 0) return false;
          if (ctrl3.view !== void 0) return false;
          if (ctrl3.validation !== void 0) return false;
          return true;
        };
        const can_proceed = verify_ctrl_conditions(ctrl2);
        if (can_proceed) {
          const { context: context2 } = ctrl2;
          ensure_control_models(ctrl2, { data });
          ctrl2.validation = new Control_Validation();
          ctrl2.view = ctrl2.view || new Control_View({
            context: context2
          });
          ctrl2.view.data.model.mixins = ctrl2.view.data.model.mixins || new Collection();
          ctrl2.view.data.model.mixins.on("change", (e_change) => {
            const { name, value: value2 } = e_change;
            if (name === "insert") {
              const o_mxs = {};
              ctrl2.view.data.model.mixins.each((mx) => {
                o_mxs[mx.name] = mx;
                if (ctrl2.context.mixins) {
                  const my_mx = ctrl2.context.mixins[mx.name];
                  my_mx(ctrl2);
                }
              });
            }
          });
        } else {
          console.trace();
          console.log("ctrl", ctrl2);
          throw "model_data_view_compositional_representation(ctrl) - ctrl must not have .data or .view properties";
        }
      };
      module.exports = model_data_view_compositional_representation;
    }
  });

  // node_modules/jsgui3-html/html-core/control-enh.js
  var require_control_enh = __commonJS({
    "node_modules/jsgui3-html/html-core/control-enh.js"(exports, module) {
      var jsgui2 = require_lang();
      var {
        get_a_sig: get_a_sig2,
        each,
        tof,
        def
      } = jsgui2;
      var v_subtract2 = jsgui2.util.v_subtract;
      var {
        prom_or_cb
      } = require_fnl();
      var Text_Node = require_text_node();
      var Control_Core = require_control_core();
      var has_window = typeof window !== "undefined";
      var gfx = require_gfx_core();
      var { Rect } = gfx;
      var model_data_view_compositional_representation = require_model_data_view_compositional_representation();
      var desc = (ctrl2, callback2) => {
        if (ctrl2.get) {
          var content = ctrl2.get("content");
          if (content) {
            var t_content = typeof content;
            if (t_content === "string" || t_content === "number") {
            } else {
              var arr = content._arr;
              var c2, l2 = arr.length;
              var item2, t_item;
              for (c2 = 0; c2 < l2; c2++) {
                item2 = arr[c2];
                t_item = typeof item2;
                if (t_item === "string" || t_item === "numbers") {
                } else {
                  callback2(arr[c2]);
                  desc(arr[c2], callback2);
                }
              }
            }
          }
        }
      };
      var dom_desc = (el, callback2) => {
        callback2(el);
        var cns = el.childNodes;
        var l2 = cns.length;
        for (var c2 = 0; c2 < l2; c2++) {
          dom_desc(cns[c2], callback2);
        }
      };
      var mapDomEventNames = {
        "change": true,
        "click": true,
        "dblclick": true,
        "mousedown": true,
        "mouseup": true,
        "mousemove": true,
        "mouseover": true,
        "mouseout": true,
        "blur": true,
        "focus": true,
        "keydown": true,
        "keyup": true,
        "keypress": true,
        "contextmenu": true,
        "touchstart": true,
        "touchmove": true,
        "touchend": true,
        "touchcancel": true,
        "touchforcechange": true,
        "transitionend": true,
        "abort": true,
        "canplay": true,
        "canplaythrough": true,
        "durationchange": true,
        "emptied": true,
        "ended": true,
        "error": true,
        "loadeddata": true,
        "loadedmetadata": true,
        "loadstart": true,
        "pause": true,
        "play": true,
        "playing": true,
        "progress": true,
        "ratechange": true,
        "seeked": true,
        "seeking": true,
        "submit": true,
        "stalled": true,
        "suspend": true,
        "timeupdate": true,
        "volumechange": true,
        "waiting": true
      };
      var Control2 = class extends Control_Core {
        constructor(spec, fields) {
          spec = spec || {};
          super(spec, fields);
          const o_repr = {};
          if (spec.data) o_repr.data = spec.data;
          model_data_view_compositional_representation(this, o_repr);
          if (spec.id) {
            this.__id = spec.id;
          }
          if (spec.__id) {
            this.__id = spec.__id;
          }
          if (spec.__type_name) {
            this.__type_name = spec.__type_name;
          }
          this.map_raises_dom_events = {};
          if (spec.el) {
            var jgf = spec.el.getAttribute("data-jsgui-fields");
            if (jgf) {
              this._persisted_fields = this._persisted_fields || {};
              var s_pre_parse = jgf.replace(/\[DBL_QT\]/g, '"').replace(/\[SNG_QT\]/g, "'");
              s_pre_parse = s_pre_parse.replace(/\'/g, '"');
              var props = JSON.parse(s_pre_parse);
              let exempt_prop_names = {};
              each(props, (v, i) => {
                if (exempt_prop_names[i]) {
                } else {
                  this._persisted_fields[i] = v;
                }
              });
            }
          }
          if (spec.el) {
            if (def(this.selection_scope)) {
              this.selection_scope = this.context.new_selection_scope(this);
            }
            var tn = spec.el.getAttribute("data-jsgui-type");
            if (tn) this.__type_name = tn;
            var id = spec.el.getAttribute("data-jsgui-id");
            if (id) this.__id = id;
          }
          if (!spec.el) {
            this.compose_using_compositional_model();
          }
          this.view.ui.compositional.on("change", (e) => {
            const { name } = e;
            if (name === "model") {
              this.recompose_using_compositional_model();
            }
          });
          if (spec.size) {
            this.size = spec.size;
          }
          if (spec.background) {
            if (spec.background.color) {
              this.background.color = spec.background.color;
            }
          }
          const set_view_ui_composition_model_from_spec = () => {
            if (spec.comp) {
              this.view.ui.compositional.model = spec.comp;
            } else if (spec.composition) {
              this.view.ui.compositional.model = spec.composition;
            } else if (spec.view) {
              if (spec.view.ui) {
                if (spec.view.ui.compositional) {
                  if (spec.view.ui.compositional.model) {
                    this.view.ui.compositional.model = spec.view.ui.compositional.model;
                  }
                }
              }
            }
          };
          set_view_ui_composition_model_from_spec();
        }
        recompose_using_compositional_model() {
          this.content.clear();
          this.compose_using_compositional_model();
        }
        compose_using_compositional_model() {
          let cm;
          const { context: context2 } = this;
          if (this.view.ui.compositional.model) {
            cm = this.view.ui.compositional.model;
          }
          const tcm = tof(cm);
          const compose_from_compositional_model_array = (arr_cm) => {
            const l2 = arr_cm.length;
            if (l2 > 0) {
              for (let c2 = 0; c2 < l2; c2++) {
                const composition_item = arr_cm[c2];
                const tci = tof(composition_item);
                if (tci === "function" || tci === "control") {
                  const ctrl2 = new composition_item({ context: context2 });
                  this.add(ctrl2);
                } else if (tci === "array") {
                  if (composition_item.length === 2) {
                    const [t0, t12] = [tof(composition_item[0]), tof(composition_item[1])];
                    if ((t0 === "function" || t0 === "control") && t12 === "object") {
                      composition_item[1].context = context2;
                      const ctrl2 = new composition_item[0](composition_item[1]);
                      this.add(ctrl2);
                    } else if (t0 === "string" && (t12 === "function" || t12 === "control")) {
                      const ctrl2 = new composition_item[1]({ context: context2 });
                      this.add(ctrl2);
                      this._ctrl_fields = this._ctrl_fields || {};
                      this._ctrl_fields[composition_item[0]] = ctrl2;
                    } else {
                      console.log("[t0, t1]", [t0, t12]);
                      console.trace();
                      throw "stop / nyi";
                    }
                  } else if (composition_item.length === 3) {
                    const [t0, t12, t2] = [tof(composition_item[0]), tof(composition_item[1]), tof(composition_item[2])];
                    if (t0 === "string" && (t12 === "function" || t12 === "control") && t2 === "object") {
                      composition_item[2].context = context2;
                      const ctrl2 = new composition_item[1](composition_item[2]);
                      this.add(ctrl2);
                      this._ctrl_fields = this._ctrl_fields || {};
                      this._ctrl_fields[composition_item[0]] = ctrl2;
                    } else {
                      console.log("[t0, t1, t2]", [t0, t12, t2]);
                      console.trace();
                      throw "stop / nyi";
                    }
                  } else {
                    console.trace();
                    throw "stop / nyi";
                  }
                }
              }
            }
          };
          if (tcm === "array") {
            compose_from_compositional_model_array(cm);
          }
        }
        "ctrls"(obj_ctrls) {
          this._ctrl_fields = this._ctrl_fields || {};
          let cf = this._ctrl_fields;
          each(obj_ctrls, (ctrl2, name) => {
            cf[name] = this[name] = ctrl2;
            this.add(ctrl2);
          });
          return this;
        }
        "bcr"() {
          var a = arguments;
          a.l = a.length;
          var sig = get_a_sig2(a, 1);
          if (sig === "[]") {
            var el = this.dom.el;
            var bcr = el.getBoundingClientRect();
            const res_rect = new Rect([bcr.width, bcr.height], [bcr.left, bcr.top]);
            return res_rect;
          } else if (sig === "[a]") {
            let [pos, br_pos, size] = a[0];
            this.style({
              "position": "absolute",
              "left": pos[0] + "px",
              "top": pos[1] + "px",
              "width": size[0] + "px",
              "height": size[1] + "px"
            });
          }
        }
        get size() {
          if (this._size) {
            return this._size;
          } else {
            if (this.dom.el) {
              var bcr = this.dom.el.getBoundingClientRect();
              return [bcr.width, bcr.height];
            }
          }
        }
        "add_text"(value2) {
          var tn = new Text_Node({
            "context": this.context,
            "text": value2 + ""
          });
          this.add(tn);
          return tn;
        }
        "computed_style"() {
          var a = arguments;
          a.l = a.length;
          var sig = get_a_sig2(a, 1);
          var y;
          if (sig == "[s]") {
            var property_name = a[0];
            var el = this.dom.el;
            if (el.currentStyle)
              y = el.currentStyle[styleProp];
            else if (window.getComputedStyle)
              y = document.defaultView.getComputedStyle(el, null).getPropertyValue(property_name);
            return y;
          }
        }
        "padding"() {
          var a = arguments;
          a.l = a.length;
          var sig = get_a_sig2(a, 1);
          if (sig == "[]") {
            var left, top, right, bottom;
            var c_padding = this.computed_style("padding");
            var s_c_padding = c_padding.split(" ");
            if (s_c_padding.length == 3) {
              top = parseInt(s_c_padding[0], 10);
              right = parseInt(s_c_padding[1], 10);
              bottom = parseInt(s_c_padding[2], 10);
              return [0, top, right, bottom];
            }
          } else {
            console.trace();
            throw "Required argument: (array)";
          }
        }
        "border"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig == "[]") {
            var left, top, right, bottom;
            var c_border = this.computed_style("border");
            console.log("c_border", c_border);
            throw "stop";
          } else {
            console.trace();
            throw "Required argument: (array)";
          }
        }
        "border_thickness"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig == "[]") {
            var left, top, right, bottom;
            var c_border = this.computed_style("border");
            var b2 = c_border.split(", ").join("");
            var s_c_border = b2.split(" ");
            var thickness = parseInt(s_c_border[0], 10);
            return thickness;
          }
        }
        "activate_recursive"() {
          var el = this.dom.el;
          var context2 = this.context;
          var map_controls = context2.map_controls;
          var parent_control;
          recursive_dom_iterate_depth(el, (el2) => {
            const nt = el2.nodeType;
            if (nt == 1) {
              var jsgui_id = el2.getAttribute("data-jsgui-id");
              if (jsgui_id) {
                var ctrl2 = map_controls[jsgui_id];
                if (!ctrl2.__active) ctrl2.activate(el2);
              }
            }
          });
        }
        "add_dom_event_listener"(event_name, fn_handler) {
          if (has_window) {
            const {
              context: context2
            } = this;
            const el = this.dom.el;
            const m = this.map_handlers_to_outer_handlers = this.map_handlers_to_outer_handlers || /* @__PURE__ */ new Map();
            let outer_handler;
            if (m.has(fn_handler)) {
              outer_handler = m.get(fn_handler);
            } else {
              outer_handler = (e) => {
                const {
                  target
                } = e;
                const jid = target.getAttribute("data-jsgui-id");
                if (jid) {
                  e.ctrl_target = context2.map_controls[jid];
                }
                fn_handler(e);
              };
              m.set(fn_handler, outer_handler);
            }
            if (el) {
              el.addEventListener(event_name, outer_handler, false);
            }
          }
        }
        "remove_dom_event_listener"(event_name, fn_handler) {
          if (has_window) {
            const m = this.map_handlers_to_outer_handlers;
            let outer_handler;
            if (m) {
              if (m.has(fn_handler)) {
                outer_handler = m.get(fn_handler);
              }
            }
            outer_handler = outer_handler || fn_handler;
            const el = this.dom.el;
            if (el) {
              el.removeEventListener(event_name, outer_handler, false);
            }
          }
        }
        "remove_event_listener"() {
          const a = arguments;
          const sig = get_a_sig2(a, 1);
          if (sig === "[s,f]") {
            let [event_name, fn_handler] = a;
            if (mapDomEventNames[event_name]) {
              this.remove_dom_event_listener(event_name, fn_handler);
            }
            Control_Core.prototype.remove_event_listener.apply(this, a);
          } else if (sig === "[o]") {
            each(a[0], (v, i) => {
              this.remove_event_listener(i, v);
            });
          }
        }
        "add_event_listener"() {
          const a = arguments;
          const l2 = a.length;
          const sig = get_a_sig2(a, 1);
          if (l2 === 1) {
            each(a[0], (v, i) => {
              this.add_event_listener(i, v);
            });
          }
          if (l2 === 2) {
            super.add_event_listener(a[0], a[1]);
          }
          if (l2 === 3) {
            super.add_event_listener(a[0], a[2]);
          }
          if (sig === "[s,f]" || sig === "[s,b,f]") {
            let event_name = a[0];
            let using_dom = true;
            if (l2 === 3 && a[1] === false) using_dom = false;
            let fn_handler;
            if (l2 === 2) fn_handler = a[1];
            if (l2 === 3) fn_handler = a[2];
            if (mapDomEventNames[a[0]] && using_dom) {
              this.add_dom_event_listener(event_name, fn_handler);
            }
          }
        }
        "once_active"(cb) {
          if (typeof document !== "undefined") {
            return prom_or_cb((solve, jettison) => {
              if (this.__active) {
                solve();
              } else {
                let fn_activate = () => {
                  solve();
                  setTimeout(() => {
                    this.off("activate", fn_activate);
                  }, 0);
                };
                this.on("activate", fn_activate);
              }
            }, cb);
          }
        }
        "pre_activate"() {
          if (typeof document !== "undefined") {
            if (!this.dom.el) {
              let found_el = this.context.get_ctrl_el(this) || this.context.map_els[this._id()] || document.querySelectorAll('[data-jsgui-id="' + this._id() + '"]')[0];
              if (found_el) {
                this.dom.el = found_el;
              }
            }
            if (!this.dom.el) {
            } else {
              this.load_dom_attributes_from_dom();
              if (this.dom.attributes["data-jsgui-mixins"] !== void 0) {
                const str_mixins = this.dom.attributes["data-jsgui-mixins"]?.replace(/'/g, '"');
                if (str_mixins) {
                  const o_mixins = JSON.parse(str_mixins);
                  const old_silent = this.view.data.model.mixins.silent;
                  this.view.data.model.mixins.silent = true;
                  each(o_mixins, (mixin) => {
                    const { name, options } = mixin;
                    const converted_name = name.replace(/-/g, "_");
                    this.view.data.model.mixins.push(mixin);
                    const the_mixin = this.context.mixins[converted_name];
                    if (the_mixin) {
                      the_mixin(this);
                    }
                  });
                  this.view.data.model.mixins.silent = old_silent;
                }
              }
              if (this._persisted_fields) {
                each(this._persisted_fields, (v, i) => {
                  this[i] = v;
                });
              }
              if (this.dom.attributes["data-jsgui-data-model-id"] !== void 0) {
                const context_referenced_data_model = this.context.map_data_models[this.dom.attributes["data-jsgui-data-model-id"]];
                if (context_referenced_data_model) {
                  this.data.model = context_referenced_data_model;
                  console.log("have used data.model referenced from context: " + context_referenced_data_model.__id);
                }
              }
              this.pre_activate_content_controls();
              this.add_content_change_event_listener();
              this.add_dom_attributes_changes_listener();
            }
          } else {
          }
        }
        "activate"(el) {
          if (typeof document !== "undefined" && !this.__active) {
            this.__active = true;
            if (!this.dom.el) {
              let found_el = this.context.get_ctrl_el(this) || this.context.map_els[this._id()] || document.querySelectorAll('[data-jsgui-id="' + this._id() + '"]')[0];
              if (found_el) {
                this.dom.el = found_el;
              }
            }
            if (!this.dom.el) {
            } else {
              this.activate_content_controls();
              this.raise("activate");
            }
          } else {
          }
        }
        "add_dom_attributes_changes_listener"() {
          var dom_attributes = this.dom.attributes;
          var el = this.dom.el;
          dom_attributes.on("change", (e_change) => {
            var property_name = e_change.name || e_change.key, val = e_change.value || e_change.new;
            if (el && el.nodeType === 1) {
              el.setAttribute(property_name, val);
            }
          });
        }
        "activate_this_and_subcontrols"() {
          this.iterate_this_and_subcontrols((ctrl2) => {
            if (ctrl2.dom.el) {
              ctrl2.activate();
            }
          });
        }
        "add_content_change_event_listener"() {
          const {
            context: context2
          } = this;
          var map_controls = context2.map_controls;
          let el = this.dom.el;
          this.content.on("change", (e_change) => {
            let itemDomEl;
            var type = e_change.name;
            if (type === "insert") {
              var item2 = e_change.value;
              var retrieved_item_dom_el = item2.dom.el;
              var t_ret = tof(retrieved_item_dom_el);
              if (t_ret === "string") {
                itemDomEl = retrieved_item_dom_el;
              } else {
                if (retrieved_item_dom_el) {
                  itemDomEl = retrieved_item_dom_el;
                }
                if (!itemDomEl) {
                  if (context2.map_els[item2._id()]) {
                    itemDomEl = context2.map_els[item2._id()];
                  }
                }
                if (!itemDomEl) {
                  var item_tag_name = "div";
                  var dv_tag_name = item2.dom.tagName;
                  if (dv_tag_name) {
                    item_tag_name = dv_tag_name;
                  }
                  var temp_el;
                  if (item_tag_name === "circle" || item_tag_name === "line" || item_tag_name === "polyline") {
                    var temp_svg_container = e_change.item.context.document.createElement("div");
                    temp_svg_container.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">' + e_change.item.all_html_render() + "</svg>";
                    itemDomEl = temp_svg_container.childNodes[0].childNodes[0];
                  } else {
                    temp_el = e_change.item.context.document.createElement("div");
                    temp_el.innerHTML = e_change.item.all_html_render();
                    itemDomEl = temp_el.childNodes[0];
                  }
                  item2.dom.el = itemDomEl;
                  context2.map_els[item2._id()] = itemDomEl;
                }
                ;
              }
              var t_item_dom_el = tof(itemDomEl);
              if (t_item_dom_el === "string") {
                itemDomEl = document.createTextNode(itemDomEl);
              }
              if (!itemDomEl) {
              }
              if (itemDomEl) {
                el.appendChild(itemDomEl);
                e_change.item.register_this_and_subcontrols();
              }
            } else if (type === "clear") {
              if (el) {
                el.innerHTML = "";
              }
            } else if (type === "remove") {
              if (e_change.value.dom.el) {
                e_change.value.dom.el.parentNode.removeChild(e_change.value.dom.el);
              }
            } else {
              console.trace();
              throw "NYI - Unexpected change type. e_change: " + e_change;
            }
          });
        }
        "rec_desc_ensure_ctrl_el_refs"(el) {
          el = el || this.dom.el;
          var context2 = this.context;
          if (el) {
            var c2, l2, cns;
            var jsgui_id;
            var map_els = {};
            dom_desc(el, (el2) => {
              if (el2.getAttribute) {
                jsgui_id = el2.getAttribute("data-jsgui-id");
                if (jsgui_id) {
                  map_els[jsgui_id] = el2;
                  context2.map_els[jsgui_id] = el2;
                }
              }
            });
            desc(this, (ctrl2) => {
              var t_ctrl = tof(ctrl2);
              if (ctrl2 !== this && t_ctrl === "control") {
                var id = ctrl2._id();
                if (map_els[id]) {
                  if (ctrl2.dom.el !== map_els[id]) {
                    ctrl2.dom.el = map_els[id];
                  } else {
                  }
                }
                ctrl2.activate();
              }
            });
          }
        }
        "rec_desc_activate"() {
          desc(this, (ctrl2) => {
            const t_ctrl = tof(ctrl2);
            if (t_ctrl === "control") {
              ctrl2.activate();
            }
          });
        }
        "activate_content_controls"() {
          const do_activation = () => {
            if (!this.dom.el) {
              let found_el = this.context.get_ctrl_el(this);
              if (found_el) {
                this.dom.el = found_el;
              }
            }
            const el = this.dom.el;
            if (el) {
              const context2 = this.context;
              let ctrl_fields = {}, c2, l2;
              if (el.getAttribute) {
                let cns = el.childNodes;
                let content = this.content;
                for (c2 = 0, l2 = cns.length; c2 < l2; c2++) {
                  let cn = cns[c2];
                  if (cn) {
                    let nt = cn.nodeType;
                    if (nt === 1) {
                      let cn_jsgui_id = cn.getAttribute("data-jsgui-id");
                      let cctrl = context2.map_controls[cn_jsgui_id];
                      let found = false;
                      if (cctrl) {
                        cctrl.activate();
                      }
                    }
                  }
                }
              }
            } else {
            }
          };
          do_activation();
        }
        "pre_activate_content_controls"() {
          const do_pre_activation = () => {
            if (!this.dom.el) {
              let found_el = this.context.get_ctrl_el(this);
              if (found_el) {
                this.dom.el = found_el;
              }
            }
            const el = this.dom.el;
            if (el) {
              const context2 = this.context;
              let ctrl_fields = {}, c2, l2;
              if (el.getAttribute) {
                let str_ctrl_fields = el.getAttribute("data-jsgui-ctrl-fields");
                if (str_ctrl_fields) {
                  ctrl_fields = JSON.parse(str_ctrl_fields.replace(/'/g, '"'));
                }
                let ctrl_fields_keys = Object.keys(ctrl_fields);
                let l_ctrl_fields_keys = ctrl_fields_keys.length;
                let key2, value2;
                for (c2 = 0; c2 < l_ctrl_fields_keys; c2++) {
                  key2 = ctrl_fields_keys[c2];
                  value2 = ctrl_fields[key2];
                  this[key2] = context2.map_controls[value2];
                }
                let cns = el.childNodes;
                let content = this.content;
                for (c2 = 0, l2 = cns.length; c2 < l2; c2++) {
                  let cn = cns[c2];
                  if (cn) {
                    let nt = cn.nodeType;
                    if (nt === 1) {
                      let cn_jsgui_id = cn.getAttribute("data-jsgui-id");
                      let cctrl = context2.map_controls[cn_jsgui_id];
                      let found = false;
                      if (cctrl) {
                        let ctrl_id = cctrl.__id;
                        if (ctrl_id) {
                          content.each((v, i) => {
                            if (v.__id) {
                              if (v.__id === ctrl_id) found = true;
                            }
                          });
                        }
                        if (!found) {
                          content._arr.push(cctrl);
                        }
                        cctrl.parent = this;
                      }
                    }
                    if (nt === 3) {
                      const i_sibling = c2;
                      const corresponding_ctrl = content._arr[i_sibling];
                      if (corresponding_ctrl) {
                        if (corresponding_ctrl.text === cn.nodeValue) {
                          corresponding_ctrl.dom.el = cn;
                        }
                      } else {
                        console.log("&&& no corresponding control");
                      }
                      const do_add = () => {
                        let val = cn.nodeValue;
                        console.log("adding Text_Node control", val);
                        const tn = new Text_Node({
                          context: this.context,
                          text: val,
                          el: cn
                        });
                        content.add(tn);
                      };
                    }
                  }
                }
              }
            } else {
            }
          };
          do_pre_activation();
        }
        "load_dom_attributes_from_dom"() {
          const el = this.dom.el;
          const dom_attributes = this.dom.attributes;
          let item2, name, value2, i;
          if (el) {
            const attrs = el.attributes;
            if (attrs) {
              const l2 = attrs.length;
              for (i = 0; i < l2; i++) {
                item2 = attrs.item(i);
                name = item2.name;
                value2 = item2.value;
                dom_attributes[name] = value2;
              }
            }
          }
        }
        "_search_descendents"(search) {
          const recursive_iterate = (ctrl2, item_callback) => {
            const content = ctrl2.content, t_content = tof(content);
            if (t_content === "collection") {
              if (content.length() > 0) {
                content.each((item2, i) => {
                  item_callback(item2);
                  recursive_iterate(item2, item_callback);
                });
              }
            }
          };
          const arr_matching = [];
          recursive_iterate(this, (item2) => {
            const item_type = item2.__type_name;
            if (item_type === search) {
              arr_matching.push(item2);
            } else {
            }
          });
          return arr_matching;
        }
        "_search_ancestor"(search) {
          const parent = this.parent;
          if (parent) {
            if (parent === search) {
              return true;
            } else {
              if (typeof parent.ancestor === "function") {
                return parent.ancestor(search);
              }
            }
          } else {
            return false;
          }
        }
        "add"(new_content) {
          const {
            context: context2
          } = this;
          if (context2) {
            const m = context2.map_controls_being_added_in_frame = context2.map_controls_being_added_in_frame || {};
            const tnc = tof(new_content);
            if (tnc === "array") {
              each(new_content, (v) => {
                const candd = v.this_and_descendents;
                if (candd) {
                  each(candd, (ctrl2) => {
                    if (ctrl2._id) {
                      m[ctrl2._id()] = ctrl2;
                    }
                  });
                }
              });
            } else {
              if (new_content) {
                const candd = new_content.this_and_descendents;
                if (candd) {
                  each(candd, (ctrl2) => {
                    if (ctrl2._id) {
                      m[ctrl2._id()] = ctrl2;
                    }
                  });
                }
              }
            }
          }
          return super.add(new_content);
        }
        "clear"() {
          const {
            context: context2
          } = this;
          context2.map_controls_being_removed_in_frame = context2.map_controls_being_removed_in_frame || {};
          each(this.descendents, (ctrl2) => {
            if (ctrl2._id) context2.map_controls_being_removed_in_frame[ctrl2._id()] = ctrl2;
          });
          super.clear();
        }
      };
      var p = Control2.prototype;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      module.exports = Control2;
    }
  });

  // node_modules/jsgui3-html/html-core/ModelBinder.js
  var require_ModelBinder = __commonJS({
    "node_modules/jsgui3-html/html-core/ModelBinder.js"(exports, module) {
      var { Data_Object, Data_Value: Data_Value2, tof, each } = require_lang();
      var ModelBinder = class _ModelBinder {
        constructor(sourceModel, targetModel, bindings = {}, options = {}) {
          if (typeof targetModel === "string") {
            const [
              sourceProp,
              legacyTargetModel,
              targetProp,
              legacyOptions = {}
            ] = Array.prototype.slice.call(arguments, 1);
            const normalizedBindings = {
              [sourceProp]: Object.assign(
                { to: targetProp },
                legacyOptions.transform ? { transform: legacyOptions.transform } : {},
                legacyOptions.reverse ? { reverse: legacyOptions.reverse } : {}
              )
            };
            const normalizedOptions = Object.assign({
              bidirectional: legacyOptions.twoWay || legacyOptions.bidirectional || !!legacyOptions.reverse,
              immediate: legacyOptions.immediate !== false,
              debug: legacyOptions.debug || false
            }, legacyOptions);
            return new _ModelBinder(sourceModel, legacyTargetModel, normalizedBindings, normalizedOptions);
          }
          this.sourceModel = sourceModel;
          this.targetModel = targetModel;
          this.bindings = bindings;
          this.options = Object.assign({
            bidirectional: true,
            immediate: true,
            debug: false
          }, options);
          this._listeners = [];
          this._locks = /* @__PURE__ */ new Set();
          this._active = false;
          if (this.options.immediate) {
            this.activate();
          }
        }
        /**
         * Activate all bindings
         */
        activate() {
          if (this._active) return;
          this._active = true;
          each(this.bindings, (binding, sourceProp) => {
            this._setupBinding(sourceProp, binding);
          });
          if (this.options.debug) {
            console.log("[ModelBinder] Activated bindings:", Object.keys(this.bindings));
          }
        }
        /**
         * Deactivate all bindings and cleanup listeners
         */
        deactivate() {
          if (!this._active) return;
          this._active = false;
          this._listeners.forEach(({ model, event, handler }) => {
            if (model && model.off) {
              model.off(event, handler);
            }
          });
          this._listeners = [];
          if (this.options.debug) {
            console.log("[ModelBinder] Deactivated bindings");
          }
        }
        /**
         * Setup a single binding between source and target properties
         * @private
         */
        _setupBinding(sourceProp, binding) {
          const targetProp = typeof binding === "string" ? binding : binding.to;
          const transform = binding.transform;
          const reverse = binding.reverse;
          const condition = binding.condition;
          if (this.sourceModel[sourceProp] !== void 0) {
            const value2 = this.sourceModel[sourceProp];
            const transformedValue = transform ? transform(value2) : value2;
            if (!condition || condition(value2)) {
              this.targetModel[targetProp] = transformedValue;
            }
          }
          const sourceHandler = (e) => {
            if (e.name === sourceProp) {
              const value2 = e.value;
              const transformedValue = transform ? transform(value2) : value2;
              if (!condition || condition(value2)) {
                const lock_key = `${sourceProp}->${targetProp}`;
                if (this._acquire(lock_key)) {
                  this.targetModel[targetProp] = transformedValue;
                  if (this.options.debug) {
                    console.log(`[ModelBinder] ${sourceProp} \u2192 ${targetProp}:`, value2, "\u2192", transformedValue);
                  }
                  this._release(lock_key);
                }
              }
            }
          };
          this.sourceModel.on("change", sourceHandler);
          this._listeners.push({
            model: this.sourceModel,
            event: "change",
            handler: sourceHandler
          });
          if (this.options.bidirectional && reverse) {
            const targetHandler = (e) => {
              if (e.name === targetProp) {
                const value2 = e.value;
                const reversedValue = reverse(value2);
                if (!condition || condition(reversedValue)) {
                  const lock_key = `${targetProp}->${sourceProp}`;
                  if (this._acquire(lock_key)) {
                    this.sourceModel[sourceProp] = reversedValue;
                    if (this.options.debug) {
                      console.log(`[ModelBinder] ${targetProp} \u2192 ${sourceProp}:`, value2, "\u2192", reversedValue);
                    }
                    this._release(lock_key);
                  }
                }
              }
            };
            this.targetModel.on("change", targetHandler);
            this._listeners.push({
              model: this.targetModel,
              event: "change",
              handler: targetHandler
            });
          }
        }
        _acquire(key2) {
          if (!key2) return true;
          if (this._locks.has(key2)) {
            if (this.options.debug) {
              console.warn("[ModelBinder] Loop suppressed for", key2);
            }
            return false;
          }
          this._locks.add(key2);
          return true;
        }
        _release(key2) {
          if (key2) {
            this._locks.delete(key2);
          }
        }
        unbind() {
          this.deactivate();
        }
        /**
         * Update a specific binding manually
         */
        updateBinding(sourceProp) {
          const binding = this.bindings[sourceProp];
          if (!binding) return;
          const targetProp = typeof binding === "string" ? binding : binding.to;
          const transform = binding.transform;
          const value2 = this.sourceModel[sourceProp];
          const transformedValue = transform ? transform(value2) : value2;
          this.targetModel[targetProp] = transformedValue;
        }
        /**
         * Get current binding state for inspection
         */
        inspect() {
          const state = {};
          each(this.bindings, (binding, sourceProp) => {
            const targetProp = typeof binding === "string" ? binding : binding.to;
            state[sourceProp] = {
              target: targetProp,
              sourceValue: this.sourceModel[sourceProp],
              targetValue: this.targetModel[targetProp],
              hasTransform: !!binding.transform,
              hasReverse: !!binding.reverse,
              bidirectional: this.options.bidirectional && !!binding.reverse
            };
          });
          return state;
        }
      };
      var ComputedProperty = class {
        constructor(model, dependencies, computeFn, options = {}) {
          this.model = model;
          this.dependencies = Array.isArray(dependencies) ? dependencies : [dependencies];
          this.computeFn = computeFn;
          this.options = Object.assign({
            propertyName: "computed",
            immediate: true,
            debug: false
          }, options);
          this._listeners = [];
          this._active = false;
          this._lastValue = void 0;
          if (this.options.immediate) {
            this.activate();
          }
        }
        activate() {
          if (this._active) return;
          this._active = true;
          this.compute();
          const handler = (e) => {
            if (this.dependencies.includes(e.name)) {
              this.compute();
            }
          };
          this.model.on("change", handler);
          this._listeners.push({ model: this.model, event: "change", handler });
          if (this.options.debug) {
            console.log("[ComputedProperty] Activated for dependencies:", this.dependencies);
          }
        }
        deactivate() {
          if (!this._active) return;
          this._active = false;
          this._listeners.forEach(({ model, event, handler }) => {
            if (model && model.off) {
              model.off(event, handler);
            }
          });
          this._listeners = [];
        }
        compute() {
          const args = this.dependencies.map((dep) => this.model[dep]);
          const newValue = this.computeFn(...args);
          if (newValue !== this._lastValue) {
            this._lastValue = newValue;
            this.model[this.options.propertyName] = newValue;
            if (this.options.debug) {
              console.log("[ComputedProperty] Updated:", this.options.propertyName, "=", newValue);
            }
          }
          return newValue;
        }
        get value() {
          return this._lastValue;
        }
        destroy() {
          this.deactivate();
        }
      };
      var PropertyWatcher = class {
        constructor(model, property, callback2, options = {}) {
          this.model = model;
          this.properties = Array.isArray(property) ? property : [property];
          this.callback = callback2;
          this.options = Object.assign({
            immediate: false,
            deep: false,
            debug: false
          }, options);
          this._handler = null;
          this._active = false;
          this.activate();
        }
        activate() {
          if (this._active) return;
          this._active = true;
          if (this.options.immediate && this.properties.length > 0) {
            const prop = this.properties[0];
            this.callback(this.model[prop], void 0, prop);
          }
          this._handler = (e) => {
            if (this.properties.includes(e.name)) {
              this.callback(e.value, e.old, e.name);
              if (this.options.debug) {
                console.log("[PropertyWatcher] Property changed:", e.name, e.old, "\u2192", e.value);
              }
            }
          };
          this.model.on("change", this._handler);
        }
        deactivate() {
          if (!this._active) return;
          this._active = false;
          if (this._handler && this.model.off) {
            this.model.off("change", this._handler);
          }
          this._handler = null;
        }
        unwatch() {
          this.deactivate();
        }
      };
      var BindingManager = class {
        constructor(control) {
          this.control = control;
          this.binders = [];
          this.computed = [];
          this.watchers = [];
        }
        /**
         * Create a new binding between models
         */
        bind(sourceModel, targetModel, bindings, options) {
          const binder = new ModelBinder(sourceModel, targetModel, bindings, options);
          this.binders.push(binder);
          return binder;
        }
        bind_value(sourceModel, sourceProp, targetModel, targetProp = sourceProp, options = {}) {
          const bindings = {
            [sourceProp]: Object.assign(
              { to: targetProp },
              options.transform ? { transform: options.transform } : {},
              options.reverse ? { reverse: options.reverse } : {},
              options.condition ? { condition: options.condition } : {}
            )
          };
          const binder_options = {
            bidirectional: options.bidirectional !== void 0 ? options.bidirectional : !!options.reverse,
            immediate: options.immediate !== void 0 ? options.immediate : true,
            debug: options.debug || false
          };
          return this.bind(sourceModel, targetModel, bindings, binder_options);
        }
        bind_collection(sourceModel, sourceProp, targetModel, targetProp = sourceProp, options = {}) {
          const map_fn = options.map;
          const clone = options.clone !== false;
          const transform = (collection = []) => {
            const arr = Array.isArray(collection) ? collection : [];
            const mapped = map_fn ? arr.map(map_fn) : arr.slice();
            return clone ? mapped.slice() : mapped;
          };
          const reverse = options.reverse_map ? (collection = []) => {
            const arr = Array.isArray(collection) ? collection : [];
            return arr.map(options.reverse_map);
          } : void 0;
          return this.bind_value(sourceModel, sourceProp, targetModel, targetProp, Object.assign({}, options, {
            transform,
            reverse,
            bidirectional: options.bidirectional && !!reverse
          }));
        }
        /**
         * Create a computed property
         */
        createComputed(model, dependencies, computeFn, options) {
          const computed = new ComputedProperty(model, dependencies, computeFn, options);
          this.computed.push(computed);
          return computed;
        }
        /**
         * Watch a property for changes
         */
        watch(model, property, callback2, options) {
          const watcher = new PropertyWatcher(model, property, callback2, options);
          this.watchers.push(watcher);
          return watcher;
        }
        /**
         * Cleanup all bindings
         */
        cleanup() {
          this.binders.forEach((b) => b.deactivate());
          this.computed.forEach((c2) => c2.deactivate());
          this.watchers.forEach((w) => w.deactivate());
          this.binders = [];
          this.computed = [];
          this.watchers = [];
        }
        /**
         * Get inspection data for all bindings
         */
        inspect() {
          return {
            binders: this.binders.map((b) => b.inspect()),
            computed: this.computed.map((c2) => ({
              propertyName: c2.options.propertyName,
              dependencies: c2.dependencies,
              value: c2.value
            })),
            watchers: this.watchers.map((w) => ({
              property: w.property,
              active: w._active
            }))
          };
        }
      };
      module.exports = {
        ModelBinder,
        ComputedProperty,
        PropertyWatcher,
        BindingManager
      };
    }
  });

  // node_modules/jsgui3-html/html-core/Transformations.js
  var require_Transformations = __commonJS({
    "node_modules/jsgui3-html/html-core/Transformations.js"(exports, module) {
      var { tof } = require_lang();
      var Transformations = {
        /**
         * Date transformations
         */
        date: {
          /**
           * Format a Date object to ISO string
           */
          toISO: (date) => {
            if (!date) return "";
            if (date instanceof Date) return date.toISOString();
            return new Date(date).toISOString();
          },
          /**
           * Format a Date object to locale string
           */
          toLocale: (date, locale = "en-US", options = {}) => {
            if (!date) return "";
            if (date instanceof Date) return date.toLocaleDateString(locale, options);
            return new Date(date).toLocaleDateString(locale, options);
          },
          /**
           * Format a Date object to custom format
           */
          format: (date, format = "YYYY-MM-DD") => {
            if (!date) return "";
            const d = date instanceof Date ? date : new Date(date);
            const map = {
              YYYY: d.getFullYear(),
              MM: String(d.getMonth() + 1).padStart(2, "0"),
              DD: String(d.getDate()).padStart(2, "0"),
              HH: String(d.getHours()).padStart(2, "0"),
              mm: String(d.getMinutes()).padStart(2, "0"),
              ss: String(d.getSeconds()).padStart(2, "0")
            };
            return format.replace(/YYYY|MM|DD|HH|mm|ss/g, (matched) => map[matched]);
          },
          /**
           * Parse a date string
           */
          parse: (str) => {
            if (!str) return null;
            const date = new Date(str);
            return isNaN(date.getTime()) ? null : date;
          },
          /**
           * Parse a date from custom format
           */
          parseFormat: (str, format = "YYYY-MM-DD") => {
            if (!str) return null;
            const parts = {
              YYYY: { start: format.indexOf("YYYY"), length: 4 },
              MM: { start: format.indexOf("MM"), length: 2 },
              DD: { start: format.indexOf("DD"), length: 2 }
            };
            const year = parseInt(str.substr(parts.YYYY.start, parts.YYYY.length));
            const month = parseInt(str.substr(parts.MM.start, parts.MM.length)) - 1;
            const day = parseInt(str.substr(parts.DD.start, parts.DD.length));
            return new Date(year, month, day);
          }
        },
        /**
         * Number transformations
         */
        number: {
          /**
           * Format number to string with decimals
           */
          toFixed: (num, decimals = 2) => {
            if (num === null || num === void 0) return "";
            return Number(num).toFixed(decimals);
          },
          /**
           * Format number with thousands separator
           */
          toLocale: (num, locale = "en-US", options = {}) => {
            if (num === null || num === void 0) return "";
            return Number(num).toLocaleString(locale, options);
          },
          /**
           * Format number as currency
           */
          toCurrency: (num, currency = "USD", locale = "en-US") => {
            if (num === null || num === void 0) return "";
            return Number(num).toLocaleString(locale, {
              style: "currency",
              currency
            });
          },
          /**
           * Format number as percentage
           */
          toPercent: (num, decimals = 0) => {
            if (num === null || num === void 0) return "";
            return (Number(num) * 100).toFixed(decimals) + "%";
          },
          /**
           * Parse number from string
           */
          parse: (str) => {
            if (str === null || str === void 0 || str === "") return null;
            const num = parseFloat(String(str).replace(/[^0-9.-]/g, ""));
            return isNaN(num) ? null : num;
          },
          /**
           * Parse integer from string
           */
          parseInt: (str) => {
            if (str === null || str === void 0 || str === "") return null;
            const num = parseInt(String(str).replace(/[^0-9-]/g, ""));
            return isNaN(num) ? null : num;
          },
          /**
           * Clamp number between min and max
           */
          clamp: (min, max) => (num) => {
            return Math.max(min, Math.min(max, Number(num)));
          }
        },
        /**
         * String transformations
         */
        string: {
          /**
           * Convert to uppercase
           */
          toUpper: (str) => {
            return str ? String(str).toUpperCase() : "";
          },
          /**
           * Convert to lowercase
           */
          toLower: (str) => {
            return str ? String(str).toLowerCase() : "";
          },
          /**
           * Capitalize first letter
           */
          capitalize: (str) => {
            if (!str) return "";
            const s = String(str);
            return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
          },
          /**
           * Capitalize each word
           */
          titleCase: (str) => {
            if (!str) return "";
            return String(str).split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
          },
          /**
           * Trim whitespace
           */
          trim: (str) => {
            return str ? String(str).trim() : "";
          },
          /**
           * Truncate string to length
           */
          truncate: (maxLength, suffix = "...") => (str) => {
            if (!str) return "";
            const s = String(str);
            if (s.length <= maxLength) return s;
            return s.substr(0, maxLength - suffix.length) + suffix;
          },
          /**
           * Default value if empty
           */
          default: (defaultValue) => (str) => {
            return str ? String(str) : defaultValue;
          }
        },
        /**
         * Boolean transformations
         */
        boolean: {
          /**
           * Convert to boolean
           */
          toBool: (value2) => {
            if (value2 === null || value2 === void 0) return false;
            if (typeof value2 === "boolean") return value2;
            if (typeof value2 === "number") return value2 !== 0;
            const str = String(value2).toLowerCase();
            return str === "true" || str === "1" || str === "yes";
          },
          /**
           * Convert to yes/no string
           */
          toYesNo: (value2) => {
            return Transformations.boolean.toBool(value2) ? "Yes" : "No";
          },
          /**
           * Convert to on/off string
           */
          toOnOff: (value2) => {
            return Transformations.boolean.toBool(value2) ? "On" : "Off";
          },
          /**
           * Invert boolean
           */
          not: (value2) => {
            return !Transformations.boolean.toBool(value2);
          }
        },
        /**
         * Array transformations
         */
        array: {
          /**
           * Join array to string
           */
          join: (separator = ", ") => (arr) => {
            if (!Array.isArray(arr)) return "";
            return arr.join(separator);
          },
          /**
           * Get array length
           */
          length: (arr) => {
            return Array.isArray(arr) ? arr.length : 0;
          },
          /**
           * Filter array
           */
          filter: (predicate) => (arr) => {
            if (!Array.isArray(arr)) return [];
            return arr.filter(predicate);
          },
          /**
           * Map array
           */
          map: (mapper) => (arr) => {
            if (!Array.isArray(arr)) return [];
            return arr.map(mapper);
          },
          /**
           * Get first element
           */
          first: (arr) => {
            return Array.isArray(arr) && arr.length > 0 ? arr[0] : null;
          },
          /**
           * Get last element
           */
          last: (arr) => {
            return Array.isArray(arr) && arr.length > 0 ? arr[arr.length - 1] : null;
          },
          /**
           * Sort array
           */
          sort: (compareFn) => (arr) => {
            if (!Array.isArray(arr)) return [];
            return [...arr].sort(compareFn);
          }
        },
        /**
         * Object transformations
         */
        object: {
          /**
           * Get property value
           */
          get: (propertyPath) => (obj2) => {
            if (!obj2) return null;
            const parts = propertyPath.split(".");
            let value2 = obj2;
            for (const part of parts) {
              if (value2 === null || value2 === void 0) return null;
              value2 = value2[part];
            }
            return value2;
          },
          /**
           * Check if object has property
           */
          has: (property) => (obj2) => {
            return obj2 && obj2.hasOwnProperty(property);
          },
          /**
           * Get object keys
           */
          keys: (obj2) => {
            return obj2 ? Object.keys(obj2) : [];
          },
          /**
           * Get object values
           */
          values: (obj2) => {
            return obj2 ? Object.values(obj2) : [];
          }
        },
        /**
         * Compose multiple transformations
         */
        compose: (...fns) => {
          return (value2) => {
            return fns.reduce((acc, fn) => fn(acc), value2);
          };
        },
        /**
         * Identity transformation (returns input unchanged)
         */
        identity: (value2) => value2,
        /**
         * Default value transformation
         */
        defaultTo: (defaultValue) => (value2) => {
          return value2 !== null && value2 !== void 0 ? value2 : defaultValue;
        },
        /**
         * Conditional transformation
         */
        when: (condition, thenTransform, elseTransform = Transformations.identity) => {
          return (value2) => {
            return condition(value2) ? thenTransform(value2) : elseTransform(value2);
          };
        },
        /**
         * Create a bidirectional transformation pair
         */
        bidirectional: (forward, reverse) => {
          return {
            transform: forward,
            reverse
          };
        }
      };
      var Validators = {
        /**
         * Required field validator
         */
        required: (value2) => {
          if (value2 === null || value2 === void 0) return false;
          if (typeof value2 === "string" && value2.trim() === "") return false;
          if (Array.isArray(value2) && value2.length === 0) return false;
          return true;
        },
        /**
         * Email validator
         */
        email: (value2) => {
          if (!value2) return true;
          const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          return re.test(String(value2));
        },
        /**
         * URL validator
         */
        url: (value2) => {
          if (!value2) return true;
          try {
            new URL(value2);
            return true;
          } catch {
            return false;
          }
        },
        /**
         * Number range validator
         */
        range: (min, max) => (value2) => {
          const num = Number(value2);
          if (isNaN(num)) return false;
          return num >= min && num <= max;
        },
        /**
         * String length validator
         */
        length: (min, max) => (value2) => {
          if (!value2) return true;
          const len = String(value2).length;
          return len >= min && len <= max;
        },
        /**
         * Pattern validator
         */
        pattern: (regex) => (value2) => {
          if (!value2) return true;
          return regex.test(String(value2));
        },
        /**
         * Custom validator
         */
        custom: (fn) => fn
      };
      module.exports = {
        Transformations,
        Validators
      };
    }
  });

  // node_modules/jsgui3-html/html-core/Data_Model_View_Model_Control.js
  var require_Data_Model_View_Model_Control = __commonJS({
    "node_modules/jsgui3-html/html-core/Data_Model_View_Model_Control.js"(exports, module) {
      var Ctrl_Enh = require_control_enh();
      var { Data_Object } = require_lang();
      var { ModelBinder, ComputedProperty, PropertyWatcher, BindingManager } = require_ModelBinder();
      var { Transformations, Validators } = require_Transformations();
      var Control_Data = require_Control_Data();
      var Control_View = require_Control_View();
      var { ensure_control_models } = require_control_model_factory();
      var Data_Model_View_Model_Control = class extends Ctrl_Enh {
        constructor(...a) {
          super(...a);
          const spec = a[0] || {};
          this._binding_manager = new BindingManager(this);
          const { context: context2 } = this;
          ensure_control_models(this, spec);
          if (this.data && this.data.model) {
            this.data.model.on("change", (e) => {
              console.log("Data_Model_View_Model_Control this.data.model change e:", e);
            });
            if (this.dom && this.dom.attributes) {
              this.dom.attributes["data-jsgui-data-model"] = this.data.model._id();
            }
          }
          if (this.view && this.view.data && this.view.data.model) {
            this.view.data.model.on("change", (e) => {
              console.log("Data_Model_View_Model_Control this.view.data.model change e:", e);
            });
            if (this.dom && this.dom.attributes) {
              this.dom.attributes["data-jsgui-view-data-model"] = this.view.data.model._id();
            }
          }
          if (spec.view && spec.view.model) {
            this.view.model = spec.view.model;
            this.view.model.on("change", (e) => {
              console.log("Data_Model_View_Model_Control this.view.model change e:", e);
            });
            if (this.dom && this.dom.attributes) {
              this.dom.attributes["data-jsgui-view-model"] = this.view.model._id();
            }
          }
          if (this.dom.el) {
            const context_keys = Array.from(Object.keys(this.context));
            const context_map_controls_keys = Array.from(Object.keys(this.context.map_controls));
            if (this.dom.el.hasAttribute("data-jsgui-data-model")) {
              const data_model_jsgui_id = this.dom.el.getAttribute("data-jsgui-data-model");
              const data_model = this.context.map_controls[data_model_jsgui_id];
              if (data_model) {
                this.data = this.data || new Control_Data({ context: context2 });
                this.data.model = data_model;
                data_model.on("change", (e) => {
                });
              }
            }
            if (this.dom.el.hasAttribute("data-jsgui-view-model")) {
              this.view = this.view || new Control_View({ context: context2 });
              const view_model_jsgui_id = this.dom.el.getAttribute("data-jsgui-view-model");
              const view_model = this.context.map_controls[view_model_jsgui_id];
              if (!!view_model) {
                this.view.model = view_model;
                view_model.on("change", (e) => {
                });
              } else {
              }
            } else {
              this.view = this.view || {};
              this.view.model = new Data_Object({
                context: context2
              });
            }
          }
        }
        pre_activate() {
          super.pre_activate();
          console.log("Data_Model_View_Model_Control pre_activate complete");
        }
        /**
         * Create a binding between data model and view model
         * @param {Object} bindings - Property binding definitions
         * @param {Object} options - Binding options
         * @example
         * this.bind({
         *     'date': {
         *         to: 'formattedDate',
         *         transform: (date) => formatDate(date, 'YYYY-MM-DD'),
         *         reverse: (str) => parseDate(str)
         *     }
         * });
         */
        bind(bindings, options = {}) {
          if (!this.data || !this.data.model) {
            console.warn("Data_Model_View_Model_Control.bind: No data.model available");
            return null;
          }
          if (!this.view || !this.view.data || !this.view.data.model) {
            console.warn("Data_Model_View_Model_Control.bind: No view.data.model available");
            return null;
          }
          return this._binding_manager.bind(
            this.data.model,
            this.view.data.model,
            bindings,
            options
          );
        }
        /**
         * Create a computed property on a model
         * @param {Object} model - Target model (data.model or view.data.model)
         * @param {Array|string} dependencies - Property names to watch
         * @param {Function} computeFn - Function to compute the value
         * @param {Object} options - Options including propertyName
         * @example
         * this.computed(this.view.data.model, ['firstName', 'lastName'], 
         *     (first, last) => `${first} ${last}`,
         *     { propertyName: 'fullName' }
         * );
         */
        computed(model, dependencies, computeFn, options = {}) {
          return this._binding_manager.createComputed(model, dependencies, computeFn, options);
        }
        /**
         * Watch a property for changes
         * @param {Object} model - Model to watch
         * @param {string} property - Property name to watch
         * @param {Function} callback - Callback function (newVal, oldVal) => void
         * @param {Object} options - Watch options
         * @example
         * this.watch(this.data.model, 'selectedItem', (newVal, oldVal) => {
         *     console.log('Selection changed:', oldVal, '', newVal);
         * });
         */
        watch(model, property, callback2, options = {}) {
          return this._binding_manager.watch(model, property, callback2, options);
        }
        /**
         * Get transformations library
         */
        get transforms() {
          return Transformations;
        }
        /**
         * Get validators library
         */
        get validators() {
          return Validators;
        }
        /**
         * Inspect all bindings for debugging
         */
        inspectBindings() {
          return this._binding_manager.inspect();
        }
        /**
         * Cleanup bindings when control is destroyed
         */
        destroy() {
          if (this._binding_manager) {
            this._binding_manager.cleanup();
          }
          if (super.destroy) {
            super.destroy();
          }
        }
      };
      module.exports = Data_Model_View_Model_Control;
    }
  });

  // node_modules/jsgui3-html/html-core/control.js
  var require_control = __commonJS({
    "node_modules/jsgui3-html/html-core/control.js"(exports, module) {
      var Control2 = require_Data_Model_View_Model_Control();
      module.exports = Control2;
    }
  });

  // node_modules/jsgui3-html/html-core/selection-scope.js
  var require_selection_scope = __commonJS({
    "node_modules/jsgui3-html/html-core/selection-scope.js"(exports, module) {
      var jsgui2 = require_lang();
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = require_control();
      var Selection_Scope = class extends jsgui2.Data_Object {
        //var Selection_Scope = jsgui.Class.extend({
        constructor(spec) {
          super(spec);
          if (spec.context) this.context = spec.context;
          if (typeof spec.id !== "undefined") this.id = spec.id;
          if (spec.ctrl) this.control = spec.ctrl;
          if (spec.control) this.control = spec.control;
          this.map_selected_controls = {};
        }
        "select_only"(ctrl2, silent = false) {
          var currently_selected;
          var count_deselected = 0;
          var selected;
          each(this.map_selected_controls, (v, i) => {
            if (v && v !== ctrl2 && v !== this.control) {
              if (v.selected) {
                v.selected = false;
                count_deselected++;
              }
            }
            if (v === ctrl2 && v !== this.control) {
              currently_selected = v.selected;
            }
          });
          this.map_selected_controls = {};
          if (typeof ctrl2._id === "function") {
            this.map_selected_controls[ctrl2._id()] = ctrl2;
          } else {
          }
          if (!currently_selected) {
            ctrl2.selected = true;
            if (!silent) {
              this.raise("change", {
                name: "selected",
                value: ctrl2
              });
              ctrl2.raise("select");
            }
          }
          if (count_deselected > 0 & !currently_selected) {
          }
        }
        "deselect_all"(silent = false) {
          each(this.map_selected_controls, (v, i) => {
            if (v) {
              if (v.selected) {
                v.selected = false;
                v.raise("deselect");
              }
            }
          });
          if (!silent) {
            this.raise("change", {
              name: "selected",
              value: void 0
            });
          }
          this.map_selected_controls = {};
        }
        "deselect"(ctrl2, silent = false) {
          if (ctrl2.selected === true) {
            ctrl2.selected = false;
          }
          if (!silent) {
            ctrl2.raise("deselected");
            this.raise("change", {
              name: "selected",
              map_selected_controls: this.map_selected_controls
            });
          }
        }
        "select"(ctrl2, silent = false) {
          if (!ctrl2.selected) {
            ctrl2.selected = true;
          }
          if (!silent) {
            ctrl2.raise("selected");
            this.raise("change", {
              name: "selected",
              map_selected_controls: this.map_selected_controls
            });
          }
        }
        // deselect controls internal to a control.
        // When selecting a control, we want to make it so that controls inside it, in the same selection context are not selected.
        //  The Selection Scope does a fair bit of the management of the selections.
        "deselect_ctrl_content"(ctrl2, silent = false) {
          var cs = ctrl2.selection_scope;
          var msc = this.map_selected_controls;
          ctrl2.content.each((v) => {
            if (v instanceof Control2) {
              v.selected = false;
              var id = v._id();
              if (msc[id]) msc[id] = false;
              this.deselect_ctrl_content(v);
              if (!silent) v.raise("deselected");
            }
          });
          if (!silent) {
            this.raise("change", {
              name: "selected",
              map_selected_controls: this.map_selected_controls
            });
          }
        }
        "select_toggle"(ctrl2, silent = false) {
          var sel = ctrl2.selected;
          var msc = this.map_selected_controls;
          var id = ctrl2._id();
          if (!sel) {
            var sel_anc = ctrl2.find_selected_ancestor_in_scope();
            if (sel_anc) {
              console.log("1) not selecting because a selected ancestor in the selection scope has been found.");
            } else {
              ctrl2.selected = true;
              this.deselect_ctrl_content(ctrl2, silent);
              msc[id] = ctrl2;
            }
          } else {
            var tsel = tof(sel);
            if (tsel === "boolean") {
              if (sel) {
                ctrl2.selected = false;
                msc[id] = false;
              } else {
                var sel_anc = ctrl2.find_selected_ancestor_in_scope();
                if (sel_anc) {
                  console.log("2) not selecting because a selected ancestor in the selection scope has been found.");
                } else {
                  this.deselect_ctrl_content(ctrl2, silent);
                  ctrl2.selected = true;
                  msc[id] = ctrl2;
                }
              }
            }
          }
          if (!silent) {
            this.raise("change");
          }
        }
      };
      module.exports = Selection_Scope;
    }
  });

  // node_modules/jsgui3-html/html-core/page-context.js
  var require_page_context = __commonJS({
    "node_modules/jsgui3-html/html-core/page-context.js"(exports, module) {
      var jsgui2 = require_lang();
      var { each, tof, is_defined, get_a_sig: get_a_sig2, Evented_Class, Data_Model } = jsgui2;
      var Selection_Scope = require_selection_scope();
      var Page_Context = class extends Evented_Class {
        constructor(spec) {
          spec = spec || {};
          super(spec);
          if (spec.browser_info) {
            this.browser_info = spec.browser_info;
          }
          ;
          if (spec.resource_pool) {
            this.resource_pool = spec.resource_pool;
          }
          this.get_vector_methodology = function() {
            if (this.browser_info.ie) {
              return "vml";
            } else {
              return "svg";
            }
          };
          this.selection_scopes = {};
          this.selection_scope_id_counter = 0;
          var map_new_ids = {};
          var map_objects = {};
          var _get_new_typed_object_id = (type_name) => {
            if (!is_defined(map_new_ids[type_name])) {
              map_new_ids[type_name] = 0;
            }
            var res2 = type_name + "_" + map_new_ids[type_name];
            map_new_ids[type_name]++;
            return res2;
          };
          this.new_id = _get_new_typed_object_id;
          this.set_max_ids = (map_max_ids) => {
            each(map_max_ids, (v, i) => {
              map_new_ids[i] = v + 1;
            });
          };
          var map_Controls = this.map_Controls = {};
          var map_controls = this.map_controls = {};
          this.map_data_models = this.map_data_models || {};
          this.map_data_model_iids = this.map_data_model_iids || {};
          this.map_control_iids = {};
          this.next_iid = 1;
        }
        "new_selection_scope"(ctrl2) {
          var res2 = new Selection_Scope({
            "context": this,
            "id": this.selection_scope_id_counter++,
            "ctrl": ctrl2
          });
          this.selection_scopes[res2.id] = res2;
          if (ctrl2) {
            ctrl2.selection_scope = res2;
            if (typeof document === "undefined") {
              ctrl2._fields = ctrl2._fields || {};
              ctrl2._fields.selection_scope = res2.id;
            }
          }
          return res2;
        }
        "make"(source) {
          let t_source = tof(source);
          if (t_source === "string") {
            let parsed = jsgui2.parse_and_mount(source, this);
          }
        }
        "update_Controls"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig === "[o]") {
            var o = a[0];
            var map_Controls = this.map_Controls;
            each(o, (name2, Constructor2) => {
              name2 = name2.toLowerCase();
              map_Controls[name2] = Constructor2;
            });
          }
          if (sig === "[s,f]") {
            var name = a[0];
            var Constructor = a[1];
            name = name.toLowerCase();
            this.map_Controls[name] = Constructor;
          }
        }
        "register_control"(control) {
          control.context = this;
          var id = control._id();
          this.map_controls[id] = control;
          control.iid = this.next_iid;
          this.map_control_iids[id] = this.next_iid++;
        }
        register_data_model(data_model) {
          if (data_model instanceof Data_Model) {
            const id = data_model._id();
            this.map_data_models[id] = data_model;
            data_model.iid = this.next_iid;
            this.map_data_model_iids[id] = this.next_iid++;
          } else {
            console.trace();
            throw "Expected Data_Model instance";
          }
        }
        "first_ctrl_matching_type"(type_name) {
          var res2;
          each(this.map_controls, (ctrl2, ctrl_id, fn_stop) => {
            if (ctrl2.__type_name === type_name) {
              fn_stop();
              res2 = ctrl2;
            }
          });
          return res2;
        }
      };
      module.exports = Page_Context;
    }
  });

  // node_modules/htmlparser/lib/htmlparser.js
  var require_htmlparser = __commonJS({
    "node_modules/htmlparser/lib/htmlparser.js"(exports, module) {
      (function() {
        function runningInNode() {
          return typeof __require == "function" && typeof exports == "object" && typeof module == "object" && typeof __filename == "string" && typeof __dirname == "string";
        }
        if (!runningInNode()) {
          var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : this;
          if (!_global.Tautologistics)
            _global.Tautologistics = {};
          else if (_global.Tautologistics.NodeHtmlParser)
            return;
          _global.Tautologistics.NodeHtmlParser = {};
          exports = _global.Tautologistics.NodeHtmlParser;
        }
        var ElementType = {
          Text: "text",
          Directive: "directive",
          Comment: "comment",
          Script: "script",
          Style: "style",
          Tag: "tag"
          //Any tag that isn't special
        };
        function Parser(handler, options) {
          this._options = options ? options : {};
          if (this._options.includeLocation == void 0) {
            this._options.includeLocation = false;
          }
          this.validateHandler(handler);
          this._handler = handler;
          this.reset();
        }
        Parser._reTrim = /(^\s+|\s+$)/g;
        Parser._reTrimComment = /(^\!--|--$)/g;
        Parser._reWhitespace = /\s/g;
        Parser._reTagName = /^\s*(\/?)\s*([^\s\/]+)/;
        Parser._reAttrib = //Find attributes in a tag
        /([^=<>\"\'\s]+)\s*=\s*"([^"]*)"|([^=<>\"\'\s]+)\s*=\s*'([^']*)'|([^=<>\"\'\s]+)\s*=\s*([^'"\s]+)|([^=<>\"\'\s\/]+)/g;
        Parser._reTags = /[\<\>]/g;
        Parser.prototype.parseComplete = function Parser$parseComplete(data) {
          this.reset();
          this.parseChunk(data);
          this.done();
        };
        Parser.prototype.parseChunk = function Parser$parseChunk(data) {
          if (this._done)
            this.handleError(new Error("Attempted to parse chunk after parsing already done"));
          this._buffer += data;
          this.parseTags();
        };
        Parser.prototype.done = function Parser$done() {
          if (this._done)
            return;
          this._done = true;
          if (this._buffer.length) {
            var rawData = this._buffer;
            this._buffer = "";
            var element = {
              raw: rawData,
              data: this._parseState == ElementType.Text ? rawData : rawData.replace(Parser._reTrim, ""),
              type: this._parseState
            };
            if (this._parseState == ElementType.Tag || this._parseState == ElementType.Script || this._parseState == ElementType.Style)
              element.name = this.parseTagName(element.data);
            this.parseAttribs(element);
            this._elements.push(element);
          }
          this.writeHandler();
          this._handler.done();
        };
        Parser.prototype.reset = function Parser$reset() {
          this._buffer = "";
          this._done = false;
          this._elements = [];
          this._elementsCurrent = 0;
          this._current = 0;
          this._next = 0;
          this._location = {
            row: 0,
            col: 0,
            charOffset: 0,
            inBuffer: 0
          };
          this._parseState = ElementType.Text;
          this._prevTagSep = "";
          this._tagStack = [];
          this._handler.reset();
        };
        Parser.prototype._options = null;
        Parser.prototype._handler = null;
        Parser.prototype._buffer = null;
        Parser.prototype._done = false;
        Parser.prototype._elements = null;
        Parser.prototype._elementsCurrent = 0;
        Parser.prototype._current = 0;
        Parser.prototype._next = 0;
        Parser.prototype._location = null;
        Parser.prototype._parseState = ElementType.Text;
        Parser.prototype._prevTagSep = "";
        Parser.prototype._tagStack = null;
        Parser.prototype.parseTagAttribs = function Parser$parseTagAttribs(elements) {
          var idxEnd = elements.length;
          var idx = 0;
          while (idx < idxEnd) {
            var element = elements[idx++];
            if (element.type == ElementType.Tag || element.type == ElementType.Script || element.type == ElementType.style)
              this.parseAttribs(element);
          }
          return elements;
        };
        Parser.prototype.parseAttribs = function Parser$parseAttribs(element) {
          if (element.type != ElementType.Script && element.type != ElementType.Style && element.type != ElementType.Tag)
            return;
          var tagName = element.data.split(Parser._reWhitespace, 1)[0];
          var attribRaw = element.data.substring(tagName.length);
          if (attribRaw.length < 1)
            return;
          var match;
          Parser._reAttrib.lastIndex = 0;
          while (match = Parser._reAttrib.exec(attribRaw)) {
            if (element.attribs == void 0)
              element.attribs = {};
            if (typeof match[1] == "string" && match[1].length) {
              element.attribs[match[1]] = match[2];
            } else if (typeof match[3] == "string" && match[3].length) {
              element.attribs[match[3].toString()] = match[4].toString();
            } else if (typeof match[5] == "string" && match[5].length) {
              element.attribs[match[5]] = match[6];
            } else if (typeof match[7] == "string" && match[7].length) {
              element.attribs[match[7]] = match[7];
            }
          }
        };
        Parser.prototype.parseTagName = function Parser$parseTagName(data) {
          if (data == null || data == "")
            return "";
          var match = Parser._reTagName.exec(data);
          if (!match)
            return "";
          return (match[1] ? "/" : "") + match[2];
        };
        Parser.prototype.parseTags = function Parser$parseTags() {
          var bufferEnd = this._buffer.length - 1;
          while (Parser._reTags.test(this._buffer)) {
            this._next = Parser._reTags.lastIndex - 1;
            var tagSep = this._buffer.charAt(this._next);
            var rawData = this._buffer.substring(this._current, this._next);
            var element = {
              raw: rawData,
              data: this._parseState == ElementType.Text ? rawData : rawData.replace(Parser._reTrim, ""),
              type: this._parseState
            };
            var elementName = this.parseTagName(element.data);
            if (this._tagStack.length) {
              if (this._tagStack[this._tagStack.length - 1] == ElementType.Script) {
                if (elementName.toLowerCase() == "/script")
                  this._tagStack.pop();
                else {
                  if (element.raw.indexOf("!--") != 0) {
                    element.type = ElementType.Text;
                    if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Text) {
                      var prevElement = this._elements[this._elements.length - 1];
                      prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep + element.raw;
                      element.raw = element.data = "";
                    }
                  }
                }
              } else if (this._tagStack[this._tagStack.length - 1] == ElementType.Style) {
                if (elementName.toLowerCase() == "/style")
                  this._tagStack.pop();
                else {
                  if (element.raw.indexOf("!--") != 0) {
                    element.type = ElementType.Text;
                    if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Text) {
                      var prevElement = this._elements[this._elements.length - 1];
                      if (element.raw != "") {
                        prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep + element.raw;
                        element.raw = element.data = "";
                      } else {
                        prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep;
                      }
                    } else {
                      if (element.raw != "") {
                        element.raw = element.data = element.raw;
                      }
                    }
                  }
                }
              } else if (this._tagStack[this._tagStack.length - 1] == ElementType.Comment) {
                var rawLen = element.raw.length;
                if (element.raw.charAt(rawLen - 2) == "-" && element.raw.charAt(rawLen - 1) == "-" && tagSep == ">") {
                  this._tagStack.pop();
                  if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Comment) {
                    var prevElement = this._elements[this._elements.length - 1];
                    prevElement.raw = prevElement.data = (prevElement.raw + element.raw).replace(Parser._reTrimComment, "");
                    element.raw = element.data = "";
                    element.type = ElementType.Text;
                  } else
                    element.type = ElementType.Comment;
                } else {
                  element.type = ElementType.Comment;
                  if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Comment) {
                    var prevElement = this._elements[this._elements.length - 1];
                    prevElement.raw = prevElement.data = prevElement.raw + element.raw + tagSep;
                    element.raw = element.data = "";
                    element.type = ElementType.Text;
                  } else
                    element.raw = element.data = element.raw + tagSep;
                }
              }
            }
            if (element.type == ElementType.Tag) {
              element.name = elementName;
              var elementNameCI = elementName.toLowerCase();
              if (element.raw.indexOf("!--") == 0) {
                element.type = ElementType.Comment;
                delete element["name"];
                var rawLen = element.raw.length;
                if (element.raw.charAt(rawLen - 1) == "-" && element.raw.charAt(rawLen - 2) == "-" && tagSep == ">")
                  element.raw = element.data = element.raw.replace(Parser._reTrimComment, "");
                else {
                  element.raw += tagSep;
                  this._tagStack.push(ElementType.Comment);
                }
              } else if (element.raw.indexOf("!") == 0 || element.raw.indexOf("?") == 0) {
                element.type = ElementType.Directive;
              } else if (elementNameCI == "script") {
                element.type = ElementType.Script;
                if (element.data.charAt(element.data.length - 1) != "/")
                  this._tagStack.push(ElementType.Script);
              } else if (elementNameCI == "/script")
                element.type = ElementType.Script;
              else if (elementNameCI == "style") {
                element.type = ElementType.Style;
                if (element.data.charAt(element.data.length - 1) != "/")
                  this._tagStack.push(ElementType.Style);
              } else if (elementNameCI == "/style")
                element.type = ElementType.Style;
              if (element.name && element.name.charAt(0) == "/")
                element.data = element.name;
            }
            if (element.raw != "" || element.type != ElementType.Text) {
              if (this._options.includeLocation && !element.location) {
                element.location = this.getLocation(element.type == ElementType.Tag);
              }
              this.parseAttribs(element);
              this._elements.push(element);
              if (element.type != ElementType.Text && element.type != ElementType.Comment && element.type != ElementType.Directive && element.data.charAt(element.data.length - 1) == "/")
                this._elements.push({
                  raw: "/" + element.name,
                  data: "/" + element.name,
                  name: "/" + element.name,
                  type: element.type
                });
            }
            this._parseState = tagSep == "<" ? ElementType.Tag : ElementType.Text;
            this._current = this._next + 1;
            this._prevTagSep = tagSep;
          }
          if (this._options.includeLocation) {
            this.getLocation();
            this._location.row += this._location.inBuffer;
            this._location.inBuffer = 0;
            this._location.charOffset = 0;
          }
          this._buffer = this._current <= bufferEnd ? this._buffer.substring(this._current) : "";
          this._current = 0;
          this.writeHandler();
        };
        Parser.prototype.getLocation = function Parser$getLocation(startTag) {
          var c2, l2 = this._location, end = this._current - (startTag ? 1 : 0), chunk = startTag && l2.charOffset == 0 && this._current == 0;
          for (; l2.charOffset < end; l2.charOffset++) {
            c2 = this._buffer.charAt(l2.charOffset);
            if (c2 == "\n") {
              l2.inBuffer++;
              l2.col = 0;
            } else if (c2 != "\r") {
              l2.col++;
            }
          }
          return {
            line: l2.row + l2.inBuffer + 1,
            col: l2.col + (chunk ? 0 : 1)
          };
        };
        Parser.prototype.validateHandler = function Parser$validateHandler(handler) {
          if (typeof handler != "object")
            throw new Error("Handler is not an object");
          if (typeof handler.reset != "function")
            throw new Error("Handler method 'reset' is invalid");
          if (typeof handler.done != "function")
            throw new Error("Handler method 'done' is invalid");
          if (typeof handler.writeTag != "function")
            throw new Error("Handler method 'writeTag' is invalid");
          if (typeof handler.writeText != "function")
            throw new Error("Handler method 'writeText' is invalid");
          if (typeof handler.writeComment != "function")
            throw new Error("Handler method 'writeComment' is invalid");
          if (typeof handler.writeDirective != "function")
            throw new Error("Handler method 'writeDirective' is invalid");
        };
        Parser.prototype.writeHandler = function Parser$writeHandler(forceFlush) {
          forceFlush = !!forceFlush;
          if (this._tagStack.length && !forceFlush)
            return;
          while (this._elements.length) {
            var element = this._elements.shift();
            switch (element.type) {
              case ElementType.Comment:
                this._handler.writeComment(element);
                break;
              case ElementType.Directive:
                this._handler.writeDirective(element);
                break;
              case ElementType.Text:
                this._handler.writeText(element);
                break;
              default:
                this._handler.writeTag(element);
                break;
            }
          }
        };
        Parser.prototype.handleError = function Parser$handleError(error2) {
          if (typeof this._handler.error == "function")
            this._handler.error(error2);
          else
            throw error2;
        };
        function RssHandler(callback2) {
          RssHandler.super_.call(this, callback2, { ignoreWhitespace: true, verbose: false, enforceEmptyTags: false });
        }
        inherits(RssHandler, DefaultHandler);
        RssHandler.prototype.done = function RssHandler$done() {
          var feed = {};
          var feedRoot;
          var found = DomUtils.getElementsByTagName(function(value2) {
            return value2 == "rss" || value2 == "feed";
          }, this.dom, false);
          if (found.length) {
            feedRoot = found[0];
          }
          if (feedRoot) {
            if (feedRoot.name == "rss") {
              feed.type = "rss";
              feedRoot = feedRoot.children[0];
              feed.id = "";
              try {
                feed.title = DomUtils.getElementsByTagName("title", feedRoot.children, false)[0].children[0].data;
              } catch (ex) {
              }
              try {
                feed.link = DomUtils.getElementsByTagName("link", feedRoot.children, false)[0].children[0].data;
              } catch (ex) {
              }
              try {
                feed.description = DomUtils.getElementsByTagName("description", feedRoot.children, false)[0].children[0].data;
              } catch (ex) {
              }
              try {
                feed.updated = new Date(DomUtils.getElementsByTagName("lastBuildDate", feedRoot.children, false)[0].children[0].data);
              } catch (ex) {
              }
              try {
                feed.author = DomUtils.getElementsByTagName("managingEditor", feedRoot.children, false)[0].children[0].data;
              } catch (ex) {
              }
              feed.items = [];
              DomUtils.getElementsByTagName("item", feedRoot.children).forEach(function(item2, index, list) {
                var entry = {};
                try {
                  entry.id = DomUtils.getElementsByTagName("guid", item2.children, false)[0].children[0].data;
                } catch (ex) {
                }
                try {
                  entry.title = DomUtils.getElementsByTagName("title", item2.children, false)[0].children[0].data;
                } catch (ex) {
                }
                try {
                  entry.link = DomUtils.getElementsByTagName("link", item2.children, false)[0].children[0].data;
                } catch (ex) {
                }
                try {
                  entry.description = DomUtils.getElementsByTagName("description", item2.children, false)[0].children[0].data;
                } catch (ex) {
                }
                try {
                  entry.pubDate = new Date(DomUtils.getElementsByTagName("pubDate", item2.children, false)[0].children[0].data);
                } catch (ex) {
                }
                feed.items.push(entry);
              });
            } else {
              feed.type = "atom";
              try {
                feed.id = DomUtils.getElementsByTagName("id", feedRoot.children, false)[0].children[0].data;
              } catch (ex) {
              }
              try {
                feed.title = DomUtils.getElementsByTagName("title", feedRoot.children, false)[0].children[0].data;
              } catch (ex) {
              }
              try {
                feed.link = DomUtils.getElementsByTagName("link", feedRoot.children, false)[0].attribs.href;
              } catch (ex) {
              }
              try {
                feed.description = DomUtils.getElementsByTagName("subtitle", feedRoot.children, false)[0].children[0].data;
              } catch (ex) {
              }
              try {
                feed.updated = new Date(DomUtils.getElementsByTagName("updated", feedRoot.children, false)[0].children[0].data);
              } catch (ex) {
              }
              try {
                feed.author = DomUtils.getElementsByTagName("email", feedRoot.children, true)[0].children[0].data;
              } catch (ex) {
              }
              feed.items = [];
              DomUtils.getElementsByTagName("entry", feedRoot.children).forEach(function(item2, index, list) {
                var entry = {};
                try {
                  entry.id = DomUtils.getElementsByTagName("id", item2.children, false)[0].children[0].data;
                } catch (ex) {
                }
                try {
                  entry.title = DomUtils.getElementsByTagName("title", item2.children, false)[0].children[0].data;
                } catch (ex) {
                }
                try {
                  entry.link = DomUtils.getElementsByTagName("link", item2.children, false)[0].attribs.href;
                } catch (ex) {
                }
                try {
                  entry.description = DomUtils.getElementsByTagName("summary", item2.children, false)[0].children[0].data;
                } catch (ex) {
                }
                try {
                  entry.pubDate = new Date(DomUtils.getElementsByTagName("updated", item2.children, false)[0].children[0].data);
                } catch (ex) {
                }
                feed.items.push(entry);
              });
            }
            this.dom = feed;
          }
          RssHandler.super_.prototype.done.call(this);
        };
        function DefaultHandler(callback2, options) {
          this.reset();
          this._options = options ? options : {};
          if (this._options.ignoreWhitespace == void 0)
            this._options.ignoreWhitespace = false;
          if (this._options.verbose == void 0)
            this._options.verbose = true;
          if (this._options.enforceEmptyTags == void 0)
            this._options.enforceEmptyTags = true;
          if (typeof callback2 == "function")
            this._callback = callback2;
        }
        DefaultHandler._emptyTags = {
          area: 1,
          base: 1,
          basefont: 1,
          br: 1,
          col: 1,
          frame: 1,
          hr: 1,
          img: 1,
          input: 1,
          isindex: 1,
          link: 1,
          meta: 1,
          param: 1,
          embed: 1
        };
        DefaultHandler.reWhitespace = /^\s*$/;
        DefaultHandler.prototype.dom = null;
        DefaultHandler.prototype.reset = function DefaultHandler$reset() {
          this.dom = [];
          this._done = false;
          this._tagStack = [];
          this._tagStack.last = function DefaultHandler$_tagStack$last() {
            return this.length ? this[this.length - 1] : null;
          };
        };
        DefaultHandler.prototype.done = function DefaultHandler$done() {
          this._done = true;
          this.handleCallback(null);
        };
        DefaultHandler.prototype.writeTag = function DefaultHandler$writeTag(element) {
          this.handleElement(element);
        };
        DefaultHandler.prototype.writeText = function DefaultHandler$writeText(element) {
          if (this._options.ignoreWhitespace) {
            if (DefaultHandler.reWhitespace.test(element.data))
              return;
          }
          this.handleElement(element);
        };
        DefaultHandler.prototype.writeComment = function DefaultHandler$writeComment(element) {
          this.handleElement(element);
        };
        DefaultHandler.prototype.writeDirective = function DefaultHandler$writeDirective(element) {
          this.handleElement(element);
        };
        DefaultHandler.prototype.error = function DefaultHandler$error(error2) {
          this.handleCallback(error2);
        };
        DefaultHandler.prototype._options = null;
        DefaultHandler.prototype._callback = null;
        DefaultHandler.prototype._done = false;
        DefaultHandler.prototype._tagStack = null;
        DefaultHandler.prototype.handleCallback = function DefaultHandler$handleCallback(error2) {
          if (typeof this._callback != "function")
            if (error2)
              throw error2;
            else
              return;
          this._callback(error2, this.dom);
        };
        DefaultHandler.prototype.isEmptyTag = function(element) {
          var name = element.name.toLowerCase();
          if (name.charAt(0) == "/") {
            name = name.substring(1);
          }
          return this._options.enforceEmptyTags && !!DefaultHandler._emptyTags[name];
        };
        DefaultHandler.prototype.handleElement = function DefaultHandler$handleElement(element) {
          if (this._done)
            this.handleCallback(new Error("Writing to the handler after done() called is not allowed without a reset()"));
          if (!this._options.verbose) {
            delete element.raw;
            if (element.type == "tag" || element.type == "script" || element.type == "style")
              delete element.data;
          }
          if (!this._tagStack.last()) {
            if (element.type != ElementType.Text && element.type != ElementType.Comment && element.type != ElementType.Directive) {
              if (element.name.charAt(0) != "/") {
                this.dom.push(element);
                if (!this.isEmptyTag(element)) {
                  this._tagStack.push(element);
                }
              }
            } else
              this.dom.push(element);
          } else {
            if (element.type != ElementType.Text && element.type != ElementType.Comment && element.type != ElementType.Directive) {
              if (element.name.charAt(0) == "/") {
                var baseName = element.name.substring(1);
                if (!this.isEmptyTag(element)) {
                  var pos = this._tagStack.length - 1;
                  while (pos > -1 && this._tagStack[pos--].name != baseName) {
                  }
                  if (pos > -1 || this._tagStack[0].name == baseName)
                    while (pos < this._tagStack.length - 1)
                      this._tagStack.pop();
                }
              } else {
                if (!this._tagStack.last().children)
                  this._tagStack.last().children = [];
                this._tagStack.last().children.push(element);
                if (!this.isEmptyTag(element))
                  this._tagStack.push(element);
              }
            } else {
              if (!this._tagStack.last().children)
                this._tagStack.last().children = [];
              this._tagStack.last().children.push(element);
            }
          }
        };
        var DomUtils = {
          testElement: function DomUtils$testElement(options, element) {
            if (!element) {
              return false;
            }
            for (var key2 in options) {
              if (key2 == "tag_name") {
                if (element.type != "tag" && element.type != "script" && element.type != "style") {
                  return false;
                }
                if (!options["tag_name"](element.name)) {
                  return false;
                }
              } else if (key2 == "tag_type") {
                if (!options["tag_type"](element.type)) {
                  return false;
                }
              } else if (key2 == "tag_contains") {
                if (element.type != "text" && element.type != "comment" && element.type != "directive") {
                  return false;
                }
                if (!options["tag_contains"](element.data)) {
                  return false;
                }
              } else {
                if (!element.attribs || !options[key2](element.attribs[key2])) {
                  return false;
                }
              }
            }
            return true;
          },
          getElements: function DomUtils$getElements(options, currentElement, recurse, limit) {
            recurse = recurse === void 0 || recurse === null || !!recurse;
            limit = isNaN(parseInt(limit)) ? -1 : parseInt(limit);
            if (!currentElement) {
              return [];
            }
            var found = [];
            var elementList;
            function getTest(checkVal) {
              return (function(value2) {
                return value2 == checkVal;
              });
            }
            for (var key2 in options) {
              if (typeof options[key2] != "function") {
                options[key2] = getTest(options[key2]);
              }
            }
            if (DomUtils.testElement(options, currentElement)) {
              found.push(currentElement);
            }
            if (limit >= 0 && found.length >= limit) {
              return found;
            }
            if (recurse && currentElement.children) {
              elementList = currentElement.children;
            } else if (currentElement instanceof Array) {
              elementList = currentElement;
            } else {
              return found;
            }
            for (var i = 0; i < elementList.length; i++) {
              found = found.concat(DomUtils.getElements(options, elementList[i], recurse, limit));
              if (limit >= 0 && found.length >= limit) {
                break;
              }
            }
            return found;
          },
          getElementById: function DomUtils$getElementById(id, currentElement, recurse) {
            var result = DomUtils.getElements({ id }, currentElement, recurse, 1);
            return result.length ? result[0] : null;
          },
          getElementsByTagName: function DomUtils$getElementsByTagName(name, currentElement, recurse, limit) {
            return DomUtils.getElements({ tag_name: name }, currentElement, recurse, limit);
          },
          getElementsByTagType: function DomUtils$getElementsByTagType(type, currentElement, recurse, limit) {
            return DomUtils.getElements({ tag_type: type }, currentElement, recurse, limit);
          }
        };
        function inherits(ctor, superCtor) {
          var tempCtor = function() {
          };
          tempCtor.prototype = superCtor.prototype;
          ctor.super_ = superCtor;
          ctor.prototype = new tempCtor();
          ctor.prototype.constructor = ctor;
        }
        exports.Parser = Parser;
        exports.DefaultHandler = DefaultHandler;
        exports.RssHandler = RssHandler;
        exports.ElementType = ElementType;
        exports.DomUtils = DomUtils;
      })();
    }
  });

  // node_modules/jsgui3-html/html-core/parse-mount.js
  var require_parse_mount = __commonJS({
    "node_modules/jsgui3-html/html-core/parse-mount.js"(exports, module) {
      var htmlparser = require_htmlparser();
      var { tof, each } = require_lang();
      var map_jsgui_attr_names = {
        "name": true,
        "class": true,
        "content": true,
        "__type_name": true,
        "context": true,
        "key": true,
        "size": true
      };
      var log = () => {
      };
      var parse = function(str_content, context2, control_set, callback2) {
        str_content = str_content.trim();
        const handler = new htmlparser.DefaultHandler(function(error2, dom) {
          if (error2) {
            log("parse error", error2);
          } else {
            log("dom", dom);
            let recurse = (dom2, depth, callback3) => {
              let tdom = tof(dom2);
              let res3;
              log("tdom", tdom);
              log("dom item", dom2);
              if (tdom === "array") {
                each(dom2, (v, i) => {
                  recurse(v, depth + 1, callback3);
                  callback3(v, depth, i);
                });
              } else if (tdom === "object") {
                if (dom2.children) {
                  each(dom2.children, (child, i) => {
                    recurse(child, depth + 1, callback3);
                    callback3(child, depth, i);
                  });
                }
              } else {
                log("dom", dom2);
              }
            };
            let last_depth = 0;
            let map_siblings_at_depth = {};
            let res_controls = {};
            const handle_text = (text, depth, sibling_index) => {
              let tn = new control_set.Text_Node({
                text,
                context: context2,
                sibling_index
              });
              res_controls.unnamed = res_controls.unnamed || [];
              res_controls.unnamed.push(tn);
              map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
              map_siblings_at_depth[depth].push(tn);
              last_depth = depth;
            };
            const handle_tag = (tag, depth, sibling_index) => {
              const tag_with_no_children = {};
              if (tag.raw) tag_with_no_children.raw = tag.raw;
              if (tag.data) tag_with_no_children.data = tag.data;
              if (tag.type) tag_with_no_children.type = tag.type;
              if (tag.name) tag_with_no_children.name = tag.name;
              if (tag.attribs) tag_with_no_children.attribs = tag.attribs;
              const create_ctrl = (tag2, content) => {
                if (control_set[tag2.name]) {
                  let Ctrl = control_set[tag2.name];
                  log("tag", tag2);
                  let a = tag2.attribs || {};
                  if (content) a.content = content;
                  each(content, (item2) => {
                  });
                  log("attribs a", a);
                  log("\n\n");
                  a.context = context2;
                  let ctrl3 = new Ctrl(a);
                  if (a.name) {
                    res_controls.named = res_controls.named || {};
                    res_controls.named[a.name] = ctrl3;
                  } else {
                    res_controls.unnamed = res_controls.unnamed || [];
                    res_controls.unnamed.push(ctrl3);
                  }
                  const arr_dom_attrs = [];
                  each(a, (a_value, a_name) => {
                    if (!map_jsgui_attr_names[a_name]) {
                      arr_dom_attrs.push([a_name, a_value]);
                    }
                  });
                  each(arr_dom_attrs, (attr) => {
                    const [name, value2] = attr;
                    ctrl3.dom.attributes[name] = value2;
                  });
                  return ctrl3;
                } else {
                  console.trace();
                  throw "lacking jsgui control for " + tag2.name;
                }
              };
              let my_children;
              let ctrl2;
              if (depth > last_depth) {
                ctrl2 = create_ctrl(tag_with_no_children);
                map_siblings_at_depth[depth] = [];
                map_siblings_at_depth[depth].push(ctrl2);
              } else if (depth < last_depth) {
                my_children = map_siblings_at_depth[last_depth];
                if (my_children) {
                  ctrl2 = create_ctrl(tag_with_no_children, my_children);
                } else {
                  ctrl2 = create_ctrl(tag_with_no_children);
                }
                map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                map_siblings_at_depth[last_depth] = null;
                map_siblings_at_depth[depth].push(ctrl2);
              } else {
                ctrl2 = create_ctrl(tag_with_no_children);
                map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                map_siblings_at_depth[depth].push(ctrl2);
              }
              last_depth = depth;
            };
            recurse(dom, 0, (item2, depth, sibling_index) => {
              if (item2.type === "text") {
                let trimmed = item2.data.trim();
                if (trimmed.length > 0) {
                  handle_text(item2.raw, depth, sibling_index);
                }
              } else if (item2.type === "tag") {
                handle_tag(item2, depth, sibling_index);
              }
            });
            const depth_0_ctrls = map_siblings_at_depth[0];
            callback2(null, [depth_0_ctrls, res_controls]);
          }
        });
        var parser = new htmlparser.Parser(handler);
        parser.parseComplete(str_content);
      };
      var parse_mount = function(str_content, target, control_set) {
        return new Promise(async (solve, jettison) => {
          let container;
          let a = arguments;
          let l2 = a.length;
          if (l2 === 4) {
            container = a[2];
            control_set = a[3];
          } else {
            container = target;
          }
          const { context: context2 } = target;
          parse(str_content, context2, control_set, (err, res_parse) => {
            if (err) {
              jettison(err);
            } else {
              const [depth_0_ctrls, res_controls] = res_parse;
              each(res_controls.named, (ctrl2, name) => {
                target[name] = ctrl2;
              });
              const is_active_context = context2.__is_active;
              each(depth_0_ctrls, (new_ctrl) => {
                container.add(new_ctrl);
                if (is_active_context) {
                  setTimeout(() => {
                    new_ctrl.activate();
                  }, 0);
                }
              });
              if (res_controls.named) {
                target._ctrl_fields = target._ctrl_fields || {};
                Object.assign(target._ctrl_fields, res_controls.named);
              }
              solve(depth_0_ctrls);
            }
          });
        });
      };
      var res2 = {
        parse,
        parse_mount
      };
      module.exports = res2;
    }
  });

  // node_modules/jsgui3-html/html-core/html-core.js
  var require_html_core = __commonJS({
    "node_modules/jsgui3-html/html-core/html-core.js"(exports, module) {
      var jsgui2 = require_lang();
      var Text_Node = require_text_node();
      var Page_Context = require_page_context();
      var Selection_Scope = require_selection_scope();
      var Control_Data = require_Control_Data();
      var Control_View = require_Control_View();
      var { parse_mount, parse } = require_parse_mount();
      var { str_arr_mapify, get_a_sig: get_a_sig2, each, prop } = jsgui2;
      var Control2 = jsgui2.Control = require_Data_Model_View_Model_Control();
      jsgui2.load_type("control", "C", (item2) => item2 instanceof Control2);
      var Evented_Class = jsgui2.Evented_Class;
      var tof = jsgui2.tof;
      var map_Controls = jsgui2.map_Controls = {};
      var def = jsgui2.is_defined;
      var core_extension = str_arr_mapify(function(tagName) {
        jsgui2.controls[tagName] = jsgui2[tagName] = class extends Control2 {
          constructor(spec) {
            let str;
            if (typeof spec === "string") {
              str = spec;
              spec = {
                __type_name: tagName
              };
            } else {
              if (typeof spec === "object") {
                spec.__type_name = tagName;
              }
            }
            super(spec);
            this.dom.tagName = tagName;
          }
        };
        jsgui2[tagName].prototype._tag_name = tagName;
        map_Controls[tagName] = jsgui2[tagName];
      });
      var core_extension_no_closing_tag = str_arr_mapify(function(tagName) {
        jsgui2[tagName] = class extends Control2 {
          constructor(spec) {
            spec.__type_name = tagName;
            super(spec);
            this.dom.tagName = tagName;
            this.dom.noClosingTag = true;
          }
        };
        jsgui2[tagName].prototype._tag_name = tagName;
        map_Controls[tagName] = jsgui2[tagName];
      });
      var recursive_dom_iterate = function(el, callback2) {
        callback2(el);
        var cns = el.childNodes;
        for (var c2 = 0, l2 = cns.length; c2 < l2; c2++) {
          recursive_dom_iterate(cns[c2], callback2);
        }
      };
      var recursive_dom_iterate_depth2 = function(el, callback2) {
        var cns = el.childNodes;
        for (var c2 = 0, l2 = cns.length; c2 < l2; c2++) {
          recursive_dom_iterate_depth2(cns[c2], callback2);
        }
        callback2(el);
      };
      var pre_activate = (context2) => {
        console.log("jsgui html-core pre_activate");
        if (!context2) {
          throw "jsgui-html-enh pre_activate(context) - need to supply context parameter.";
        }
        const map_controls = context2.map_controls || {};
        var map_jsgui_els = {};
        var map_jsgui_types = {};
        var arr_controls = [];
        var max_typed_ids = {};
        const map_ctrl_parent_ids_by_ctrl_ids = {};
        var id_before__ = function(id) {
          var pos1 = id.lastIndexOf("_");
          var res2 = id.substr(0, pos1);
          return res2;
        };
        var num_after = function(id) {
          return parseInt(id.substr(id.lastIndexOf("_") + 1), 10);
        };
        let map_els = () => {
          recursive_dom_iterate(document, (el) => {
            const nt = el.nodeType;
            if (nt === 1) {
              const jsgui_id = el.getAttribute("data-jsgui-id");
              if (jsgui_id) {
                if (el.parentNode) {
                  if (el.parentNode.nodeType === 1) {
                    const parent_jsgui_id = el.parentNode.getAttribute("data-jsgui-id");
                    if (parent_jsgui_id) {
                      map_ctrl_parent_ids_by_ctrl_ids[jsgui_id] = parent_jsgui_id;
                    }
                  }
                }
                const ib = id_before__(jsgui_id), num = num_after(jsgui_id);
                if (!def(max_typed_ids[ib])) {
                  max_typed_ids[ib] = num;
                } else {
                  if (num > max_typed_ids[ib]) max_typed_ids[ib] = num;
                }
                map_jsgui_els[jsgui_id] = el;
                var jsgui_type = el.getAttribute("data-jsgui-type");
                if (jsgui_type) map_jsgui_types[jsgui_id] = jsgui_type;
              }
            }
          });
        };
        map_els();
        context2.set_max_ids(max_typed_ids);
        each(map_jsgui_els, (el, jsgui_id) => {
          const l_tag_name = el.tagName.toLowerCase();
          if (jsgui_id) {
            var type = map_jsgui_types[jsgui_id];
            if (!map_controls[jsgui_id]) {
              var Cstr = context2.map_Controls[type];
              if (Cstr) {
                const parent_jsgui_id = map_ctrl_parent_ids_by_ctrl_ids[jsgui_id];
                const ctrl_spec = {
                  "context": context2,
                  "__type_name": type,
                  "id": jsgui_id,
                  "el": el
                };
                if (parent_jsgui_id) {
                  if (map_controls[parent_jsgui_id]) {
                  }
                }
                var ctrl2 = new Cstr(ctrl_spec);
                if (parent_jsgui_id) {
                  if (map_controls[parent_jsgui_id]) {
                  }
                }
                arr_controls.push(ctrl2);
                if (l_tag_name === "html") {
                  context2.ctrl_document = ctrl2;
                }
                map_controls[jsgui_id] = ctrl2;
              } else {
                console.log("Missing context.map_Controls for type " + type + ", using generic Control");
                var ctrl2 = new Control2({
                  "context": context2,
                  "__type_name": type,
                  "id": jsgui_id,
                  "el": el
                });
                arr_controls.push(ctrl2);
                map_controls[jsgui_id] = ctrl2;
              }
            } else {
              var ctrl2 = map_controls[jsgui_id];
              ctrl2.dom.el = el;
              if (ctrl2.attach_dom_events) ctrl2.attach_dom_events();
            }
          }
        });
        recursive_dom_iterate_depth2(document, (el) => {
          var nt = el.nodeType;
          if (nt === 1) {
            var jsgui_id = el.getAttribute("data-jsgui-id");
            if (jsgui_id) {
              const ctrl2 = map_controls[jsgui_id];
              ctrl2.pre_activate(ctrl2.dom.el);
            }
          }
        });
      };
      var activate = function(context2) {
        const map_controls = context2.map_controls;
        console.log("jsgui html-core activate");
        console.log("jsgui.def_server_resources", jsgui2.def_server_resources);
        if (!context2) {
          throw "jsgui-html-enh activate(context) - need to supply context parameter.";
        }
        recursive_dom_iterate_depth2(document, (el) => {
          var nt = el.nodeType;
          if (nt === 1) {
            var jsgui_id = el.getAttribute("data-jsgui-id");
            if (jsgui_id) {
              const ctrl2 = map_controls[jsgui_id];
              ctrl2.activate(ctrl2.dom.el);
            }
          }
        });
      };
      jsgui2.controls = jsgui2.controls || {
        Control: Control2
      };
      jsgui2.controls.span = jsgui2.span = class span extends Control2 {
        constructor(spec) {
          spec.__type_name = "span";
          super(spec);
          this.dom.tagName = "span";
          spec = spec || {};
          prop(this, "text", spec.text || "");
          this.on("change", (e_change) => {
            const { name } = e_change;
            if (name === "text") {
              if (this.content._arr.length === 1) {
                if (this.content._arr[0] instanceof Text_Node) {
                  this.content._arr[0].text = e_change.value;
                }
              } else {
                if (this.content._arr.length === 0) {
                } else {
                  console.log("this.content._arr", this.content._arr);
                  console.trace();
                  throw "NYI";
                }
              }
            }
          });
          if (!spec.el) {
            this.compose_span();
          }
        }
        compose_span() {
          if (this.text && this.text.length > 0) {
            this.add(this.tn = this.text_node = new Text_Node({
              context: this.context,
              text: this.text
            }));
          }
        }
      };
      var String_Control = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = "string_control";
          super(spec);
          this.dom.tagName = void 0;
          spec = spec || {};
          if (typeof spec.text !== "undefined") {
            this._text = spec.text;
          } else {
            this._text = "";
          }
          if (!spec.el) {
          }
        }
        get text() {
          return this._text;
        }
        set text(value2) {
          this._text = value2;
          this.raise("change", {
            "name": "text",
            "value": value2
          });
        }
        all_html_render() {
          return this._text;
        }
        activate() {
        }
      };
      jsgui2.pre_activate = pre_activate;
      jsgui2.activate = activate;
      core_extension("html head title body div select option h1 h2 h3 h4 h5 h6 label p a script link button form textarea img ul li audio video table tr td caption thead colgroup col svg defs marker polygon line section code samp canvas");
      core_extension_no_closing_tag("link input meta");
      var HTML_Document = class extends jsgui2.Control {
        constructor(spec = {}) {
          spec.tag_name = "html";
          super(spec);
        }
      };
      var Blank_HTML_Document = class extends HTML_Document {
        constructor(spec = {}) {
          super(spec);
          var context2 = this.context;
          if (!spec.el) {
            var head = new jsgui2.head({
              "context": context2
            });
            this.content.add(head);
            var title = new jsgui2.title({
              "context": context2
            });
            head.content.add(title);
            var body = new jsgui2.body({
              "context": context2
            });
            this.content.add(body);
            this.head = head;
            this.title = title;
            this.body = body;
          }
        }
        "body"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig == "[]") {
            var content = this.content;
            var body = content.get(1);
            return body;
          }
        }
      };
      var Intersection_Finder = class extends Evented_Class {
        constructor(spec) {
          super(spec);
          let coords_ctrls;
          let update_ctrl_coords = () => {
            coords_ctrls = [];
            each(spec.controls || spec.ctrls, (ctrl2) => {
              coords_ctrls.push([ctrl2.bcr(), ctrl2]);
            });
          };
          let map_selected = /* @__PURE__ */ new Map();
          let find_intersections = (coords) => {
            update_ctrl_coords();
            let intersecting = [], newly_intersecting = [], previously_intersecting = [];
            ;
            let [btl, bbr] = coords;
            each(coords_ctrls, (cc) => {
              let [ccoords, ctrl2] = cc;
              let [cpos, cbr, csize] = ccoords;
              let intersect = cpos[0] <= bbr[0] && btl[0] <= cbr[0] && cpos[1] <= bbr[1] && btl[1] <= cbr[1];
              if (intersect) {
                if (map_selected.get(ctrl2) !== true) {
                  newly_intersecting.push(ctrl2);
                  map_selected.set(ctrl2, true);
                }
                intersecting.push(ctrl2);
              } else {
                if (map_selected.get(ctrl2) === true) {
                  previously_intersecting.push(ctrl2);
                  map_selected.set(ctrl2, false);
                }
              }
            });
            return [intersecting, newly_intersecting, previously_intersecting];
          };
          prop(this, "coords", (transform_coords) => {
            if (transform_coords[0][1] > transform_coords[1][1]) {
              let [a, b] = transform_coords;
              transform_coords = [b, a];
            }
            if (transform_coords[0][0] > transform_coords[1][0]) {
              let a = transform_coords[1][0];
              transform_coords[1][0] = transform_coords[0][0];
              transform_coords[0][0] = a;
            }
            return transform_coords;
          }, (change_coords) => {
            let intersections = find_intersections(change_coords[0]);
            if (intersections[1].length > 0 || intersections[2].length > 0) {
              this.raise("change", {
                "name": "intersections",
                "value": intersections
              });
            }
          });
          this.find_intersections = find_intersections;
        }
      };
      var Relative = class extends Control2 {
        constructor(spec) {
          spec.class = "relative";
          super(spec);
        }
      };
      jsgui2.Control_Data = Control_Data;
      jsgui2.Control_View = Control_View;
      jsgui2.Relative = Relative;
      jsgui2.String_Control = jsgui2.controls.String_Control = String_Control;
      jsgui2.HTML_Document = HTML_Document;
      jsgui2.Blank_HTML_Document = Blank_HTML_Document;
      jsgui2.Text_Node = jsgui2.controls.Text_Node = jsgui2.Text_Node = jsgui2.controls.Text_Node = Text_Node;
      jsgui2.Page_Context = Page_Context;
      jsgui2.Selection_Scope = Selection_Scope;
      jsgui2.Intersection_Finder = Intersection_Finder;
      jsgui2.parse_mount = parse_mount;
      jsgui2.parse = parse;
      module.exports = jsgui2;
    }
  });

  // node_modules/requires-port/index.js
  var require_requires_port = __commonJS({
    "node_modules/requires-port/index.js"(exports, module) {
      "use strict";
      module.exports = function required(port, protocol) {
        protocol = protocol.split(":")[0];
        port = +port;
        if (!port) return false;
        switch (protocol) {
          case "http":
          case "ws":
            return port !== 80;
          case "https":
          case "wss":
            return port !== 443;
          case "ftp":
            return port !== 21;
          case "gopher":
            return port !== 70;
          case "file":
            return false;
        }
        return port !== 0;
      };
    }
  });

  // node_modules/querystringify/index.js
  var require_querystringify = __commonJS({
    "node_modules/querystringify/index.js"(exports) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var undef;
      function decode(input) {
        try {
          return decodeURIComponent(input.replace(/\+/g, " "));
        } catch (e) {
          return null;
        }
      }
      function encode(input) {
        try {
          return encodeURIComponent(input);
        } catch (e) {
          return null;
        }
      }
      function querystring(query) {
        var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
        while (part = parser.exec(query)) {
          var key2 = decode(part[1]), value2 = decode(part[2]);
          if (key2 === null || value2 === null || key2 in result) continue;
          result[key2] = value2;
        }
        return result;
      }
      function querystringify(obj2, prefix) {
        prefix = prefix || "";
        var pairs = [], value2, key2;
        if ("string" !== typeof prefix) prefix = "?";
        for (key2 in obj2) {
          if (has.call(obj2, key2)) {
            value2 = obj2[key2];
            if (!value2 && (value2 === null || value2 === undef || isNaN(value2))) {
              value2 = "";
            }
            key2 = encode(key2);
            value2 = encode(value2);
            if (key2 === null || value2 === null) continue;
            pairs.push(key2 + "=" + value2);
          }
        }
        return pairs.length ? prefix + pairs.join("&") : "";
      }
      exports.stringify = querystringify;
      exports.parse = querystring;
    }
  });

  // node_modules/url-parse/index.js
  var require_url_parse = __commonJS({
    "node_modules/url-parse/index.js"(exports, module) {
      "use strict";
      var required = require_requires_port();
      var qs = require_querystringify();
      var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      var CRHTLF = /[\n\r\t]/g;
      var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
      var port = /:\d+$/;
      var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
      var windowsDriveLetter = /^[a-zA-Z]:/;
      function trimLeft(str) {
        return (str ? str : "").toString().replace(controlOrWhitespace, "");
      }
      var rules = [
        ["#", "hash"],
        // Extract from the back.
        ["?", "query"],
        // Extract from the back.
        function sanitize(address, url) {
          return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
        },
        ["/", "pathname"],
        // Extract from the back.
        ["@", "auth", 1],
        // Extract from the front.
        [NaN, "host", void 0, 1, 1],
        // Set left over value.
        [/:(\d*)$/, "port", void 0, 1],
        // RegExp the back.
        [NaN, "hostname", void 0, 1, 1]
        // Set left over.
      ];
      var ignore = { hash: 1, query: 1 };
      function lolcation(loc) {
        var globalVar;
        if (typeof window !== "undefined") globalVar = window;
        else if (typeof window !== "undefined") globalVar = window;
        else if (typeof self !== "undefined") globalVar = self;
        else globalVar = {};
        var location = globalVar.location || {};
        loc = loc || location;
        var finaldestination = {}, type = typeof loc, key2;
        if ("blob:" === loc.protocol) {
          finaldestination = new Url(unescape(loc.pathname), {});
        } else if ("string" === type) {
          finaldestination = new Url(loc, {});
          for (key2 in ignore) delete finaldestination[key2];
        } else if ("object" === type) {
          for (key2 in loc) {
            if (key2 in ignore) continue;
            finaldestination[key2] = loc[key2];
          }
          if (finaldestination.slashes === void 0) {
            finaldestination.slashes = slashes.test(loc.href);
          }
        }
        return finaldestination;
      }
      function isSpecial(scheme) {
        return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
      }
      function extractProtocol(address, location) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        location = location || {};
        var match = protocolre.exec(address);
        var protocol = match[1] ? match[1].toLowerCase() : "";
        var forwardSlashes = !!match[2];
        var otherSlashes = !!match[3];
        var slashesCount = 0;
        var rest;
        if (forwardSlashes) {
          if (otherSlashes) {
            rest = match[2] + match[3] + match[4];
            slashesCount = match[2].length + match[3].length;
          } else {
            rest = match[2] + match[4];
            slashesCount = match[2].length;
          }
        } else {
          if (otherSlashes) {
            rest = match[3] + match[4];
            slashesCount = match[3].length;
          } else {
            rest = match[4];
          }
        }
        if (protocol === "file:") {
          if (slashesCount >= 2) {
            rest = rest.slice(2);
          }
        } else if (isSpecial(protocol)) {
          rest = match[4];
        } else if (protocol) {
          if (forwardSlashes) {
            rest = rest.slice(2);
          }
        } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
          rest = match[4];
        }
        return {
          protocol,
          slashes: forwardSlashes || isSpecial(protocol),
          slashesCount,
          rest
        };
      }
      function resolve(relative, base) {
        if (relative === "") return base;
        var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
        while (i--) {
          if (path[i] === ".") {
            path.splice(i, 1);
          } else if (path[i] === "..") {
            path.splice(i, 1);
            up++;
          } else if (up) {
            if (i === 0) unshift = true;
            path.splice(i, 1);
            up--;
          }
        }
        if (unshift) path.unshift("");
        if (last === "." || last === "..") path.push("");
        return path.join("/");
      }
      function Url(address, location, parser) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        if (!(this instanceof Url)) {
          return new Url(address, location, parser);
        }
        var relative, extracted, parse, instruction, index, key2, instructions = rules.slice(), type = typeof location, url = this, i = 0;
        if ("object" !== type && "string" !== type) {
          parser = location;
          location = null;
        }
        if (parser && "function" !== typeof parser) parser = qs.parse;
        location = lolcation(location);
        extracted = extractProtocol(address || "", location);
        relative = !extracted.protocol && !extracted.slashes;
        url.slashes = extracted.slashes || relative && location.slashes;
        url.protocol = extracted.protocol || location.protocol || "";
        address = extracted.rest;
        if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
          instructions[3] = [/(.*)/, "pathname"];
        }
        for (; i < instructions.length; i++) {
          instruction = instructions[i];
          if (typeof instruction === "function") {
            address = instruction(address, url);
            continue;
          }
          parse = instruction[0];
          key2 = instruction[1];
          if (parse !== parse) {
            url[key2] = address;
          } else if ("string" === typeof parse) {
            index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
            if (~index) {
              if ("number" === typeof instruction[2]) {
                url[key2] = address.slice(0, index);
                address = address.slice(index + instruction[2]);
              } else {
                url[key2] = address.slice(index);
                address = address.slice(0, index);
              }
            }
          } else if (index = parse.exec(address)) {
            url[key2] = index[1];
            address = address.slice(0, index.index);
          }
          url[key2] = url[key2] || (relative && instruction[3] ? location[key2] || "" : "");
          if (instruction[4]) url[key2] = url[key2].toLowerCase();
        }
        if (parser) url.query = parser(url.query);
        if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
          url.pathname = resolve(url.pathname, location.pathname);
        }
        if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
          url.pathname = "/" + url.pathname;
        }
        if (!required(url.port, url.protocol)) {
          url.host = url.hostname;
          url.port = "";
        }
        url.username = url.password = "";
        if (url.auth) {
          index = url.auth.indexOf(":");
          if (~index) {
            url.username = url.auth.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = url.auth.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(url.auth));
          }
          url.auth = url.password ? url.username + ":" + url.password : url.username;
        }
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
      }
      function set(part, value2, fn) {
        var url = this;
        switch (part) {
          case "query":
            if ("string" === typeof value2 && value2.length) {
              value2 = (fn || qs.parse)(value2);
            }
            url[part] = value2;
            break;
          case "port":
            url[part] = value2;
            if (!required(value2, url.protocol)) {
              url.host = url.hostname;
              url[part] = "";
            } else if (value2) {
              url.host = url.hostname + ":" + value2;
            }
            break;
          case "hostname":
            url[part] = value2;
            if (url.port) value2 += ":" + url.port;
            url.host = value2;
            break;
          case "host":
            url[part] = value2;
            if (port.test(value2)) {
              value2 = value2.split(":");
              url.port = value2.pop();
              url.hostname = value2.join(":");
            } else {
              url.hostname = value2;
              url.port = "";
            }
            break;
          case "protocol":
            url.protocol = value2.toLowerCase();
            url.slashes = !fn;
            break;
          case "pathname":
          case "hash":
            if (value2) {
              var char = part === "pathname" ? "/" : "#";
              url[part] = value2.charAt(0) !== char ? char + value2 : value2;
            } else {
              url[part] = value2;
            }
            break;
          case "username":
          case "password":
            url[part] = encodeURIComponent(value2);
            break;
          case "auth":
            var index = value2.indexOf(":");
            if (~index) {
              url.username = value2.slice(0, index);
              url.username = encodeURIComponent(decodeURIComponent(url.username));
              url.password = value2.slice(index + 1);
              url.password = encodeURIComponent(decodeURIComponent(url.password));
            } else {
              url.username = encodeURIComponent(decodeURIComponent(value2));
            }
        }
        for (var i = 0; i < rules.length; i++) {
          var ins = rules[i];
          if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
        return url;
      }
      function toString(stringify) {
        if (!stringify || "function" !== typeof stringify) stringify = qs.stringify;
        var query, url = this, host = url.host, protocol = url.protocol;
        if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
        var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
        if (url.username) {
          result += url.username;
          if (url.password) result += ":" + url.password;
          result += "@";
        } else if (url.password) {
          result += ":" + url.password;
          result += "@";
        } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
          result += "@";
        }
        if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
          host += ":";
        }
        result += host + url.pathname;
        query = "object" === typeof url.query ? stringify(url.query) : url.query;
        if (query) result += "?" !== query.charAt(0) ? "?" + query : query;
        if (url.hash) result += url.hash;
        return result;
      }
      Url.prototype = { set, toString };
      Url.extractProtocol = extractProtocol;
      Url.location = lolcation;
      Url.trimLeft = trimLeft;
      Url.qs = qs;
      module.exports = Url;
    }
  });

  // node_modules/jsgui3-html/router/routing-tree.js
  var require_routing_tree = __commonJS({
    "node_modules/jsgui3-html/router/routing-tree.js"(exports, module) {
      var Routing_Tree_Node = class {
        constructor(spec) {
          spec = spec || {};
          if (spec.handler) this.handler = spec.handler;
          this.mapNormalPathChildren = {};
        }
      };
      var Variable_Routing_Tree_Node = class {
        constructor(spec) {
          this.name = spec.name;
          if (spec.handler) this.handler = spec.handler;
          this.mapNormalPathChildren = {};
        }
      };
      var Wildcard_Routing_Tree_Node = class {
        constructor(spec) {
        }
      };
      var Routing_Tree = class {
        constructor(spec) {
          this.root = new Routing_Tree_Node();
        }
        get arr_paths() {
          const res2 = [];
          const iterate = (node) => {
            if (node.mapNormalPathChildren) {
              console.log("node.name", node.name);
              const children = Object.entries(node.mapNormalPathChildren);
              if (children.length > 0) {
                for (let c2 = 0; c2 < children.length; c2++) {
                  iterate(children[c2]);
                }
              }
            }
          };
          return res2;
        }
        "setRoot404"(handler) {
          this.root404Handler = handler;
        }
        "set"(strRoute, context2, handler) {
          if (!handler) {
            handler = context2;
            context2 = void 0;
          }
          if (strRoute == "/") {
            if (context2) this.root.context = context2;
            this.root.handler = handler;
          } else {
            var splitRoute = strRoute.split("/");
            var currentNode = this.root;
            var c2 = 0;
            while (c2 < splitRoute.length) {
              var strLevel = splitRoute[c2];
              var isVariable = strLevel.substr(0, 1) == ":";
              var isWildcard = strLevel == "*";
              if (isVariable) {
                var variableName = strLevel.substr(1);
                if (!currentNode.variableChild) {
                  currentNode.variableChild = new Variable_Routing_Tree_Node({
                    "name": variableName
                  });
                  if (c2 == splitRoute.length - 1) {
                    currentNode.variableChild.handler = handler;
                    if (context2) currentNode.variableChild.context = context2;
                  }
                  currentNode = currentNode.variableChild;
                } else {
                  currentNode = currentNode.variableChild;
                }
              } else {
                if (isWildcard) {
                  currentNode.wildcardChild = new Wildcard_Routing_Tree_Node();
                  currentNode.wildcardChild.handler = handler;
                  if (context2) currentNode.wildcardChild.context = context2;
                } else {
                  var next_level_node = currentNode.mapNormalPathChildren[strLevel];
                  if (!next_level_node) {
                    currentNode.mapNormalPathChildren[strLevel] = new Routing_Tree_Node();
                    next_level_node = currentNode.mapNormalPathChildren[strLevel];
                  }
                  if (c2 === splitRoute.length - 1) {
                    currentNode.mapNormalPathChildren[strLevel].handler = handler;
                    if (context2) currentNode.mapNormalPathChildren[strLevel].context = context2;
                  }
                  currentNode = next_level_node;
                }
              }
              c2++;
            }
          }
        }
        "get"(url) {
          var params;
          if (url == "/") {
            var root = this.root;
            if (root.context) {
              return [root.context, this.root.handler, {}];
            } else {
              var res2;
              if (this.root.handler) {
                res2 = this.root.handler;
              } else {
                if (this.root.wildcardChild) {
                  if (this.root.wildcardChild.handler) {
                    if (this.root.wildcardChild.context) {
                      return [this.root.wildcardChild.context, this.root.wildcardChild.handler, {}];
                    } else {
                      return this.root.wildcardChild.handler;
                    }
                    throw "stop";
                  }
                }
              }
              return res2;
            }
          } else {
            var posQM = url.indexOf("?");
            if (posQM > -1) {
              url = url.substr(0, posQM);
            }
            var splitUrl = url.split("/");
            var currentNode = this.root;
            var c2 = 0;
            while (c2 < splitUrl.length) {
              var strLevel = splitUrl[c2];
              if (currentNode) {
                var next_level_node = currentNode.mapNormalPathChildren[strLevel];
                if (next_level_node) {
                } else {
                  if (currentNode.variableChild) {
                    next_level_node = currentNode.variableChild;
                    params = params || {};
                    params[currentNode.variableChild.name] = decodeURI(strLevel);
                  } else {
                    if (currentNode.wildcardChild) {
                      var arr_the_rest = splitUrl.slice(c2);
                      var str_wildcard_value = arr_the_rest.join("/");
                      if (url.endsWith("/")) str_wildcard_value += "/";
                      if (currentNode.wildcardChild.context) {
                        return [currentNode.wildcardChild.context, currentNode.wildcardChild.handler, {
                          "wildcard_value": str_wildcard_value
                        }];
                      } else {
                        return [currentNode.wildcardChild.handler, {
                          "wildcard_value": str_wildcard_value
                        }];
                      }
                    }
                  }
                }
              }
              if (c2 === splitUrl.length - 1) {
                if (next_level_node) {
                  if (next_level_node.handler) {
                    if (params) {
                      if (next_level_node.context) {
                        return [next_level_node.context, next_level_node.handler, params];
                      } else {
                        return [next_level_node.handler, params];
                      }
                    } else {
                      if (next_level_node.context) {
                        return [next_level_node.context, next_level_node.handler];
                      } else {
                        return next_level_node.handler;
                      }
                    }
                  } else {
                    if (next_level_node.wildcardChild) {
                      var arr_the_rest = splitUrl.slice(c2);
                      var str_wildcard_value = arr_the_rest.join("/");
                      if (params) {
                        params.wildcard_value = decodeURI(str_wildcard_value);
                        if (next_level_node.wildcardChild.context) {
                          return [next_level_node.wildcardChild.context, next_level_node.wildcardChild.handler, params];
                        } else {
                          return [next_level_node.wildcardChild.handler, params];
                        }
                      } else {
                        if (next_level_node.wildcardChild.context) {
                          return [next_level_node.wildcardChild.context, next_level_node.wildcardChild.handler, params];
                        } else {
                          return [next_level_node.wildcardChild.handler, {
                            "wildcard_value": str_wildcard_value
                          }];
                        }
                      }
                    }
                  }
                } else {
                  if (currentNode) {
                    return [currentNode.handler, params];
                  }
                }
              }
              currentNode = next_level_node;
              c2++;
            }
            return this.root404Handler;
          }
        }
      };
      Routing_Tree.Node = Routing_Tree_Node;
      Routing_Tree.Variable_Node = Variable_Routing_Tree_Node;
      Routing_Tree.Wildcard_Node = Wildcard_Routing_Tree_Node;
      module.exports = Routing_Tree;
    }
  });

  // node_modules/jsgui3-html/router/router.js
  var require_router = __commonJS({
    "node_modules/jsgui3-html/router/router.js"(exports, module) {
      var url = require_url_parse();
      var jsgui2 = require_lang();
      var tof = jsgui2.tof;
      var get_item_sig = jsgui2.get_item_sig;
      var Routing_Tree = require_routing_tree();
      var default_logger = (level, message, meta) => {
        const log_meta = meta && Object.keys(meta).length ? meta : void 0;
        if (level === "error" && console.error) {
          console.error("[router]", message, log_meta || "");
        } else if (level === "warn" && console.warn) {
          console.warn("[router]", message, log_meta || "");
        } else if (console.log) {
          console.log("[router]", message, log_meta || "");
        }
      };
      var default_not_found_handler = (req, res2) => {
        if (res2) {
          if (typeof res2.statusCode === "number") {
            res2.statusCode = res2.statusCode && res2.statusCode !== 200 ? res2.statusCode : 404;
          }
          if (typeof res2.setHeader === "function" && !res2.headersSent) {
            res2.setHeader("Content-Type", "text/plain; charset=utf-8");
          }
          if (typeof res2.end === "function" && !res2.writableEnded) {
            res2.end("Not Found");
          }
        }
      };
      var Router = class {
        constructor(spec) {
          spec = spec || {};
          if (spec.name) {
            this.name = spec.name;
          } else {
            this.name = "Router";
          }
          this.routing_tree = new Routing_Tree();
          this.logger = spec.logger || default_logger;
          this.handle_not_found_fn = spec.handle_not_found || default_not_found_handler;
          this.handle_error_fn = spec.handle_error;
          this._listeners = /* @__PURE__ */ new Map();
        }
        on(event_name, handler) {
          if (!handler) return this;
          let set_listeners = this._listeners.get(event_name);
          if (!set_listeners) {
            set_listeners = /* @__PURE__ */ new Set();
            this._listeners.set(event_name, set_listeners);
          }
          set_listeners.add(handler);
          return this;
        }
        off(event_name, handler) {
          if (!handler) return this;
          const set_listeners = this._listeners.get(event_name);
          if (set_listeners) {
            set_listeners.delete(handler);
            if (set_listeners.size === 0) {
              this._listeners.delete(event_name);
            }
          }
          return this;
        }
        emit(event_name, ...args) {
          const set_listeners = this._listeners.get(event_name);
          if (!set_listeners || set_listeners.size === 0) return false;
          for (const listener of Array.from(set_listeners)) {
            try {
              listener(...args);
            } catch (err) {
              this._log("error", "router_listener_error", {
                event: event_name,
                error: err
              });
            }
          }
          return true;
        }
        _log(level, message, meta) {
          if (this.logger) {
            try {
              this.logger(level, message, meta || {});
            } catch (err) {
              if (console && console.error) {
                console.error("[router] logger error", err);
              }
            }
          }
        }
        set_logger(fn_logger) {
          this.logger = fn_logger || default_logger;
        }
        set_not_found_handler(fn_handler) {
          this.handle_not_found_fn = fn_handler || default_not_found_handler;
        }
        set_error_handler(fn_handler) {
          this.handle_error_fn = fn_handler;
        }
        "start"(callback2) {
          callback2(null, true);
        }
        "set_route"(str_route, context2, fn_handler) {
          this._log("debug", "set_route", {
            route: str_route
          });
          return this.routing_tree.set(str_route, context2, fn_handler);
        }
        "meets_requirements"() {
          return true;
        }
        _invoke_handler(handler, context2, req, res2, params, result) {
          try {
            if (params && typeof params === "object") {
              req.params = params;
            }
            if (context2) {
              handler.call(context2, req, res2);
            } else {
              handler(req, res2);
            }
            result.handled = true;
            result.params = params;
          } catch (err) {
            result.handled = true;
            result.params = params;
            result.handlerError = err;
            this._log("error", "handler_error", {
              url: req && req.url,
              error: err,
              params
            });
            this.emit("error", err, {
              req,
              res: res2,
              params,
              handler
            });
            if (this.handle_error_fn) {
              try {
                this.handle_error_fn(err, req, res2, params);
              } catch (secondary_err) {
                this._log("error", "error_handler_failure", {
                  url: req && req.url,
                  error: secondary_err
                });
                this.emit("error", secondary_err, {
                  req,
                  res: res2,
                  params,
                  handler: this.handle_error_fn,
                  stage: "error-handler"
                });
              }
            }
          }
        }
        _handle_not_found(req, res2, meta, result) {
          const details = Object.assign({
            url: req && req.url
          }, meta || {});
          this._log("warn", "route_not_found", details);
          this.emit("not-found", {
            req,
            res: res2,
            meta: details
          });
          if (this.handle_not_found_fn) {
            try {
              this.handle_not_found_fn(req, res2);
            } catch (err) {
              result.handlerError = err;
              this._log("error", "not_found_handler_error", {
                url: req && req.url,
                error: err
              });
              this.emit("error", err, {
                req,
                res: res2,
                stage: "not-found"
              });
            }
          }
        }
        get arr_paths() {
          return this.routing_tree.arr_paths;
        }
        "process"(req, res2) {
          const result = {
            handled: false,
            params: void 0,
            handlerError: void 0
          };
          var rt = this.routing_tree;
          let parsed_url;
          try {
            parsed_url = url(req.url, true);
          } catch (err) {
            this._log("error", "url_parse_error", {
              url: req && req.url,
              error: err
            });
            result.handlerError = err;
            this.emit("error", err, {
              req,
              res: res2,
              stage: "url-parse"
            });
            return result;
          }
          if (!parsed_url) {
            return result;
          }
          var route_res = rt.get(req.url);
          var handler;
          var context2;
          var params;
          var route_type = tof(route_res);
          if (route_type === "array") {
            var rr_sig = get_item_sig(route_res, 1);
            if (route_res.length === 3) {
              context2 = route_res[0];
              handler = route_res[1];
              params = route_res[2];
            } else if (rr_sig == "[D,f]") {
              context2 = route_res[0];
              handler = route_res[1];
            } else if (rr_sig == "[f,o]") {
              handler = route_res[0];
              params = route_res[1];
            } else if (rr_sig == "[o,f]") {
              context2 = route_res[0];
              handler = route_res[1];
            } else if (route_res.length === 2 && typeof route_res[0] === "function" && tof(route_res[1]) === "object") {
              handler = route_res[0];
              params = route_res[1];
            }
          } else if (route_type === "function") {
            handler = route_res;
          } else if (route_type === "object" && route_res) {
            if (typeof route_res.handler === "function") {
              handler = route_res.handler;
              context2 = route_res.context;
              if (route_res.params) {
                params = route_res.params;
              }
            }
          }
          if (handler && typeof handler === "function") {
            this._invoke_handler(handler, context2, req, res2, params, result);
            return result;
          }
          this._handle_not_found(req, res2, {
            url: req && req.url
          }, result);
          return result;
        }
      };
      Router.Routing_Tree = Routing_Tree;
      module.exports = Router;
    }
  });

  // node_modules/jsgui3-html/resource/pool.js
  var require_pool = __commonJS({
    "node_modules/jsgui3-html/resource/pool.js"(exports, module) {
      var jsgui2 = require_lang();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var arrayify = jsgui2.arrayify;
      var tof = jsgui2.tof;
      var get_a_sig2 = jsgui2.get_a_sig;
      var filter_map_by_regex = jsgui2.filter_map_by_regex;
      var Evented_Class = jsgui2.Evented_Class;
      var Data_Object = jsgui2.Data_Object;
      var fp = jsgui2.fp;
      var is_defined = jsgui2.is_defined;
      var Collection = jsgui2.Collection;
      var Resource_Pool = class extends Evented_Class {
        constructor(spec) {
          super(spec);
          this.resources = new Collection({
            //'index_by': 'name'
            "fn_index": (item2) => {
              var key2 = item2.name;
              return key2;
            }
          });
        }
        "add"(obj2) {
          var obj_name = obj2.name;
          let log_trace = () => {
            console.log("");
            console.log("** obj_name " + obj_name);
            console.trace();
            console.log("");
          };
          if (obj_name === void 0) {
            console.log("obj", obj2);
            console.trace();
            throw "Resource_Pool.add(undefined) error";
          }
          if (this.has_resource(obj_name)) {
            throw "Resource pool already has resource with name " + obj_name;
          } else {
            this.resources.add(obj2);
            obj2.pool = this;
            if (obj2.name !== void 0) {
              Object.defineProperty(this, obj2.name, {
                get() {
                  return obj2;
                }
              });
            }
            this.raise_event("added", obj2);
          }
        }
        "push"(obj2) {
          return this.add(obj2);
        }
        "has_resource"() {
          const a = arguments;
          const sig = get_a_sig2(a, 1);
          if (sig == "[s]") {
            const obj_lookup_val = a[0];
            return this.resources.has(obj_lookup_val);
          }
        }
        get resource_names() {
          var res2 = [];
          each(this.resources, (resource) => {
            res2.push(resource.name);
          });
          return res2;
        }
        "get_resource"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig2(a, 1);
          if (sig === "[s]") {
            var obj_lookup_val = a[0];
            var find_result = this.resources.find(obj_lookup_val);
            if (find_result) {
              var res2 = find_result;
            }
            return res2;
          }
        }
        "count"() {
          return this.resources.length;
        }
        // May be useful to have a callback parameter here rather than just publish / subscribe.
        "start"(callback2) {
          var arr_resources_meeting_requirements = [];
          this.resources.each(function(v, i) {
            var mr = v.meets_requirements();
            if (mr) {
              arr_resources_meeting_requirements.push(v);
            }
          });
          var l_resources = this.resources.length();
          if (arr_resources_meeting_requirements.length === l_resources) {
            var fns = [];
            var num_to_start = arr_resources_meeting_requirements.length;
            var num_starting = 0, num_started = 0;
            var cb = function(err, start_res) {
              num_starting--;
              num_started++;
              if (num_started == num_to_start) {
                if (callback2) callback2(null, true);
              }
            };
            each(arr_resources_meeting_requirements, (resource_ready_to_start) => {
              resource_ready_to_start.start(cb);
              num_starting++;
            });
          }
        }
      };
      module.exports = Resource_Pool;
    }
  });

  // node_modules/jsgui3-html/resource/resource.js
  var require_resource = __commonJS({
    "node_modules/jsgui3-html/resource/resource.js"(exports, module) {
      var jsgui2 = require_lang();
      var Pool = require_pool();
      var Evented_Class = jsgui2.Evented_Class;
      var Class = jsgui2.Class;
      var Collection = jsgui2.Collection;
      var is_defined = jsgui2.is_defined;
      var fp = jsgui2.fp;
      var stringify = jsgui2.stringify;
      var tof = jsgui2.tof;
      var call_multi = jsgui2.call_multi;
      var get_a_sig2 = jsgui2.get_a_sig;
      var each = jsgui2.each;
      var Resource = class extends Evented_Class {
        // The link between the abstract resource and the resource on the internet / network / computer.
        //'fields': {
        //	//'meta': Data_Object
        //	'meta': 'data_object'
        //},
        // Problem with how it sets the fields.
        constructor(spec) {
          if (!is_defined(spec)) spec = {};
          super(spec);
          if (spec.name) this.name = spec.name;
          if (spec.pool) this.pool = spec.pool;
          if (is_defined(spec.startup_type)) {
            this.startup_type = spec.startup_type;
          }
          this.getters = {};
          this.setters = {};
        }
        "start"(callback2) {
          callback2(null, true);
        }
        // meets_requirements
        //  check if all the prerequisite resources are active
        //  maybe check for login status if applicable.
        "meets_requirements"() {
          return true;
        }
        // 'get' will be the function to use.
        // may have toJson / to_json.
        "get_abstract"() {
        }
        "authenticate"(token) {
          return true;
        }
        // Resources could also operate in connected mode.
        //  How the connection gets handled will be outside of the scope of the resource itself.
        // the last item in the signature is the callback
        /*
        
            'set'(name, value, callback) {
                var al = arguments.length;
        
                // self setter?
        
                if (al === 3) {
                    if (this.setters[name]) {
                        this.setters[name](value, callback);
                    }
                }
            }
        
            'get'(name, callback) {
                var al = arguments.length;
                if (al === 2) {
                    if (this.getters[name]) {
                        this.getters[name](callback);
                    }
                }
            }
        
            */
      };
      Resource.Pool = Pool;
      module.exports = Resource;
    }
  });

  // node_modules/jsgui3-html/resource/data-kv-resource.js
  var require_data_kv_resource = __commonJS({
    "node_modules/jsgui3-html/resource/data-kv-resource.js"(exports, module) {
      var jsgui2 = require_lang();
      var Pool = require_pool();
      var Evented_Class = jsgui2.Evented_Class;
      var Class = jsgui2.Class;
      var Collection = jsgui2.Collection;
      var is_defined = jsgui2.is_defined;
      var fp = jsgui2.fp;
      var stringify = jsgui2.stringify;
      var tof = jsgui2.tof;
      var call_multi = jsgui2.call_multi;
      var get_a_sig2 = jsgui2.get_a_sig;
      var each = jsgui2.each;
      var Resource = require_resource();
      var Data_KV_Resource = class extends Resource {
        // The link between the abstract resource and the resource on the internet / network / computer.
        //'fields': {
        //	//'meta': Data_Object
        //	'meta': 'data_object'
        //},
        // Problem with how it sets the fields.
        constructor(spec) {
          if (!is_defined(spec)) spec = {};
          super(spec);
          if (is_defined(spec.name)) {
          }
          if (spec.name) this.name = spec.name;
          if (spec.pool) this.pool = spec.pool;
          if (is_defined(spec.startup_type)) {
            this.startup_type = spec.startup_type;
          }
          this.getters = {};
          this.setters = {};
        }
        "start"(callback2) {
          callback2(null, true);
        }
        // meets_requirements
        //  check if all the prerequisite resources are active
        //  maybe check for login status if applicable.
        "meets_requirements"() {
          return true;
        }
        // 'get' will be the function to use.
        // may have toJson / to_json.
        "get_abstract"() {
        }
        "authenticate"(token) {
          return true;
        }
        // Resources could also operate in connected mode.
        //  How the connection gets handled will be outside of the scope of the resource itself.
        // the last item in the signature is the callback
        "set"(name, value2, callback2) {
          var al = arguments.length;
          if (al === 3) {
            if (this.setters[name]) {
              this.setters[name](value2, callback2);
            }
          }
        }
        "get"(name, callback2) {
          var al = arguments.length;
          if (al === 2) {
            if (this.getters[name]) {
              this.getters[name](callback2);
            }
          }
        }
      };
      Resource.Pool = Pool;
      module.exports = Data_KV_Resource;
    }
  });

  // node_modules/jsgui3-html/resource/data-transform-resource.js
  var require_data_transform_resource = __commonJS({
    "node_modules/jsgui3-html/resource/data-transform-resource.js"(exports, module) {
      var jsgui2 = require_lang();
      var Pool = require_pool();
      var Evented_Class = jsgui2.Evented_Class;
      var Class = jsgui2.Class;
      var Collection = jsgui2.Collection;
      var is_defined = jsgui2.is_defined;
      var fp = jsgui2.fp;
      var stringify = jsgui2.stringify;
      var tof = jsgui2.tof;
      var call_multi = jsgui2.call_multi;
      var get_a_sig2 = jsgui2.get_a_sig;
      var each = jsgui2.each;
      var Resource = require_resource();
      var Data_Transform_Resource = class extends Resource {
        // The link between the abstract resource and the resource on the internet / network / computer.
        //'fields': {
        //	//'meta': Data_Object
        //	'meta': 'data_object'
        //},
        // Problem with how it sets the fields.
        // JSON input data description info object
        // JSON output data description info object
        // JSON transformation data description info object.
        // .info
        // .meta.info
        // Will be POJOs.???
        // .i.i .i.o .i.t
        //  input schema, output schema, transformation function
        //  make it possible to express the algo here / in the constructor.
        //  also should be able to work remotely when the resource is remote.
        // .m.i.i
        constructor(spec) {
          if (!is_defined(spec)) spec = {};
          super(spec);
          if (is_defined(spec.name)) {
          }
          if (spec.name) this.name = spec.name;
          if (spec.pool) this.pool = spec.pool;
          const meta = {
            info: {},
            fn: {}
          };
          Object.defineProperty(this, "meta", {
            get() {
              return meta;
            }
          });
          Object.defineProperty(this, "m", {
            get() {
              return meta;
            }
          });
          Object.defineProperty(meta, "i", {
            get() {
              return meta.info;
            }
          });
          Object.defineProperty(meta, "fns", {
            get() {
              return meta.fn;
            }
          });
          Object.defineProperty(meta, "fn", {
            get() {
              return meta.fn;
            }
          });
          Object.defineProperty(meta, "f", {
            get() {
              return meta.fn;
            }
          });
          if (spec.fn_transform) {
            if (tof(spec.transform) === "function") {
              meta.fn.transform = spec.fn_transform;
            } else {
            }
          }
          if (is_defined(spec.startup_type)) {
            this.startup_type = spec.startup_type;
          }
        }
        "start"(callback2) {
          callback2(null, true);
        }
        // meets_requirements
        //  check if all the prerequisite resources are active
        //  maybe check for login status if applicable.
        "meets_requirements"() {
          return true;
        }
        // 'get' will be the function to use.
        // may have toJson / to_json.
        "get_abstract"() {
        }
        "authenticate"(token) {
          return true;
        }
        // Resources could also operate in connected mode.
        //  How the connection gets handled will be outside of the scope of the resource itself.
        // the last item in the signature is the callback
        "transform"(value2, options) {
          throw "Need specific implementation";
        }
      };
      Resource.Pool = Pool;
      module.exports = Data_Transform_Resource;
    }
  });

  // node_modules/jsgui3-html/resource/compilation-resource.js
  var require_compilation_resource = __commonJS({
    "node_modules/jsgui3-html/resource/compilation-resource.js"(exports, module) {
      var Data_Transform_Resource = require_data_transform_resource();
      var Compilation_Resource = class extends Data_Transform_Resource {
        constructor(spec) {
          super(spec);
        }
        // Which languages?
        //  String names
        //  Or objects describing the languages / formats....
        // With templating, will need to provide it with various values as well....
        //  A single values object should be OK.
        //   Or a promise / observable that will return them.
        // Could be either remote or local....
        // Call through web API, other means, or directly calling a function in the JS codebase.
      };
      module.exports = Compilation_Resource;
    }
  });

  // node_modules/jsgui3-html/resource/compiler-resource.js
  var require_compiler_resource = __commonJS({
    "node_modules/jsgui3-html/resource/compiler-resource.js"(exports, module) {
      var Data_Transform_Resource = require_data_transform_resource();
      var Compiler_Resource = class extends Data_Transform_Resource {
        constructor(spec) {
          super(spec);
        }
        // Which languages?
        //  String names
        //  Or objects describing the languages / formats....
        // With templating, will need to provide it with various values as well....
        //  A single values object should be OK.
        //   Or a promise / observable that will return them.
        // Could be either remote or local....
        // Call through web API, other means, or directly calling a function in the JS codebase.
      };
      module.exports = Compiler_Resource;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/Active_HTML_Document.js
  var require_Active_HTML_Document = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/Active_HTML_Document.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { Blank_HTML_Document } = jsgui2;
      var Active_HTML_Document = class extends Blank_HTML_Document {
        constructor(spec = {}) {
          super(spec);
          this.active();
        }
        // Seems a bit like 'view features'.
        "include_js"(url) {
          const body = this.get("body");
          var script = new jsgui2.script({
            //<script type="text/JavaScript" src="abc.js"><\/script>
            "context": this.context
          });
          var dom = script.dom;
          var domAttributes = dom.attributes;
          domAttributes.type = "text/javascript";
          domAttributes.src = url;
          body.add(script);
        }
        "include_css"(url) {
          var head = this.get("head");
          var link = new jsgui2.link({
            //<script type="text/JavaScript" src="abc.js"><\/script>
            "context": this.context
          });
          var dom = link.dom;
          var domAttributes = dom.attributes;
          domAttributes["rel"] = "stylesheet";
          domAttributes["type"] = "text/css";
          domAttributes["href"] = url;
          head.content.add(link);
        }
        "include_jsgui_client"(js_file_require_data_main) {
          js_file_require_data_main = js_file_require_data_main || "/js/web/jsgui-html-client";
          var head = this.head;
          var body = this.body;
          var script = new jsgui2.script({
            //<script type="text/JavaScript" src="abc.js"><\/script>
            "context": this.context
          });
          var domAttributes = script.dom.attributes;
          domAttributes.set({
            "type": "text/javascript",
            "src": "/js/web/require.js",
            "data-main": js_file_require_data_main
          });
          body.add(script);
        }
        "include_client_css"() {
          var head = this.get("head");
          var link = new jsgui2.link({
            //<script type="text/JavaScript" src="abc.js"><\/script>
            "context": this.context
          });
          var domAttributes = link.dom.attributes;
          domAttributes.rel = "stylesheet";
          domAttributes.type = "text/css";
          domAttributes.href = "/css/basic.css";
          head.content.add(link);
        }
        // also need to include jsgui client css
      };
      module.exports = Active_HTML_Document;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/button.js
  var require_button = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/button.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Control2 = jsgui2.Control;
      var Button = class extends Control2 {
        constructor(spec = {}, add, make) {
          spec.__type_name = spec.__type_name || "button";
          spec.tag_name = "button";
          super(spec);
          this.add_class("button");
          if (spec.text || spec.label) {
            this.text = spec.text || spec.label;
          }
          if (!spec.el) {
            this.compose_button();
          }
        }
        "compose_button"() {
          if (this.text) {
            this.add(this.text);
          }
        }
        "activate"() {
          super.activate();
        }
      };
      module.exports = Button;
      if (__require.main === module) {
        class London_Button extends Button {
          constructor(spec = {}, add, make) {
            spec.text = "London, England";
            super(spec, add, make);
          }
        }
        const lbtn = new London_Button();
        console.log(lbtn.all_html_render());
      }
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/1-advanced/vector/arrow-button.js
  var require_arrow_button = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/1-advanced/vector/arrow-button.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Control2 = jsgui2.Control;
      var def = jsgui2.is_defined;
      var Button = require_button();
      var Arrow_Button = class extends Button {
        constructor(spec, add, make) {
          spec.size = spec.size || [32, 32];
          spec.text = void 0;
          spec.__type_name = spec.__type_name || "arrow_button";
          super(spec);
          let rotation = 0;
          Object.defineProperty(this, "rotation", {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
              return rotation;
            },
            set(value2) {
              rotation = value2;
              this.raise("change", {
                "name": "rotation",
                "value": value2
              });
            },
            enumerable: true,
            configurable: true
          });
          let direction;
          this.on("change", (e) => {
            if (e.name === "rotation") {
              this.line.dom.attributes.transform = "rotate(" + e.value + ", 50, 50)";
              this.polygon.dom.attributes.transform = "rotate(" + e.value + ", 50, 50)";
            }
            if (e.name === "direction") {
              if (e.value === "left") this.rotation = 270;
              if (e.value === "up") this.rotation = 0;
              if (e.value === "right") this.rotation = 90;
              if (e.value === "down") this.rotation = 180;
            }
          });
          Object.defineProperty(this, "direction", {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
              return direction;
            },
            set(value2) {
              direction = value2;
              this.raise("change", {
                "name": "direction",
                "value": value2
              });
            },
            enumerable: true,
            configurable: true
          });
          if (def(spec.rotation)) {
            rotation = spec.rotation;
          }
          if (!spec.el) {
            this.compose_arrow_button();
          }
          if (def(spec.direction)) {
            this.direction = spec.direction;
          }
        }
        "compose_arrow_button"() {
          this.add_class("arrow");
          let svg = this.svg = new jsgui2.svg({
            "context": this.context
          });
          svg.dom.attributes.viewBox = "0 0 100 100";
          let polygon = this.polygon = new jsgui2.polygon({
            context: this.context
          });
          polygon.dom.attributes.points = "50 0, 70 20, 30 20";
          let line = this.line = new jsgui2.line({
            "context": this.context
          });
          line.dom.attributes.x1 = 50;
          line.dom.attributes.y1 = 96;
          line.dom.attributes.x2 = 50;
          line.dom.attributes.y2 = 10;
          line.dom.attributes.transform = "rotate(" + this.rotation + ", 50, 50)";
          polygon.dom.attributes.transform = "rotate(" + this.rotation + ", 50, 50)";
          line.dom.attributes["stroke-width"] = 8;
          svg.add(line);
          svg.add(polygon);
          this.add(svg);
        }
        "activate"() {
          super.activate();
        }
      };
      module.exports = Arrow_Button;
    }
  });

  // node_modules/jsgui3-html/control_mixins/dragable.js
  var require_dragable = __commonJS({
    "node_modules/jsgui3-html/control_mixins/dragable.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var {
        each,
        tof
      } = require_lang();
      var dragable = (ctrl2, opts = {}) => {
        let {
          bounds: bounds2,
          handle,
          mode,
          start_action,
          condition
        } = opts;
        start_action = start_action || ["touchstart", "mousedown"];
        if (tof(start_action) === "string") start_action = [start_action];
        let bounds_pos;
        let bounds_is_parent = bounds2 && bounds2 === ctrl2.parent;
        if (bounds2 === "parent") {
          bounds2 = ctrl2.parent;
          bounds_is_parent = true;
        }
        if (bounds2) {
          bounds_pos = bounds2.pos || [bounds2.dom.el.offsetLeft, bounds2.dom.el.offsetTop];
        }
        handle = handle || ctrl2;
        const old_dragable = ctrl2.dragable;
        if (old_dragable) {
          console.trace();
          throw "NYI / Deprecated";
        }
        let drag_mode = opts.drag_mode || opts.mode || "translate";
        if (bounds_is_parent) {
        }
        let pos_md, pos_mm, pos_mu, pos_md_within_ctrl;
        const setup_isomorphic = () => {
          const old_silent = ctrl2.view.data.model.mixins.silent;
          ctrl2.view.data.model.mixins.silent = true;
          ctrl2.view.data.model.mixins.push({
            name: "dragable"
          });
          ctrl2.view.data.model.mixins.silent = old_silent;
          field(ctrl2, "dragable");
        };
        setup_isomorphic();
        if (typeof document === "undefined") {
          ctrl2.on("server-pre-render", (e) => {
            if (ctrl2.dragable === true) {
              ctrl2._fields = ctrl2._fields || {};
              ctrl2._fields.dragable = true;
            }
          });
        }
        if (ctrl2.dom.el) {
          let ctrl_body = ctrl2.context.body();
          let dragging = false;
          let drag_offset_distance = opts.start_distance || 6;
          let movement_offset;
          let item_start_pos;
          let bounds_size;
          let bounds_offset;
          let half_item_width, item_width;
          let initial_bounds_bcr2, initial_bcr;
          let initial_bcr_offset_from_bounds2;
          const el = ctrl2.dom.el;
          let ctrl_translation3d = new Float32Array(3);
          let initial_ctrl_translation3d;
          let initial_ctrl_translate;
          const begin_drag = (pos) => {
            initial_bcr = ctrl2.bcr();
            if (bounds2) {
              if (typeof bounds2.bcr === "function") {
                initial_bounds_bcr2 = bounds2.bcr();
                initial_bcr_offset_from_bounds2 = [
                  [initial_bcr[0][0] - initial_bounds_bcr2[0][0], initial_bcr[0][1] - initial_bounds_bcr2[0][1]],
                  [initial_bcr[1][0] - initial_bounds_bcr2[1][0], initial_bcr[1][1] - initial_bounds_bcr2[1][1]],
                  [initial_bcr[2][0] - initial_bounds_bcr2[2][0], initial_bcr[2][1] - initial_bounds_bcr2[2][1]]
                ];
              }
            }
            if (drag_mode === "within-parent") {
              dragging = true;
              item_start_pos = ctrl2.pos;
              const ctrl_pos_to_be = [item_start_pos[0] - movement_offset[0], item_start_pos[1] - movement_offset[1]];
              ctrl2.pos = ctrl_pos_to_be;
            } else if (drag_mode === "translate") {
              initial_ctrl_translate = ctrl2.ta.slice(6, 8);
              dragging = true;
            } else {
              if (drag_mode === "x") {
                dragging = true;
                item_start_pos = ctrl2.pos || [ctrl2.dom.el.offsetLeft, ctrl2.dom.el.offsetTop];
                half_item_width = Math.round(ctrl2.dom.el.offsetWidth / 2);
                item_width = ctrl2.dom.el.offsetWidth;
                bounds_offset = [bounds2.dom.el.offsetLeft, bounds2.dom.el.offsetTop];
                ctrl2.pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1]];
              } else {
                console.log("drag_mode", drag_mode);
                throw "NYI";
              }
            }
            ctrl2.raise("dragstart");
          };
          const move_drag = (pos) => {
            let ctrl_size = [ctrl2.dom.el.offsetWidth, ctrl2.dom.el.offsetHeight];
            if (drag_mode === "translate") {
              let tr_x = movement_offset[0] + initial_ctrl_translate[0];
              let tr_y = movement_offset[1] + initial_ctrl_translate[1];
              if (bounds2) {
                const current_bounds_bcr = bounds2.bcr();
                const bounds_left = current_bounds_bcr[0][0];
                const bounds_top = current_bounds_bcr[0][1];
                const bounds_right = current_bounds_bcr[1][0] - ctrl_size[0];
                const bounds_bottom = current_bounds_bcr[1][1] - ctrl_size[1];
                const min_x_offset = bounds_left - initial_ctrl_translate[0];
                const max_x_offset = bounds_right - initial_ctrl_translate[0];
                const min_y_offset = bounds_top - initial_ctrl_translate[1];
                const max_y_offset = bounds_bottom - initial_ctrl_translate[1];
                if (tr_x < min_x_offset) tr_x = min_x_offset;
                if (tr_x > max_x_offset) tr_x = max_x_offset;
                if (tr_y < min_y_offset) tr_y = min_y_offset;
                if (tr_y > max_y_offset) tr_y = max_y_offset;
              }
              ctrl2.ta[6] = tr_x;
              ctrl2.ta[7] = tr_y;
            } else if (drag_mode === "within-parent") {
              bounds2 = bounds2 || ctrl2.parent;
              bounds_size = bounds2.bcr()[2];
              let new_pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1] + movement_offset[1]];
              if (new_pos[0] < 0) new_pos[0] = 0;
              if (new_pos[1] < 0) new_pos[1] = 0;
              if (new_pos[0] > bounds_size[0] - ctrl_size[0]) new_pos[0] = bounds_size[0] - ctrl_size[0];
              if (new_pos[1] > bounds_size[1] - ctrl_size[1]) new_pos[1] = bounds_size[1] - ctrl_size[1];
              ctrl2.pos = new_pos;
            } else if (drag_mode === "x") {
              bounds_size = [bounds2.dom.el.offsetWidth, bounds2.dom.el.offsetHeight];
              let new_pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1]];
              if (new_pos[0] < bounds_pos[0] - half_item_width) new_pos[0] = bounds_pos[0] - half_item_width;
              if (new_pos[0] > bounds_size[0] - ctrl_size[0] + bounds_offset[0] + half_item_width) new_pos[0] = bounds_size[0] - ctrl_size[0] + bounds_offset[0] + half_item_width;
              ctrl2.pos = new_pos;
            }
          };
          const body_mm = (e_mm) => {
            let touch_count = 0;
            if (e_mm.touches) touch_count = e_mm.touches.length;
            if (e_mm.touches) {
              pos_mm = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
            } else {
              pos_mm = [e_mm.pageX, e_mm.pageY];
            }
            if (touch_count === 0 || touch_count === 1) {
              if (e_mm.buttons === 0) {
                body_mu();
              } else {
                if (e_mm.pageX || e_mm.touches) {
                  let pos_mm2;
                  if (e_mm.touches) {
                    pos_mm2 = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
                  } else {
                    pos_mm2 = [e_mm.pageX, e_mm.pageY];
                  }
                  if (pos_mm2[0] !== void 0 && pos_mm2[1] !== void 0) {
                    movement_offset = [pos_mm2[0] - pos_md[0], pos_mm2[1] - pos_md[1]];
                    if (!dragging) {
                      let abs_offset = [Math.abs(movement_offset[0]), Math.abs(movement_offset[1])];
                      let abs_offset_dist = Math.sqrt(Math.pow(abs_offset[0], 2) + Math.pow(abs_offset[1], 2));
                      if (abs_offset_dist >= drag_offset_distance) {
                        begin_drag(pos_mm2);
                      }
                    } else {
                      move_drag(pos_mm2);
                    }
                  }
                }
              }
            }
          };
          const end_drag = (e_mu) => {
            ctrl_body.off("mousemove", body_mm);
            ctrl_body.off("mouseup", body_mu);
            ctrl_body.off("touchmove", body_mm);
            ctrl_body.off("touchend", body_mu);
            if (dragging) {
              dragging = false;
              ctrl2.raise("dragend", {
                movement_offset
              });
            }
          };
          const body_mu = (e_mu) => {
            end_drag(e_mu);
          };
          const h_md = (e_md) => {
            if (!condition || condition()) {
              if (e_md.pageX) {
                pos_md_within_ctrl = [e_md.offsetX, e_md.offsetX];
              } else {
                pos_md_within_ctrl = [0, 0];
              }
              dragging = false;
              pos_md = [e_md.pageX || e_md.touches[0].pageX, e_md.pageY || e_md.touches[0].pageY];
              ctrl_body.on("mousemove", body_mm);
              ctrl_body.on("mouseup", body_mu);
              ctrl_body.on("touchmove", body_mm);
              ctrl_body.on("touchend", body_mu);
            }
          };
          ctrl2.on("change", (e_change) => {
            let n = e_change.name, value2 = e_change.value;
            if (n === "dragable") {
              if (value2 === true) {
                if (typeof document === "undefined") {
                } else {
                  let apply_start_handlers = (start_action2) => {
                    if (!handle.has_drag_md_handler) {
                      handle.has_drag_md_handler = true;
                      each(start_action2, (sa) => {
                        handle.on(sa, h_md);
                      });
                    }
                  };
                  ctrl2.once_active(() => {
                    apply_start_handlers(start_action);
                  });
                }
              } else {
                if (typeof document === "undefined") {
                } else {
                  ((start_action2) => {
                    each(start_action2, (sa) => {
                      handle.off(sa, h_md);
                    });
                  })(start_action);
                  handle.has_drag_md_handler = false;
                }
              }
            }
          });
        }
        if (!old_dragable) {
        }
      };
      module.exports = dragable;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/horizontal-slider.js
  var require_horizontal_slider = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/horizontal-slider.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var v_subtract2 = jsgui2.v_subtract;
      var {
        prop,
        field
      } = require_oext();
      var mx_dragable = require_dragable();
      var Horizontal_Slider = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        // This should be customizable in which values it holds.
        //  For the moment, set up the value range on the server, and send that to the client as fields which we get back from the DOM when
        //  the Control gets activated.
        // I think this can take a min, a max, and a value.
        //  Perhaps operating in 'proportion' mode between 0 and 1 is easiest?
        //  Also having it handle time values - could use ms.
        // Basically, this needs to be told its min value, its max value, and its current value.
        // Also, want 'ghost' drag mode so that the handle can be dragged, and only changes position on release
        //  For different scrubber behaviour to what is in the iPod app.
        constructor(spec, add, make) {
          spec.__type_name = spec.__type_name || "horizontal_slider";
          super(spec);
          field(this, "min", spec.min || 0);
          field(this, "value", spec.value || 0);
          field(this, "max", spec.max || 100);
          if (!spec.el) {
            this.compose_horizontal_slider();
          }
        }
        "compose_horizontal_slider"() {
          let h_bar, v_bar;
          const context2 = this.context;
          let div_relative = this.add(new Control2({
            "class": "relative",
            "context": context2
          }));
          this.add_class("horizontal slider");
          h_bar = new Control2({
            "class": "h-bar",
            "context": context2
          });
          v_bar = new Control2({
            "class": "v-bar",
            "context": context2
          });
          div_relative.add(h_bar);
          div_relative.add(v_bar);
          let ctrl_fields = {
            "div_relative": div_relative,
            "h_bar": h_bar,
            "v_bar": v_bar
          };
          this._ctrl_fields = this._ctrl_fields || {};
          Object.assign(this._ctrl_fields, ctrl_fields);
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            console.log("Horizontal Slider activate");
            var h_bar = this.h_bar;
            var v_bar = this.v_bar;
            mx_dragable(v_bar, {
              mode: "x",
              bounds: h_bar,
              start_distance: 1
            });
            v_bar.dragable = true;
            v_bar.on("dragend", (e_complete) => {
              let bar_left = v_bar.dom.el.offsetLeft;
              let h_v_width = Math.round(v_bar.dom.el.offsetWidth / 2);
              let bar_x = bar_left - h_v_width;
              let h_width = h_bar.dom.el.offsetWidth;
              let prop2 = bar_x / h_width;
              let range_diff = this.max - this.min;
              let v = prop2 * range_diff + this.min;
              this._.value = v;
              this.raise("choose-value", v);
            });
            this.on("change", (e_change) => {
              var name = e_change.name, value2 = e_change.value;
              if (name === "value") {
                this.bar_value = value2;
              }
            });
            this.on("resize", (e) => {
              this.bar_value = this._.value;
            });
          }
        }
        set bar_value(value2) {
          const {
            h_bar,
            v_bar
          } = this;
          var min = this.min;
          var max = this.max;
          let prop2 = (value2 - min) / (max - min);
          var size_h_bar = h_bar.size || [h_bar.dom.el.offsetWidth, h_bar.dom.el.offsetHeight];
          let v_bar_center_pos = Math.round(size_h_bar[0] * prop2) + h_bar.dom.el.offsetLeft;
          let v_bar_left_pos = v_bar_center_pos - Math.round(v_bar.dom.el.offsetWidth / 2);
          let v_bar_top = v_bar.dom.el.offsetTop;
          if (v_bar.pos) {
            v_bar.pos = [v_bar_left_pos, v_bar.pos[1]];
          } else {
            v_bar.dom.attributes.style.left = v_bar_left_pos;
          }
          this._.value = value2;
        }
      };
      module.exports = Horizontal_Slider;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/audio-volume.js
  var require_audio_volume = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/audio-volume.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Horizontal_Slider = require_horizontal_slider();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var v_subtract2 = jsgui2.v_subtract;
      var Audio_Volume = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //'fields': [
        //	['text', String]
        //],
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "audio_volume";
          if (!spec.abstract && !spec.el) {
            this.add_class("audio-volume");
            var h_slider = add(Horizontal_Slider({
              "min": 0,
              "max": 100,
              "value": 100
            }));
            var ctrl_fields = {
              "h_slider": h_slider._id()
            };
            this.active();
          }
        }
        "activate"() {
          super.activate();
          console.log("Audio Volume activate");
          var h_slider = this.h_slider;
        }
      };
      module.exports = Audio_Volume;
    }
  });

  // node_modules/jsgui3-html/control_mixins/selectable.js
  var require_selectable = __commonJS({
    "node_modules/jsgui3-html/control_mixins/selectable.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var { each, is_array, is_def } = require_lib_lang_mini();
      var selectable = (ctrl2, ctrl_handle, opts) => {
        const setup_isomorphic = () => {
          const old_silent = ctrl2.view.data.model.mixins.silent;
          ctrl2.view.data.model.mixins.silent = true;
          ctrl2.view.data.model.mixins.push({
            name: "selectable"
          });
          ctrl2.view.data.model.mixins.silent = old_silent;
          ctrl2.on("change", (e_change) => {
            let {
              name,
              value: value2
            } = e_change;
            if (name === "selected") {
              if (value2) {
                ctrl2.add_class("selected");
              } else {
                ctrl2.remove_class("selected");
              }
            }
            ;
            return true;
          });
        };
        setup_isomorphic();
        if (typeof document === "undefined") {
          ctrl2.on("server-pre-render", (e) => {
            if (ctrl2.selectable === true) {
              ctrl2._fields = ctrl2._fields || {};
              ctrl2._fields.selectable = true;
              if (ctrl2.selected === true) {
                ctrl2._fields.selected = true;
              }
            }
          });
        }
        if (ctrl2.dom.el) {
          let select_toggle = false;
          let select_multi = false;
          let condition;
          let preventDefault = true;
          let selection_action = ["mousedown", "touchstart"];
          const old_selectable2 = ctrl2.selectable;
          if (old_selectable2) {
            console.trace();
            throw "NYI / Deprecated";
          } else {
            if (!opts) {
              if (ctrl_handle) {
                if (!ctrl_handle.activate) {
                  opts = ctrl_handle;
                  ctrl_handle = void 0;
                }
              }
            }
            if (opts) {
              if (opts.handle) {
                ctrl_handle = opts.handle;
              }
              if (opts.select_toggle || opts.toggle) {
                select_toggle = true;
              }
              if (opts.select_multi || opts.multi) {
                select_multi = true;
              }
              if (opts.single) {
                select_multi = false;
              }
              if (opts.selection_action) {
                selection_action = opts.selection_action;
              }
              if (opts.condition) {
                condition = opts.condition;
              }
              if (opts.preventDefault === false) {
                preventDefault = false;
              }
            }
            ctrl_handle = ctrl_handle || ctrl2;
            let click_handler = (e) => {
              if (ctrl2.selectable && !ctrl2.selection_scope && !ctrl2.disabled) {
                if (!condition || condition()) {
                  var ctrl_key = e.ctrlKey;
                  var meta_key = e.metaKey;
                  if (select_multi) {
                    if (ctrl_key || meta_key) {
                      ctrl2.action_select_toggle();
                    } else {
                      if (select_toggle) {
                        ctrl2.action_select_toggle();
                      } else {
                        ctrl2.action_select_only();
                      }
                    }
                  } else {
                    if (select_toggle) {
                      if (ctrl2.selected) {
                        ctrl2.deselect();
                      } else {
                        ctrl2.action_select_only();
                      }
                    } else {
                      ctrl2.action_select_only();
                    }
                  }
                  if (preventDefault) {
                    e.preventDefault();
                  }
                } else {
                  console.log("failed condition check");
                }
              } else {
              }
            };
            let ss;
            const apply_all = (ctrl3) => {
              let id = ctrl3._id();
              ctrl3.on("change", (e_change) => {
                let n = e_change.name, value2 = e_change.value;
                let ss2 = ctrl3.find_selection_scope();
                if (n === "selected") {
                  if (value2 === true) {
                    ctrl3.add_class("selected");
                    if (ss2) ss2.map_selected_controls[id] = ctrl3;
                  } else {
                    ctrl3.remove_class("selected");
                    if (ss2) ss2.map_selected_controls[id] = null;
                  }
                }
                if (n === "selectable") {
                  if (value2 === true) {
                    apply_active_selectable(ctrl3);
                  } else {
                    if (typeof document === "undefined") {
                    } else {
                      if (is_array(selection_action)) {
                        selection_action.forEach((i) => {
                          ctrl_handle.off(i, click_handler);
                        });
                      } else {
                        ctrl_handle.off(selection_action, click_handler);
                      }
                      ctrl_handle.has_selection_click_handler = false;
                    }
                  }
                }
              });
            };
            const apply_active_selectable = (ctrl3) => {
              ctrl3.deselect = ctrl3.deselect || (() => {
                ss = ss || ctrl3.find_selection_scope();
                if (ss) ss.deselect(ctrl3);
                ctrl3.raise("deselect");
              });
              ctrl3.select = ctrl3.select || (() => {
                ss = ss || ctrl3.find_selection_scope();
                if (ss) ss.select(ctrl3);
                ctrl3.raise("select");
              });
              ctrl3.action_select_only = ctrl3.action_select_only || (() => {
                ss = ss || ctrl3.find_selection_scope();
                if (ss) {
                  ss.select_only(ctrl3);
                } else {
                  each(ctrl3.siblings, (sibling) => {
                    sibling.selected = false;
                  });
                  ctrl3.selected = true;
                }
              });
              ctrl3.action_select_toggle = ctrl3.action_select_toggle || (() => {
                ss = ss || ctrl3.find_selection_scope();
                ss.select_toggle(ctrl3);
              });
              if (typeof document === "undefined") {
              } else {
                ctrl3.once_active(() => {
                  if (!ctrl_handle.has_selection_click_handler) {
                    ctrl_handle.has_selection_click_handler = true;
                    if (Array.isArray(selection_action)) {
                      selection_action.forEach((i) => {
                        ctrl_handle.on(i, click_handler);
                      });
                    } else {
                      ctrl_handle.on(selection_action, click_handler);
                    }
                  }
                });
              }
            };
            field(ctrl2, "selected");
            field(ctrl2, "selectable");
            apply_all(ctrl2);
            ctrl2.on("activate", (e) => {
              if (ctrl2.selectable) apply_all(ctrl2);
            });
          }
        }
      };
      module.exports = selectable;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Cell.js
  var require_Cell = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Cell.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var mx_selectable = require_selectable();
      var { field } = require_oext();
      var Control2 = jsgui2.Control;
      var Cell = class extends Control2 {
        constructor(spec) {
          (spec = spec || {}).__type_name = "cell";
          super(spec);
          this.add_class("cell");
          field(this, "x", spec.x);
          field(this, "y", spec.y);
          field(this, "data", spec.data);
          if (!spec.el) {
            this.compose_grid_cell();
          }
          mx_selectable(this);
        }
        compose_grid_cell() {
          let o = {
            context: this.context
          };
          if (this.data) o.text = this.data;
          this.add(this.span = new jsgui2.span(o));
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.span = this.span;
        }
        activate() {
          if (!this.__active) {
            super.activate();
          }
        }
      };
      module.exports = Cell;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/menu-node.js
  var require_menu_node = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/menu-node.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { stringify, each, tof, Control: Control2 } = jsgui2;
      var Menu_Node = class _Menu_Node extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        // Actually having a different content?
        //  Or use inner_content.
        // Menu node having expanded and contracted states.
        // Menu Node has an image and some text, and a contrainer control for othe Menu nodes.
        //  Can be collapsed so that the internal items don't show
        //'fields': [
        //['text', String]
        //],
        //'fields': {
        //	'img_src': 'string',
        //	'text': 'string'
        //},
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "menu_node";
          if (!this._abstract) {
            if (!spec.el) {
              this.add_class("menu-node");
              var spec_state = spec.state, state;
              var main_control = make(Control2({ "class": "main" }));
              this.add(main_control);
              if (spec.img_src) {
              }
              if (spec.text) {
                this.text = spec.text;
                var span = make(jsgui2.span({}));
                span.add(spec.text);
                main_control.add(span);
              }
              var menu = spec.menu;
              if (menu) {
                this.set("menu", menu);
              }
              var inner_control = this.inner_control = make(Control2({ "class": "inner hidden" }));
              this.add(inner_control);
              if (spec.value) {
                var obj_menu = spec.value;
                var t_obj_menu = tof(obj_menu);
                console.log("t_obj_menu", t_obj_menu);
                if (t_obj_menu == "array") {
                  each(obj_menu, function(v) {
                    var tv = tof(v);
                    if (tv == "string") {
                      var nested_menu_node = make(_Menu_Node({
                        "text": v,
                        "menu": menu
                      }));
                      inner_control.add(nested_menu_node);
                    }
                  });
                }
              }
              var ctrl_fields = {
                "inner_control": inner_control._id(),
                "main_control": main_control._id(),
                "menu": spec.menu._id()
              };
              this.set("dom.attributes.data-jsgui-ctrl-fields", stringify(ctrl_fields).replace(/"/g, "'"));
              if (spec_state) {
                if (spec_state == "open" || spec_state == "closed") {
                  state = this.set("state", spec_state);
                } else {
                  throw 'spec.state expects "open" or "closed".';
                }
              } else {
                state = this.set("state", "open");
              }
            }
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            var inner_control = this.inner_control;
            var main_control = this.main_control;
            var menu = this.menu;
            var that2 = this;
          }
        }
        "close_all"() {
          console.log("menu-node close_all");
          var inner_control = this.inner_control;
          inner_control.content.each(function(v, i) {
            var tn = v.__type_name;
            if (tn == "menu_node") {
              v.close_all();
            }
          });
          inner_control.hide();
          this.set("state", "closed", true);
        }
        "close"() {
          var inner_control = this.inner_control;
          inner_control.hide();
          this.set("state", "closed", true);
        }
        "open"() {
          var inner_control = this.inner_control;
          inner_control.show();
          this.set("state", "open", true);
        }
      };
      module.exports = Menu_Node;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/context-menu.js
  var require_context_menu = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/context-menu.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Menu_Node = require_menu_node();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var Context_Menu = class extends Control2 {
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "context_menu";
          this.add_class("context menu");
          if (!spec.abstract) {
            const obj2 = spec.value;
            const tobj = tof(obj2);
            if (tobj === "object") {
              each(obj2, (v, key2) => {
                const menu_node = make(Menu_Node({
                  "text": key2,
                  "value": v,
                  "menu": this
                }));
                this.add(menu_node);
              });
            }
            if (tobj === "array") {
              each(obj2, (v, index) => {
                var vsig = jsgui2.get_item_sig(v, 1);
                if (vsig == "[s,f]") {
                  var text = v[0];
                  var item_callback = v[1];
                  var menu_node = make(Menu_Node({
                    "text": text,
                    "value": text,
                    "menu": this
                  }));
                  this.add(menu_node);
                }
              });
            }
          }
          this._features = this._features || [];
          each(["menu"], this._features.push);
        }
        "activate"() {
          super.activate();
        }
        "close_all"() {
          console.log("menu close_all");
          this.content.each(function(v, i) {
            v.close_all();
          });
        }
      };
      module.exports = Context_Menu;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/grid.js
  var require_grid = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/grid.js"(exports, module) {
      var jsgui2 = require_html_core();
      var {
        stringify,
        each,
        tof,
        def,
        Control: Control2
      } = jsgui2;
      var mx_selectable = require_selectable();
      var {
        prop,
        field
      } = require_oext();
      var Cell = require_Cell();
      var Grid_Cell = Cell;
      var Grid = class extends Control2 {
        constructor(spec, add, make) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "grid";
          super(spec);
          if (spec.cell_selection) {
            this.cell_selection = spec.cell_selection;
          }
          this.add_class("grid");
          var spec_data = spec.data;
          this._arr_rows = [];
          field(this, "composition_mode");
          if (spec.composition_mode) {
            this.composition_mode = spec.composition_mode;
          } else {
            this.composition_mode = "divs";
          }
          prop(this, "grid_size", spec.grid_size || [12, 12]);
          field(this, "cell_size");
          if (spec.cell_size) this.cell_size = spec.cell_size;
          field(this, "column_headers", false);
          field(this, "row_headers", false);
          prop(this, "data", false);
          this.map_cells = {};
          this.arr_cells = {};
          if (spec.data) {
            let t_data = tof(spec.data);
            if (t_data === "array") {
              let max_x = -1;
              let y, x, ly, lx, arr = spec.data, arr_row;
              ly = arr.length;
              for (y = 0; y < ly; y++) {
                arr_row = arr[y];
                lx = arr_row.length;
                if (lx > max_x) max_x = lx;
                for (x = 0; x < lx; x++) {
                }
              }
              _grid_size = [max_x, ly];
            }
          }
          if (!spec.el) {
            var data;
            this.full_compose_as_divs();
            this._fields = this._fields || {};
            Object.assign(this._fields, {
              "composition_mode": this.composition_mode,
              "grid_size": this.grid_size
            });
            if (this.cell_size) {
              this._fields.cell_size = this.cell_size;
            }
          }
          this.changes({
            grid_size: (v) => {
              if (!spec.el) {
                this.clear();
                this.full_compose_as_divs();
              }
            }
          });
        }
        //  Have the size system set up within the 'view model'.
        "refresh_size"() {
          if (this.composition_mode === "divs") {
            let [num_columns, num_rows] = this.grid_size;
            var cell_border_thickness = 1;
            var _2_cell_border_thickness = cell_border_thickness * 2;
            if (this.size) {
              var cell_size = this.cell_size || [Math.floor(this.size[0] / num_columns) - _2_cell_border_thickness, Math.floor(this.size[1] / num_rows) - _2_cell_border_thickness];
              var cell_v_border_thickness = 2;
              this.each_row((row) => {
                row.size = [this.size[0], cell_size[1] + cell_v_border_thickness];
              });
              this.each_cell((cell) => {
                cell.size = cell_size;
              });
            } else {
              console.log(".size was not available");
            }
          }
        }
        "each_row"(cb_row) {
          each(this._arr_rows, cb_row);
        }
        "each_cell"(cb_cell) {
          each(this._arr_rows, (row, i_row) => {
            row.content.each((cell, i_cell) => {
              cb_cell(cell, [i_cell, i_row]);
            });
          });
        }
        "get_cell"(x, y) {
          console.trace();
          throw "NYI";
        }
        "add_cell"(content) {
          var cell = new Grid_Cell({
            context: this.context
          });
          if (this.cell_selection) {
            cell.selectable = true;
          } else {
          }
          if (content) {
            cell.add(content);
          }
          cell.active();
          this.main.add(cell);
          return cell;
        }
        "full_compose_as_divs"() {
          let main = this.main = new Control2({
            context: this.context,
            class: "main"
          });
          this.add(main);
          let rows = this.main = new Control2({
            context: this.context,
            class: "rows"
          });
          main.add(rows);
          let map_cells = this.map_cells, arr_cells = this.arr_cells;
          if (this.grid_size) {
            let [num_columns, num_rows] = this.grid_size;
            var cell_border_thickness = 0;
            var _2_cell_border_thickness = cell_border_thickness * 2;
            let cell_size;
            if (this.size) {
              cell_size = this.cell_size || [Math.floor(this.size[0] / num_columns) - _2_cell_border_thickness, Math.floor(this.size[1] / num_rows) - _2_cell_border_thickness];
            } else {
              cell_size = this.cell_size;
            }
            let row_width, row_height;
            let row_header_width;
            if (this.cell_size) {
              if (this.row_headers) {
                row_header_width = this.row_headers.width || row_header_width;
                row_width = this.cell_size[0] * num_columns + row_header_width;
              } else {
                row_width = this.cell_size[0] * num_columns;
              }
              row_height = this.cell_size[1];
            } else {
              if (this.size) row_height = Math.floor(this.size[1] / num_rows);
            }
            const data = this.data;
            var x, y;
            if (this.column_headers) {
              let header_row = new Control2({
                context: this.context
              });
              header_row.add_class("header");
              header_row.add_class("row");
              if (row_height) {
                header_row.style("height", row_height);
              }
              if (row_width) {
                header_row.style("width", row_width);
              }
              rows.add(header_row);
              if (this.row_headers) {
                var cell = new Control2({
                  context: this.context,
                  __type_name: "grid_cell"
                });
                cell.add_class("grid-header");
                cell.add_class("cell");
                if (row_header_width) {
                  cell.size = [row_header_width, cell_size[1]];
                } else {
                  cell.size = cell_size;
                }
                header_row.add(cell);
              }
              for (x = 0; x < num_columns; x++) {
                var cell = new Control2({
                  context: this.context,
                  __type_name: "grid_cell"
                });
                cell.add_class("column-header");
                cell.add_class("cell");
                cell.size = cell_size;
                header_row.add(cell);
              }
            }
            for (y = 0; y < num_rows; y++) {
              var row_container = new Control2({
                context: this.context
              });
              if (row_height) {
                row_container.style("height", row_height);
              }
              if (row_width) {
                row_container.style("width", row_width);
              }
              row_container.add_class("row");
              this._arr_rows.push(row_container);
              rows.add(row_container);
              if (this.row_headers) {
                var cell = new Control2({
                  context: this.context,
                  __type_name: "grid_cell"
                });
                cell.add_class("row-header");
                cell.add_class("cell");
                if (row_header_width) {
                  cell.size = [row_header_width, cell_size[1]];
                } else {
                  cell.size = cell_size;
                }
                row_container.add(cell);
              }
              for (x = 0; x < num_columns; x++) {
                let o = {
                  context: this.context,
                  x,
                  y
                };
                if (data) {
                  o.data = data[y][x];
                }
                var cell = new Grid_Cell(o);
                cell.selectable = true;
                if (cell_size) cell.size = cell_size;
                row_container.add(cell);
                arr_cells[x] = arr_cells[x] || [];
                arr_cells[x][y] = cell;
                map_cells["[" + x + "," + y + "]"] = cell;
              }
            }
          }
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.main = main;
          this._ctrl_fields.rows = rows;
        }
        "full_compose_as_table"() {
          this.dom.tagName = table;
          var data = this.data;
          var range = data.range;
          var value2;
          if (tof(data) === "data_grid") {
            var x, y, max_x = range[0], max_y = range[1];
            var ctrl_cell, ctrl_row;
            var size = this.size().value();
            var tbody_params = {
              "context": this.context,
              "tagName": "tbody"
            };
            if (size) {
              tbody_params.size = [size[0][0], size[1][0]];
            }
            var tbody = new Control2(tbody_params);
            this.add(tbody);
            for (y = 0; y <= max_y; y++) {
              ctrl_row = new jsgui2.tr({
                "context": this.context
              });
              tbody.add(ctrl_row);
              for (x = 0; x <= max_x; x++) {
                ctrl_cell = new jsgui2.td({
                  "context": this.context
                });
                ctrl_row.add(ctrl_cell);
                value2 = data.get(x, y);
                ctrl_cell.add_text(value2);
              }
            }
          } else {
            throw "Unexpected data type. Expected data_grid, got " + tof(data);
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            this.selection_scope = this.selection_scope || this.context.new_selection_scope(this);
            var load_rows = () => {
              var _arr_rows = this._arr_rows = [];
              this.rows.content._arr.forEach((v) => {
                _arr_rows.push(v);
              });
            };
            load_rows();
            var load_cells = () => {
              each(this._arr_rows, (row) => {
                each(row.content._arr, (cell) => {
                });
              });
            };
          }
        }
      };
      Grid.css = `
table.grid {
    background-color: #eceff1;
    border: 1px solid #546e7a;
    padding: 2px;
    cursor: default;
}
table.grid tbody {
    overflow: hidden;
    display: block;
}
table.grid td {
    padding: 1px;
}
.data-row .data-item {
    display: inline;
    margin-left: 2px;
    padding: 2px;
}
.mid-width {
    width: 450px;
}
div.grid {
    user-select: none;
    clear: both;
}
div.grid .header.row .cell {
    text-align: center
}
div.grid .row {
    clear: both;
}
div.grid .header.row .cell span {
    position: relative;
    top: 4px;
    left: 0px;
    font-size: 11pt;
}
div.grid .row .cell {
    float: left;
    box-sizing: border-box;
    border-right: 1px solid #AAAAAA;
    border-bottom: 1px solid #999999;
}
div.grid .row .cell.selected {
    float: left;
    box-sizing: border-box;
    border: 2px solid #2046df;
    border-radius: 4px;
}
div.grid .row .cell.selected span {
    position: relative;
    left: 3px;
    top: -1px;
    font-size: 16pt;
}
div.grid .row .cell span {
    position: relative;
    left: 5px;
    top: 1px;
    font-size: 16pt;
}
`;
      Grid.Cell = Grid.Grid_Cell = Grid_Cell;
      module.exports = Grid;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/color-grid.js
  var require_color_grid = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/color-grid.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Grid = require_grid();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var v_subtract2 = jsgui2.util.v_subtract;
      var {
        field,
        prop
      } = require_oext();
      var Color_Grid = class extends Grid {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "color_grid";
          super(spec);
          this.add_class("color-grid");
          this.internal_relative_div = true;
          prop(this, "palette", spec.palette);
          if (!spec.abstract && !spec.el) {
            this.compose_color_palette_grid();
          }
          this.on("resize", (e_resize) => {
            if (this.grid) {
              var _2_padding = 12;
              var new_grid_size = v_subtract2(e_resize.value, [_2_padding, _2_padding]);
              this.grid.size = new_grid_size;
            }
          });
        }
        activate() {
          if (!this.activate.__active) {
            super.activate();
            this.grid.selection_scope.on("change", (e) => {
              const {
                name,
                value: value2
              } = e;
              if (name === "selected") {
                const selected_ctrl = value2;
                if (selected_ctrl) {
                  let color = selected_ctrl._color;
                  this.raise("choose-color", {
                    value: color
                  });
                }
              }
            });
            const old_make_grid_cells_selectable = () => {
              this.grid.each_cell((cell) => {
              });
            };
          }
        }
        each_cell(cb) {
          return this.grid.each_cell(cb);
        }
        add_grid_cells() {
          if (this.palette) {
            let c2 = 0;
            this.grid.each_cell((cell) => {
              var item2 = this.palette[c2++];
              if (item2) {
                if (item2.hex) {
                  cell.color = item2.hex;
                } else {
                  if (typeof item2 === "string") {
                    cell.color = item2;
                  }
                }
              }
            });
          }
        }
        compose_color_palette_grid() {
          var padding = 6;
          const grid = this.grid = new Grid({
            "context": this.context,
            "grid_size": this.grid_size,
            "size": this.size,
            "cell_selection": "single"
          });
          grid.each_cell((cell, [x, y]) => {
          });
          this.add(grid);
          this.add_grid_cells();
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.grid = grid;
        }
      };
      if (__require.main === module) {
        console.log("pal_crayola.length", pal_crayola.length);
      } else {
      }
      module.exports = Color_Grid;
    }
  });

  // node_modules/jsgui3-html/html-core/arr_colors.js
  var require_arr_colors = __commonJS({
    "node_modules/jsgui3-html/html-core/arr_colors.js"(exports, module) {
      var pal_crayola2 = [
        {
          "hex": "#EFDECD",
          "name": "Almond",
          "rgb": "(239, 222, 205)"
        },
        {
          "hex": "#CD9575",
          "name": "Antique Brass",
          "rgb": "(205, 149, 117)"
        },
        {
          "hex": "#FDD9B5",
          "name": "Apricot",
          "rgb": "(253, 217, 181)"
        },
        {
          "hex": "#78DBE2",
          "name": "Aquamarine",
          "rgb": "(120, 219, 226)"
        },
        {
          "hex": "#87A96B",
          "name": "Asparagus",
          "rgb": "(135, 169, 107)"
        },
        {
          "hex": "#FFA474",
          "name": "Atomic Tangerine",
          "rgb": "(255, 164, 116)"
        },
        {
          "hex": "#FAE7B5",
          "name": "Banana Mania",
          "rgb": "(250, 231, 181)"
        },
        {
          "hex": "#9F8170",
          "name": "Beaver",
          "rgb": "(159, 129, 112)"
        },
        {
          "hex": "#FD7C6E",
          "name": "Bittersweet",
          "rgb": "(253, 124, 110)"
        },
        {
          "hex": "#000000",
          "name": "Black",
          "rgb": "(0,0,0)"
        },
        {
          "hex": "#ACE5EE",
          "name": "Blizzard Blue",
          "rgb": "(172, 229, 238)"
        },
        {
          "hex": "#1F75FE",
          "name": "Blue",
          "rgb": "(31, 117, 254)"
        },
        {
          "hex": "#A2A2D0",
          "name": "Blue Bell",
          "rgb": "(162, 162, 208)"
        },
        {
          "hex": "#6699CC",
          "name": "Blue Gray",
          "rgb": "(102, 153, 204)"
        },
        {
          "hex": "#0D98BA",
          "name": "Blue Green",
          "rgb": "(13, 152, 186)"
        },
        {
          "hex": "#7366BD",
          "name": "Blue Violet",
          "rgb": "(115, 102, 189)"
        },
        {
          "hex": "#DE5D83",
          "name": "Blush",
          "rgb": "(222, 93, 131)"
        },
        {
          "hex": "#CB4154",
          "name": "Brick Red",
          "rgb": "(203, 65, 84)"
        },
        {
          "hex": "#B4674D",
          "name": "Brown",
          "rgb": "(180, 103, 77)"
        },
        {
          "hex": "#FF7F49",
          "name": "Burnt Orange",
          "rgb": "(255, 127, 73)"
        },
        {
          "hex": "#EA7E5D",
          "name": "Burnt Sienna",
          "rgb": "(234, 126, 93)"
        },
        {
          "hex": "#B0B7C6",
          "name": "Cadet Blue",
          "rgb": "(176, 183, 198)"
        },
        {
          "hex": "#FFFF99",
          "name": "Canary",
          "rgb": "(255, 255, 153)"
        },
        {
          "hex": "#1CD3A2",
          "name": "Caribbean Green",
          "rgb": "(28, 211, 162)"
        },
        {
          "hex": "#FFAACC",
          "name": "Carnation Pink",
          "rgb": "(255, 170, 204)"
        },
        {
          "hex": "#DD4492",
          "name": "Cerise",
          "rgb": "(221, 68, 146)"
        },
        {
          "hex": "#1DACD6",
          "name": "Cerulean",
          "rgb": "(29, 172, 214)"
        },
        {
          "hex": "#BC5D58",
          "name": "Chestnut",
          "rgb": "(188, 93, 88)"
        },
        {
          "hex": "#DD9475",
          "name": "Copper",
          "rgb": "(221, 148, 117)"
        },
        {
          "hex": "#9ACEEB",
          "name": "Cornflower",
          "rgb": "(154, 206, 235)"
        },
        {
          "hex": "#FFBCD9",
          "name": "Cotton Candy",
          "rgb": "(255, 188, 217)"
        },
        {
          "hex": "#FDDB6D",
          "name": "Dandelion",
          "rgb": "(253, 219, 109)"
        },
        {
          "hex": "#2B6CC4",
          "name": "Denim",
          "rgb": "(43, 108, 196)"
        },
        {
          "hex": "#EFCDB8",
          "name": "Desert Sand",
          "rgb": "(239, 205, 184)"
        },
        {
          "hex": "#6E5160",
          "name": "Eggplant",
          "rgb": "(110, 81, 96)"
        },
        {
          "hex": "#CEFF1D",
          "name": "Electric Lime",
          "rgb": "(206, 255, 29)"
        },
        {
          "hex": "#71BC78",
          "name": "Fern",
          "rgb": "(113, 188, 120)"
        },
        {
          "hex": "#6DAE81",
          "name": "Forest Green",
          "rgb": "(109, 174, 129)"
        },
        {
          "hex": "#C364C5",
          "name": "Fuchsia",
          "rgb": "(195, 100, 197)"
        },
        {
          "hex": "#CC6666",
          "name": "Fuzzy Wuzzy",
          "rgb": "(204, 102, 102)"
        },
        {
          "hex": "#E7C697",
          "name": "Gold",
          "rgb": "(231, 198, 151)"
        },
        {
          "hex": "#FCD975",
          "name": "Goldenrod",
          "rgb": "(252, 217, 117)"
        },
        {
          "hex": "#A8E4A0",
          "name": "Granny Smith Apple",
          "rgb": "(168, 228, 160)"
        },
        {
          "hex": "#95918C",
          "name": "Gray",
          "rgb": "(149, 145, 140)"
        },
        {
          "hex": "#1CAC78",
          "name": "Green",
          "rgb": "(28, 172, 120)"
        },
        {
          "hex": "#1164B4",
          "name": "Green Blue",
          "rgb": "(17, 100, 180)"
        },
        {
          "hex": "#F0E891",
          "name": "Green Yellow",
          "rgb": "(240, 232, 145)"
        },
        {
          "hex": "#FF1DCE",
          "name": "Hot Magenta",
          "rgb": "(255, 29, 206)"
        },
        {
          "hex": "#B2EC5D",
          "name": "Inchworm",
          "rgb": "(178, 236, 93)"
        },
        {
          "hex": "#5D76CB",
          "name": "Indigo",
          "rgb": "(93, 118, 203)"
        },
        {
          "hex": "#CA3767",
          "name": "Jazzberry Jam",
          "rgb": "(202, 55, 103)"
        },
        {
          "hex": "#3BB08F",
          "name": "Jungle Green",
          "rgb": "(59, 176, 143)"
        },
        {
          "hex": "#FEFE22",
          "name": "Laser Lemon",
          "rgb": "(254, 254, 34)"
        },
        {
          "hex": "#FCB4D5",
          "name": "Lavender",
          "rgb": "(252, 180, 213)"
        },
        {
          "hex": "#FFF44F",
          "name": "Lemon Yellow",
          "rgb": "(255, 244, 79)"
        },
        {
          "hex": "#FFBD88",
          "name": "Macaroni and Cheese",
          "rgb": "(255, 189, 136)"
        },
        {
          "hex": "#F664AF",
          "name": "Magenta",
          "rgb": "(246, 100, 175)"
        },
        {
          "hex": "#AAF0D1",
          "name": "Magic Mint",
          "rgb": "(170, 240, 209)"
        },
        {
          "hex": "#CD4A4C",
          "name": "Mahogany",
          "rgb": "(205, 74, 76)"
        },
        {
          "hex": "#EDD19C",
          "name": "Maize",
          "rgb": "(237, 209, 156)"
        },
        {
          "hex": "#979AAA",
          "name": "Manatee",
          "rgb": "(151, 154, 170)"
        },
        {
          "hex": "#FF8243",
          "name": "Mango Tango",
          "rgb": "(255, 130, 67)"
        },
        {
          "hex": "#C8385A",
          "name": "Maroon",
          "rgb": "(200, 56, 90)"
        },
        {
          "hex": "#EF98AA",
          "name": "Mauvelous",
          "rgb": "(239, 152, 170)"
        },
        {
          "hex": "#FDBCB4",
          "name": "Melon",
          "rgb": "(253, 188, 180)"
        },
        {
          "hex": "#1A4876",
          "name": "Midnight Blue",
          "rgb": "(26, 72, 118)"
        },
        {
          "hex": "#30BA8F",
          "name": "Mountain Meadow",
          "rgb": "(48, 186, 143)"
        },
        {
          "hex": "#C54B8C",
          "name": "Mulberry",
          "rgb": "(197, 75, 140)"
        },
        {
          "hex": "#1974D2",
          "name": "Navy Blue",
          "rgb": "(25, 116, 210)"
        },
        {
          "hex": "#FFA343",
          "name": "Neon Carrot",
          "rgb": "(255, 163, 67)"
        },
        {
          "hex": "#BAB86C",
          "name": "Olive Green",
          "rgb": "(186, 184, 108)"
        },
        {
          "hex": "#FF7538",
          "name": "Orange",
          "rgb": "(255, 117, 56)"
        },
        {
          "hex": "#FF2B2B",
          "name": "Orange Red",
          "rgb": "(255, 43, 43)"
        },
        {
          "hex": "#F8D568",
          "name": "Orange Yellow",
          "rgb": "(248, 213, 104)"
        },
        {
          "hex": "#E6A8D7",
          "name": "Orchid",
          "rgb": "(230, 168, 215)"
        },
        {
          "hex": "#414A4C",
          "name": "Outer Space",
          "rgb": "(65, 74, 76)"
        },
        {
          "hex": "#FF6E4A",
          "name": "Outrageous Orange",
          "rgb": "(255, 110, 74)"
        },
        {
          "hex": "#1CA9C9",
          "name": "Pacific Blue",
          "rgb": "(28, 169, 201)"
        },
        {
          "hex": "#FFCFAB",
          "name": "Peach",
          "rgb": "(255, 207, 171)"
        },
        {
          "hex": "#C5D0E6",
          "name": "Periwinkle",
          "rgb": "(197, 208, 230)"
        },
        {
          "hex": "#FDDDE6",
          "name": "Piggy Pink",
          "rgb": "(253, 221, 230)"
        },
        {
          "hex": "#158078",
          "name": "Pine Green",
          "rgb": "(21, 128, 120)"
        },
        {
          "hex": "#FC74FD",
          "name": "Pink Flamingo",
          "rgb": "(252, 116, 253)"
        },
        {
          "hex": "#F78FA7",
          "name": "Pink Sherbet",
          "rgb": "(247, 143, 167)"
        },
        {
          "hex": "#8E4585",
          "name": "Plum",
          "rgb": "(142, 69, 133)"
        },
        {
          "hex": "#7442C8",
          "name": "Purple Heart",
          "rgb": "(116, 66, 200)"
        },
        {
          "hex": "#9D81BA",
          "name": "Purple Mountain's Majesty",
          "rgb": "(157, 129, 186)"
        },
        {
          "hex": "#FE4EDA",
          "name": "Purple Pizzazz",
          "rgb": "(254, 78, 218)"
        },
        {
          "hex": "#FF496C",
          "name": "Radical Red",
          "rgb": "(255, 73, 108)"
        },
        {
          "hex": "#D68A59",
          "name": "Raw Sienna",
          "rgb": "(214, 138, 89)"
        },
        {
          "hex": "#714B23",
          "name": "Raw Umber",
          "rgb": "(113, 75, 35)"
        },
        {
          "hex": "#FF48D0",
          "name": "Razzle Dazzle Rose",
          "rgb": "(255, 72, 208)"
        },
        {
          "hex": "#E3256B",
          "name": "Razzmatazz",
          "rgb": "(227, 37, 107)"
        },
        {
          "hex": "#EE204D",
          "name": "Red",
          "rgb": "(238,32 ,77 )"
        },
        {
          "hex": "#FF5349",
          "name": "Red Orange",
          "rgb": "(255, 83, 73)"
        },
        {
          "hex": "#C0448F",
          "name": "Red Violet",
          "rgb": "(192, 68, 143)"
        },
        {
          "hex": "#1FCECB",
          "name": "Robin's Egg Blue",
          "rgb": "(31, 206, 203)"
        },
        {
          "hex": "#7851A9",
          "name": "Royal Purple",
          "rgb": "(120, 81, 169)"
        },
        {
          "hex": "#FF9BAA",
          "name": "Salmon",
          "rgb": "(255, 155, 170)"
        },
        {
          "hex": "#FC2847",
          "name": "Scarlet",
          "rgb": "(252, 40, 71)"
        },
        {
          "hex": "#76FF7A",
          "name": "Screamin' Green",
          "rgb": "(118, 255, 122)"
        },
        {
          "hex": "#9FE2BF",
          "name": "Sea Green",
          "rgb": "(159, 226, 191)"
        },
        {
          "hex": "#A5694F",
          "name": "Sepia",
          "rgb": "(165, 105, 79)"
        },
        {
          "hex": "#8A795D",
          "name": "Shadow",
          "rgb": "(138, 121, 93)"
        },
        {
          "hex": "#45CEA2",
          "name": "Shamrock",
          "rgb": "(69, 206, 162)"
        },
        {
          "hex": "#FB7EFD",
          "name": "Shocking Pink",
          "rgb": "(251, 126, 253)"
        },
        {
          "hex": "#CDC5C2",
          "name": "Silver",
          "rgb": "(205, 197, 194)"
        },
        {
          "hex": "#80DAEB",
          "name": "Sky Blue",
          "rgb": "(128, 218, 235)"
        },
        {
          "hex": "#ECEABE",
          "name": "Spring Green",
          "rgb": "(236, 234, 190)"
        },
        {
          "hex": "#FFCF48",
          "name": "Sunglow",
          "rgb": "(255, 207, 72)"
        },
        {
          "hex": "#FD5E53",
          "name": "Sunset Orange",
          "rgb": "(253, 94, 83)"
        },
        {
          "hex": "#FAA76C",
          "name": "Tan",
          "rgb": "(250, 167, 108)"
        },
        {
          "hex": "#18A7B5",
          "name": "Teal Blue",
          "rgb": "(24, 167, 181)"
        },
        {
          "hex": "#EBC7DF",
          "name": "Thistle",
          "rgb": "(235, 199, 223)"
        },
        {
          "hex": "#FC89AC",
          "name": "Tickle Me Pink",
          "rgb": "(252, 137, 172)"
        },
        {
          "hex": "#DBD7D2",
          "name": "Timberwolf",
          "rgb": "(219, 215, 210)"
        },
        {
          "hex": "#17806D",
          "name": "Tropical Rain Forest",
          "rgb": "(23, 128, 109)"
        },
        {
          "hex": "#DEAA88",
          "name": "Tumbleweed",
          "rgb": "(222, 170, 136)"
        },
        {
          "hex": "#77DDE7",
          "name": "Turquoise Blue",
          "rgb": "(119, 221, 231)"
        },
        {
          "hex": "#FFFF66",
          "name": "Unmellow Yellow",
          "rgb": "(255, 255, 102)"
        },
        {
          "hex": "#926EAE",
          "name": "Violet (Purple)",
          "rgb": "(146, 110, 174)"
        },
        {
          "hex": "#324AB2",
          "name": "Violet Blue",
          "rgb": "(50, 74, 178)"
        },
        {
          "hex": "#F75394",
          "name": "Violet Red",
          "rgb": "(247, 83, 148)"
        },
        {
          "hex": "#FFA089",
          "name": "Vivid Tangerine",
          "rgb": "(255, 160, 137)"
        },
        {
          "hex": "#8F509D",
          "name": "Vivid Violet",
          "rgb": "(143, 80, 157)"
        },
        {
          "hex": "#FFFFFF",
          "name": "White",
          "rgb": "(255, 255, 255)"
        },
        {
          "hex": "#A2ADD0",
          "name": "Wild Blue Yonder",
          "rgb": "(162, 173, 208)"
        },
        {
          "hex": "#FF43A4",
          "name": "Wild Strawberry",
          "rgb": "(255, 67, 164)"
        },
        {
          "hex": "#FC6C85",
          "name": "Wild Watermelon",
          "rgb": "(252, 108, 133)"
        },
        {
          "hex": "#CDA4DE",
          "name": "Wisteria",
          "rgb": "(205, 164, 222)"
        },
        {
          "hex": "#FCE883",
          "name": "Yellow",
          "rgb": "(252, 232, 131)"
        },
        {
          "hex": "#C5E384",
          "name": "Yellow Green",
          "rgb": "(197, 227, 132)"
        },
        {
          "hex": "#FFAE42",
          "name": "Yellow Orange",
          "rgb": "(255, 174, 66)"
        }
      ];
      module.exports = pal_crayola2;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/color-palette.js
  var require_color_palette = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/color-palette.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Color_Grid = require_color_grid();
      var { v_subtract: v_subtract2 } = jsgui2;
      var Control2 = jsgui2.Control;
      var {
        field,
        prop
      } = require_oext();
      var pal_crayola2 = require_arr_colors();
      var Color_Palette = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "color_palette";
          super(spec);
          this.add_class("color-palette");
          prop(this, "palette", spec.palette || pal_crayola2);
          prop(this, "grid_size", spec.grid_size || [12, 12]);
          if (!spec.abstract && !spec.el) {
            this.compose_color_grid();
          }
          this.on("resize", (e_resize) => {
          });
        }
        activate() {
          if (!this.activate.__active) {
            super.activate();
            const attach_on_change_named_property_handler = (obj2, property_name, fn_handler) => {
              obj2.on("change", (e) => {
                if (property_name === e.name) {
                  fn_handler(e);
                }
              });
            };
            attach_on_change_named_property_handler(this, "selected", (e) => {
              const selected_ctrl = e.value;
              if (selected_ctrl) {
                let color = selected_ctrl._color;
                this.raise("choose-color", {
                  value: color
                });
              }
            });
            const old_make_grid_cells_selectable = () => {
              this.grid.each_cell((cell) => {
              });
            };
          }
        }
        compose_color_grid() {
          console.log("compose_color_grid");
          var padding = 6;
          const fg_bg_color_grid = new Color_Grid({
            "context": this.context,
            "grid_size": [2, 1],
            "size": [80, 40]
          });
          this.add(fg_bg_color_grid);
          const color_grid_pxsize = v_subtract2(this.size, [0, 46]);
          const color_grid = this.grid = new Color_Grid({
            "context": this.context,
            "grid_size": this.grid_size,
            "palette": this.palette,
            "size": color_grid_pxsize,
            "cell_selection": "single"
          });
          this.add(color_grid);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.color_grid = color_grid;
          this._ctrl_fields.fg_bg_color_grid = fg_bg_color_grid;
        }
      };
      if (__require.main === module) {
        console.log("pal_crayola.length", pal_crayola2.length);
      } else {
      }
      module.exports = Color_Palette;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/checkbox.js
  var require_checkbox = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/checkbox.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var group = jsgui2.group;
      var Checkbox = class extends Control2 {
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "checkbox";
          this.add_class("checkbox");
          const context2 = this.context;
          if (!spec.abstract && !spec.el) {
            const name = this.name;
            const html_check = new Control2({
              "context": context2
            });
            html_check.dom.tagName = "input";
            html_check.dom.attributes.type = "checkbox";
            html_check.dom.attributes.name = name;
            html_check.dom.attributes.id = html_check._id();
            var html_label = new Control2({
              "context": context2
            });
            html_label.dom.tagName = "label";
            if (is_defined(spec.text)) {
              html_label.add(spec.text);
            } else {
              if (is_defined(spec.label?.text)) html_label.add(spec.label.text);
            }
            html_label.dom.attributes.for = html_check._id();
            this.add(html_check);
            this.add(html_label);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.check = html_check;
            this._ctrl_fields.label = html_label;
            this._fields = this._fields || {};
            if (is_defined(this.value)) this._fields.value = this.value;
          }
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            super.activate();
            var html_check = this.check;
            var el_checkbox = html_check.dom.el;
            var label = this.label;
            html_check.on("change", (e_change) => {
              console.log("el_radio.checked", el_radio.checked);
              this.raise("change", {
                name: "checked",
                value: el_checkbox.checked
              });
            });
          }
        }
      };
      Checkbox.css = `
.checkbox input + label {
    margin-left: 6px;
}
`;
      module.exports = Checkbox;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/combo-box.js
  var require_combo_box = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/combo-box.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Control2 = jsgui2.Control;
      var Combo_Box = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "combo_box";
          super(spec);
        }
      };
      module.exports = Combo_Box;
    }
  });

  // node_modules/jsgui3-html/control_mixins/coverable.js
  var require_coverable = __commonJS({
    "node_modules/jsgui3-html/control_mixins/coverable.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { prop, field, Control: Control2 } = jsgui2;
      var coverable = (ctrl2, opts) => {
        let select_toggle = false;
        let select_multi = false;
        if (!opts) {
        }
        if (opts) {
        }
        let ctrl_cover;
        ctrl2.cover = (content) => {
          ctrl_cover = new Control2({
            context: ctrl2.context,
            class: "cover"
          });
          let ctrl_cover_bg = new Control2({
            context: ctrl2.context,
            class: "background"
          });
          let ctrl_cover_fg = new Control2({
            context: ctrl2.context,
            class: "foreground"
          });
          content.remove();
          ctrl_cover.add(ctrl_cover_bg);
          ctrl_cover.add(ctrl_cover_fg);
          ctrl_cover_fg.add(content);
          ctrl2.add(ctrl_cover);
          return ctrl_cover;
        };
        ctrl2.uncover = () => {
          ctrl_cover.remove();
          ctrl_cover = null;
        };
        field(ctrl2, "covered");
      };
      module.exports = coverable;
    }
  });

  // node_modules/jsgui3-html/control_mixins/typed_data/date.js
  var require_date = __commonJS({
    "node_modules/jsgui3-html/control_mixins/typed_data/date.js"(exports, module) {
      var lang = require_lang();
      var is_defined = lang.is_defined;
      var date = (ctrl2, spec) => {
        let _date, _year, _month, _day;
        let constructor = () => {
          Object.defineProperty(ctrl2, `date`, {
            get() {
              return _date;
            },
            set(value2) {
              let old = _date;
              _date = value2;
              if (typeof document === "undefined") {
                ctrl2._fields = ctrl2._fields || {};
                ctrl2._fields["date"] = value2;
              }
              ctrl2.raise("change", {
                "name": "date",
                "old": old,
                //'new': _disabled,
                "value": _date
              });
            },
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(ctrl2, `year`, {
            get() {
              return _year;
            },
            set(value2) {
              let old = _year;
              _year = value2;
              if (typeof document === "undefined") {
                ctrl2._fields = ctrl2._fields || {};
                ctrl2._fields["year"] = value2;
              }
              ctrl2.raise("change", {
                "name": "year",
                "old": old,
                //'new': _disabled,
                "value": _year
              });
            },
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(ctrl2, `month`, {
            get() {
              return _month;
            },
            set(value2) {
              let old = _month;
              _month = value2;
              if (typeof document === "undefined") {
                ctrl2._fields = ctrl2._fields || {};
                ctrl2._fields["month"] = value2;
              }
              ctrl2.raise("change", {
                "name": "month",
                "old": old,
                //'new': _disabled,
                "value": _month
              });
            },
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(ctrl2, `day`, {
            get() {
              return _day;
            },
            set(value2) {
              let old = _day;
              _day = value2;
              if (typeof document === "undefined") {
                ctrl2._fields = ctrl2._fields || {};
                ctrl2._fields["day"] = value2;
              }
              ctrl2.raise("change", {
                "name": "day",
                "old": old,
                //'new': _disabled,
                "value": _day
              });
            },
            enumerable: true,
            configurable: false
          });
          if (is_defined(spec.year) && is_defined(spec.month)) {
            ctrl2.month = spec.month;
            ctrl2.year = spec.year;
          } else {
            let now = /* @__PURE__ */ new Date();
            ctrl2.month = now.getMonth();
            ctrl2.year = now.getFullYear();
          }
          Object.assign(ctrl2, {
            next_month: () => {
              if (ctrl2.month === 11) {
                ctrl2.month = 0;
                ctrl2.year = ctrl2.year + 1;
              } else {
                ctrl2.month = ctrl2.month + 1;
              }
              ctrl2.refresh_month_view();
            },
            previous_month: () => {
              if (ctrl2.month === 0) {
                ctrl2.month = 11;
                ctrl2.year = ctrl2.year - 1;
              } else {
                ctrl2.month = ctrl2.month - 1;
              }
              ctrl2.refresh_month_view();
            },
            next_year: () => {
              ctrl2.year = ctrl2.year + 1;
              ctrl2.refresh_month_view();
            },
            previous_year: () => {
              ctrl2.year = ctrl2.year - 1;
              ctrl2.refresh_month_view();
            }
          });
        };
        let activate = () => {
        };
        if (spec) {
          constructor();
        } else {
          activate();
        }
      };
      module.exports = date;
    }
  });

  // node_modules/jsgui3-html/control_mixins/display.js
  var require_display = __commonJS({
    "node_modules/jsgui3-html/control_mixins/display.js"(exports, module) {
      var lang = require_lang();
      var { Evented_Class, tof, each } = lang;
      var Ctrl_Display_Mode_Category = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          let name;
          if (spec.name) {
            name = spec.name;
          } else {
            throw "Ctrl_Display_Mode_Category requires a name property";
          }
        }
      };
      var Ctrl_Display_Modes_Categories = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          const map_categories = {}, arr_categories = [];
          if (spec.names) {
            if (tof(spec.names) === "array") {
              each(spec.names, (name) => {
                const cat = new Ctrl_Display_Mode_Category({ name });
                map_categories[name] = cat;
                arr_categories.push(cat);
              });
            } else {
              throw "NYI";
            }
          }
        }
      };
      var Ctrl_Display_Modes = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          const arr_category_names = ["size", "layout", "colors", "interactivity"];
          const categories = new Ctrl_Display_Modes_Categories({ names: arr_category_names });
          Object.defineProperty(ctrl, "categories", {
            get() {
              return categories;
            },
            set(value2) {
              throw "NYI";
            }
          });
        }
      };
      var Ctrl_Display = class extends Evented_Class {
        // so it can have on change events.
        constructor(spec = {}) {
          super(spec);
          let ctrl2;
          if (spec.ctrl) ctrl2 = spec.ctrl;
          const modes = new Ctrl_Display_Modes({});
          Object.defineProperty(this, "modes", {
            get() {
              return modes;
            },
            set(value2) {
              throw "NYI";
            }
          });
        }
      };
      var display = (ctrl2, opts = {}) => {
        if (ctrl2.display) {
          throw "ctrl already has .display property";
        } else {
          const ctrl_display = new Ctrl_Display({
            ctrl: ctrl2
          });
          Object.defineProperty(ctrl2, "display", {
            get() {
              return ctrl_display;
            },
            set(value2) {
              throw "NYI";
            }
          });
        }
      };
      module.exports = display;
    }
  });

  // node_modules/jsgui3-html/control_mixins/display-modes.js
  var require_display_modes = __commonJS({
    "node_modules/jsgui3-html/control_mixins/display-modes.js"(exports, module) {
      var display_modes = (ctrl2, opts = {}) => {
      };
      module.exports = display_modes;
    }
  });

  // node_modules/jsgui3-html/control_mixins/fast-touch-click.js
  var require_fast_touch_click = __commonJS({
    "node_modules/jsgui3-html/control_mixins/fast-touch-click.js"(exports, module) {
      var fast_touch_click = (ctrl2) => {
        let has_moved_away = false;
        ctrl2.on("touchstart", (ets) => {
          ets.preventDefault();
        });
        ctrl2.on("touchend", (ete) => {
          if (!has_moved_away) {
            ctrl2.raise("click", ete);
          }
          has_moved_away = false;
        });
        ctrl2.on("touchmove", (etm) => {
          has_moved_away = true;
        });
      };
      module.exports = fast_touch_click;
    }
  });

  // node_modules/jsgui3-html/control_mixins/popup.js
  var require_popup = __commonJS({
    "node_modules/jsgui3-html/control_mixins/popup.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var context_ensure_popup_layer = (context2) => {
        let ctrl_document = context2.ctrl_document;
        let body = context2.map_controls["body_0"];
        if (!body.popup_layer) {
          body.popup_layer = new Control2({
            "context": context2,
            "__type_name": "popup_layer"
          });
          body.popup_layer.add_class("popup-layer");
          body.add(body.popup_layer);
        }
        return body.popup_layer;
      };
      var popup = (ctrl2) => {
        let context2 = ctrl2.context;
        ctrl2.popup = () => {
          let popup_layer = context_ensure_popup_layer(context2);
          let parent, placeholder;
          setTimeout(() => {
            placeholder = new Control2({
              "context": context2,
              "__type_name": "placeholder"
            });
            parent = ctrl2.parent;
            let absolute_container = new Control2({
              "context": context2
            });
            popup_layer.add(absolute_container);
            absolute_container.add(placeholder);
            parent.content.swap(ctrl2, placeholder);
            let bcr = placeholder.dom.el.getBoundingClientRect();
            absolute_container.dom.attrs.style.position = "absolute";
            absolute_container.dom.attrs.style.left = bcr.left + "px";
            absolute_container.dom.attrs.style.top = bcr.top + "px";
            ctrl2.remove_class("hidden");
          }, 0);
          const replace = () => {
            ctrl2.add_class("hidden");
            parent.content.swap(placeholder, ctrl2);
          };
          return replace;
        };
      };
      module.exports = popup;
    }
  });

  // node_modules/jsgui3-html/control_mixins/drag_like_events.js
  var require_drag_like_events = __commonJS({
    "node_modules/jsgui3-html/control_mixins/drag_like_events.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var {
        each,
        tof
      } = require_lang();
      var drag_like_events = (ctrl2, opts = {}) => {
        let {
          //condition
        } = opts;
        let start_action;
        if (!ctrl2.__using_drag_like_events) {
          start_action = start_action || ["touchstart", "mousedown"];
          if (tof(start_action) === "string") start_action = [start_action];
          let pos_md, pos_mm, pos_mu, pos_md_within_ctrl;
          let ctrl_body = ctrl2.context.body();
          let dragging = false;
          let drag_offset_distance = opts.start_distance || 6;
          let movement_offset;
          let item_start_pos;
          let half_item_width, item_width, initial_bcr;
          const el = ctrl2.dom.el;
          let initial_ctrl_translate;
          const begin_drag = (pos) => {
            initial_bcr = ctrl2.bcr();
            dragging = true;
            const old_bounds_handling_code = () => {
              if (bounds) {
                if (typeof bounds.bcr === "function") {
                  initial_bounds_bcr = bounds.bcr();
                  initial_bcr_offset_from_bounds = [
                    [initial_bcr[0][0] - initial_bounds_bcr[0][0], initial_bcr[0][1] - initial_bounds_bcr[0][1]],
                    [initial_bcr[1][0] - initial_bounds_bcr[1][0], initial_bcr[1][1] - initial_bounds_bcr[1][1]],
                    [initial_bcr[2][0] - initial_bounds_bcr[2][0], initial_bcr[2][1] - initial_bounds_bcr[2][1]]
                  ];
                }
              }
            };
            ctrl2.raise("drag-like-action-start");
          };
          const move_drag = (pos) => {
            ctrl2.raise("drag-like-action-move", {
              offset: movement_offset
            });
          };
          const body_mm = (e_mm) => {
            let touch_count = 0;
            if (e_mm.touches) touch_count = e_mm.touches.length;
            if (e_mm.buttons === 0 && touch_count === 0) {
              body_mu();
            } else {
              if (e_mm.touches) {
                pos_mm = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
              } else {
                pos_mm = [e_mm.pageX, e_mm.pageY];
              }
              if (touch_count === 0 || touch_count === 1) {
                if (e_mm.pageX || e_mm.touches) {
                  let pos_mm2;
                  if (e_mm.touches) {
                    pos_mm2 = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
                  } else {
                    pos_mm2 = [e_mm.pageX, e_mm.pageY];
                  }
                  if (pos_mm2[0] !== void 0 && pos_mm2[1] !== void 0) {
                    movement_offset = [pos_mm2[0] - pos_md[0], pos_mm2[1] - pos_md[1]];
                    if (!dragging) {
                      let abs_offset = [Math.abs(movement_offset[0]), Math.abs(movement_offset[1])];
                      let abs_offset_dist = Math.sqrt(Math.pow(abs_offset[0], 2) + Math.pow(abs_offset[1], 2));
                      if (abs_offset_dist >= drag_offset_distance) {
                        begin_drag(pos_mm2);
                      }
                    } else {
                      move_drag(pos_mm2);
                    }
                  }
                }
              }
            }
          };
          const end_drag = (e_mu) => {
            ctrl_body.off("mousemove", body_mm);
            ctrl_body.off("mouseup", body_mu);
            ctrl_body.off("touchmove", body_mm);
            ctrl_body.off("touchend", body_mu);
            if (dragging) {
              dragging = false;
              ctrl2.raise("drag-like-action-end", {
                offset: movement_offset
              });
            }
          };
          const body_mu = (e_mu) => {
            end_drag(e_mu);
          };
          const h_md = (e_md) => {
            if (e_md.pageX) {
              pos_md_within_ctrl = [e_md.offsetX, e_md.offsetX];
            } else {
              pos_md_within_ctrl = [0, 0];
            }
            dragging = false;
            pos_md = [e_md.pageX || e_md.touches[0].pageX, e_md.pageY || e_md.touches[0].pageY];
            ctrl_body.on("mousemove", body_mm);
            ctrl_body.on("mouseup", body_mu);
            ctrl_body.on("touchmove", body_mm);
            ctrl_body.on("touchend", body_mu);
          };
          field(ctrl2, "drag_like_events");
          ctrl2.on("change", (e_change) => {
            let n = e_change.name, value2 = e_change.value;
            if (n === "drag_like_events") {
              if (value2 === true) {
                if (typeof document === "undefined") {
                } else {
                  let apply_start_handlers = (start_action2) => {
                    if (!ctrl2.has_drag_like_md_handler) {
                      ctrl2.has_drag_like_md_handler = true;
                      each(start_action2, (sa) => {
                        ctrl2.on(sa, h_md);
                      });
                    }
                  };
                  ctrl2.once_active(() => {
                    apply_start_handlers(start_action);
                  });
                }
              } else {
                if (typeof document === "undefined") {
                } else {
                  ((start_action2) => {
                    each(start_action2, (sa) => {
                      ctrl2.off(sa, h_md);
                    });
                  })(start_action);
                  ctrl2.has_drag_md_handler = false;
                }
              }
            }
          });
          ctrl2.__using_drag_like_events = true;
        }
      };
      module.exports = drag_like_events;
    }
  });

  // node_modules/jsgui3-html/control_mixins/resizable.js
  var require_resizable = __commonJS({
    "node_modules/jsgui3-html/control_mixins/resizable.js"(exports, module) {
      var Control2 = require_control();
      var drag_like_events = require_drag_like_events();
      var { tof } = require_lang();
      var resizable = (ctrl2, options = { resize_mode: "br_handle" }) => {
        const extra_margin = options.extra_margin !== void 0 ? options.extra_margin : 2;
        const { bounds: bounds2 } = options;
        const extent_bounds = options.extent_bounds || options.extent;
        const t_extent_bounds = tof(extent_bounds);
        let min_bound, max_bound;
        if (bounds2) {
          [min_bound, max_bound] = bounds2;
        }
        const { resize_mode } = options;
        const start_action = ["touchstart", "mousedown"];
        let initial_size, initial_measured_pos_within_ctrl_bounds;
        if (resize_mode === "br_handle") {
          if (ctrl2.ctrl_relative) {
            if (ctrl2.ctrl_br_resize_handle) {
              console.log("ctrl.ctrl_br_resize_handle already detected");
            } else {
              const ctrl_br_resize_handle = new Control2({
                context: ctrl2.context
              });
              ctrl_br_resize_handle.add_class("bottom-right");
              ctrl_br_resize_handle.add_class("resize-handle");
              ctrl_br_resize_handle.add("\u25E2");
              ctrl2.ctrl_relative.add(ctrl_br_resize_handle);
              ctrl_br_resize_handle.pre_activate();
              ctrl_br_resize_handle.activate();
              ctrl2.ctrl_br_resize_handle = ctrl_br_resize_handle;
              drag_like_events(ctrl_br_resize_handle);
              ctrl_br_resize_handle.drag_like_events = true;
              let css_transition;
              ctrl_br_resize_handle.on("drag-like-action-start", () => {
                initial_size = ctrl2.bcr()[2];
                if (t_extent_bounds === "control") {
                  const ctrl_bcr = ctrl2.bcr();
                  const extent_bounds_ctrl_bcr = extent_bounds.bcr();
                  const pos_offset = [ctrl_bcr[0][0] - extent_bounds_ctrl_bcr[0][0], ctrl_bcr[0][1] - extent_bounds_ctrl_bcr[0][1]];
                  const extent_bounds_ctrl_measured_size = extent_bounds_ctrl_bcr[2];
                  const bounded_max_size = [extent_bounds_ctrl_measured_size[0] - pos_offset[0] - extra_margin, extent_bounds_ctrl_measured_size[1] - pos_offset[1] - extra_margin];
                  max_bound = bounded_max_size;
                }
                ctrl2.add_class("no-transitions");
                ctrl_br_resize_handle.add_class("resizing");
              });
              ctrl_br_resize_handle.on("drag-like-action-move", (e_drag_like_action_move) => {
                const { offset: offset2 } = e_drag_like_action_move;
                const new_size = [initial_size[0] + offset2[0], initial_size[1] + offset2[1]];
                if (min_bound) {
                  if (new_size[0] < min_bound[0]) new_size[0] = min_bound[0];
                  if (new_size[1] < min_bound[1]) new_size[1] = min_bound[1];
                }
                if (max_bound) {
                  if (new_size[0] > max_bound[0]) new_size[0] = max_bound[0];
                  if (new_size[1] > max_bound[1]) new_size[1] = max_bound[1];
                }
                ctrl2.size = new_size;
              });
              ctrl_br_resize_handle.on("drag-like-action-end", (e_drag_like_action_end) => {
                ctrl_br_resize_handle.remove_class("resizing");
                ctrl2.remove_class("no-transitions");
              });
            }
          } else {
            console.trace();
            throw "NYI";
          }
        }
      };
      module.exports = resizable;
    }
  });

  // node_modules/jsgui3-html/control_mixins/deletable.js
  var require_deletable = __commonJS({
    "node_modules/jsgui3-html/control_mixins/deletable.js"(exports, module) {
      var deletable = (ctrl2) => {
        ctrl2.delete = () => {
          ctrl2.remove();
          ctrl2.raise("delete");
        };
      };
      module.exports = deletable;
    }
  });

  // node_modules/jsgui3-html/control_mixins/selected-deletable.js
  var require_selected_deletable = __commonJS({
    "node_modules/jsgui3-html/control_mixins/selected-deletable.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var deletable = require_deletable();
      var selected_deletable = (ctrl2) => {
        deletable(ctrl2);
        let old_selected_deletable = ctrl2.selected_deletable;
        let click_handler = (e) => {
        };
        let press_handler = (event) => {
          const keyName = event.key;
          if (keyName === "Delete") {
            ctrl2.delete();
          }
        };
        ctrl2.on("change", (e_change) => {
          let {
            name,
            value: value2
          } = e_change;
          if (name === "selected") {
            ctrl2.once_active(() => {
              if (value2) {
                document.addEventListener("keydown", press_handler, false);
              } else {
                document.removeEventListener("keydown", press_handler, false);
              }
            });
          }
          ;
          return true;
        });
        if (true) {
          if (old_selected_deletable !== void 0) {
            ctrl2.selected_deletable = old_selected_deletable;
          }
        }
      };
      module.exports = selected_deletable;
    }
  });

  // node_modules/jsgui3-html/control_mixins/selected-resizable.js
  var require_selected_resizable = __commonJS({
    "node_modules/jsgui3-html/control_mixins/selected-resizable.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var selected_resizable = (ctrl2, ctrl_handle) => {
        let old_selected_resizable = ctrl2.old_selected_resizable;
        let click_handler = (e) => {
        };
        let press_handler = (event) => {
          const keyName = event.key;
          console.log("event", event);
          if (keyName === "Control") {
            return;
          }
          if (event.ctrlKey) {
          } else {
          }
        };
        ctrl2.on("change", (e_change) => {
          let {
            name,
            value: value2
          } = e_change;
          if (name === "selected") {
            ctrl2.once_active(() => {
              if (value2) {
                document.addEventListener("keypress", press_handler, false);
              } else {
                document.removeEventListener("keypress", press_handler, false);
              }
            });
          }
          ;
          return true;
        });
        if (true) {
          if (old_selectable !== void 0) {
            ctrl2.selected_deletable = old_sselected_deletableelectable;
          }
        }
      };
      module.exports = selected_resizable;
    }
  });

  // node_modules/jsgui3-html/control_mixins/selection-box-host.js
  var require_selection_box_host = __commonJS({
    "node_modules/jsgui3-html/control_mixins/selection-box-host.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var coords_to_lt_wh = (coords_pair) => {
        let l2, t, r, b, w, h, min = Math.min, max = Math.max;
        l2 = min(coords_pair[0][0], coords_pair[1][0]);
        r = max(coords_pair[0][0], coords_pair[1][0]);
        t = min(coords_pair[0][1], coords_pair[1][1]);
        b = max(coords_pair[0][1], coords_pair[1][1]);
        w = r - l2;
        h = b - t;
        return [
          [l2, t],
          [w, h]
        ];
      };
      var selection_box_host = (ctrl2) => {
        let click_handler = (e) => {
          if (ctrl2.selectable && !ctrl2.selection_scope) {
            var ctrl_key = e.ctrlKey;
            var meta_key = e.metaKey;
            if (ctrl_key || meta_key) {
              ctrl2.action_select_toggle();
            } else {
              ctrl2.action_select_only();
            }
          }
        };
        field(ctrl2, "selection_box_host");
        ctrl2.selection_box_host = true;
        let old_activate = ctrl2.activate;
        ctrl2.activate = function(spec) {
          if (old_activate) {
            old_activate.call(this, spec);
          }
          let selection_box;
          let md_pos, mm_pos, md_offset_within_ctrl, mm_offset_within_ctrl;
          let isf;
          let nsb = this.new_selection_box = (pos) => {
            this.add(selection_box = new Control2({
              context: this.context,
              css: {
                position: "absolute"
              },
              "class": "selection-box",
              pos
            }));
            selection_box.activate();
            prop(selection_box, "coords", (e_change) => {
              let lt_wh = coords_to_lt_wh(e_change[0]);
              [selection_box.pos, selection_box.size] = lt_wh;
            });
            return selection_box;
          };
          ctrl2.drag_events((md) => {
            console.log("md", md);
            let main_boxes = ctrl2.$(".main-box");
            let do_begin_selection_box = true;
            if (md.target.tagName.toLowerCase() === "span") {
              do_begin_selection_box = false;
            }
            if (do_begin_selection_box) {
              md_pos = md.pos;
              ctrl2.find_selection_scope().deselect_all();
              let ctrl_pos = ctrl2.bcr()[0];
              md_offset_within_ctrl = v_subtract(md.pos, ctrl_pos);
              md_offset_within_ctrl[1] -= window.scrollY;
              md_pos[1] -= window.scrollY;
              isf = new jsgui2.Intersection_Finder({
                controls: main_boxes
              });
              isf.on("change", (e_change) => {
                if (e_change.name === "intersections") {
                  let [intersecting, newly_intersecting, previously_intersecting] = e_change.value;
                  each(newly_intersecting, (ctrl3) => {
                    let sel = ctrl3.closest((cmatch) => {
                      return cmatch.selectable === true;
                    });
                    if (sel) sel.selected = true;
                  });
                  each(previously_intersecting, (ctrl3) => {
                    let sel = ctrl3.closest((match) => match.selectable === true);
                    if (sel) sel.selected = false;
                  });
                }
              });
              let selection_box2 = nsb(md.pos);
              if (selection_box2) {
              }
            } else {
              return false;
            }
          }, (mm) => {
            if (selection_box) {
              mm_pos = mm.pos;
              mm_pos[1] -= window.scrollY;
              let ctrl_pos = ctrl2.bcr()[0];
              mm_offset_within_ctrl = v_subtract(mm.pos, ctrl_pos);
              selection_box.coords = [md_offset_within_ctrl, mm_offset_within_ctrl];
              isf.coords = [md_pos, mm_pos];
            }
          }, (mu) => {
            selection_box.remove();
            isf = null;
          });
        };
      };
      module.exports = selection_box_host;
    }
  });

  // node_modules/jsgui3-html/control_mixins/press-events.js
  var require_press_events = __commonJS({
    "node_modules/jsgui3-html/control_mixins/press-events.js"(exports, module) {
      var { get_truth_map_from_arr, each } = require_lang();
      var press_events = (ctrl2, options = {}) => {
        ctrl2.__mx = ctrl2.__mx || {};
        ctrl2.__mx.press_events = true;
        const press_event_names = ["press-start", "press-move", "press-end", "press-hold", "press-drag-start"];
        const map_press_event_names = get_truth_map_from_arr(press_event_names);
        const setup_isomorphic = () => {
          const old_silent = ctrl2.view.data.model.mixins.silent;
          ctrl2.view.data.model.mixins.silent = true;
          ctrl2.view.data.model.mixins.push({
            name: "press-events"
          });
          ctrl2.view.data.model.mixins.silent = old_silent;
        };
        setup_isomorphic();
        if (ctrl2.dom.el) {
          ctrl2.once_active(() => {
            const body = ctrl2.context.body();
            const { css } = options;
            let handling_is_setup = false;
            let pos_start;
            let movement_offsets;
            let pos_move;
            let movement_offset;
            let timeout_hold;
            let drag_started = false;
            let el;
            const hold_movement_threshold = 4;
            let move_mag;
            const ms_short = 500;
            const ts = (e) => {
              if (e.touches.length === 1) {
                e.pos = [e.pageX = e.touches[0].pageX, e.pageY = e.touches[0].pageY];
                el = e.el = e.touches[0].target;
                return ps(e);
              }
            };
            const md = (e) => {
              let path = e.path || e.composedPath();
              el = e.el = path[0];
              return ps(e);
            };
            const mm = (e) => {
              e.pos = [e.pageX = e.pageX, e.pageY = e.pageY];
              return pm(e);
            };
            const tm = (e) => {
              e.pos = [e.pageX = e.touches[0].pageX, e.pageY = e.touches[0].pageY];
              return pm(e);
            };
            const pm = (e) => {
              pos_move = e.pos;
              e.movement_offset = movement_offset = [e.pos[0] - pos_start[0], e.pos[1] - pos_start[1]];
              movement_offsets.push(movement_offset);
              e.movement_offsets = movement_offsets;
              e.move_mag = move_mag = Math.sqrt(Math.pow(movement_offset[0], 2) + Math.pow(movement_offset[1], 2));
              e.ctrl = ctrl2;
              ctrl2.raise("press-move", e);
              if (move_mag >= 4 && !drag_started) {
                ctrl2.raise("press-drag-start", e);
                drag_started = true;
              }
            };
            const pe = (e) => {
              e.movement_offsets = movement_offsets;
              e.move_mag = move_mag;
              e.ctrl = ctrl2;
              e.el = el;
              if (timeout_hold) clearTimeout(timeout_hold);
              body.off({
                touchend: te,
                touchmove: tm,
                mouseup: mu,
                mousemove: mm
              });
              ctrl2.raise("press-end", e);
            };
            const mu = (e) => {
              body.off({
                mouseup: mu,
                mousemove: mm
              });
              e.pos = [e.pageX, e.pageY];
              return pe(e);
            };
            const te = (e) => {
              body.off({
                touchend: te,
                touchmove: tm
              });
              e.pos = pos_move || pos_start;
              return pe(e);
            };
            const ps = (e) => {
              movement_offsets = [];
              move_mag = 0;
              drag_started = false;
              let is_touch_event = !!e.touches;
              e.is_touch_event = is_touch_event;
              pos_start = [e.pageX, e.pageY];
              if (is_touch_event) {
                body.on({
                  touchend: te,
                  touchmove: tm
                });
              } else {
                body.on({
                  mouseup: mu,
                  mousemove: mm
                });
              }
              e.ctrl = ctrl2;
              ctrl2.raise("press-start", e);
              timeout_hold = setTimeout(() => {
                if (move_mag <= hold_movement_threshold) {
                  ctrl2.raise("press-hold", e);
                }
              }, ms_short);
            };
            const setup = () => {
              ctrl2.on({
                "touchstart": ts,
                "mousedown": md
              });
              handling_is_setup = true;
            };
            const unsetup = () => {
              ctrl2.off({
                "touchstart": ts,
                "mousedown": md
              });
              handling_is_setup = false;
            };
            const outer_setup = () => {
              ctrl2.event_events = true;
              const relying_on_recognising_adding_of_event_listeners = () => {
                ctrl2.on("add-event-listener", (e) => {
                  const { name } = e;
                  if (map_press_event_names[name]) {
                    if (!handling_is_setup) {
                      setup();
                    }
                  }
                });
                ctrl2.on("remove-event-listener", (e) => {
                  const { name } = e;
                  if (map_press_event_names[name]) {
                    console.log("ctrl remove-event-listener", name);
                    const bnec = ctrl2.bound_named_event_counts;
                    console.log("bound_named_event_counts bnec", bnec);
                    console.log("name", name);
                    let count_bound_press_events = 0;
                    each(bnec, (count, event_name) => {
                      if (map_press_event_names[event_name]) count_bound_press_events += count;
                    });
                    if (count_bound_press_events === 0) {
                      unsetup();
                    }
                  }
                });
              };
              const just_do_it = () => {
                if (!handling_is_setup) {
                  setup();
                }
              };
              just_do_it();
            };
            outer_setup();
          });
        }
        if (typeof window !== "undefined" && ctrl2.dom && ctrl2.dom.el) {
          ctrl2.on("press-start", (e_ps) => {
            const outsideHandler = (e_pe) => {
              if (!ctrl2.dom.el.contains(e_pe.target)) {
                ctrl2.raise("press-outside", e_pe);
              }
              window.removeEventListener("mouseup", outsideHandler);
              window.removeEventListener("touchend", outsideHandler);
            };
            window.addEventListener("mouseup", outsideHandler);
            window.addEventListener("touchend", outsideHandler);
          });
        }
      };
      module.exports = press_events;
    }
  });

  // node_modules/jsgui3-html/control_mixins/press-outside.js
  var require_press_outside = __commonJS({
    "node_modules/jsgui3-html/control_mixins/press-outside.js"(exports, module) {
      var press_events = require_press_events();
      var press_outside = (ctrl2, options = {}) => {
        let once = options.one || options.once || false;
        console.log("press_outside");
        ctrl2.__mx = ctrl2.__mx || {};
        if (!ctrl2.__mx || !ctrl2.__mx.press_events) {
          press_events(ctrl2);
        }
        ctrl2.__mx.press_outside = true;
        const body = ctrl2.context.body();
        if (!body.__mx || !body.__mx.press_events) {
          press_events(body);
        }
        ctrl2.event_events = true;
        const body_press = (e) => {
          console.log("press_outside body press e", e);
          const { ctrl_target } = e;
          const match = ctrl_target === ctrl2 || ctrl_target.ancestor(ctrl2);
          if (!match) {
            ctrl2.raise("press-outside", e);
          }
        };
        const setup_body_press = () => {
          body.on("press-end", body_press);
        };
        const remove_body_press = () => {
          body.off("press-end", body_press);
        };
        ctrl2.on("add-event-listener", (e) => {
          const { name } = e;
          if (name === "press-outside") {
            setup_body_press();
          }
        });
        ctrl2.on("remove-event-listener", (e) => {
          const { name } = e;
          if (name === "press-outside") {
            remove_body_press();
          }
        });
      };
      module.exports = press_outside;
    }
  });

  // node_modules/jsgui3-html/control_mixins/pressed-state.js
  var require_pressed_state = __commonJS({
    "node_modules/jsgui3-html/control_mixins/pressed-state.js"(exports, module) {
      var {
        field,
        prop
      } = require_oext();
      var press_events = require_press_events();
      var pressed_state = (ctrl2, options = {}) => {
        ctrl2.__mx = ctrl2.__mx || {};
        if (!ctrl2.__mx || !ctrl2.__mx.press_events) {
          press_events(ctrl2);
        }
        ctrl2.__mx.pressed_state = true;
        const setup_isomorphic = () => {
          const old_silent = ctrl2.view.data.model.mixins.silent;
          ctrl2.view.data.model.mixins.silent = true;
          ctrl2.view.data.model.mixins.push({
            name: "pressed-state"
          });
          ctrl2.view.data.model.mixins.silent = old_silent;
        };
        setup_isomorphic();
        field(ctrl2.view.data.model, "state");
        ctrl2.on("press-start", () => {
          ctrl2.view.data.model.state = "pressed";
        });
        ctrl2.on("press-end", () => {
          ctrl2.view.data.model.state = "not-pressed";
        });
        ctrl2.view.data.model.on("change", (e) => {
          const { name, value: value2 } = e;
          if (name === "state") {
            if (value2 === "pressed") ctrl2.add_class("pressed");
            else ctrl2.remove_class("pressed");
          }
        });
      };
      module.exports = pressed_state;
    }
  });

  // node_modules/jsgui3-html/control_mixins/mx.js
  var require_mx = __commonJS({
    "node_modules/jsgui3-html/control_mixins/mx.js"(exports, module) {
      var mx = {
        coverable: require_coverable(),
        date: require_date(),
        display: require_display(),
        display_modes: require_display_modes(),
        fast_touch_click: require_fast_touch_click(),
        model_data_view_compositional_representation: require_model_data_view_compositional_representation(),
        popup: require_popup(),
        resizable: require_resizable(),
        selectable: require_selectable(),
        selected_deletable: require_selected_deletable(),
        selected_resizable: require_selected_resizable(),
        selection_box_host: require_selection_box_host(),
        dragable: require_dragable(),
        drag_like_events: require_drag_like_events(),
        press_events: require_press_events(),
        press_outside: require_press_outside(),
        pressed_state: require_pressed_state()
      };
      module.exports = mx;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Dropdown_Menu.js
  var require_Dropdown_Menu = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Dropdown_Menu.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var { is_array, is_arr_of_strs } = jsgui2;
      var Control2 = jsgui2.Control;
      var {
        field,
        prop
      } = require_oext();
      var { press_events, pressed_state, selectable } = require_mx();
      var Dropdown_Menu = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "dropdown_menu";
          super(spec);
          this.add_class("dropdown-menu");
          field(this.view.data.model, "state");
          field(this.view.data.model, "options");
          this.view.data.model.on("change", (e_change) => {
            const { name, value: value2 } = e_change;
            if (name === "state") {
              if (value2 === "open") {
                this.remove_class("closed");
                this.add_class("open");
              } else if (value2 === "closed") {
                this.remove_class("open");
                this.add_class("closed");
              }
            } else {
            }
          });
          this.view.data.model.state = "closed";
          if (spec.options) {
            this.view.data.model.options = spec.options;
          }
          if (!spec.abstract && !spec.el) {
            this.compose_dropdown_menu();
          }
        }
        compose_dropdown_menu() {
          const { context: context2 } = this;
          const ctrl_closed_top = new Control2({ context: context2 });
          ctrl_closed_top.add_class("closed-top");
          const ctrl_closed_top_item_itself = new Control2({ context: context2 });
          ctrl_closed_top_item_itself.add_class("item-itself");
          ctrl_closed_top.add(ctrl_closed_top_item_itself);
          const ctrl_dropdown_icon = new Control2({ context: context2 });
          ctrl_dropdown_icon.add_class("dropdown-icon");
          ctrl_dropdown_icon.add("\u25BC");
          ctrl_closed_top.add(ctrl_dropdown_icon);
          this.add(ctrl_closed_top);
          const ctrl_open_items = new Control2({ context: context2 });
          ctrl_open_items.add_class("open-items");
          this.add(ctrl_open_items);
          const dm_options = this.view.data.model.options;
          if (is_array(dm_options)) {
            if (is_arr_of_strs(dm_options)) {
              each(dm_options, (str_option) => {
                const ctrl_option = new Control2({
                  context: context2
                });
                ctrl_option.add_class("item");
                ctrl_option.add(str_option);
                ctrl_open_items.add(ctrl_option);
              });
            }
          }
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.ctrl_dropdown_icon = ctrl_dropdown_icon;
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const { ctrl_dropdown_icon } = this;
            pressed_state(ctrl_dropdown_icon);
            ctrl_dropdown_icon.on("click", (e_click) => {
              if (this.view.data.model.state === "closed") {
                this.view.data.model.state = "open";
              } else {
                this.view.data.model.state = "closed";
              }
            });
          }
        }
      };
      Dropdown_Menu.css = `
.dropdown-menu {
    height: 64px;
    width: 384px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
}

.dropdown-menu .closed-top {
    height: 56px;
    width: 376px;
    background-color: #EEEEEE;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
    display: flex;
    flex-direction: row;
}

.dropdown-menu .closed-top .item-itself {
    height: 53px;
    width: 320px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
}

.dropdown-menu .closed-top .dropdown-icon {
    height: 53px;
    width: 53px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    margin-left: 2px;
    font-size: 53px;
    line-height: 53px;
    color: #888888;
}

.dropdown-menu .closed-top .dropdown-icon.pressed {
    background-color: #F0F0F0;
}

.dropdown-menu .open-items {
    width: 376px;
    height: 414px;
    background-color: #EEEEEE;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
}

.dropdown-menu.closed .open-items {
    display: none;
}

.dropdown-menu .open-items .item {
    width: 373px;
    height: 64px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    text-indent: 12px;
    font-size: 52px;
    line-height: 56px;
}

.dropdown-menu .open-items .item:not(:first-child) {
    margin-top: 2px;
}



`;
      if (__require.main === module) {
        const ddm = new Dropdown_Menu();
        console.log(ddm.all_html_render());
      } else {
      }
      module.exports = Dropdown_Menu;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/Text_Input.js
  var require_Text_Input = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/Text_Input.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var { Control: Control2, Control_Data, Control_View, Data_Object, Data_Model, Data_Value: Data_Value2 } = jsgui2;
      var { prop, field } = require_oext();
      var Text_Input = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "text_input";
          spec.class = "text-input";
          super(spec);
          const { context: context2 } = this;
          if (spec.placeholder) this.placeholder = spec.placeholder;
          if (!spec.el) {
          }
          const view_data_model_change_handler = (e) => {
            const { name, value: value2, old } = e;
            if (name === "value") {
              if (this.dom.el) {
                this.dom.el.value = value2 + "";
              }
              this.data.model.value = value2;
            }
          };
          this.view.data.model.on("change", view_data_model_change_handler);
          this.view.data.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (name === "model") {
              if (old instanceof Data_Model) {
                old.off("change", view_data_model_change_handler);
              }
              value2.on("change", view_data_model_change_handler);
            }
          });
          const data_model_change_handler = (e) => {
            const { name, value: value2, old } = e;
            if (name === "value") {
              this.view.data.model.value = value2;
            }
          };
          this.data.model.on("change", data_model_change_handler);
          const setup_handle_data_model_itself_changing = () => {
            this.data.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "model") {
                if (old instanceof Data_Model) {
                  old.off("change", data_model_change_handler);
                }
                if (value2 instanceof Data_Model) {
                  value2.on("change", data_model_change_handler);
                }
              }
            });
          };
          setup_handle_data_model_itself_changing();
          if (this.data.model.value !== void 0) {
            this.view.data.model.value = this.data.model.value;
          }
          if (spec.value) {
            this.data.model.value = spec.value;
          }
          this.dom.tagName = "input";
          this.dom.attributes.type = "text";
        }
        get value() {
          return this.data.model.value;
        }
        set value(v) {
          this.data.model.value = v;
        }
        /*
            compose_text_input() {
        
                // More like the DOM settings rather than composition.
        
                
        
                // And it's placeholder text
                //   That's not part of the data model.
                //   Maybe it's the presentation data model? Presentation model?
        
        
        
                // ui.data.model perhaps....
                // ui.model perhaps???
                //   want some kind of consistency to calling things data models.
        
        
                //   And would define types there.
                
        
        
                // ui is the presentation basically.
        
        
        
        
        
                if (this.placeholder) this.dom.attributes.placeholder = this.placeholder;
        
        
            }
            */
        // A ll getter for the string value???
        // ll_value???
        // ll_value_type???
        activate() {
          if (!this.__active) {
            super.activate();
            const { dom } = this;
            this.view.data.model.value = dom.el.value;
            const activate_sync_dom_to_view_ui_ll_data_model = () => {
              const dm = this.view.ui.ll.data.model;
              this.add_dom_event_listener("change", (e) => {
                dm.value = dom.el.value;
              });
              this.add_dom_event_listener("keypress", (e_keypress) => {
                dm.value = dom.el.value;
              });
              this.add_dom_event_listener("keyup", (e_keyup) => {
                dm.value = dom.el.value;
              });
              this.add_dom_event_listener("keydown", (e_keydown) => {
                dm.value = dom.el.value;
              });
            };
            const handle_change_event = (e) => {
              this.view.data.model.value = dom.el.value;
            };
            const activate_sync_dom_to_view_ll_data_model = () => {
              this.add_dom_event_listener("change", (e) => {
                handle_change_event(e);
              });
              this.add_dom_event_listener("keypress", (e) => {
                handle_change_event(e);
              });
              this.add_dom_event_listener("keyup", (e) => {
                handle_change_event(e);
              });
              this.add_dom_event_listener("keydown", (e) => {
                handle_change_event(e);
              });
            };
            activate_sync_dom_to_view_ll_data_model();
          }
        }
      };
      module.exports = Text_Input;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/text-item.js
  var require_text_item = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/text-item.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var textNode = require_text_node();
      var fields = [
        ["value", String, ""]
      ];
      var Text_Item = class extends Control2 {
        // is an Input element.
        //  type of either text or password.
        // could possibly specify some of the starting field values in this part.
        constructor(spec) {
          super(spec, fields);
          this.__type_name = "text_item";
          this.add_class("item");
          this.add(new textNode({
            text: this.value,
            context: this.context
          }));
        }
      };
      module.exports = Text_Item;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Indicator.js
  var require_Indicator = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Indicator.js"(exports, module) {
      var jsgui2 = require_html_core();
      var {
        Control: Control2,
        parse_mount,
        parse,
        field
      } = jsgui2;
      var Indicator = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "indicator";
          super(spec);
          const {
            context: context2
          } = this;
          this.add_class("indicator");
          if (!spec.el) {
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
          }
        }
      };
      module.exports = Indicator;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Status_Indicator.js
  var require_Status_Indicator = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Status_Indicator.js"(exports, module) {
      var Indicator = require_Indicator();
      var Status_Indicator = class extends Indicator {
        constructor(spec) {
          super(spec);
          this.on("change", (e) => {
            const { name, value: value2 } = e;
            console.log("status indicator change", name, value2);
          });
          this.data.on("change", (e) => {
            const { name, value: value2 } = e;
            console.log("status indicator .data change", name, value2);
          });
          this.data.model.on("change", (e) => {
            const { name, value: value2 } = e;
            console.log("status indicator .data.model change", name, value2);
          });
        }
        // bind this to a data value?
        //   simple function, could deal with lower level stuff where necessary.
      };
      Status_Indicator.css = `
.indicator {
    display: inline-block;
    width: 1em;
    height: 1em;
    border-radius: 50%;
    background-color: var(--status-indicator-color, gray);
}       
.indicator.on {
    background-color: green;
}       
.indicator.off {
    background-color: red;
}
.indicator.yes {
    background-color: blue;
}
.indicator.no {
    background-color: orange;
}   
.indicator.unknown {
    background-color: gray;
}   
`;
      module.exports = Status_Indicator;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Validation_Status_Indicator.js
  var require_Validation_Status_Indicator = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Validation_Status_Indicator.js"(exports, module) {
      var Status_Indicator = require_Status_Indicator();
      var Control_Validation = require_Control_Validation();
      var Validation_Status_Indicator = class extends Status_Indicator {
        // Likely will need some client-side recoherence with whatever model(s).
        // vsi.data.model.value being the status value itself?
        // vsi.data.model.validation.state perhaps?????
        //   
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "validation_status_indicator";
          super(spec);
          this.add_class("validation-status");
          const { context: context2 } = this;
          const create_control_validation_but_maybe_we_dont_need_it = () => {
            const o_validation = { context: context2 };
            if (spec.validation) {
              if (spec.validation.data) {
                if (spec.validation.data.model) {
                  o_validation.data = {
                    model: spec.validation.data.model
                  };
                }
              }
            }
            this.validation = new Control_Validation(o_validation);
            this.validation.state.on("change", (e) => {
              const { name, old, value: value2 } = e;
              if (name === "valid") {
                if (value2 === true) {
                  this.remove_class("is-not-valid");
                  this.add_class("is-valid");
                } else if (value2 === false) {
                  this.remove_class("is-valid");
                  this.add_class("is-not-valid");
                }
              }
            });
          };
          this.data.on("change", (e) => {
            console.log("V_S_I change e:", e);
            const { name, old, value: value2 } = e;
            if (name === "model") {
              console.log("vsi data model change e", e);
            }
          });
          this.data.model.validation.state.on("change", (e) => {
            console.log("Validation_Status_Indicator .data.model.validation.state change e:", e);
          });
        }
        activate() {
          const log_some_things = () => {
            console.log("Validation_Status_Indicator activate");
            console.log("this.validation", this.validation);
            console.log("this.validation.state", this.validation.state);
            console.log("this.validation.data.model", this.validation.data.model);
            console.log("this.data.model", this.data.model);
            console.log("this.data.model.value", this.data.model.value);
          };
        }
        // And activation????
        //   Would nice to have less needing to be done in activate functions.
      };
      Validation_Status_Indicator.css = `
    .validation-status.indicator {
        width: 24px;
        height: 24px;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
        border: 1px solid #333333;
        border-radius: 3px;
    }
    .validation-status.indicator.is-valid {
        background-color: '#66DD66'
    }
    .validation-status.indicator.is-not-valid {
        background-color: '#DD6666'
    }
`;
      module.exports = Validation_Status_Indicator;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Text_Field.js
  var require_Text_Field = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Text_Field.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Text_Input = require_Text_Input();
      var Text_Item = require_text_item();
      var { Control: Control2, Control_Data, Control_View, Data_Object, Data_Value: Data_Value2, Data_Model } = jsgui2;
      var { field } = require_lang();
      var Data_Model_View_Model_Control = require_Data_Model_View_Model_Control();
      var Validation_Status_Indicator = require_Validation_Status_Indicator();
      var { model_data_view_compositional_representation } = require_mx();
      var fields = [
        ["text", String],
        ["name", String],
        //['value', String],
        ["type", String],
        ["editable", Boolean, true],
        ["show_text", Boolean, true]
      ];
      var Text_Field = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        //  and can have other fields possibly.
        constructor(spec) {
          super(spec, fields);
          this.editable = true;
          this.__type_name = "text_field";
          this.add_class("text-field");
          if (spec.placeholder) this.placeholder = spec.placeholder;
          const { context: context2 } = this;
          const data_model_change_handler = (e) => {
            console.log("Text_Field data_model_change_handler e", e);
            const { name, old, value: value2 } = e;
            if (name === "value") {
              this.view.data.model.value = value2;
            }
          };
          this.data.model.on("change", data_model_change_handler);
          this.data.on("change", (e) => {
            const { name, value: value2, old } = e;
            console.log("Text_Field data change e:", e);
            if (name === "model") {
              if (old instanceof Data_Model) {
                old.off("change", data_model_change_handler);
              }
              value2.on("change", data_model_change_handler);
            }
          });
          const view_data_model_change_handler = (e) => {
            const { name, old, value: value2 } = e;
            if (name === "value") {
              this.data.model.value = value2;
              if (this.text_input) {
                this.text_input.data.model.value = value2;
              }
            }
          };
          this.view.data.model.on("change", view_data_model_change_handler);
          this.view.data.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (name === "model") {
              if (old instanceof Data_Model) {
                old.off("change", view_data_model_change_handler);
              }
              value2.on("change", view_data_model_change_handler);
            }
          });
          const old_setup_data_and_view = () => {
            this.data = new Control_Data({ context: context2 });
            if (spec.data && spec.data.model) {
              this.data.model = spec.data.model;
            } else {
              this.data.model = new Data_Value2({ context: context2 });
            }
            this.view = new Control_View({ context: context2 });
            if (spec.view && spec.view.data.model) {
              this.view.data.model = spec.view.data.model;
            } else {
              this.view.data.model = new Data_Value2({ context: context2 });
            }
            this.view.data.model.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "value") {
                if (value2 !== old) {
                  this.data.model.value = value2;
                  this.text_input.data.model.value = value2;
                }
              }
            });
          };
          if (!spec.el) {
            this.compose_text_field();
          }
          if (spec.value !== void 0) {
            this.data.model.value = spec.value;
          }
        }
        setup_inner_control_events() {
          const { text_input } = this;
          this.view.data.model.on("change", (e) => {
            const { name, old, value: value2 } = e;
            if (name === "value") {
              text_input.data.model.value = value2;
            }
          });
          text_input.data.model.on("change", (e) => {
            const { name, old, value: value2 } = e;
            if (name === "value") {
              this.view.data.model.value = value2;
            }
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const { dom, text_input } = this;
            this.setup_inner_control_events();
          }
        }
        compose_text_field() {
          const old_composition_code = () => {
            var left = new jsgui2.div({
              "context": this.context
            });
            left.add_class("left");
            var right = new jsgui2.div({
              "context": this.context
            });
            right.add_class("right");
            this.add(left);
            this.add(right);
            var clearall = new jsgui2.div({
              "context": this.context
            });
            clearall.add_class("clearall");
            this.add(clearall);
            if (this.show_text) {
              var label = new jsgui2.label({
                "context": this.context
              });
              label.add(this.text);
              left.add(label);
            }
            const _ctrl_fields = this._ctrl_fields = this._ctrl_fields || {};
            if (this.editable) {
              let o_spec = {
                "context": this.context,
                "value": this.value
              };
              if (this.placeholder) o_spec.placeholder = this.placeholder;
              var text_input = new Text_Input(o_spec);
              var tiid = text_input._id();
              text_input.dom.attributes.id = tiid;
              text_input.dom.attributes.name = this.name;
              label.dom.attributes.for = tiid;
              text_input.dom.attributes.type = this.type;
              right.add(text_input);
              _ctrl_fields.text_input = text_input;
              this.text_input = this.text_input = text_input;
            } else {
              var text_item = new Text_Item({
                "context": this.context,
                "value": this.value
              });
              right.add(text_item);
              _ctrl_fields.text_item = text_item;
              this.text_item = text_item;
            }
          };
          const using_compositional_model = () => {
            this.view.ui.compositional.model = [
              // (string, function || constructor) handling needed for the composition system.
              // (string, function || constructor, object)
              ["left_part", Control2, { class: "left", comp: [["label", jsgui2.label]] }],
              ["right_part", Control2, { class: "right", comp: [["text_input", Text_Input, { "value": this.value }]] }]
            ];
            const label = this._ctrl_fields.left_part.content._arr[0];
            const text_input = this._ctrl_fields.right_part.content._arr[0];
            if (this.text) {
              label.add(this.text);
            }
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.label = label;
            this._ctrl_fields.text_input = text_input;
            this.label = label;
            this.text_input = text_input;
          };
          using_compositional_model();
        }
      };
      module.exports = Text_Field;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/file-upload.js
  var require_file_upload = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/file-upload.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Text_Field = require_Text_Field();
      var Button = require_button();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var File_Upload = class extends Control2 {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          var autosubmit = spec.autosubmit || false;
          var mode = "medium";
          if (spec.mode) mode = spec.mode;
          if (mode == "icon" || mode == "mini" || mode == "compact") autosubmit = true;
          this.__type_name = "file_upload";
          var req = this.context.req;
          var frm = new jsgui2.form({
            "context": this.context
          });
          this.action = spec.action || "/upload/";
          var da = this.dom.attrs;
          da.action = this.action;
          da.method = "POST";
          da.enctype = "multipart/form-data";
          this.add(frm);
          var input_file = new jsgui2.input({
            //'type': 'file',
            "context": this.context
          });
          input_file.set("dom.attributes.type", "file");
          input_file.set("dom.attributes.name", "file");
          frm.add(input_file);
          if (mode === "normal" || mode === "large") {
            var btn = new Button({
              "context": this.context
            });
            var bda = btn.dom.attrs;
            bda.type = "submit";
            bda.value = "submit";
            bda.class = "upload";
            btn.add("Upload");
            frm.add(btn);
          }
          var ctrl_fields = {
            "input_file": input_file._id(),
            "form": frm._id()
          };
        }
        "activate"() {
          super.activate();
          console.log("activate File_Upload");
          var mode = this.mode;
          var autosubmit = this.autosubmit;
          var input_file = this.input_file;
          var form = this.form;
          if (autosubmit) {
            input_file.add_event_listener("change", function(e_change) {
              console.log("e_change", e_change);
              form.dom.el.submit();
            });
          }
        }
      };
      module.exports = File_Upload;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/1-editor/form_field.js
  var require_form_field = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/1-editor/form_field.js"(exports, module) {
      var Control2 = require_control();
      var Text_Input = require_Text_Input();
      var Validation_Status_Indicator = require_Validation_Status_Indicator();
      var Form_Field = class extends Control2 {
        constructor(options = {}) {
          super(options);
          const { context: context2 } = options;
          this.config = {
            label: options.label || "",
            name: options.name || "",
            type: options.type || "text",
            // text, email, password, checkbox, select, textarea
            placeholder: options.placeholder || "",
            required: options.required || false,
            input_control: options.input_control || null,
            // Custom input control
            validator: options.validator || null
          };
          this.add_class("form-field");
          if (this.config.label) {
            this.label_container = new Control2({ context: context2, tag_name: "div" });
            this.label_container.add_class("form-field-label-container");
            this.label = new Control2({ context: context2, tag_name: "label" });
            this.label.add_class("form-field-label");
            this.label.add(this.config.label);
            if (this.config.required) {
              this.required_indicator = new Control2({ context: context2, tag_name: "span" });
              this.required_indicator.add_class("required-indicator");
              this.required_indicator.add(" *");
              this.label.add(this.required_indicator);
            }
            this.label_container.add(this.label);
            this.add(this.label_container);
          }
          this.input_container = new Control2({ context: context2, tag_name: "div" });
          this.input_container.add_class("form-field-input-container");
          if (this.config.input_control) {
            this.input = this.config.input_control;
          } else {
            this.input = this._create_input_control(context2);
          }
          this.input_container.add(this.input);
          this.validation_indicator = new Validation_Status_Indicator({ context: context2 });
          this.validation_indicator.add_class("form-field-validation");
          this.input_container.add(this.validation_indicator);
          this.add(this.input_container);
          this.error_message = new Control2({ context: context2, tag_name: "div" });
          this.error_message.add_class("form-field-error");
          this.add(this.error_message);
        }
        _create_input_control(context2) {
          const { type, placeholder, name } = this.config;
          switch (type) {
            case "text":
            case "email":
            case "password":
            case "number":
            case "url":
            case "tel":
              const input = new Text_Input({ context: context2 });
              input.dom.attributes.type = type;
              input.dom.attributes.name = name;
              if (placeholder) input.dom.attributes.placeholder = placeholder;
              return input;
            case "textarea":
              const textarea = new Control2({ context: context2, tag_name: "textarea" });
              textarea.dom.attributes.name = name;
              if (placeholder) textarea.dom.attributes.placeholder = placeholder;
              textarea.add_class("form-textarea");
              return textarea;
            case "checkbox":
              const checkbox = new Control2({ context: context2, tag_name: "input" });
              checkbox.dom.attributes.type = "checkbox";
              checkbox.dom.attributes.name = name;
              checkbox.add_class("form-checkbox");
              return checkbox;
            case "select":
              const select = new Control2({ context: context2, tag_name: "select" });
              select.dom.attributes.name = name;
              select.add_class("form-select");
              return select;
            default:
              return new Text_Input({ context: context2 });
          }
        }
        /**
         * Set the field value
         */
        set_value(value2) {
          const { type } = this.config;
          if (type === "checkbox") {
            this.input.dom.el.checked = !!value2;
          } else if (type === "select") {
            this.input.dom.el.value = value2;
          } else {
            this.input.dom.el.value = value2 || "";
          }
        }
        /**
         * Get the field value
         */
        get_value() {
          const { type } = this.config;
          if (type === "checkbox") {
            return this.input.dom.el.checked;
          } else {
            return this.input.dom.el.value;
          }
        }
        /**
         * Set validation state
         */
        set_validation(is_valid, error_message = "") {
          if (is_valid) {
            this.validation_indicator.set_status("valid");
            this.error_message.content.clear();
            this.remove_class("has-error");
          } else {
            this.validation_indicator.set_status("invalid");
            this.error_message.content.clear();
            this.error_message.add(error_message);
            this.add_class("has-error");
          }
        }
        /**
         * Clear validation state
         */
        clear_validation() {
          this.validation_indicator.set_status("neutral");
          this.error_message.content.clear();
          this.remove_class("has-error");
        }
        /**
         * Enable/disable the field
         */
        set_enabled(enabled) {
          this.input.dom.el.disabled = !enabled;
          if (enabled) {
            this.remove_class("disabled");
          } else {
            this.add_class("disabled");
          }
        }
      };
      module.exports = Form_Field;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/horizontal-menu.js
  var require_horizontal_menu = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/horizontal-menu.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Menu_Node = require_menu_node();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var group = jsgui2.group;
      var Horizontal_Menu = class extends Control2 {
        // could have a title field.
        //'fields': {
        //	'title': String
        //},
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "horizontal_menu";
          this.dom.attrs.class = "horizontal menu";
          if (!spec.abstract && !spec.el) {
            var obj2 = spec.value;
            var tobj = tof(obj2);
            if (tobj == "object") {
              each(obj2, (v, key2) => {
                var menu_node = make(Menu_Node({
                  "text": key2,
                  "value": v,
                  "menu": this
                }));
                this.add(menu_node);
              });
            }
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            var last_clicked;
            this.content.each((v, i) => {
              v.on("click", (e_click) => {
                var v_state = v.state;
                v.open();
                v.one_mousedown_anywhere(function(e_mousedown) {
                  if (!e_mousedown.within_this) {
                    v.close();
                  } else {
                  }
                });
              });
              v.on("mouseup", function(e_mouseup) {
              });
            });
          }
        }
        "close_all"() {
          console.log("menu close_all");
          this.content.each((v, i) => {
            v.close_all();
          });
        }
      };
      module.exports = Horizontal_Menu;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/4-data/data-item.js
  var require_data_item = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/4-data/data-item.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var fields = [
        ["value", Object]
      ];
      var Data_Item = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        // this.__type_name = 'text_item';
        constructor(spec) {
          super(spec, fields);
          this.__type_name = "data_item";
          this.add_class("data-item");
          let context2 = this.context;
          this.add(new jsgui2.textNode({
            text: this.value + "",
            context: this.context
          }));
        }
      };
      module.exports = Data_Item;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/4-data/data-row.js
  var require_data_row = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/4-data/data-row.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Data_Item = require_data_item();
      var Data_Row = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        constructor(spec) {
          super(spec);
          this.add_class("data-row");
          let context2 = this.context;
          let items = this.items = [];
          if (spec.items) {
            each(spec.items, (item2) => {
              items.push(this.add(new Data_Item({
                "context": context2,
                "value": item2
              })));
            });
          }
        }
      };
      module.exports = Data_Row;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/date-picker.js
  var require_date_picker = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/date-picker.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { Control: Control2, Control_Data, Control_View, Data_Object } = jsgui2;
      var { field } = require_oext();
      var Date_Picker = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "date_picker";
          super(spec);
          this.add_class("date-picker");
          this.dom.tagName = "input";
          this.dom.attributes.type = "date";
          const { context: context2 } = this;
          if (!spec.el) {
            this.compose_date_picker();
          }
          const construct_synchronised_data_and_view_models = () => {
            this.data = new Control_Data({ context: context2 });
            if (spec.data && spec.data.model) {
              this.data.model = spec.data.model;
            } else {
              this.data.model = new Data_Object({ context: context2 });
              field(this.data.model, "value");
            }
            this.view = new Control_View({ context: context2 });
            if (spec.view && spec.view.data.model) {
              this.view.data.model = spec.view.data.model;
            } else {
              this.view.data.model = new Data_Object({ context: context2 });
              field(this.view.data.model, "value");
            }
            this.data.model.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "value") {
                if (value2 !== old) {
                  this.view.data.model.value = value2;
                }
              }
            });
            this.view.data.model.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "value") {
                if (value2 !== old) {
                  this.data.model.value = value2;
                  if (this.dom.el) {
                    this.dom.el.value = value2;
                  }
                }
              }
            });
          };
          construct_synchronised_data_and_view_models();
          this.assign_data_model_value_change_handler();
        }
        assign_data_model_value_change_handler() {
          if (this.data && this.data.model) {
            this.data.model.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "value") {
                if (value2 !== old) {
                  this.view.data.model.value = value2;
                }
              }
            });
          }
        }
        compose_date_picker() {
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const { dom } = this;
            const activate_view_model_to_dom_model_sync = () => {
              this.add_dom_event_listener("change", (e) => {
                this.view.data.model.value = dom.el.value;
              });
              this.add_dom_event_listener("keypress", (e_keypress) => {
                this.view.data.model.value = dom.el.value;
              });
              this.add_dom_event_listener("keyup", (e_keyup) => {
                this.view.data.model.value = dom.el.value;
              });
              this.add_dom_event_listener("keydown", (e_keydown) => {
                this.view.data.model.value = dom.el.value;
              });
            };
            activate_view_model_to_dom_model_sync();
          }
        }
      };
      module.exports = Date_Picker;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/dropdown-list.js
  var require_dropdown_list = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/dropdown-list.js"(exports, module) {
      var jsgui2 = require_html_core();
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Dropdown_List = class extends Control2 {
        constructor(spec) {
          super(spec);
          console.trace();
          throw "Deprtecating this control for the moment. Try Select_Options or Dropdown_Menu instead.";
          this.options = spec.options;
          if (!spec.skip_compose) this.compose();
        }
        compose() {
          const context2 = this.context;
          each(this.options, (option) => {
            let t = tof(option);
            let ctrl_option = new jsgui2.option({
              context: context2
            });
            if (t === "string") {
              ctrl_option.dom.attributes.value = option;
              ctrl_option.add(new jsgui2.textNode("option"));
            }
          });
        }
      };
      module.exports = Dropdown_List;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/panel.js
  var require_panel = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/panel.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var def = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var Panel = class extends Control2 {
        // panel name?
        // could have a title field.
        //'fields': {
        //    'name': String
        //}
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "panel";
          super(spec);
          this.add_class("panel");
          if (def(spec.name)) {
            this.name = spec.name;
          }
          if (!spec.abstract && !spec.el) {
            var l2 = 0;
            let n = this.name;
            if (def(n)) {
              let f = this._fields = this._fields || {};
              f.name = n;
            }
          }
        }
        //'resizable': function() {
        //},
        /*
            'activate'() {
                // May need to register Flexiboard in some way on the client.
        
                if (!this.__active) {
                    super.activate();
                    this.content.on('change', e => {
                        console.log('e', e);
                        console.log('this', this);
                    })
                }
                
            }
            */
      };
      module.exports = Panel;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/title-bar.js
  var require_title_bar = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/title-bar.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { stringify, each, tof, def, Control: Control2 } = jsgui2;
      var fields = [
        ["text", String]
      ];
      var Title_Bar = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "title_bar";
          super(spec, fields);
          if (!spec.el) {
            this.add_class("title-bar title bar");
            var span = new jsgui2.span({
              "context": this.context,
              "text": this.text
            });
            this.add(span);
          }
        }
      };
      module.exports = Title_Bar;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/toggle-button.js
  var require_toggle_button = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/toggle-button.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { stringify, each, tof, def, Control: Control2 } = jsgui2;
      var { prop, field } = require_oext();
      var Toggle_Button = class extends Control2 {
        constructor(spec, add, make) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "toggle_button";
          super(spec);
          this.add_class("toggle-button");
          field(this, "states", spec.states || "");
          field(this, "state", spec.state || "");
          if (!spec.abstract && !spec.el) {
            const _compose = () => {
              var span_state = this.span_state = new jsgui2.span({ "context": this.context, text: this.state });
              this.add(span_state);
            };
            const compose = () => jsgui2.parse_mount(`<span name='span_state'>${this.state}</span>`, this, jsgui2.controls);
            compose();
          }
          this.on("change", (e_change) => {
            if (this.span_state) this.span_state.text = e_change.value;
          });
          if (typeof document === "undefined") {
            this.dom.attributes["data-jsgui-ctrl-fields"] = stringify({
              "span_state": this.span_state._id()
            }).replace(/"/g, "'");
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            this.on("click", (e_click) => {
              var state = this.state;
              var states = this.states;
              var i_current_state;
              if (tof(states) === "array") {
                each(states, (i_state, i) => {
                  if (i_state === state) {
                    i_current_state = i;
                  }
                });
                var i_next_state = i_current_state + 1;
                if (i_next_state === states.length) i_next_state = 0;
                var str_next_state = states[i_next_state];
                this.raise("toggle", {
                  "state": str_next_state
                });
                this.state = str_next_state;
              } else {
                throw "stop";
              }
            });
          }
        }
      };
      module.exports = Toggle_Button;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/plus-minus-toggle-button.js
  var require_plus_minus_toggle_button = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/plus-minus-toggle-button.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Toggle_Button = require_toggle_button();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Plus_Minus_Toggle_Button = class extends Toggle_Button {
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          spec.__type_name = "plus_minus_toggle_button";
          spec.states = ["+", "-"];
          spec.state = spec.state || "-";
          super(spec);
          let state = this.state = spec.state;
        }
      };
      module.exports = Plus_Minus_Toggle_Button;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/vertical-expander.js
  var require_vertical_expander = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/vertical-expander.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Control2 = jsgui2.Control;
      var { prop, field } = require_oext();
      var Vertical_Expander = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //'fields': [
        //	['text', String]
        //],
        //  and can have other fields possibly.
        constructor(spec) {
          spec.__type_name = "vertical_expander";
          super(spec);
          this.add_class("vertical expander");
          field(this, "state");
          field(this, "states");
          this.state = spec.state;
          this.states = spec.states;
        }
        "activate"() {
          super.activate();
          var orig_height;
          var el = this.dom.el;
          if (el) {
            el.style.transition = "height 0.125s linear";
            var ui_close = () => {
              var h = el.childNodes[0].offsetHeight;
              orig_height = h;
              el.style.height = orig_height + "px";
              setTimeout(function() {
                el.style.overflow = "hidden";
                el.style.height = "0px";
              }, 0);
            };
            var ui_open = () => {
              var fnTransitionEnd = function(e_end) {
                el.removeEventListener("transitionend", fnTransitionEnd);
              };
              el.addEventListener("transitionend", fnTransitionEnd, false);
              el.style.height = orig_height + "px";
            };
            this.on("change", (e_change) => {
              var val = e_change.value;
              if (val == "closed") {
                ui_close();
              }
              if (val == "open") {
                ui_open();
              }
            });
          } else {
            console.log("WARNING: vertical_expander expected el to activate");
            console.trace();
          }
        }
        "toggle"() {
          if (this.state == "open") {
            this.state = "closed";
          }
          if (this.state == "closed") {
            this.state = "open";
          }
        }
        "open"() {
          this.state = "open";
        }
        "close"() {
          this.state = "closed";
        }
        // Open, close, expand, contract
        //  Could have a state variable as well.
        //  Will listen to changes in that state variable.
      };
      module.exports = Vertical_Expander;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/tree-node.js
  var require_tree_node = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/tree-node.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Plus_Minus_Toggle_Button = require_plus_minus_toggle_button();
      var Vertical_Expander = require_vertical_expander();
      var mx_selectable = require_selectable();
      var {
        prop,
        field
      } = require_oext();
      var {
        stringify,
        each,
        tof,
        def,
        Control: Control2
      } = jsgui2;
      var Tree_Node = class _Tree_Node extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "tree_node";
          if (!def(spec.expandable)) spec.expandable = true;
          super(spec);
          mx_selectable(this);
          field(this, "depth");
          field(this, "state", "open");
          this.expandable = spec.expandable;
          if (def(spec.depth)) this.depth = spec.depth;
          if (spec) {
            var spec_state = spec.state, state;
            if (spec_state === "open" || spec_state === "closed") {
              this.state = spec_state;
            } else {
            }
            if (spec.text) {
              this.text = spec.text;
            } else {
              if (spec.name) {
                this.text = spec.name;
              }
            }
          } else {
            this.state = "open";
          }
          if (spec.img_src) {
          }
          if (typeof spec.el === "undefined") {
            this.compose_tree_node(spec);
          }
          if (this.inner_control) {
            this.inner_control.content.on("change", (e_change) => {
              let coll = e_change.target;
              let has_tree_node = false;
              each(coll, (v, i, stop) => {
                if (v instanceof _Tree_Node) {
                  has_tree_node = true;
                  stop();
                }
              });
              if (has_tree_node) {
                this.toggle_button.show();
              } else {
                this.toggle_button.hide();
              }
            });
          }
        }
        "compose_tree_node"(spec) {
          let my = (p) => {
            p.context = this.context;
            return p;
          };
          const add = (item2) => this.add(item2);
          const make = (item2) => this.make(item2);
          var top_line = add(new Control2(my({
            "class": "top-line"
          })));
          let rest_of_top_line;
          if (def(this.depth)) {
            for (let c2 = 0; c2 < this.depth; c2++) {
              let depth_block = new Control2(my({
                "class": "depth-block"
              }));
              top_line.add(depth_block);
            }
          }
          let plus_minus, inner_control;
          let spec3 = {};
          if (this.state === "closed") {
            spec3.state = "+";
          }
          top_line.add(plus_minus = new Plus_Minus_Toggle_Button(my(spec3)));
          this.toggle_button = plus_minus;
          plus_minus.hide();
          var main_box = top_line.add(new Control2(my({
            "class": "main-box"
          })));
          if (this.img_src) {
            rest_of_top_line.add(new jsgui2.img(my({
              "dom": {
                "attributes": {
                  "src": this.img_src
                }
              }
            })));
          }
          main_box.add(new jsgui2.span(my({
            text: this.text,
            "class": "text"
          })));
          let expander;
          if (this.expandable) {
            expander = add(new Vertical_Expander(my({
              //state: this.state
            })));
            expander.add(inner_control = new Control2(my({
              "class": "inner"
            })));
            this.inner_control = inner_control;
            this.expander = expander;
            if (spec.nodes) {
              for (let node of spec.nodes) {
                node.context = this.context;
                node.depth = this.depth + 1;
                let tn = new _Tree_Node(node);
                this.inner_control.add(tn);
              }
              expander.state = this.state = "open";
            } else {
              expander.state = this.state = "closed";
            }
          } else {
            plus_minus.hide();
          }
          var ctrl_fields = this._ctrl_fields = Object.assign(this._ctrl_fields || {}, {
            "toggle_button": plus_minus
          });
          if (expander) {
            ctrl_fields.inner_control = inner_control;
            ctrl_fields.expander = expander;
          }
          this.add_class("tree-node");
          this.active();
        }
        // adding a node - need to set up its depth?
        // I think a pre-render function would be useful.
        //  Something that sets data-jsgui DOM attributes.
        // Seems we need a separate 'register' stage, where controls, with their DOM els get registered with the central jsgui system.
        // whenever something is added to the DOM, the nodes need to be registered.
        //  within the page context
        // Want automatic activation of any control that gets added.
        //  Added to an active control.
        // __is_active
        "activate"(el) {
          if (!this.__active) {
            super.activate(el);
            this.rec_desc_ensure_ctrl_el_refs();
            var toggle_button = this.toggle_button;
            var inner_control = this.inner_control;
            var expander = this.expander;
            if (expander) {
              if (toggle_button) {
                toggle_button.on("toggle", (e_toggle) => {
                  let state = e_toggle.state;
                  if (state === "-") {
                    expander.open();
                    this.raise("expand");
                    this.raise("open");
                  } else {
                    expander.close();
                    this.raise("contract");
                    this.raise("close");
                  }
                });
              }
            }
          }
        }
      };
      module.exports = Tree_Node;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/tree.js
  var require_tree = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/tree.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { stringify, each, tof, def, Control: Control2 } = jsgui2;
      var Panel = require_panel();
      var Title_Bar = require_title_bar();
      var Tree_Node = require_tree_node();
      var { prop, field } = require_oext();
      var Tree = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "tree";
          super(spec);
          this.add_class("tree");
          field(this, "title");
          this.title = spec.title;
          if (!spec.el) {
            this.compose_tree(spec);
          }
          this.on("change", (e_change) => {
            if (e_change.name === "title") {
              this.title_bar.text = e_change.value;
            }
            ;
          });
        }
        compose_tree(spec) {
          if (this.title !== void 0) {
            this.add(this.title_bar = new Title_Bar({
              context: this.context,
              text: this.title
            }));
          }
          this.add(this.main = new Panel({
            context: this.context
          }));
          if (spec.nodes) {
            for (let node of spec.nodes) {
              node.context = this.context;
              node.depth = 0;
              let tn = new Tree_Node(node);
              this.main.add(tn);
            }
          }
          this._ctrl_fields = Object.assign(this._ctrl_fields || {}, {
            //'title_bar': this.title_bar,
            "main": this.main
          });
          if (this.title_bar) {
            this._ctrl_fields.title_bar = this.title_bar;
          }
        }
        clear() {
          this.main.clear();
        }
        activate() {
          super.activate();
          this.selection_scope = this.context.new_selection_scope();
        }
      };
      module.exports = Tree;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/file-tree.js
  var require_file_tree = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/file-tree.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Tree = require_tree();
      var File_Tree = class extends Tree {
        constructor(spec) {
          spec.__type_name = "file_tree";
          super(spec);
          this.add_class("file tree file-tree");
          const context2 = this.context;
          let fs_resource = spec.fs || spec.fs_resource;
          if (fs_resource) {
            this.fs_resource = fs_resource;
          } else {
            let resources = context2.resources;
            console.log("File_Tree context resources", resources);
            console.log("File_Tree context.resource_pool", context2.resource_pool);
            console.log("Object.keys(context)", Object.keys(context2));
          }
          if (!spec.el) {
            this.compose_file_tree();
          }
        }
        compose_file_tree() {
        }
        activate() {
        }
      };
      module.exports = File_Tree;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/file-tree-node.js
  var require_file_tree_node = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/file-tree-node.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Tree_Node = require_tree_node();
      var File_Tree_Node = class extends Tree_Node {
        constructor(spec) {
          if (spec.file) {
            let file = spec.file;
            let filename = file.name;
            spec.text = file.name;
          }
          spec.__type_name = "file_tree_node";
          spec.expandable = false;
          super(spec);
          this.add_class("file");
          if (!spec.el) {
          }
        }
      };
      module.exports = File_Tree_Node;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/icon.js
  var require_icon = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/icon.js"(exports, module) {
      var jsgui2 = require_html_core();
      var {
        Control: Control2,
        parse_mount,
        parse,
        field
      } = jsgui2;
      var Icon = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "icon";
          let size = spec.size = spec.size || [64, 64];
          super(spec);
          const {
            context: context2
          } = this;
          this.add_class("icon");
          field(this, "key", spec.icon_key || spec.key);
          const compose = () => {
            const {
              key: key2
            } = this;
            const imgurl = "/img/icons/" + key2;
            const img = new jsgui2.img({
              context: context2,
              size: [64, 64]
            });
            img.dom.attributes.src = imgurl;
            this.add(img);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.img = img;
          };
          if (!spec.el) {
            compose();
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const {
              img
            } = this;
            this.on("change", ({
              name,
              value: value2
            }) => {
              if (name === "key") {
                const imgurl = "/img/icons/" + value2;
                img.dom.attributes.src = imgurl;
              }
            });
          }
        }
      };
      module.exports = Icon;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/item.js
  var require_item = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/item.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { Control: Control2, controls, tf: tf2, are_equal, each } = jsgui2;
      var { span } = controls;
      var { prop, field } = require_oext();
      var Icon = require_icon();
      var Item = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "item";
          super(spec);
          this.add_class("item");
        }
      };
      module.exports = Item;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/list.js
  var require_list = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/list.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Item = require_item();
      var { each } = jsgui2;
      var { prop } = require_lang();
      var Control2 = jsgui2.Control;
      var Collection = jsgui2.Collection;
      var mx_selectable = require_selectable();
      var List = class extends Control2 {
        // Items collection as a field?
        //  This would have control content items.
        //  It would / may also have a Collection of items.
        //  It would get given its items as JSON / a JS object / array, and then would create the content Controls.
        // Want it to be easy to create a list, give it the data or the data source.
        /*
         'fields': [
         //['text', String]
         ['toggle_button', Control],
         ['inner_control', Control],
         ['expander', Control]
         ],
         */
        constructor(spec, add, make) {
          super(spec);
          var that2 = this;
          this.__type_name = "list";
          prop(this, "ordered", spec.ordered || false);
          if (this.ordered) {
            this.dom.tagName = "ol";
          } else {
            this.dom.tagName = "ul";
          }
          this.add_class("list");
          prop(this, "items", spec.items);
          if (!spec.el) {
            this.compose_list();
          }
        }
        "compose_list"() {
          each(this.items, (item2, index) => {
            var ctrl_item = new Item({
              "context": this.context,
              "value": item2
            });
            ctrl_item._fields = ctrl_item._fields || {};
            ctrl_item._fields.index = index;
            mx_selectable(ctrl_item);
            ctrl_item.selectable = true;
            this.add(ctrl_item);
          });
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            each(this.$("item"), (item2) => {
              item2.selectable = true;
            });
            let ss = this.find_selection_scope();
            if (ss && ss.on) {
              ss.on("change", (e_change) => {
                let item2 = e_change.value;
                this.selected_index = item2.index;
                this.raise("change", {
                  "name": "selection",
                  "value": item2.index
                });
              });
            }
          }
        }
      };
      module.exports = List;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/item-selector.js
  var require_item_selector = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/item-selector.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var def = jsgui2.is_defined;
      var Item_View = require_item();
      var List = require_list();
      var mx_popup = require_popup();
      var Item_Selector = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "item_selector";
          super(spec);
          this.add_class("item-selector");
          if (spec.items) {
            this.items = spec.items;
          } else {
            this.items = [];
          }
          if (spec.loop) this.loop = spec.loop;
          if (def(spec.item_index)) {
            this.item_index = spec.item_index;
          } else {
            if (!def(this.item_index)) {
              this.item_index = 0;
            }
          }
          if (!spec.el) {
            this.compose_item_selector();
            this.finish_item_selector();
          }
        }
        finish_item_selector() {
          this.item_list.on("change", (e_change) => {
            if (e_change.name === "selection") {
              let selected_index = e_change.value;
              this.item_index = selected_index;
              this.current_item_view.item = this.items[selected_index];
              this.raise("change", {
                "name": "value",
                "value": this.items[selected_index],
                "index": selected_index
              });
              this.value = this.items[selected_index];
              setTimeout(() => {
                this.item_list.hide();
              }, 120);
            }
          });
        }
        compose_item_selector() {
          let current_item_view = this.current_item_view = new Item_View({
            context: this.context,
            item: this.items[this.item_index]
          });
          this.add(current_item_view);
          let item_list = this.item_list = new List({
            context: this.context,
            items: this.items
          });
          item_list.hide();
          item_list.add_class("item-selector");
          mx_popup(item_list);
          this.add(item_list);
          this._fields = this._fields || {};
          this._fields.item_index = this.item_index;
          this._fields.items = this.items;
          if (this.loop) this._fields.loop = this.loop;
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.current_item_view = current_item_view;
          this._ctrl_fields.item_list = item_list;
        }
        previous(raise_event = true) {
          let o_change;
          if (this.item_index > 0) {
            this.item_index--;
            this.current_item_view.item = this.items[this.item_index];
            if (raise_event) {
              o_change = {
                value: this.items[this.item_index],
                index: this.item_index,
                size: -1
              };
            }
          } else {
            if (this.loop) {
              this.item_index = this.items.length - 1;
              this.current_item_view.item = this.items[this.item_index];
              if (raise_event) {
                this.raise("loop", -1);
                o_change = {
                  value: this.items[this.item_index],
                  loop: -1,
                  index: this.item_index,
                  size: -1
                };
              }
            }
          }
          if (o_change) {
            if (this.item_index === 0) {
              o_change.first = true;
            }
            if (this.item_index === this.items.length - 1) {
              o_change.last = true;
            }
            this.raise("change", o_change);
          }
        }
        next(raise_event = true) {
          let old_index = this.item_index;
          let old = this.items[this.item_index];
          let o_change;
          if (this.item_index < this.items.length - 1) {
            this.item_index++;
            this.current_item_view.item = this.items[this.item_index];
            if (raise_event) {
              o_change = {
                value: this.items[this.item_index],
                index: this.item_index,
                size: 1
              };
            }
          } else {
            if (this.loop) {
              this.item_index = 0;
              this.current_item_view.item = this.items[this.item_index];
              if (raise_event) {
                this.raise("loop", 1);
                o_change = {
                  value: this.items[this.item_index],
                  loop: 1,
                  index: this.item_index,
                  size: 1
                };
              }
            }
          }
          if (o_change) {
            if (this.item_index === 0) {
              o_change.first = true;
            }
            if (this.item_index === this.items.length - 1) {
              o_change.last = true;
            }
            this.raise("change", o_change);
          }
        }
        activate() {
          let ctrl2 = this;
          if (!this.__active) {
            super.activate();
            let item_list = this.item_list;
            mx_popup(item_list);
            let has_moved_away = false;
            let t = false;
            this.on("touchstart", (ets) => {
              t = true;
              item_list.popup();
              ets.preventDefault();
            });
            this.on("touchend", (ete) => {
              if (!has_moved_away) {
              }
              has_moved_away = false;
              item_list.hide();
            });
            this.on("touchmove", (etm) => {
              has_moved_away = true;
            });
            this.on("click", (ec) => {
              if (!t) {
                let replace = item_list.popup();
                let body = this.context.map_controls["body_0"];
                let body_click_handler = (e_click) => {
                  let target_ctrl = this.context.map_controls[e_click.target.getAttribute("data-jsgui-id")];
                  let anc = target_ctrl.ancestor(item_list);
                  if (anc) {
                  } else {
                    body.off("click", body_click_handler);
                    replace();
                  }
                };
                setTimeout(() => {
                  body.on("click", body_click_handler);
                }, 0);
              }
            });
            this.finish_item_selector();
          }
        }
      };
      module.exports = Item_Selector;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/2-misc/left-right-arrows-selector.js
  var require_left_right_arrows_selector = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/2-misc/left-right-arrows-selector.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Control2 = jsgui2.Control;
      var def = jsgui2.is_defined;
      var Arrow_Button = require_arrow_button();
      var Item_Selector = require_item_selector();
      var Left_Right_Arrows_Selector = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "left_right_arrows_selector";
          super(spec);
          this.add_class("left-right");
          this.add_class("arrows-selector");
          if (spec.items) {
            this.items = spec.items;
          }
          if (def(spec.item_index)) {
            this.item_index = spec.item_index;
          }
          if (def(spec.loop)) {
            this.loop = spec.loop;
          }
          if (!spec.el) {
            this.compose_lras();
          }
        }
        compose_lras() {
          let context2 = this.context;
          let left_arrow = new Arrow_Button({
            context: context2,
            direction: "left"
          });
          let is_spec = {
            context: context2
          };
          if (this.items) is_spec.items = this.items;
          if (this.item_index) is_spec.item_index = this.item_index;
          if (this.loop) is_spec.loop = this.loop;
          let item_selector = new Item_Selector(is_spec);
          let right_arrow = new Arrow_Button({
            context: context2,
            direction: "right"
          });
          this.add(left_arrow);
          this.add(item_selector);
          this.add(right_arrow);
          this._fields = this._fields || {};
          if (this.items) this._fields.items = this.items;
          if (def(this.item_index)) this._fields.item_index = this.item_index;
          if (def(this.loop)) this._fields.loop = this.loop;
          this._ctrl_fields = {
            left_arrow,
            item_selector,
            right_arrow
          };
        }
        previous(raise_event = true) {
          this.item_selector.previous(raise_event);
        }
        next(raise_event = true) {
          this.item_selector.next(raise_event);
        }
        activate() {
          if (!this.__active) {
            super.activate();
            let { left_arrow, item_selector, right_arrow } = this;
            left_arrow.on("click", (e_click) => {
              this.previous();
            });
            item_selector.on("change", (e_change) => {
              if (!this.loop) {
                if (e_change.first) {
                  left_arrow.disabled = true;
                } else {
                  left_arrow.disabled = false;
                }
                if (e_change.last) {
                  right_arrow.disabled = true;
                } else {
                  right_arrow.disabled = false;
                }
              }
              this.raise("change", e_change);
            });
            right_arrow.on("click", (e_click) => {
              this.next();
            });
            if (this.loop) {
              item_selector.on("loop", (loop_direction) => {
                this.raise("loop", loop_direction);
              });
            }
          }
        }
      };
      module.exports = Left_Right_Arrows_Selector;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/line-chart.js
  var require_line_chart = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/line-chart.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var extend = jsgui2.extend;
      var Control2 = jsgui2.Control;
      var Collection = jsgui2.Collection;
      var Line_Chart = class extends Control2 {
        constructor(spec) {
          super(spec);
          this.__type_name = "line_chart";
          if (!spec.abstract && !spec.el) {
            this.add_class("line-chart no-select");
            var vert_margin = 10;
            var left_margin = 80;
            var right_margin = 24;
            var axis_thickness = 2;
            var x_major_notch_spacing = spec.x_major_notch_spacing || spec.major_notch_spacing || 50;
            var y_major_notch_spacing = spec.y_major_notch_spacing || spec.major_notch_spacing || 50;
            var x_minor_notch_spacing = spec.x_minor_notch_spacing || spec.major_minor_spacing || 10;
            var y_minor_notch_spacing = spec.y_minor_notch_spacing || spec.major_minor_spacing || 10;
            var suppress_0_axes_labels = true;
            this.set({
              "vert_margin": vert_margin,
              "left_margin": left_margin,
              "right_margin": right_margin,
              "axis_thickness": axis_thickness,
              "x_major_notch_spacing": x_major_notch_spacing,
              "y_major_notch_spacing": y_major_notch_spacing,
              "x_minor_notch_spacing": x_minor_notch_spacing,
              "y_minor_notch_spacing": y_minor_notch_spacing,
              "suppress_0_axes_labels": suppress_0_axes_labels
            });
            this.add_full_axes();
          }
          var num_days = this.get("num_days");
          if (typeof window == "undefined") {
            extend(this._fields = this._fields || {}, {
              "vert_margin": vert_margin,
              "left_margin": left_margin,
              "right_margin": right_margin,
              "axis_thickness": axis_thickness,
              "x_major_notch_spacing": x_major_notch_spacing,
              "y_major_notch_spacing": y_major_notch_spacing,
              "x_minor_notch_spacing": x_minor_notch_spacing,
              "y_minor_notch_spacing": y_minor_notch_spacing,
              "suppress_0_axes_labels": suppress_0_axes_labels,
              "range": this.get("range").value(),
              "x_origin": this.get("x_origin").value(),
              "y_origin": this.get("y_origin").value()
            });
          }
        }
        "add_full_axes"() {
          var vert_margin = this.get("vert_margin");
          var left_margin = this.get("left_margin");
          var right_margin = this.get("right_margin");
          var axis_thickness = this.get("axis_thickness");
          var x_major_notch_spacing = this.get("x_major_notch_spacing");
          var y_major_notch_spacing = this.get("y_major_notch_spacing");
          var x_minor_notch_spacing = this.get("x_minor_notch_spacing");
          var y_minor_notch_spacing = this.get("y_minor_notch_spacing");
          var suppress_0_axes_labels = this.get("suppress_0_axes_labels");
          var size = this.get("size").value();
          var w = size[0][0];
          var h = size[1][0];
          var range = this.get("range").value();
          console.log("range", range);
          var y_axis_x, x_axis_y;
          var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
          var x_range = x_max - x_min, y_range = y_max - y_min;
          var y_axis_is_at_origin = x_min <= 0 && x_max >= 0;
          var x_axis_is_at_origin = y_min <= 0 && y_max >= 0;
          var x_axis_left = left_margin;
          var x_axis_right = w - right_margin;
          var y_axis_top = vert_margin;
          var y_axis_bottom = h - vert_margin;
          var x_chart_distance = x_axis_right - x_axis_left;
          var y_chart_distance = y_axis_bottom - y_axis_top;
          var x_axis_length = w - left_margin - right_margin;
          var y_axis_length = h - 2 * vert_margin;
          var x_scale = x_range / x_axis_length;
          var y_scale = y_range / y_axis_length;
          var x_origin, y_origin;
          var values_from_pixel_location = function(px_loc) {
            var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
            var res2 = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
            return res2;
          };
          var pixel_location_from_values = function(values) {
            var res2 = [Math.round(origin[0] + values[0] * 1 / x_scale), Math.round(origin[1] + values[1] * -1 / y_scale)];
            return res2;
          };
          var x_location_from_value = function(x_value) {
            return Math.round(x_origin + x_value * 1 / x_scale);
          };
          var y_location_from_value = function(y_value) {
            return Math.round(y_origin + y_value * -1 / y_scale);
          };
          var svg = new Control2({
            "context": this.context,
            "tag_name": "svg"
          });
          svg.set("dom.attributes", {
            "width": w,
            "height": h,
            "viewPort": "0 0 " + w + " " + h,
            "version": "1.1",
            "xmlns": "http://www.w3.org/2000/svg"
          });
          this.add(svg);
          this.set("svg", svg);
          if (y_axis_is_at_origin) {
            var prop_through = -1 * x_min / x_range;
            var distance_through = x_chart_distance * prop_through;
            x_origin = x_axis_left + distance_through;
            y_axis_x = x_origin;
          } else {
            throw "stop";
          }
          if (x_axis_is_at_origin) {
            var prop_through = -1 * y_min / y_range;
            var distance_through = y_chart_distance * prop_through;
            y_origin = y_axis_bottom - distance_through;
            x_axis_y = y_origin;
          } else {
            throw "stop";
          }
          this.x_origin = x_origin;
          this.y_origin = y_origin;
          var y_axis_top = vert_margin;
          var y_axis_bottom = h - vert_margin;
          var add_y_axis_line = function() {
            var y_axis = new Control2({
              "context": this.context,
              "tag_name": "line"
            });
            y_axis.set("dom.attributes", {
              "width": 10,
              "height": h,
              "x1": y_axis_x,
              "y1": y_axis_top,
              "x2": y_axis_x,
              "y2": y_axis_bottom,
              "stroke": "#000000",
              "stroke-width": 2
            });
            svg.add(y_axis);
          };
          var add_x_axis_line = function() {
            var x_axis = new Control2({
              "context": this.context,
              "tag_name": "line"
            });
            x_axis.set("dom.attributes", {
              "width": 10,
              "height": h,
              "x1": x_axis_left,
              "y1": x_axis_y,
              "x2": x_axis_right,
              "y2": x_axis_y,
              "stroke": "#000000",
              "stroke-width": 2
            });
            svg.add(x_axis);
          };
          var add_x_notch_group = function(spacing, height2) {
            var num_notches_left_of_origin = Math.floor(x_min * -1 / spacing);
            var num_notches_right_of_origin = Math.floor(x_max / spacing);
            var first_notch_x_value = num_notches_left_of_origin * spacing * -1;
            var notch_x_value = first_notch_x_value;
            while (notch_x_value <= x_max) {
              var x_notch = new Control2({
                "context": this.context,
                "tag_name": "line"
              });
              var x_location = x_location_from_value(notch_x_value);
              x_notch.set("dom.attributes", {
                "width": 2,
                "height": height2,
                "x1": x_location,
                "y1": y_origin,
                "x2": x_location,
                "y2": y_origin + height2,
                "stroke": "#AAAAAA",
                "stroke-width": 2
                //'xmlns': 'http://www.w3.org/2000/svg',
                //'version': '1.1'
              });
              svg.add(x_notch);
              notch_x_value += spacing;
            }
          };
          var add_x_label_group = function(spacing) {
            var num_notches_left_of_origin = Math.floor(x_min * -1 / spacing);
            var num_notches_right_of_origin = Math.floor(x_max / spacing);
            var first_notch_x_value = num_notches_left_of_origin * spacing * -1;
            var notch_x_value = first_notch_x_value;
            while (notch_x_value <= x_max) {
              if (!(suppress_0_axes_labels && notch_x_value === 0)) {
                var x_location = x_location_from_value(notch_x_value);
                var x_notch_label = new Control2({
                  "context": this.context,
                  "tag_name": "text"
                });
                x_notch_label.set("dom.attributes", {
                  "x": x_location - 4,
                  "y": y_origin + 28,
                  "font-family": "Verdana",
                  "font-size": 14
                });
                x_notch_label.add(notch_x_value + "");
                svg.add(x_notch_label);
              }
              notch_x_value += spacing;
            }
          };
          var add_y_label_group = function(spacing) {
            var num_notches_below_origin = Math.floor(y_min * -1 / spacing);
            var num_notches_above_origin = Math.floor(y_max / spacing);
            var first_notch_y_value = num_notches_below_origin * spacing * -1;
            var notch_y_value = first_notch_y_value;
            while (notch_y_value <= y_max) {
              if (!(suppress_0_axes_labels && notch_y_value === 0)) {
                var y_notch = new Control2({
                  "context": this.context,
                  "tag_name": "line"
                });
                var y_location = y_location_from_value(notch_y_value);
                var y_notch_label = new Control2({
                  "context": this.context,
                  "tag_name": "text"
                });
                y_notch_label.set("dom.attributes", {
                  "x": x_origin - 48,
                  "y": y_location + 6,
                  "font-family": "Verdana",
                  "font-size": 14
                });
                y_notch_label.add(notch_y_value + "");
                svg.add(y_notch_label);
              }
              notch_y_value += spacing;
            }
          };
          var add_y_notch_group = function(spacing, length) {
            var num_notches_below_origin = Math.floor(y_min * -1 / spacing);
            var num_notches_above_origin = Math.floor(y_max / spacing);
            var first_notch_y_value = num_notches_below_origin * spacing * -1;
            var notch_y_value = first_notch_y_value;
            while (notch_y_value <= y_max) {
              var y_notch = new Control2({
                "context": this.context,
                "tag_name": "line"
              });
              var y_location = y_location_from_value(notch_y_value);
              y_notch.set("dom.attributes", {
                "width": length,
                "height": 2,
                "x1": x_origin - length,
                "y1": y_location,
                "x2": x_origin,
                "y2": y_location,
                "stroke": "#AAAAAA",
                "stroke-width": 2
                //'xmlns': 'http://www.w3.org/2000/svg',
                //'version': '1.1'
              });
              svg.add(y_notch);
              notch_y_value += spacing;
            }
          };
          var add_x_axis_major_notches = function() {
            add_x_notch_group(x_major_notch_spacing, 20);
          };
          var add_x_axis_minor_notches = function() {
            add_x_notch_group(x_minor_notch_spacing, 10);
          };
          var add_origin_label = function() {
            var origin_label = new Control2({
              "context": this.context,
              "tag_name": "text"
            });
            origin_label.set("dom.attributes", {
              "x": x_origin - 14,
              "y": y_origin + 14,
              "font-family": "Verdana",
              "font-size": 14
              //,
              //'xmlns': 'http://www.w3.org/2000/svg',
              //'version': '1.1'
            });
            origin_label.add("0");
            svg.add(origin_label);
          };
          var add_y_axis_major_notches = function() {
            add_y_notch_group(y_major_notch_spacing, 20);
          };
          var add_y_axis_minor_notches = function() {
            console.log("x_minor_notch_spacing", y_minor_notch_spacing);
            add_y_notch_group(y_minor_notch_spacing, 10);
          };
          var add_major_x_axis_labels = function() {
            add_x_label_group(x_major_notch_spacing);
          };
          var add_major_y_axis_labels = function() {
            add_y_label_group(y_major_notch_spacing);
          };
          var add_major_axes_labels = function() {
            add_major_x_axis_labels();
            add_major_y_axis_labels();
          };
          add_x_axis_minor_notches();
          add_x_axis_major_notches();
          add_y_axis_minor_notches();
          add_y_axis_major_notches();
          add_x_axis_line();
          add_y_axis_line();
          add_major_axes_labels();
          add_origin_label();
        }
        "render_axes"() {
        }
        "values_from_pixel_location"(px_loc) {
          var el = this.dom.el;
          var w = el.clientWidth;
          var h = el.clientHeight;
          var x_origin = this.x_origin;
          var y_origin = this.y_origin;
          var vert_margin = this.vert_margin;
          var left_margin = this.left_margin;
          var right_margin = this.right_margin;
          var x_axis_length = w - left_margin - right_margin;
          var y_axis_length = h - 2 * vert_margin;
          var range = this.range;
          var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
          var x_range = x_max - x_min, y_range = y_max - y_min;
          var x_scale = x_range / x_axis_length;
          var y_scale = y_range / y_axis_length;
          var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
          var res2 = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
          return res2;
        }
        "pixel_location_from_values"(values) {
          var el = this.dom.el;
          var w, h;
          if (el) {
            w = el.clientWidth;
            h = el.clientHeight;
          } else {
            var size = this.size();
            w = size._[0][0];
            h = size._[1][0];
          }
          var x_origin = this.x_origin;
          var y_origin = this.y_origin;
          var vert_margin = this.vert_margin;
          var left_margin = this.left_margin;
          var right_margin = this.right_margin;
          var x_axis_length = w - left_margin - right_margin;
          var y_axis_length = h - 2 * vert_margin;
          var range = this.range;
          var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
          var x_range = x_max - x_min, y_range = y_max - y_min;
          var x_scale = x_range / x_axis_length;
          var y_scale = y_range / y_axis_length;
          var res2 = [Math.round(x_origin + values[0] * 1 / x_scale), Math.round(y_origin + values[1] * -1 / y_scale)];
          return res2;
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            var that2 = this;
            var el = this.dom.el;
            var w = el.clientWidth;
            var h = el.clientHeight;
            var size = [w, h];
            var vert_margin = this.vert_margin;
            var left_margin = this.left_margin;
            var right_margin = this.right_margin;
            var axis_thickness = this.axis_thickness;
            var x_major_notch_spacing = this.x_major_notch_spacing;
            var y_major_notch_spacing = this.y_major_notch_spacing;
            var x_minor_notch_spacing = this.x_minor_notch_spacing;
            var y_minor_notch_spacing = this.y_minor_notch_spacing;
            var suppress_0_axes_labels = this.suppress_0_axes_labels;
            var x_origin = this.x_origin;
            var y_origin = this.y_origin;
            var range = this.range;
            var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
            var y_axis_is_at_origin = x_min <= 0 && x_max >= 0;
            var x_axis_is_at_origin = y_min <= 0 && y_max >= 0;
            var x_axis_left = left_margin;
            var x_axis_right = w - right_margin;
            var y_axis_top = vert_margin;
            var y_axis_bottom = h - vert_margin;
            var x_axis_length = w - left_margin - right_margin;
            var y_axis_length = h - 2 * vert_margin;
            var x_range = x_max - x_min, y_range = y_max - y_min;
            var x_scale = x_range / x_axis_length;
            var y_scale = y_range / y_axis_length;
            var log_values = function() {
              console.log("x_range", x_range);
              console.log("y_range", y_range);
              console.log("x_scale", x_scale);
              console.log("y_scale", y_scale);
              console.log("left_margin", left_margin);
              console.log("right_margin", right_margin);
              console.log("range", range);
              console.log("tof range", tof(range));
            };
            var context2 = this.context;
            var values_from_pixel_location = function(px_loc) {
              var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
              var res2 = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
              return res2;
            };
            var pixel_location_from_values = function(values) {
              var res2 = [Math.round(origin[0] + values[0] * 1 / x_scale), Math.round(origin[1] + values[1] * -1 / y_scale)];
              return res2;
            };
            var x_location_from_value = function(x_value) {
              return Math.round(x_origin + x_value * 1 / x_scale);
            };
            var y_location_from_value = function(y_value) {
              return Math.round(y_origin + y_value * -1 / y_scale);
            };
            var findPos = function(obj2) {
              var curleft = curtop = 0;
              if (obj2.offsetParent) {
                do {
                  curleft += obj2.offsetLeft;
                  curtop += obj2.offsetTop;
                } while (obj2 = obj2.offsetParent);
              }
              return [curleft, curtop];
            };
            this.add_event_listener("mousemove", function(e_mousemove) {
              var pos = findPos(el);
              var click_x, click_y;
              if (e_mousemove.pageX || e_mousemove.pageY) {
                click_x = e_mousemove.pageX;
                click_y = e_mousemove.pageY;
              }
              var click_pos = [click_x, click_y];
              var pos_within_this = jsgui2.v_subtract(click_pos, pos);
              var values = values_from_pixel_location(pos_within_this);
              e_mousemove.chart_position = values;
            });
            this.add_event_listener("click", function(e_click) {
              var pos = findPos(el);
              var click_x, click_y;
              if (e_click.pageX || e_click.pageY) {
                click_x = e_click.pageX;
                click_y = e_click.pageY;
              }
              var click_pos = [click_x, click_y];
              var pos_within_this = jsgui2.v_subtract(click_pos, pos);
              var values = values_from_pixel_location(pos_within_this);
              e_click.chart_position = values;
            });
          }
        }
      };
      module.exports = Line_Chart;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/1-advanced/login.js
  var require_login = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/1-advanced/login.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Text_Field = require_Text_Field();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Login = class extends Control2 {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.add_class("login-control");
          var req = this.context.req;
          console.log("--- Within Login Control ---");
          var headers = req.headers;
          console.log("headers " + stringify(headers));
          var auth = this.context.auth;
          console.log("auth " + stringify(auth));
          if (auth && auth.verified) {
            var div_logged_in = new jsgui2.div({
              "context": this.context
            });
            var span_logged_in = new jsgui2.span({
              "context": this.context
            });
            span_logged_in.add("Logged in as: " + auth.username);
            div_logged_in.add(span_logged_in);
            var frm = new jsgui2.form({
              "context": this.context
            });
            frm.dom.attrs.set({
              "action": "/logout/?returnurl=%2F",
              "method": "POST"
            });
            div_logged_in.add(frm);
            var btn = new jsgui2.button({
              "context": this.context
            });
            btn.dom.attrs.set({
              "type": "submit",
              "value": "submit",
              "class": "logout"
            });
            btn.add("Logout");
            frm.add(btn);
            this.add(div_logged_in);
          } else {
            var frm = new jsgui2.form({
              "context": this.context
            });
            frm.dom.attrs.set({
              "action": "/logout/?returnurl=%2F",
              "method": "POST"
            });
            this.add(frm);
            var tf_username = new Text_Field({
              "text": "Username",
              "name": "username",
              "value": "",
              "type": "text",
              "context": this.context
            });
            frm.add(tf_username);
            var tf_password = new Text_Field({
              // a name field as well?
              //  a name for the form
              "text": "Password",
              "name": "password",
              "value": "",
              "type": "password",
              "context": this.context
            });
            frm.add(tf_password);
            var btn = new jsgui2.button({
              "context": this.context
            });
            btn.dom.attrs.set({
              "type": "submit",
              "value": "submit",
              "class": "login"
            });
            btn.add("Login");
            frm.add(btn);
          }
        }
      };
      module.exports = Login;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/modal.js
  var require_modal = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/modal.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var def = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var Modal = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "modal";
          super(spec);
          this.add_class("modal");
        }
      };
      module.exports = Modal;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/tile-slide.js
  var require_tile_slide = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/tile-slide.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var fnl = require_fnl();
      var prom_or_cb = fnl.prom_or_cb;
      var Tile_Slider = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = "tile_slider";
          super(spec);
          if (!spec.el) {
            this.compose_tile_slider();
          }
        }
        compose_tile_slider() {
          const context2 = this.context;
          let above = new Control2({
            "contect": context2
          });
          above.add_class("above");
          this.add(above);
          let left = new Control2({
            "contect": context2
          });
          left.add_class("left");
          this.add(left);
          let right = new Control2({
            "contect": context2
          });
          right.add_class("right");
          this.add(right);
          let below = new Control2({
            "contect": context2
          });
          below.add_class("below");
          this.add(below);
          let central = new Control2({
            "contect": context2
          });
          central.add_class("central");
          this.add(central);
          this.above = above;
          this.left = left;
          this.central = central;
          this.right = right;
          this.below = below;
          this._ctrl_fields = {
            "above": above,
            "left": left,
            "central": central,
            "right": right,
            "below": below
          };
          this._fields = {
            "size": this.size
          };
        }
        // Need repositioning after sliding.
        // So the central slide is now the current one.
        //  Could be worth keeping these cached?
        //  For the moment, just want 1 further in each direction.
        // Just the sliding.
        // previous, next
        // previous_major
        // next_major
        //  used for changing years
        // previous_year = previous_major
        // prev2
        // Transitions of the non-framed version would be cool.
        // move_previous
        // does the slide to the left / right
        //  rearrange / arrange things so that the next operation is ready.
        slide_to_left() {
          return prom_or_cb((resolve, reject) => {
            let ms = 333;
            let s = ms / 1e3;
            this.central.dom.attributes.style.transition = "transform " + s + "s";
            this.central.dom.attributes.style.transform = "translate(" + -1 * this.size[0] + "px, 0px)";
            this.right.dom.attributes.style.transition = "transform " + s + "s";
            this.right.dom.attributes.style.transform = "translate(" + -1 * this.size[0] + "px, 0px)";
            this.right.one("transitionend", (e_end) => {
              resolve();
            });
          }, callback);
        }
        slide_to_right(callback2) {
          return prom_or_cb((resolve, reject) => {
            this.central.dom.attributes.style.transition = "transform 0.33s";
            this.central.dom.attributes.style.transform = "translate(" + this.size[0] + "px, 0px)";
            this.left.dom.attributes.style.transition = "transform 0.33s";
            this.left.dom.attributes.style.transform = "translate(" + this.size[0] + "px, 0px)";
            this.left.one("transitionend", (e_end) => {
              resolve();
            });
          }, callback2);
        }
        activate() {
          if (!this.__active) {
            super.activate();
            setTimeout(async () => {
              await this.slide_to_right();
              console.log("awaited slide to right");
            }, 2e3);
          }
        }
      };
      var Tile_Slide = function(Ctrl, fn_prev_spec, fn_next_spec, adjacencies = {
        left: -1,
        right: 1
      }) {
        class Tile_Sliding_Ctrl extends Tile_Slider {
          constructor(spec) {
            let slider_spec = {
              context: spec.context,
              size: spec.size
            };
            super(slider_spec);
            if (spec.size) {
              slider_spec.size = spec.size;
              this.size = spec.size;
            }
            this.spec = spec;
            if (!spec.el) {
              this.compose_tile_sliding_ctrl();
            }
            if (spec.size) {
            }
          }
          compose_tile_sliding_ctrl() {
            let prev_spec = fn_prev_spec(this.spec);
            let next_spec = fn_next_spec(this.spec);
            if (this.spec.size) {
              this.central.size = this.spec.size;
              this.dom.attributes.style.overflow = "hidden";
              this.dom.attributes.style.position = "relative";
              this.left.dom.attributes.style.position = "absolute";
              this.left.dom.attributes.style.left = -1 * this.spec.size[0] + "px";
              this.right.dom.attributes.style.position = "absolute";
              this.right.dom.attributes.style.left = this.spec.size[0] + "px";
              this.left.size = this.spec.size;
              this.right.size = this.spec.size;
            }
            if (adjacencies.left === -1) {
              let left_ctrl_prev = new Ctrl(prev_spec);
              this.left.add(left_ctrl_prev);
            }
            let ctrl2 = new Ctrl(this.spec);
            this.central.add(ctrl2);
            if (adjacencies.right === 1) {
              let left_ctrl_prev = new Ctrl(next_spec);
              this.right.add(left_ctrl_prev);
              if (next_spec.size) {
              }
            }
          }
        }
        return Tile_Sliding_Ctrl;
      };
      Tile_Slider.wrap = Tile_Slide;
      module.exports = Tile_Slider;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/month-view.js
  var require_month_view = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/month-view.js"(exports, module) {
      var jsgui2 = require_html_core();
      var clone = jsgui2.clone;
      var each = jsgui2.each;
      var is_defined = jsgui2.is_defined;
      var Grid = require_grid();
      var Tile_Slider = require_tile_slide();
      var days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
      var bgc_disabled = "#DDDDDD";
      var bgc_enabled = "inherit";
      var mx_date = require_date();
      var Month_View = class extends Grid {
        constructor(spec) {
          spec.grid_size = [7, 7];
          spec.size = spec.size || [360, 200];
          spec.__type_name = "month_view";
          super(spec);
          mx_date(this, spec);
          if (!spec.el) {
            this.compose_month_view();
          }
          this.context.new_selection_scope(this);
        }
        activate() {
          super.activate();
          let cells = this.$("grid_cell");
          each(cells, (cell) => {
            cell.on("change", (e_change) => {
              if (e_change.name === "selected" && e_change.value && is_defined(cell.value)) {
                this.day = cell.value;
              }
            });
          });
        }
        compose_month_view() {
          this.refresh_month_view();
          this.add_class("month-view");
          let days_row = this._arr_rows[0];
          days_row.add_class("days");
          days_row.add_class("header");
          each(days_row.content._arr, (cell, i) => {
            if (cell.span) {
              cell.span.add(days[i]);
            }
          });
          let cell_pos = [0, 1], ctrl_row = this._arr_rows[cell_pos[1]];
          let advance_cell = () => {
            if (cell_pos[0] === ctrl_row.content._arr.length - 1) {
              if (cell_pos[1] < this._arr_rows.length - 1) {
                cell_pos[0] = 0;
                cell_pos[1]++;
                ctrl_row = this._arr_rows[cell_pos[1]];
              } else return false;
            } else {
              cell_pos[0]++;
            }
            return true;
          };
          let d = new Date(this.year, this.month, 1);
          let got_day = d.getDay() - 1;
          if (got_day < 0) got_day = 6;
          while (cell_pos[0] < got_day) {
            let cell = ctrl_row.content._arr[cell_pos[0]++];
            cell.selectable = false;
            cell.select_unique = true;
            cell.background.color = bgc_disabled;
          }
          let did_advance = true;
          while (did_advance) {
            let cell = ctrl_row.content._arr[cell_pos[0]];
            cell.selectable = true;
            cell.select_unique = true;
            cell.value = d.getDate();
            cell._fields = cell._fields || {};
            cell._fields.value = cell.value;
            d.setDate(d.getDate() + 1);
            did_advance = advance_cell() && d.getDate() !== 1;
          }
          while (cell_pos[0] <= 6) {
            let cell = ctrl_row.content._arr[cell_pos[0]++];
            cell.selectable = false;
            cell.select_unique = true;
            cell.background.color = bgc_disabled;
          }
          if (cell_pos[1] < 6) {
            cell_pos = [0, 6];
            ctrl_row = this._arr_rows[cell_pos[1]];
            while (cell_pos[0] <= 6) {
              let cell = ctrl_row.content._arr[cell_pos[0]++];
              cell.selectable = false;
              cell.select_unique = true;
              cell.background.color = bgc_disabled;
            }
          }
        }
        refresh_month_view() {
          let d = new Date(this.year, this.month, 1), m = d.getMonth();
          let got_day = d.getDay() - 1;
          if (got_day < 0) got_day = 6;
          let day = this.day;
          this.each_cell((cell, cell_pos) => {
            let [x, y] = cell_pos;
            if (y > 0) {
              if (y === 1) {
                if (x < got_day) {
                  cell.background.color = bgc_disabled;
                  cell.selectable = false;
                  if (cell.deselect) cell.deselect();
                  cell.value = null;
                  cell.iterate_this_and_subcontrols((ctrl2) => {
                    if (ctrl2.dom.tagName === "span") ctrl2.text = "";
                  });
                } else {
                  cell.background.color = bgc_enabled;
                  cell.selectable = true;
                  cell.span.add(d.getDate() + "");
                  d.setDate(d.getDate() + 1);
                }
              } else {
                let dm = d.getMonth();
                if (dm === m) {
                  cell.background.color = bgc_enabled;
                  cell.selectable = true;
                  cell.span.add(d.getDate() + "");
                  d.setDate(d.getDate() + 1);
                } else {
                  cell.background.color = bgc_disabled;
                  cell.selectable = false;
                  if (cell.deselect) cell.deselect();
                  cell.value = null;
                }
              }
            }
          });
        }
      };
      Month_View.Tiled = Tile_Slider.wrap(Month_View, (spec) => {
        spec = clone(spec);
        if (!is_defined(spec.month)) {
          let now = /* @__PURE__ */ new Date();
          spec.month = now.getMonth();
          spec.year = now.getFullYear();
        }
        spec.month = spec.month - 1;
        if (spec.month < 0) {
          spec.month = 11;
          spec.year = spec.year - 1;
        }
        return spec;
      }, (spec) => {
        spec = clone(spec);
        if (!is_defined(spec.month)) {
          let now = /* @__PURE__ */ new Date();
          spec.month = now.getMonth();
          spec.year = now.getFullYear();
        }
        spec.month = spec.month + 1;
        if (spec.month > 11) {
          spec.month = 0;
          spec.year = spec.year + 1;
        }
        return spec;
      });
      module.exports = Month_View;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/radio-button.js
  var require_radio_button = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/radio-button.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var group = jsgui2.group;
      var Radio_Button = class extends Control2 {
        // panel name?
        // could have a title field.
        // Items field could be an array.
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "radio_button";
          this.add_class("radio-button");
          var context2 = this.context;
          if (spec.group_name) this.group_name = spec.group_name;
          if (spec.text) this.text = spec.text;
          if (spec.label) this.text = spec.label;
          if (!spec.abstract && !spec.el) {
            var name = this.group_name;
            var html_radio = new Control2({
              context: context2
            });
            {
              const { dom } = html_radio;
              dom.tagName = "input";
              const { attributes } = dom;
              attributes.type = "radio";
              attributes.name = name;
              attributes.id = html_radio._id();
            }
            var html_label = new Control2({
              "context": context2
            });
            html_label.dom.tagName = "label";
            var text_value = this.text + "";
            if (is_defined(text_value)) {
              html_label.add(text_value);
            }
            html_label.dom.attributes.for = html_radio._id();
            this.add(html_radio);
            this.add(html_label);
          }
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            super.activate();
            var radio = this.radio;
            var label = this.label;
          }
        }
      };
      module.exports = Radio_Button;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/radio-button-group.js
  var require_radio_button_group = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/radio-button-group.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var group = jsgui2.group;
      var Radio_Button = require_radio_button();
      var Radio_Button_Group = class extends Control2 {
        // panel name?
        // Should not need to give a group name...
        //'fields': {
        //    'items': Array
        //},
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "radio_button_group";
          this.add_class("radio-button-group");
          var context2 = this.context;
          if (!spec.abstract && !spec.el) {
            var id = this._id();
            var items = this.get("items").value();
            each(items, (v, i) => {
              var radio_button = new Radio_Button({
                "context": context2,
                "name": id,
                "text": v,
                "value": v
              });
              this.add(radio_button);
            });
          }
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            var that2 = this;
            super.activate();
            var ctrl_checked;
            this.content.each(function(ctrl2, i) {
              ctrl2.on("change", false, function(e_change) {
                ctrl_checked = ctrl2;
                that2.raise("change", {
                  "checked": ctrl_checked
                });
              });
            });
          }
        }
      };
      module.exports = Radio_Button_Group;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/tabbed-panel.js
  var require_tabbed_panel = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/tabbed-panel.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Control2 = jsgui2.Control;
      var mx_selectable = require_selectable();
      var { each, is_array, tof } = jsgui2;
      var Panel = require_panel();
      var List = require_list();
      var Radio_Button_Group = require_radio_button_group();
      var Radio_Button = require_radio_button();
      var Tab = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "tab";
          super(spec);
          let _group_name;
          Object.defineProperty(this, "group_name", {
            get() {
              return _group_name;
            },
            set(value2) {
              let old = _group_name;
              _group_name = value2;
              this.raise("change", { "name": "group_name", "old": old, "value": value2 });
            }
          });
          _group_name = spec.group_name;
          let _name;
          Object.defineProperty(this, "name", {
            get() {
              return _name;
            },
            set(value2) {
              let old = _name;
              _name = value2;
              this.raise("change", { "name": "name", "old": old, "value": value2 });
            }
          });
          _name = spec.name;
          this.add_class("tab");
          mx_selectable(this);
          this.selectable = true;
          if (!spec.el) {
            this.construct_tab();
          }
        }
        construct_tab() {
          const { context: context2 } = this;
          const radio_button = new Radio_Button({
            context: context2,
            group_name: this.group_name,
            text: this.name
          });
          this.add(radio_button);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.radio_button = radio_button;
          (this._fields = this._fields || {}).name = this.name;
        }
      };
      Tab.css = `
.tab { }
`;
      var Tab_Group = class extends List {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "tab_group";
          super(spec);
          this.add_class("tab-group");
          this.tab_names = spec.tab_names || spec.tabs;
          if (!spec.el) {
            this.compose_tab_group();
          }
        }
        compose_tab_group() {
          each(this.tab_names, (tab_name) => {
            this.add(new Tab({
              context: this.context,
              name: tab_name,
              group_name: this.__id
            }));
          });
        }
      };
      Tab_Group.css = `
.tab-group {
    display: flex;
    column-gap: 6px;
}
`;
      var Tabbed_Panel = class extends Panel {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "tabbed_panel";
          super(spec);
          this.add_class("tab-container");
          this.tabs = spec.tabs;
          if (!spec.el) {
            this.compose_tabbed_panel(spec.tabs);
          }
        }
        compose_tabbed_panel(tabs_def) {
          const { context: context2 } = this;
          this.tab_pages = [];
          const add_tab = (name, group_name) => {
            var html_radio = new Control2({ context: context2 });
            {
              const { dom } = html_radio;
              dom.tagName = "input";
              const { attributes } = dom;
              attributes.type = "radio";
              attributes.name = group_name;
            }
            html_radio.add_class("tab-input");
            this.add(html_radio);
            html_radio.dom.attributes.id = html_radio.__id;
            const label = new jsgui2.controls.label({ context: context2 });
            label.dom.attributes.for = html_radio.dom.attributes.id;
            label.add_class("tab-label");
            label.add(name);
            this.add(label);
            const tab_page = new Control2({ context: context2 });
            tab_page.add_class("tab-page");
            this.tab_pages.push(tab_page);
            this.add(tab_page);
            return tab_page;
          };
          let i_tab = 0;
          each(this.tabs, (tab) => {
            const group_name = this._id();
            const t = tof(tab);
            if (t === "string") {
              add_tab(tab, group_name);
              i_tab++;
            } else {
              if (t === "array") {
                const tab_label_text = tab[0];
                const tab_content = tab[1];
                const tab_page = add_tab(tab_label_text, group_name);
                tab_page.add(tab_content);
              } else {
                console.log("tab", tab);
                console.log("t", t);
                throw "NYI";
              }
            }
          });
          const ctrl_break = new Control2({ context: context2 });
          ctrl_break.add_class("break");
          this.add(ctrl_break);
          this._ctrl_fields = this._ctrl_fields || {};
        }
        activate() {
          if (!this.__active) {
            this.__active = true;
            const tab_pages = [];
            each(this.content._arr, (ctrl2) => {
              if (ctrl2.has_class("tab-page")) {
                tab_pages.push(ctrl2);
              }
            });
            this.tab_pages = tab_pages;
            console.log("tab_pages.length", tab_pages.length);
          }
        }
      };
      Tabbed_Panel.css = `
.tab-container {
    display: flex;
    flex-wrap: wrap;
    flex-direction: row; /* Change to 'row' for top or bottom tabs */
    width: 300px; /* Adjust width as needed */
    position: relative;
    height: 300px;
}
.break {
    flex-basis: 100%;
    height: 0;
}
.tab-input {
    display: none;
}
.tab-label {
    height: 22px;
    background-color: #ccc;
    padding: 4px;
    margin: 2px;
    cursor: pointer;
}
.tab-input:checked + .tab-label {
    background-color: #DDFFDD;
}
.tab-input:checked + .tab-label + .tab-page {
    display: block;
}
.tab-page {
    display: none;
    


    /*
    order: 100;
    left: 4px;
    right: 4px;
    top: 32px;
    */


    /* height: calc(100% - 32px); */

    height: 300px;
    width: 300px;
    background-color: #FFFFFF;
    border: 1px solid #CCCCCC;
}
`;
      module.exports = Tabbed_Panel;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/app/multi-layout-mode.js
  var require_multi_layout_mode = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/app/multi-layout-mode.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Panel = require_panel();
      var Tabbed_Panel = require_tabbed_panel();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var group = jsgui2.group;
      var Multi_Layout_Mode = class extends Control2 {
        // could have a title field.
        //'fields': {
        //	'title': String
        //},
        // maybe add before make would be better. add will probably be used more.
        constructor(spec) {
          spec.__type_name = spec.__type_name || "multi_layout_mode";
          super(spec);
          this.layout_mode = spec.layout_mode;
          var make = this.context.make;
          var context2 = this.context;
          this.add_class("multi-layout-mode");
          if (!spec.el) {
            this.compose_mlm();
          }
          this._features = this._features || [];
        }
        "compose_mlm"() {
          var layout_mode = this.layout_mode;
          let context2 = this.context;
          if (layout_mode) {
            this.add_class(layout_mode);
          }
          var panel_title = new Panel({
            "context": context2,
            "name": "title",
            "class": "title"
          });
          var panel_navigation = new Panel({
            "context": context2,
            "name": "navigation",
            "class": "navigation"
          });
          var panel_main = new Panel({
            "context": context2,
            "name": "main",
            "class": "main"
          });
          var panel_misc = new Panel({
            "context": context2,
            "name": "misc",
            "class": "misc"
          });
          if (layout_mode == "fluid-fixed") {
            var panel_top = new Panel({
              "context": context2,
              "name": "top"
            });
            panel_top.add_class("top");
            var panel_left_wrapper = new Panel({
              "context": context2,
              "name": "left-wrapper"
            });
            panel_left_wrapper.add_class("left-wrapper");
            var panel_left = new Panel({
              "context": context2,
              "name": "left"
            });
            panel_left.add_class("left");
            var panel_right = new Panel({
              "context": context2,
              "name": "right"
            });
            panel_right.add_class("right");
            var panel_bottom = new Panel({
              "context": context2,
              "name": "bottom"
            });
            panel_bottom.add_class("bottom");
            this.add(panel_top);
            this.add(panel_left_wrapper);
            panel_left_wrapper.add(panel_left);
            this.add(panel_right);
            this.add(panel_bottom);
            panel_top.add(panel_title);
            panel_bottom.add(panel_navigation);
            panel_left.add(panel_main);
            panel_right.add(panel_misc);
          } else if (layout_mode === "tools-at-top") {
            this.add(panel_title);
            this.add(panel_navigation);
            var main_column = new Control2({
              "context": context2,
              "class": "main-column"
            });
            this.add(main_column);
            main_column.add(panel_misc);
            main_column.add(panel_main);
          } else {
            this.add(panel_title);
            this.add(panel_navigation);
            this.add(panel_main);
            this.add(panel_misc);
          }
          this.title = panel_title;
          this.nav = this.navigation = panel_navigation;
          this.main = panel_main;
          this.misc = panel_misc;
          this._ctrl_fields = this._ctrl_fields || {};
          Object.assign(this._ctrl_fields, {
            "title": panel_title,
            "nav": panel_navigation,
            "main": panel_main,
            "misc": panel_misc
          });
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
          }
        }
        //,
        // Takes on the menu of the maximized window (for the moment).
        //  Could have its own menu possibly
        //'menu': function(menu_spec) {
        //}
      };
      module.exports = Multi_Layout_Mode;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/1-editor/property_editor.js
  var require_property_editor = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/1-editor/property_editor.js"(exports, module) {
      var Panel = require_panel();
      var Control2 = require_control();
      var Text_Input = require_Text_Input();
      var Checkbox = require_checkbox();
      var Property_Editor = class extends Panel {
        constructor(options = {}) {
          super(options);
          this.add_class("property-editor");
          const { context: context2 } = this;
          this.header = new Control2({ context: context2, tag_name: "div" });
          this.header.add_class("property-editor-header");
          this.header_title = new Control2({ context: context2, tag_name: "h3" });
          this.header_title.add("Properties");
          this.header.add(this.header_title);
          this.add(this.header);
          this.properties_container = new Control2({ context: context2, tag_name: "div" });
          this.properties_container.add_class("property-editor-properties");
          this.add(this.properties_container);
          this.no_selection_message = new Control2({ context: context2, tag_name: "div" });
          this.no_selection_message.add_class("property-editor-no-selection");
          this.no_selection_message.add("Select a field to edit its properties");
          this.properties_container.add(this.no_selection_message);
          this.current_item = null;
          this.property_fields = {};
        }
        /**
         * Load properties for an item
         */
        load_item(item2, on_change) {
          this.current_item = item2;
          this.on_change = on_change;
          this.property_fields = {};
          this.properties_container.content.clear();
          if (!item2) {
            this.properties_container.add(this.no_selection_message);
            return;
          }
          const { context: context2 } = this;
          const properties = item2.properties || {};
          this._add_property_group(context2, "Field Type", properties.type || "text", null, true);
          this._add_property_group(context2, "Label", properties.label || "", (value2) => {
            properties.label = value2;
            if (this.on_change) this.on_change();
          });
          this._add_property_group(context2, "Name/ID", properties.name || "", (value2) => {
            properties.name = value2;
            if (this.on_change) this.on_change();
          });
          if (["text", "email", "password", "number", "url", "tel", "textarea"].includes(properties.type)) {
            this._add_property_group(context2, "Placeholder", properties.placeholder || "", (value2) => {
              properties.placeholder = value2;
              if (this.on_change) this.on_change();
            });
          }
          this._add_property_checkbox(context2, "Required", properties.required || false, (checked) => {
            properties.required = checked;
            if (this.on_change) this.on_change();
          });
          if (properties.type === "select") {
            this._add_property_group(
              context2,
              "Options (comma-separated)",
              (properties.options || []).join(", "),
              (value2) => {
                properties.options = value2.split(",").map((s) => s.trim()).filter((s) => s);
                if (this.on_change) this.on_change();
              }
            );
          }
          this._add_property_group(context2, "Width (%)", properties.width || "100", (value2) => {
            properties.width = value2;
            if (this.on_change) this.on_change();
          });
          const delete_btn = new Control2({ context: context2, tag_name: "button" });
          delete_btn.add_class("property-editor-delete-btn");
          delete_btn.add("Delete Field");
          delete_btn.on("click", () => {
            if (this.on_delete) this.on_delete(item2);
          });
          this.properties_container.add(delete_btn);
        }
        _add_property_group(context2, label, value2, on_change, read_only = false) {
          const group = new Control2({ context: context2, tag_name: "div" });
          group.add_class("property-group");
          const label_el = new Control2({ context: context2, tag_name: "label" });
          label_el.add_class("property-label");
          label_el.add(label);
          group.add(label_el);
          const input = new Text_Input({ context: context2 });
          input.add_class("property-input");
          input.dom.el.value = value2;
          if (read_only) input.dom.el.disabled = true;
          if (on_change && !read_only) {
            input.on("input", () => {
              on_change(input.dom.el.value);
            });
          }
          group.add(input);
          this.properties_container.add(group);
          this.property_fields[label] = input;
          return group;
        }
        _add_property_checkbox(context2, label, checked, on_change) {
          const group = new Control2({ context: context2, tag_name: "div" });
          group.add_class("property-group");
          group.add_class("property-group-checkbox");
          const checkbox = new Checkbox({ context: context2 });
          checkbox.add_class("property-checkbox");
          checkbox.dom.el.checked = checked;
          if (on_change) {
            checkbox.on("change", () => {
              on_change(checkbox.dom.el.checked);
            });
          }
          const label_el = new Control2({ context: context2, tag_name: "label" });
          label_el.add_class("property-label");
          label_el.add(label);
          group.add(checkbox);
          group.add(label_el);
          this.properties_container.add(group);
          this.property_fields[label] = checkbox;
          return group;
        }
        /**
         * Set the delete callback
         */
        set_on_delete(callback2) {
          this.on_delete = callback2;
        }
      };
      module.exports = Property_Editor;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/1-advanced/popup-menu-button.js
  var require_popup_menu_button = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/1-advanced/popup-menu-button.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Button = require_button();
      var Item = require_item();
      var Collection = jsgui2.Collection;
      var Data_Value2 = jsgui2.Data_Value;
      var Popup_Menu_Button = class extends Button {
        // panel name?
        // could have a title field.
        //'fields': {
        //    'name': String
        //}
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          spec.no_compose = true;
          spec["class"] = "popup-menu-button";
          super(spec);
          this.__type_name = "popup_menu_button";
          var context2 = this.context;
          var setup_mixins = function() {
            this.mixin(
              ["open_closed", "closed"],
              ["item_container"]
            );
          };
          this.states = ["closed", "open"];
          this.state = new Data_Value2("closed");
          this.i_state = 0;
          var active_fields = this.active_fields = {};
          active_fields.states = this.states;
          active_fields.state = this.state;
          active_fields.i_state = this.i_state;
          var compose = () => {
            this.text = spec.text || spec.label || "";
            var root_menu_item = new Item({
              "context": context2,
              "item": this.text
            });
            root_menu_item.add_class("popup-menu");
            this.add(root_menu_item);
            root_menu_item.inner.add_class("popup-menu");
            this.root_menu_item = root_menu_item;
            if (spec.items) {
              let items = this.items = new Collection(spec.items);
              each(items, (item2) => {
                var menu_item = new Item({
                  "context": context2,
                  "item": item2
                });
                menu_item.add_class("popup-menu");
                root_menu_item.inner.add(menu_item);
              });
            }
            ;
            var ctrl_fields = {
              "root_menu_item": root_menu_item._id()
            };
            this.dom.attrs["data-jsgui-fields"] = stringify(active_fields).replace(/"/g, "'");
            this.dom.attrs["data-jsgui-ctrl-fields"] = stringify(ctrl_fields).replace(/"/g, "'");
          };
          if (!spec.abstract && !spec.el) {
            compose();
          }
          if (spec.el) {
            compose();
          }
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            super.activate();
            var root_menu_item = this.root_menu_item;
            this.state.on("change", (e_change) => {
              var val = e_change.value;
              if (val === "open") {
                root_menu_item.inner.pop_into_body();
                this.one_mousedown_elsewhere((e_mousedown_elsewhere) => {
                  console.log("e_mousedown_elsewhere", e_mousedown_elsewhere);
                  setTimeout(function() {
                    this.i_state = 0;
                    this.state.set("closed");
                  }, 300);
                });
              }
              ;
              root_menu_item.state.set(val);
            });
            root_menu_item.on("click", (e_click) => {
              var new_i_state = that.i_state + 1;
              if (new_i_state === that.states.length) {
                new_i_state = 0;
              }
              this.i_state = new_i_state;
              this.state.set(that.states[new_i_state]);
            });
            root_menu_item.inner.content.each((inner_menu_item) => {
              inner_menu_item.on("click", (e_click) => {
                root_menu_item.state.set("closed");
                this.i_state = 0;
              });
            });
          }
        }
      };
      module.exports = Popup_Menu_Button;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/1-editor/Rich_Text_Editor.js
  var require_Rich_Text_Editor = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/1-editor/Rich_Text_Editor.js"(exports, module) {
      var Control2 = require_control();
      var Rich_Text_Editor = class extends Control2 {
        constructor(options = {}) {
          options.__type_name = options.__type_name || "rich_text_editor";
          super(options);
          const { context: context2 } = this;
          this.add_class("rich-text-editor");
          this.config = {
            placeholder: options.placeholder || "Start typing...",
            initial_html: options.initial_html || "",
            min_height: options.min_height || "200px",
            max_height: options.max_height || "500px",
            toolbar_position: options.toolbar_position || "top",
            // top, bottom, floating
            on_change: options.on_change || null,
            read_only: options.read_only || false
          };
          this._create_toolbar(context2);
          this._create_editor(context2);
          this.is_dirty = false;
          this.last_html = "";
        }
        /**
         * Create the formatting toolbar
         */
        _create_toolbar(context2) {
          this.toolbar = new Control2({ context: context2, tag_name: "div" });
          this.toolbar.add_class("rte-toolbar");
          const buttons = [
            ["bold", "<strong>B</strong>", "Bold (Ctrl+B)"],
            ["italic", "<em>I</em>", "Italic (Ctrl+I)"],
            ["underline", "<u>U</u>", "Underline (Ctrl+U)"],
            ["separator"],
            ["insertUnorderedList", "\u2022 List", "Bullet List"],
            ["insertOrderedList", "1. List", "Numbered List"],
            ["separator"],
            ["createLink", "\u{1F517}", "Insert Link", this._handle_create_link.bind(this)],
            ["unlink", "\u{1F517}\u2717", "Remove Link"],
            ["separator"],
            ["removeFormat", "\u2717", "Clear Formatting"]
          ];
          buttons.forEach((btn_def) => {
            if (btn_def[0] === "separator") {
              const sep = new Control2({ context: context2, tag_name: "span" });
              sep.add_class("rte-toolbar-separator");
              this.toolbar.add(sep);
            } else {
              const [command, icon, title, custom_handler] = btn_def;
              const button = new Control2({ context: context2, tag_name: "button" });
              button.add_class("rte-toolbar-button");
              button.dom.attributes.type = "button";
              button.dom.attributes.title = title;
              button.dom.attributes["data-command"] = command;
              button.dom.innerHTML = icon;
              if (custom_handler) {
                button.custom_handler = custom_handler;
              }
              this.toolbar.add(button);
            }
          });
          this.add(this.toolbar);
        }
        /**
         * Create the contenteditable editor area
         */
        _create_editor(context2) {
          this.editor_container = new Control2({ context: context2, tag_name: "div" });
          this.editor_container.add_class("rte-editor-container");
          this.editor = new Control2({ context: context2, tag_name: "div" });
          this.editor.add_class("rte-editor");
          this.editor.dom.attributes.contenteditable = "true";
          this.editor.dom.attributes["data-placeholder"] = this.config.placeholder;
          if (this.config.initial_html) {
            this.editor.dom.innerHTML = this.config.initial_html;
          }
          if (this.editor.dom.el) {
            this.editor.dom.el.style.minHeight = this.config.min_height;
            this.editor.dom.el.style.maxHeight = this.config.max_height;
          }
          if (this.config.read_only && this.editor.dom.el) {
            this.editor.dom.el.contentEditable = "false";
          }
          this.editor_container.add(this.editor);
          this.add(this.editor_container);
        }
        /**
         * Activate - attach event listeners (client-only)
         */
        activate() {
          if (!this.__active) {
            super.activate();
            const toolbar_buttons = this.toolbar.dom.el.querySelectorAll(".rte-toolbar-button");
            toolbar_buttons.forEach((btn) => {
              btn.addEventListener("click", (e) => {
                e.preventDefault();
                const command = btn.getAttribute("data-command");
                const button_control = Array.from(this.toolbar.content._items).find(
                  (item2) => item2.dom && item2.dom.el === btn
                );
                if (button_control && button_control.custom_handler) {
                  button_control.custom_handler(command);
                } else {
                  this._execute_command(command);
                }
                this.editor.dom.el.focus();
              });
            });
            this.editor.dom.el.addEventListener("input", () => {
              this.is_dirty = true;
              this._handle_change();
            });
            this.editor.dom.el.addEventListener("paste", (e) => {
              e.preventDefault();
              const text = e.clipboardData.getData("text/plain");
              document.execCommand("insertText", false, text);
            });
            this.editor.dom.el.addEventListener("keydown", (e) => {
              if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                  case "b":
                    e.preventDefault();
                    this._execute_command("bold");
                    break;
                  case "i":
                    e.preventDefault();
                    this._execute_command("italic");
                    break;
                  case "u":
                    e.preventDefault();
                    this._execute_command("underline");
                    break;
                }
              }
            });
            document.addEventListener("selectionchange", () => {
              if (this.editor.dom.el.contains(document.activeElement)) {
                this._update_toolbar_states();
              }
            });
            this._update_toolbar_states();
          }
        }
        /**
         * Execute a formatting command
         */
        _execute_command(command, value2 = null) {
          document.execCommand(command, false, value2);
          this._handle_change();
        }
        /**
         * Handle link creation (custom handler)
         */
        _handle_create_link(command) {
          const selection = window.getSelection();
          if (selection.rangeCount === 0 || selection.isCollapsed) {
            alert("Please select text to create a link");
            return;
          }
          const url = prompt("Enter URL:", "https://");
          if (url && url.trim() !== "" && url !== "https://") {
            if (!url.startsWith("http://") && !url.startsWith("https://") && !url.startsWith("mailto:")) {
              alert("URL must start with http://, https://, or mailto:");
              return;
            }
            this._execute_command("createLink", url);
          }
        }
        /**
         * Update toolbar button active states based on current selection
         */
        _update_toolbar_states() {
          const toolbar_buttons = this.toolbar.dom.el.querySelectorAll(".rte-toolbar-button");
          toolbar_buttons.forEach((btn) => {
            const command = btn.getAttribute("data-command");
            try {
              const is_active = document.queryCommandState(command);
              if (is_active) {
                btn.classList.add("active");
              } else {
                btn.classList.remove("active");
              }
            } catch (e) {
              btn.classList.remove("active");
            }
          });
        }
        /**
         * Handle content change
         */
        _handle_change() {
          const current_html = this.get_html();
          if (current_html !== this.last_html) {
            this.last_html = current_html;
            if (this.config.on_change) {
              this.config.on_change(current_html);
            }
          }
        }
        /**
         * Get HTML content from editor
         */
        get_html() {
          if (!this.editor.dom.el) {
            return this.config.initial_html || "";
          }
          const html = this.editor.dom.el.innerHTML;
          return this._sanitize_html(html);
        }
        /**
         * Set HTML content in editor
         */
        set_html(html) {
          const sanitized = this._sanitize_html(html);
          if (this.editor.dom.el) {
            this.editor.dom.el.innerHTML = sanitized;
          }
          this.last_html = sanitized;
          this.is_dirty = false;
        }
        /**
         * Get plain text content (strips all HTML)
         */
        get_text() {
          if (!this.editor.dom.el) {
            return "";
          }
          return this.editor.dom.el.textContent || "";
        }
        /**
         * Basic HTML sanitization
         * Removes dangerous tags and attributes
         * 
         * TODO Phase 2: Replace with DOMPurify for production
         * This is a minimal implementation for MVP
         */
        _sanitize_html(html) {
          if (!html) return "";
          html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "");
          html = html.replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, "");
          html = html.replace(/\s*on\w+\s*=\s*[^\s>]*/gi, "");
          html = html.replace(/href\s*=\s*["']javascript:[^"']*["']/gi, "");
          const dangerous_tags = ["script", "iframe", "object", "embed", "form", "input", "button"];
          dangerous_tags.forEach((tag) => {
            const regex = new RegExp(`<${tag}\\b[^<]*(?:(?!<\\/${tag}>)<[^<]*)*<\\/${tag}>`, "gi");
            html = html.replace(regex, "");
          });
          return html;
        }
        /**
         * Clear all content
         */
        clear() {
          this.set_html("");
        }
        /**
         * Check if editor has content
         */
        is_empty() {
          const text = this.get_text().trim();
          return text.length === 0;
        }
        /**
         * Set read-only mode
         */
        set_read_only(read_only) {
          this.config.read_only = read_only;
          if (this.editor.dom.el) {
            this.editor.dom.el.contentEditable = read_only ? "false" : "true";
          }
          if (read_only) {
            this.toolbar.add_class("disabled");
          } else {
            this.toolbar.remove_class("disabled");
          }
        }
        /**
         * Focus the editor
         */
        focus() {
          if (this.editor.dom.el) {
            this.editor.dom.el.focus();
          }
        }
        /**
         * Get character count
         * TODO Phase 4: Add to UI, show live count below editor
         */
        get_character_count() {
          return this.get_text().length;
        }
        /**
         * Get word count
         * TODO Phase 4: Add to UI, show alongside character count
         */
        get_word_count() {
          const text = this.get_text().trim();
          if (text.length === 0) return 0;
          return text.split(/\s+/).length;
        }
      };
      module.exports = Rich_Text_Editor;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/scrollbar.js
  var require_scrollbar = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/scrollbar.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Button = require_button();
      var Scrollbar = class extends Control2 {
        // Though maybe tell it to be an array and it should be an array rather than a collection?
        //  Or a Data_Value that holds an array?
        //'fields': [
        //    ['text', String],
        //    ['state', String],
        //    ['states', Array]
        //],
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "scrollbar";
          this.active();
          var that2 = this;
          var context2 = this.context;
          if (!spec.abstract && !spec.el) {
            this.add_class("scrollbar");
            var btn_negitive = new Button({
              "context": context2
            });
            var scroll_area = new Control2({
              "context": context2
            });
            var dragable_scroller = new Control2({
              "context": context2
            });
            var btn_positive = new Button({
              "context": context2
            });
            this.add(btn_negitive);
            scroll_area.add(dragable_scroller);
            this.add(scroll_area);
            this.add(btn_positive);
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            var that2 = this;
          }
        }
      };
      var Horizontal_Scrollbar = class extends Scrollbar {
        constructor(spec) {
          super(spec);
          this.__direction = "horizontal";
        }
      };
      var Vertical_Scrollbar = class extends Scrollbar {
        constructor(spec) {
          super(spec);
          this.__direction = "vertical";
        }
      };
      Scrollbar.H = Scrollbar.Horizontal = Horizontal_Scrollbar;
      Scrollbar.V = Scrollbar.Vertical = Vertical_Scrollbar;
      module.exports = Scrollbar;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/scroll-view.js
  var require_scroll_view = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/scroll-view.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Scrollbar = require_scrollbar();
      var H_Scrollbar = Scrollbar.H;
      var V_Scrollbar = Scrollbar.V;
      var Scroll_View = class extends Control2 {
        // Though maybe tell it to be an array and it should be an array rather than a collection?
        //  Or a Data_Value that holds an array?
        //'fields': [
        //    ['text', String],
        //    ['state', String],
        //    ['states', Array]
        //],
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "toggle_button";
          this.add_class("scrollbar");
          if (!spec.abstract && !spec.el) {
            var inner_view = new Control2({
              "context": this.context
            });
            var h_scrollbar = new H_Scrollbar({
              "context": this.context
            });
            var v_scrollbar = new V_Scrollbar({
              "context": this.context
            });
            this.add(inner_view);
            this.add(h_scrollbar);
            this.add(v_scrollbar);
            this.active();
          }
          var that2 = this;
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            var that2 = this;
          }
        }
      };
      module.exports = Scroll_View;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/search-bar.js
  var require_search_bar = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/search-bar.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { Control: Control2 } = jsgui2;
      var view_model_spec = {
        name: "search_bar",
        version: "0.0.1",
        type: "control",
        fields: {
          number_of_lines: 1
        },
        actions: ["search"]
      };
      var { prop, field } = require_oext();
      var Search_Bar = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "search_bar";
          super(spec);
          this.add_class("search-bar");
          field(this, "value");
          if (!spec.el) {
            const jsguiml = '<Text_Input name="input"></Text_Input><Button name="btn"></Button>';
            jsgui2.parse_mount(jsguiml, this, jsgui2.controls);
          }
        }
        // onkeypress 
        activate() {
          if (!this.__active) {
            super.activate();
            const { input, btn } = this;
            input.on("change", (e_change) => {
              const { name, value: value2 } = e_change;
              if (name === "value") {
                this.value = value2;
              }
            });
          }
        }
      };
      Search_Bar.prototype.view_model_spec = view_model_spec;
      module.exports = Search_Bar;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/Select_Options.js
  var require_Select_Options = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/Select_Options.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { Control: Control2, Control_Data, Control_View, Data_Object, is_array, is_arr_of_strs, each } = jsgui2;
      var { field } = require_oext();
      var Select_Options = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "select_options";
          spec.tag_name = "select";
          super(spec);
          const { context: context2 } = this;
          const construct_synchronised_data_and_view_models = () => {
            this.data = new Control_Data({ context: context2 });
            if (spec.data && spec.data.model) {
              this.data.model = spec.data.model;
            } else {
              this.data.model = new Data_Object({ context: context2 });
              field(this.data.model, "value");
              field(this.data.model, "options");
            }
            this.view = new Control_View({ context: context2 });
            if (spec.view && spec.view.data.model) {
              this.view.data.model = spec.view.data.model;
            } else {
              this.view.data.model = new Data_Object({ context: context2 });
              field(this.view.data.model, "value");
              field(this.view.data.model, "options");
            }
            this.data.model.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "value") {
                if (value2 !== old) {
                  this.view.data.model.value = value2;
                }
              } else if (name === "options") {
                if (value2 !== old) {
                  this.view.data.model.options = value2;
                }
              }
            });
            this.view.data.model.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "value") {
                if (value2 !== old) {
                  this.data.model.value = value2;
                  if (this.dom.el) {
                    this.dom.el.value = value2;
                  }
                }
              } else if (name === "options") {
                if (value2 !== old) {
                  this.data.model.options = value2;
                }
              }
            });
          };
          construct_synchronised_data_and_view_models();
          if (spec.options) {
            this.data.model.options = spec.options;
          }
          if (!spec.el) {
            this.compose();
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const { dom } = this;
            const activate_view_model_to_dom_model_sync = () => {
              this.add_dom_event_listener("change", (e) => {
                console.log("dom.el.value", dom.el.value);
                this.view.data.model.value = dom.el.value;
              });
            };
            activate_view_model_to_dom_model_sync();
          }
        }
        compose() {
          const { context: context2 } = this;
          const dm_options = this.data.model.options;
          if (is_array(dm_options)) {
            if (is_arr_of_strs(dm_options)) {
              console.log("dm_options is an array of strings");
              each(dm_options, (str_option) => {
                const ctrl_option = new jsgui2.option({
                  context: context2
                });
                ctrl_option.dom.attributes.value = str_option;
                ctrl_option.add(str_option);
                this.add(ctrl_option);
              });
            }
          }
        }
      };
      module.exports = Select_Options;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/single-line.js
  var require_single_line = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/single-line.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Single_Line = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        constructor(spec) {
          super(spec);
          this.add_class("single-line");
          this.__type_name = "single_line";
          var value2 = this.value;
          var display_value;
          var meta_field = this.get("meta_field");
          if (meta_field) {
            display_value = value2.meta.get(meta_field.value());
          }
          var el = this.dom.el;
          if (!el) {
            var span = new jsgui2.span({
              "context": this.context
              //,
              //'content': display_value
            });
            if (display_value) {
              span.add(display_value);
            }
            this.add(span);
            this.set("span", span);
          }
        }
        "activate"() {
          super.activate();
          var content = this.content;
          var span = content.get(0);
          var val = span.dom.el.innerHTML;
          this.value = val;
        }
      };
      module.exports = Single_Line;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/3-page/standard-web-page.js
  var require_standard_web_page = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/3-page/standard-web-page.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Standard_Web_Page = class extends jsgui2.Blank_HTML_Document {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Standard_Web_Page;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/start-stop-toggle-button.js
  var require_start_stop_toggle_button = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/start-stop-toggle-button.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Toggle_Button = require_toggle_button();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Start_Stop_Toggle_Button = class extends Toggle_Button {
        //'fields': [
        //['text', String]
        //],
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          spec.states = ["start", "stop"];
          spec.state = spec.state || "start";
          super(spec);
          this.__type_name = "start_stop_toggle_button";
          this.add_class("start-stop toggle-button");
          this.on("change", (e_change) => {
            const { name, value: value2 } = e_change;
            if (name === "state") {
              if (value2 === "stop") {
                this.raise("start");
              }
              if (value2 === "start") {
                this.raise("stop");
              }
            }
          });
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
          }
        }
      };
      module.exports = Start_Stop_Toggle_Button;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/1-advanced/string-span.js
  var require_string_span = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/1-advanced/string-span.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { controls, parse, each, are_equal } = jsgui2;
      var { Control: Control2, Text_Node } = controls;
      var Button = require_button();
      var { field, prop } = require_oext();
      var press_events = require_press_events();
      var watch_resize = (ctrl2) => {
        let last_size = ctrl2.bcr();
        const inner = () => {
          requestAnimationFrame((timestamp) => {
            const current_size = ctrl2.bcr();
            const same_size = are_equal(last_size, current_size);
            if (same_size) {
            } else {
              ctrl2.raise("resize");
              last_size = current_size;
            }
            inner();
          });
        };
        inner();
      };
      var suspended_frame = (ctrl2, opts = {
        offset: 0
      }) => {
        const { context: context2 } = ctrl2;
        const body = context2.body();
        let arr_ctrls = [];
        let arr_ctrls_with_poss = [];
        const { offset: offset2 } = opts;
        const measure_ctrl = () => {
          const bcr = ctrl2.bcr();
          console.log("bcr", bcr);
          return bcr;
        };
        const clear = () => {
          each(arr_ctrls, (ctrl3) => {
            ctrl3.remove();
          });
          arr_ctrls = [];
          arr_ctrls_with_poss = [];
        };
        const get_suspended_ctrl_doc_pos = (suspended_ctrl, pos) => {
          const m = measure_ctrl();
          const [tl, br, size] = m;
          const map_pos_fns = {
            "tl": () => [tl[0] - offset2, tl[1] - offset2],
            "tm": () => [t1[0] + 1 / 2 * size[0], t1[1] - offset2],
            "tr": () => [br[0] + offset2, tl[1] - offset2]
          };
          if (map_pos_fns[pos]) {
            const retrieved_pos = map_pos_fns[pos]();
            if (retrieved_pos) {
              if (suspended_ctrl.size) {
                const half_size = [suspended_ctrl.size[0] / 2, suspended_ctrl.size[1] / 2];
                const docpos = [retrieved_pos[0] - half_size[0], retrieved_pos[1] - half_size[1]];
                return docpos;
              } else {
                return retrieved_pos;
              }
            }
          }
        };
        const add = (ctrl_to_add, pos) => {
          const docpos = get_suspended_ctrl_doc_pos(ctrl_to_add, pos);
          console.log("docpos", docpos);
          ctrl_to_add.style({
            "position": "absolute",
            "left": docpos[0] + "px",
            "top": docpos[1] + "px"
          });
          body.add(ctrl_to_add);
          arr_ctrls.push(ctrl_to_add);
          arr_ctrls_with_poss.push([ctrl_to_add, pos]);
          ctrl_to_add.activate();
        };
        const sync_dimensions = () => {
          each(arr_ctrls_with_poss, (cwp) => {
            const [ctrl3, pos] = cwp;
            const docpos = get_suspended_ctrl_doc_pos(ctrl3, pos);
            ctrl3.style({
              "left": docpos[0] + "px",
              "top": docpos[1] + "px"
            });
          });
        };
        watch_resize(ctrl2);
        ctrl2.on("resize", (e_resize) => {
          sync_dimensions();
        });
        const res2 = {
          add,
          clear
        };
        return res2;
      };
      var editable = (ctrl2) => {
        field(ctrl2, "editable", true);
        field(ctrl2, "editing", false);
        const { context: context2 } = ctrl2;
        ctrl2.on("activate", (e) => {
          console.log("new mini mixin editable ctrl on activate");
          let initial_text = ctrl2.dom.el.textContent;
          press_events(ctrl2);
          const sframe = suspended_frame(ctrl2, {
            offset: 8
          });
          const btn_cancel = new Button({
            context: context2,
            class: "cancel button",
            size: [24, 24],
            text: "\u2B8C"
          });
          btn_cancel.style({
            "line-height": "18px",
            "color": "#8B0000",
            "font-weight": "bold"
          });
          const btn_ok = new Button({
            context: context2,
            class: "ok button",
            size: [24, 24],
            text: "\u2713"
          });
          btn_ok.style({
            "line-height": "18px",
            "color": "#228B22",
            // forest green
            "font-weight": "bold"
          });
          const cancel_editing = () => {
            console.log("cancel_editing");
            sframe.clear();
            ctrl2.remove_class("editing");
            ctrl2.editing = false;
            ctrl2.dom.attributes.contenteditable = false;
            ctrl2.dom.el.textContent = initial_text;
          };
          const save_editing = () => {
            console.log("save_editing");
            const new_text = ctrl2.dom.el.textContent;
            console.log("new_text", new_text);
            sframe.clear();
            ctrl2.remove_class("editing");
            ctrl2.editing = false;
            ctrl2.dom.attributes.contenteditable = false;
            ctrl2.raise("edit-complete", {
              old: initial_text,
              value: new_text
            });
          };
          let has_events = false;
          const start_editing = () => {
            ctrl2.editing = true;
            initial_text = ctrl2.dom.el.textContent;
            ctrl2.add_class("editing");
            sframe.add(btn_cancel, "tl");
            sframe.add(btn_ok, "tr");
            if (!has_events) {
              btn_cancel.on("click", (e2) => {
                cancel_editing();
              });
              btn_ok.on("click", (e2) => {
                save_editing();
              });
              has_events = true;
            }
            ctrl2.dom.attributes.contenteditable = true;
          };
          ctrl2.on({
            "press-end": (e_press_end) => {
              console.log("e_press_end", e_press_end);
              if (!ctrl2.editing) {
                start_editing();
              }
            }
          });
        });
      };
      var String_Span = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "string_span";
          spec.tag_name = "span";
          spec.class = "string";
          super(spec);
          field(this, "value", spec.value);
          editable(this);
          const { context: context2 } = this;
          const compose = () => {
            let tn = new Text_Node({
              context: context2,
              text: spec.value
            });
            this.add(tn);
          };
          if (!spec.el) {
            compose();
          }
        }
        // listen for edit-complete to update the .text property.
        //  silent update?
        activate() {
          if (!this.__active) {
            super.activate();
            this.on({
              "edit-complete": (e) => {
                const { old, value: value2 } = e;
                if (old !== value2) {
                  this.value = value2;
                }
              }
            });
          }
        }
        // Popups outside of this?
        //  Will need to position the popup divs within the DOM.
        //  Suspended_Around_Bounding_Rect
        //  Frame
        // Popups around bounding rect (mixin)?
        //  Would be very useful for a variety of things that appear around the frames / borders of controls.
        // how / when does this get activated...?
        // setup for hover....
        // Click to edit
        // Editable behaviour
        //  Click to edit.
        // 
      };
      module.exports = String_Span;
    }
  });

  // node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/timespan-selector.js
  var require_timespan_selector = __commonJS({
    "node_modules/jsgui3-html/controls/organised/0-core/0-basic/1-compositional/timespan-selector.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var Control2 = jsgui2.Control;
      var Date_Picker = jsgui2.Date_Picker;
      var Timespan_Selector = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "timespan_selector";
          super(spec);
          if (spec.span) {
            this.span = spec.span;
          } else {
            this.span = [];
          }
          if (!spec.skip_compose) {
            this.compose();
          }
        }
        compose() {
          let context2 = this.context;
          let date_from = this.span[0] || /* @__PURE__ */ new Date("2018-06-20T11:00:00");
          let date_to = this.span[0] || /* @__PURE__ */ new Date("2018-08-20T11:00:00");
          let picker_from = new Date_Picker({
            context: this.context,
            date: date_from
          });
          this.add(picker_from);
          let picker_to = new Date_Picker({
            context: this.context,
            date: date_to
          });
          this.add(picker_to);
        }
      };
      module.exports = Timespan_Selector;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/titled-panel.js
  var require_titled_panel = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/titled-panel.js"(exports, module) {
      var jsgui2 = require_html_core();
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var tof = jsgui2.tof;
      var is_defined = jsgui2.is_defined;
      var Control2 = jsgui2.Control;
      var Panel = require_panel();
      var Title_Bar = require_title_bar();
      var Titled_Panel = class extends Panel {
        constructor(spec) {
          super(spec);
          this.__type_name = "titled_panel";
          if (!spec.abstract && !spec.el) {
            var title_bar = new Title_Bar({
              "context": this.context,
              "text": this.title
            });
            title_bar.active();
            this.add(title_bar);
            var inner_control = new Control2({
              "context": this.context
            });
            inner_control.active();
            this.add(inner_control);
          }
        }
        "activate"() {
          super.activate();
          const { title_bar, inner_control } = this;
        }
      };
      module.exports = Titled_Panel;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/Toolbar.js
  var require_Toolbar = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/Toolbar.js"(exports, module) {
      var Control2 = require_control();
      var Button = require_button();
      var Toolbar = class extends Control2 {
        constructor(options = {}) {
          super(options);
          this.add_class("toolbar");
          if (options.orientation === "vertical") {
            this.add_class("toolbar-vertical");
          } else {
            this.add_class("toolbar-horizontal");
          }
          this.items = [];
        }
        /**
         * Add a button to the toolbar
         */
        addButton(config) {
          const { context: context2 } = this;
          const button = new Button({ context: context2 });
          button.add_class("toolbar-button");
          if (config.icon) {
            const icon = new Control2({ context: context2, tag_name: "span" });
            icon.add_class("toolbar-button-icon");
            icon.add(config.icon);
            button.add(icon);
          }
          if (config.label) {
            const label = new Control2({ context: context2, tag_name: "span" });
            label.add_class("toolbar-button-label");
            label.add(config.label);
            button.add(label);
          }
          if (config.tooltip) {
            button.dom.attributes.title = config.tooltip;
          }
          if (config.onClick) {
            button.on("click", config.onClick);
          }
          this.add(button);
          this.items.push(button);
          return button;
        }
        /**
         * Add a separator
         */
        addSeparator() {
          const { context: context2 } = this;
          const separator = new Control2({ context: context2, tag_name: "div" });
          separator.add_class("toolbar-separator");
          this.add(separator);
          this.items.push(separator);
          return separator;
        }
        /**
         * Add a spacer (flexible space)
         */
        addSpacer() {
          const { context: context2 } = this;
          const spacer = new Control2({ context: context2, tag_name: "div" });
          spacer.add_class("toolbar-spacer");
          this.add(spacer);
          this.items.push(spacer);
          return spacer;
        }
        /**
         * Add any custom control
         */
        addControl(control) {
          control.add_class("toolbar-item");
          this.add(control);
          this.items.push(control);
          return control;
        }
        /**
         * Clear all items
         */
        clear() {
          this.content.clear();
          this.items = [];
        }
      };
      module.exports = Toolbar;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/5-ui/toolbox.js
  var require_toolbox = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/5-ui/toolbox.js"(exports, module) {
      var jsgui2 = require_html_core();
      var { Control: Control2 } = jsgui2;
      var { prop, field } = require_oext();
      var Toolbox = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "toolbox";
          super(spec);
          this.add_class("toolbox");
        }
      };
      module.exports = Toolbox;
    }
  });

  // node_modules/jsgui3-html/controls/organised/1-standard/6-layout/window.js
  var require_window = __commonJS({
    "node_modules/jsgui3-html/controls/organised/1-standard/6-layout/window.js"(exports, module) {
      var jsgui2 = require_html_core();
      var Horizontal_Menu = require_horizontal_menu();
      var Button = require_button();
      var { def, each } = jsgui2;
      var Control2 = jsgui2.Control;
      var { dragable, resizable } = require_mx();
      var Window = class extends Control2 {
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "window";
          this.add_class("window");
          const show_buttons = def(spec.show_buttons) ? spec.show_buttons : true;
          if (!spec.abstract && !spec.el) {
            const { context: context2 } = this;
            const div_relative = new Control2({
              context: context2
            });
            div_relative.add_class("relative");
            const title_bar = new Control2({
              context: context2
            });
            title_bar.add_class("title");
            title_bar.add_class("bar");
            const title_h2 = new jsgui2.controls.h2({
              context: context2
            });
            title_bar.add(title_h2);
            if (typeof spec.title === "string") {
              title_h2.add(spec.title);
            }
            div_relative.add(title_bar);
            let btn_minimize, btn_maximize, btn_close;
            if (show_buttons) {
              const right_button_group = new Control2({
                context: context2
              });
              right_button_group.add_class("button-group");
              right_button_group.add_class("right");
              btn_minimize = new Button({
                context: context2
              });
              const span = (text) => {
                const res2 = new jsgui2.controls.span({ context: context2 });
                res2.add(text);
                return res2;
              };
              btn_minimize.add(span("\u2296"));
              right_button_group.add(btn_minimize);
              btn_maximize = new Button({
                context: context2
              });
              btn_maximize.add(span("\u2295"));
              right_button_group.add(btn_maximize);
              btn_close = new Button({
                context: context2
              });
              btn_close.add(span("\u2297"));
              right_button_group.add(btn_close);
              title_bar.add(right_button_group);
            }
            const ctrl_inner = new Control2({
              context: context2
            });
            ctrl_inner.add_class("inner");
            div_relative.add(ctrl_inner);
            this.add(div_relative);
            this.ctrl_inner = ctrl_inner;
            this.inner = ctrl_inner;
            this.title_bar = title_bar;
            this.ctrl_relative = div_relative;
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.ctrl_inner = ctrl_inner;
            this._ctrl_fields.inner = ctrl_inner;
            this._ctrl_fields.title_bar = title_bar;
            this._ctrl_fields.ctrl_relative = div_relative;
            if (show_buttons) {
              this._ctrl_fields.btn_minimize = btn_minimize;
              this._ctrl_fields.btn_maximize = btn_maximize;
              this._ctrl_fields.btn_close = btn_close;
            }
          }
        }
        bring_to_front_z() {
          let max_z = 0;
          each(this.parent.content, (ctrl2) => {
            if (ctrl2 !== this) {
              const z = parseInt(ctrl2.dom.attributes.style["z-index"]);
              if (!isNaN(z) && z > max_z) max_z = z;
            }
          });
          this.dom.attributes.style["z-index"] = parseInt(max_z) + 1;
        }
        glide_to_pos(pos) {
          return new Promise((s, j) => {
            const [my_new_left, my_new_top] = pos;
            const x_diff = my_new_left - this.ta[6];
            const y_diff = my_new_top - this.ta[7];
            const ms_total_animation_time = 140;
            let animation_start;
            const start_tx = this.ta[6];
            const start_ty = this.ta[7];
            let i_frame = 0;
            const skip_zeroth_frame = false;
            const process_frame = () => {
              if (skip_zeroth_frame && i_frame === 0) {
                requestAnimationFrame((timestamp) => {
                  i_frame++;
                  process_frame();
                });
              } else {
                requestAnimationFrame((timestamp) => {
                  if (!animation_start) {
                    animation_start = timestamp;
                    process_frame();
                  } else {
                    const time_since = timestamp - animation_start;
                    if (time_since < ms_total_animation_time) {
                      const proportion_through = time_since / ms_total_animation_time;
                      const proportional_x_diff = x_diff * proportion_through;
                      const proportional_y_diff = y_diff * proportion_through;
                      this.ta[6] = start_tx + proportional_x_diff;
                      this.ta[7] = start_ty + proportional_y_diff;
                      i_frame++;
                      process_frame();
                    } else {
                      this.ta[6] = start_tx + x_diff;
                      this.ta[7] = start_ty + y_diff;
                      s();
                    }
                  }
                });
              }
            };
            process_frame();
          });
        }
        async minimize() {
          if (this.manager) {
            this.manager.minimize(this);
          } else {
            const my_bcr = this.bcr();
            if (!this.has_class("minimized")) {
              const width_to_minimize_to = 280;
              const minimized_height = 31;
              if (this.has_class("maximized")) {
                this.was_maximized_just_before_minimizing = true;
                this.pre_minimized_pos = this.pre_maximized_pos;
                this.pre_minimized_size = this.pre_maximized_size;
                this.remove_class("maximized");
              } else {
                this.was_maximized_just_before_minimizing = false;
                this.pre_minimized_pos = my_bcr[0];
                this.pre_minimized_size = my_bcr[2];
              }
              this.dragable = false;
              const parent_bcr = this.parent.bcr();
              const parent_size = parent_bcr[2];
              setTimeout(() => {
                this.size = [width_to_minimize_to, minimized_height];
              }, 17);
              const determine_pos_to_minimize_to = () => {
                let minimized_sibling_window_bcrs = [];
                each(this.parent.content, (ctrl2) => {
                  if (ctrl2 !== this) {
                    if (ctrl2.has_class("window") && ctrl2.has_class("minimized")) {
                      const ctrl_bcr = ctrl2.bcr();
                      minimized_sibling_window_bcrs.push(ctrl_bcr);
                    }
                  }
                });
                if (minimized_sibling_window_bcrs.length > 0) {
                  minimized_sibling_window_bcrs.sort((a, b) => {
                    if (a[0][1] === b[0][1]) {
                      return a[1][0] - b[1][0];
                    } else {
                      return b[0][1] - a[0][1];
                    }
                  });
                  const last_bcr = minimized_sibling_window_bcrs.at(-1);
                  const last_r = last_bcr[1][0];
                  const extra_margin = 2;
                  if (parent_size[0] >= last_r + width_to_minimize_to + extra_margin) {
                    return [last_bcr[1][0] + extra_margin, last_bcr[0][1]];
                  } else {
                    return [0, last_bcr[0][1] - extra_margin - minimized_height];
                  }
                } else {
                  return [0, parent_size[1] - minimized_height];
                }
              };
              const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map((x) => parseInt(x));
              const dest_pos = determine_pos_to_minimize_to();
              dest_pos[0] -= ltpos[0];
              dest_pos[1] -= ltpos[1];
              await this.glide_to_pos(dest_pos);
              this.add_class("minimized");
            } else {
              if (this.was_maximized_just_before_minimizing) {
                await this.maximize();
              } else {
                setTimeout(() => {
                  this.size = this.pre_minimized_size;
                }, 17);
                const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map((x) => parseInt(x));
                const dest_pos = [this.pre_minimized_pos[0] - ltpos[0], this.pre_minimized_pos[1] - ltpos[1]];
                await this.glide_to_pos(dest_pos);
                this.remove_class("minimized");
                this.dragable = true;
              }
            }
          }
        }
        async maximize() {
          if (this.manager) {
            this.manager.maximize(this);
          } else {
            if (this.has_class("maximized")) {
              this.remove_class("maximized");
              setTimeout(() => {
                this.size = [this.pre_maximized_size[0] - 2, this.pre_maximized_size[1] - 2];
              }, 17);
              this.dragable = true;
              const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map((x) => parseInt(x));
              const dest_pos = [this.pre_maximized_pos[0] - ltpos[0], this.pre_maximized_pos[1] - ltpos[1]];
              await this.glide_to_pos(dest_pos);
            } else {
              const my_bcr = this.bcr();
              const ltpos = [this.dom.attributes.style.left, this.dom.attributes.style.top].map((x) => parseInt(x));
              if (this.has_class("minimized")) {
                this.remove_class("minimized");
                this.pre_maximized_pos = this.pre_minimized_pos;
                this.pre_maximized_size = this.pre_minimized_size;
              } else {
                this.pre_maximized_pos = my_bcr[0];
                this.pre_maximized_size = my_bcr[2];
              }
              this.add_class("maximized");
              this.dragable = false;
              const parent_bcr = this.parent.bcr();
              const parent_size = parent_bcr[2];
              setTimeout(() => {
                this.size = [parent_size[0] - 4, parent_size[1] - 4];
              }, 17);
              const [tx, ty] = [this.ta[6], this.ta[7]];
              const dest_pos = [0 - ltpos[0], 0 - ltpos[1]];
              await this.glide_to_pos(dest_pos);
            }
          }
        }
        close() {
          if (this.manager) {
            this.manager.close(this);
          } else {
            this.remove();
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            const { title_bar, btn_minimize, btn_maximize, btn_close } = this;
            if (btn_close) {
              btn_close.on("click", () => {
                this.close();
              });
              btn_close.on("press", () => {
                this.close();
              });
            }
            if (btn_maximize) {
              btn_maximize.on("click", () => {
                this.maximize();
              });
              btn_maximize.on("press", () => {
                this.maximize();
              });
            }
            if (btn_minimize) {
              btn_minimize.on("click", () => {
                this.minimize();
              });
              btn_minimize.on("press", () => {
                this.minimize();
              });
            }
            title_bar.on("dblclick", () => {
              this.maximize();
            });
            this.on("mousedown", () => {
              this.bring_to_front_z();
            });
            dragable(this, {
              drag_mode: "translate",
              handle: this.title_bar,
              bounds: this.parent
            });
            this.dragable = true;
            resizable(this, {
              resize_mode: "br_handle",
              bounds: [[120, 80], void 0],
              extent_bounds: this.parent
            });
            setInterval(() => {
              if (this.has_class("minimized")) {
                const extended_bcr = this.bcr().extend("left", 80);
                const minimized_siblings = this.siblings.filter((x) => x.has_class("minimized"));
                const overlaps = extended_bcr.overlaps(minimized_siblings);
                if (overlaps && overlaps.length > 0) {
                  const max_overlap_width = Math.max(...overlaps.map((x) => x.w));
                  if (max_overlap_width <= 78) {
                    const parent_bcr = this.parent.bcr();
                    const parent_left = parent_bcr[0][0];
                    const my_bcr = this.bcr();
                    const my_left = my_bcr[0][0];
                    const dist_from_parent_left = my_left - parent_left;
                    if (dist_from_parent_left > 2) {
                      this.ta[6] = this.ta[6] - 1;
                    }
                  }
                } else {
                  const parent_bcr = this.parent.bcr();
                  const parent_left = parent_bcr[0][0];
                  const my_bcr = this.bcr();
                  const my_left = my_bcr[0][0];
                  const dist_from_parent_left = my_left - parent_left;
                  if (dist_from_parent_left > 2) {
                    if (dist_from_parent_left > 8) {
                      this.ta[6] = this.ta[6] - 8;
                    } else {
                      this.ta[6] = this.ta[6] - dist_from_parent_left;
                    }
                  }
                }
              }
            }, 18);
          }
        }
      };
      Window.css = `
.relative {
	position: relative;
}
.window.no-transitions {
	transition: none !important; 
}
:root {
	--rhsqsize: 16px;
}
.resize-handle {
	width: var(--rhsqsize);
	height: var(--rhsqsize);
	color: #CCCCCC;
	opacity: 0.45;
	position: absolute;
	line-height: var(--rhsqsize);
	font-size: var(--rhsqsize);
	user-select: none;
	transition: color 0.14s ease-in-out, opacity 0.14s ease-in-out;
}
.resize-handle:hover {
	color: #EFCF00;
	opacity: 0.5;
}
.resize-handle.resizing {
	color: #FFDF00;
	opacity: 1;
}
.bottom-right.resize-handle {
	right: 0;
	bottom: 0;
	cursor: nwse-resize;
	z-index: 10000001;
}
.window {
    position: absolute;
    border: 1px solid #CCCCCC;
	background-color: #F4F4F4;
	width: 360px;
	height: 360px;
	border-radius: 5px;
	transition: width 0.14s linear, height 0.14s linear; 
	overflow: hidden;
	-webkit-user-select: none;
	user-select: none;
}
.window .relative {
	height: inherit;
	overflow: hidden;
}
.window.minimized {
	height: 31px;
}
.window.minimized .bottom-right.resize-handle {
	display: none;
}
.window.maximized .bottom-right.resize-handle {
	display: none;
}
.window .title.bar {
    height: 31px;
	background-color: #0D4F8B;
	background-image: linear-gradient(to right, #0D4F8B , #3fb0d9);
    color: #FFFFFF;
    font-size: 12px;
    line-height: 32px;
    text-indent: 4px;
    -webkit-box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
    -moz-box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
    box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
	border-radius: 4px;
	-webkit-user-select: none;
	user-select: none;
	overflow: hidden;
	cursor: default;
}
.window .title.bar h2 {
	font-weight: 400;
	margin-left: 42px;
	float: left;
}
.window .title.bar > span {
    vertical-align: middle;
    line-height: 31px;
}
.window .title.bar .button > span {
	transform: scale(2);
    display: inline-block;
	line-height: 13px;
    height: 14px;
}
.window .title.bar .right {
    margin-right: 2px;
    margin-top: 2px;
    position: absolute;
    right: 0;
    top: 0;
	height: 29px;
}
.window .title.bar .button {
    width: 26px;
	height: 26px;
	line-height: 24px;
	font-size: 14px;
}
.window .title.bar .button + .button {
    margin-left: 3px;
}
.window .relative .inner {
	width: 100%;
	height: calc(100% - 31px);
}
`;
      module.exports = Window;
    }
  });

  // node_modules/jsgui3-html/controls/controls.js
  var require_controls = __commonJS({
    "node_modules/jsgui3-html/controls/controls.js"(exports, module) {
      var controls = {
        Active_HTML_Document: require_Active_HTML_Document(),
        Arrow_Button: require_arrow_button(),
        //Audio_Player: require('./audio-player'),
        Audio_Volume: require_audio_volume(),
        Button: require_button(),
        Cell: require_Cell(),
        // Maybe more advanced?
        Context_Menu: require_context_menu(),
        //Control: 
        Color_Grid: require_color_palette(),
        Color_Palette: require_color_palette(),
        Checkbox: require_checkbox(),
        Combo_Box: require_combo_box(),
        Dropdown_Menu: require_Dropdown_Menu(),
        // Not using (data-)connected controls.
        //Data_Grid: require('./connected/data-grid'),
        File_Upload: require_file_upload(),
        Form_Field: require_form_field(),
        // maybe 0-basic/0-layout?
        //  A layout control may be / need to be displayed a little differently.
        Grid: require_grid(),
        Grid_Cell: require_grid().Cell,
        Horizontal_Menu: require_horizontal_menu(),
        Horizontal_Slider: require_horizontal_slider(),
        //Data_Item: require('./data-item'),
        Data_Row: require_data_row(),
        Date_Picker: require_date_picker(),
        Dropdown_List: require_dropdown_list(),
        // Exclude the connected ones for the moment. Moment passed.
        // May not need to actually be 'connected'?
        //  Or other controls may get data connections too.
        File_Tree: require_file_tree(),
        File_Tree_Node: require_file_tree_node(),
        Icon: require_icon(),
        Item: require_item(),
        Item_Selector: require_item_selector(),
        //Item_View: require('./old/item-view'),
        Left_Right_Arrows_Selector: require_left_right_arrows_selector(),
        //Vector: require('./vector'),
        Line_Chart: require_line_chart(),
        List: require_list(),
        // could be in forms / standard forms.
        Login: require_login(),
        //Media_Scrubber: require('./media-scrubber'),
        Menu_Node: require_menu_node(),
        Modal: require_modal(),
        Month_View: require_month_view(),
        //Multi_Document_Interface: require('./multi-document-interface'),
        Multi_Layout_Mode: require_multi_layout_mode(),
        //Object_Editor: require('./editor/object'),
        Panel: require_panel(),
        Plus_Minus_Toggle_Button: require_plus_minus_toggle_button(),
        Property_Editor: require_property_editor(),
        // More advanced functionality - may require more work to keep it with the right APIs.
        Popup_Menu_Button: require_popup_menu_button(),
        Radio_Button: require_radio_button(),
        Radio_Button_Group: require_radio_button_group(),
        //Resize_Handle: require('./organised/0-core/0-basic/_resize-handle'),
        Rich_Text_Editor: require_Rich_Text_Editor(),
        Scroll_View: require_scroll_view(),
        Scrollbar: require_scrollbar(),
        Search_Bar: require_search_bar(),
        Select_Options: require_Select_Options(),
        Single_Line: require_single_line(),
        Standard_Web_Page: require_standard_web_page(),
        Start_Stop_Toggle_Button: require_start_stop_toggle_button(),
        String_Span: require_string_span(),
        Tabbed_Panel: require_tabbed_panel(),
        Text_Field: require_Text_Field(),
        Text_Item: require_text_item(),
        Text_Input: require_Text_Input(),
        Tile_Slider: require_tile_slide(),
        // May be moved to vector?
        Timespan_Selector: require_timespan_selector(),
        Title_Bar: require_title_bar(),
        Titled_Panel: require_titled_panel(),
        Toggle_Button: require_toggle_button(),
        Toolbar: require_Toolbar(),
        Toolbox: require_toolbox(),
        Tree: require_tree(),
        Tree_Node: require_tree_node(),
        Vertical_Expander: require_vertical_expander(),
        Window: require_window(),
        //,
        //mx: require('../control_mixins/mx')
        Indicator: require_Indicator(),
        Status_Indicator: require_Status_Indicator(),
        Validation_Status_Indicator: require_Validation_Status_Indicator()
      };
      module.exports = controls;
    }
  });

  // node_modules/jsgui3-html/html.js
  var require_html = __commonJS({
    "node_modules/jsgui3-html/html.js"(exports, module) {
      var jsgui2 = require_html_core();
      jsgui2.Router = require_router();
      jsgui2.Resource = require_resource();
      jsgui2.Resource_Pool = require_pool();
      jsgui2.Resource.Data_KV = require_data_kv_resource();
      jsgui2.Resource.Data_Transform = require_data_transform_resource();
      jsgui2.Resource.Compilation = require_compilation_resource();
      jsgui2.Resource.Compiler = require_compiler_resource();
      jsgui2.gfx = require_gfx_core();
      jsgui2.Resource.load_compiler = (name, jsfn, options) => {
        throw "NYI";
      };
      jsgui2.controls = jsgui2.controls || {};
      Object.assign(jsgui2.controls, require_controls());
      Object.assign(jsgui2, jsgui2.controls);
      jsgui2.mixins = jsgui2.mx = require_mx();
      module.exports = jsgui2;
    }
  });

  // node_modules/jsgui3-client/client-resource-pool.js
  var require_client_resource_pool = __commonJS({
    "node_modules/jsgui3-client/client-resource-pool.js"(exports, module) {
      var jsgui2 = require_html();
      var Resource_Pool = jsgui2.Resource_Pool;
      var fnl = require_fnl();
      var prom_or_cb = fnl.prom_or_cb;
      var Client_Resource_Pool = class extends Resource_Pool {
        //'fields': ,
        constructor(spec) {
          super(spec);
        }
        "start"(callback2) {
          return prom_or_cb((resolve, reject) => {
            resolve(true);
          }, callback2);
        }
      };
      module.exports = Client_Resource_Pool;
    }
  });

  // node_modules/jsgui3-client/page-context.js
  var require_page_context2 = __commonJS({
    "node_modules/jsgui3-client/page-context.js"(exports, module) {
      var jsgui2 = require_html();
      var {
        Control: Control2,
        controls,
        deep_sig,
        each
      } = jsgui2;
      var {
        Modal
      } = controls;
      var Client_Resource_Pool = require_client_resource_pool();
      var Client_Page_Context = class extends jsgui2.Page_Context {
        constructor(spec) {
          spec = spec || {};
          super(spec);
          const {
            map_controls,
            map_control_iids,
            next_iid
          } = this;
          this.document = spec.document || document;
          this.resource_pool = new Client_Resource_Pool({});
          this.__is_active = true;
          this.map_els = {};
          let ctrl_modal;
          this.mixins = jsgui2.mixins;
          Object.defineProperty(this, "modal", {
            get() {
              if (ctrl_modal) {
                return ctrl_modal;
              } else {
                ctrl_modal = new Modal({
                  context: this,
                  class: "modal"
                });
                const body = this.body();
                if (body) {
                  body.add(ctrl_modal);
                }
                return ctrl_modal;
              }
            },
            enumerable: true
          });
          let ctrl_overlay;
          Object.defineProperty(this, "overlay", {
            get() {
              if (ctrl_overlay) {
                return ctrl_overlay;
              } else {
                ctrl_overlay = new Control2({
                  context: this,
                  class: "overlay"
                });
                const body = this.body();
                if (body) {
                  body.add(ctrl_overlay);
                  ctrl_overlay.activate();
                }
                ctrl_overlay.place = (ctrl2, location) => {
                  const sloc = deep_sig(location);
                  let placement_abs_pos;
                  if (sloc === "[s,C]") {
                    const [str_description, ctrl_target] = location;
                    const target_bcr = ctrl_target.bcr();
                    const overlay_bcr = ctrl_overlay.bcr();
                    if (str_description === "below") {
                      placement_abs_pos = [target_bcr[0][0], target_bcr[1][1]];
                      const overlay_size = overlay_bcr[1];
                      const body_size = body.bcr()[1];
                      const height_left_below_placement = body_size[1] - placement_abs_pos[1];
                      ctrl2.pos = placement_abs_pos;
                      ctrl2.dom.attributes.style.position = "absolute";
                      ctrl2.dom.attributes.style["max-height"] = height_left_below_placement + "px";
                    } else {
                      console.trace();
                      throw "NYI";
                    }
                  }
                  ctrl_overlay.add(ctrl2);
                };
                return ctrl_overlay;
              }
            },
            enumerable: true
          });
          let frame_num = 0;
          let last_timestamp;
          let was_resized = false;
          this.map_controls_being_removed_in_frame = false;
          this.map_controls_being_added_in_frame = false;
          let map_ctrls_in_last_frame = {};
          let map_ctrls_in_this_frame;
          let count_dom_ctrls = 0;
          const num_data_points_per_ctrl = 32;
          this.on("activate", () => {
            each(map_controls, (ctrl2, jsgui_id) => {
              if (ctrl2.dom?.el) {
                map_ctrls_in_last_frame[jsgui_id] = ctrl2;
                count_dom_ctrls++;
              }
            });
            let ta_last_frame;
            let ta_current_frame_stored;
            let ta_current_frame_for_user;
            let ta_user_frame_changes;
            let map_current_dom_ctrl_iids;
            let map_current_dom_ctrls_by_iid = {};
            const create_controls_number_props_ta = () => {
              const ta_length = num_data_points_per_ctrl * count_dom_ctrls;
              const res2 = new Float32Array(ta_length);
              const create_map_ctrls_iids = (map_dom_ctrls) => {
                const keys = Object.keys(map_dom_ctrls);
                const res3 = {};
                each(keys, (jsgui_id, i) => {
                  res3[jsgui_id] = i;
                  map_current_dom_ctrls_by_iid[i] = map_dom_ctrls[jsgui_id];
                });
                return res3;
              };
              map_current_dom_ctrl_iids = create_map_ctrls_iids(map_ctrls_in_last_frame);
              const record_ctrls_info = (map_dom_ctrls, map_dom_ctrl_iids, ta2) => {
                each(map_dom_ctrls, (ctrl2, jsgui_id) => {
                  const iid = map_dom_ctrl_iids[jsgui_id];
                  const el = ctrl2.dom.el;
                  const bcr = el.getBoundingClientRect();
                  const start_pos = iid * num_data_points_per_ctrl;
                  let wpos = start_pos;
                  ta2[wpos++] = bcr.left;
                  ta2[wpos++] = bcr.top;
                  ta2[wpos++] = bcr.width;
                  ta2[wpos++] = bcr.height;
                  ta2[wpos++] = bcr.right;
                  ta2[wpos++] = bcr.bottom;
                });
              };
              record_ctrls_info(map_ctrls_in_last_frame, map_current_dom_ctrl_iids, res2);
              return res2;
            };
            const assign_ctrls_ta_subarrays = (ta_current_frame_for_user2, map_dom_controls, map_iids) => {
              each(map_dom_controls, (ctrl2, jsgui_id) => {
                const ctrl_iid = map_iids[jsgui_id];
                const pos_start = ctrl_iid * num_data_points_per_ctrl;
                const pos_end = pos_start + num_data_points_per_ctrl;
                ctrl2.ta = ta_current_frame_for_user2.subarray(pos_start, pos_end);
              });
            };
            const frame_process = (timestamp) => {
              frame_num++;
              const find_control_numeric_values_changed = () => {
                let i_ctrl = 0;
                let pos = 0;
                const l2 = ta_current_frame_for_user.length;
                let has_change;
                const ta_controls_which_have_changed_iids = new Int8Array(count_dom_ctrls);
                ta_controls_which_have_changed_iids.fill(-1);
                let tacwhci_wpos = 0;
                while (pos < l2) {
                  const change = ta_current_frame_for_user[pos] - ta_current_frame_stored[pos];
                  let ctrl_iid = Math.floor(pos / num_data_points_per_ctrl);
                  if (change !== 0) {
                    has_change = true;
                    ta_controls_which_have_changed_iids[tacwhci_wpos++] = ctrl_iid;
                  }
                  ta_user_frame_changes[pos] = change;
                  pos++;
                }
                if (has_change) {
                  let c2 = 0;
                  let l3 = ta_user_frame_changes.length;
                  let stop = false;
                  while (!stop && c2 < l3) {
                    const ctrl_iid = ta_controls_which_have_changed_iids[c2];
                    if (ctrl_iid === -1) {
                      stop = true;
                    } else {
                      const changed_ctrl = map_current_dom_ctrls_by_iid[ctrl_iid];
                      const ta_ctrl_changes = ta_user_frame_changes.subarray(ctrl_iid * num_data_points_per_ctrl, (ctrl_iid + 1) * num_data_points_per_ctrl);
                      const ctrl_ta = changed_ctrl.ta;
                      let i = 0, l4 = ctrl_ta.length;
                      let changed_transform = false;
                      for (i = 0; i < l4; i++) {
                        if (ta_ctrl_changes[i] !== 0) {
                          const new_val = ctrl_ta[i];
                          const X2 = 0, Y2 = 1, H2 = 2, W2 = 3, R2 = 4, B2 = 5, TX2 = 6, TY2 = 7;
                          if (i === 1) {
                          } else if (i === 2) {
                          } else if (i === 3) {
                          } else if (i === 4) {
                          } else if (i === 5) {
                          } else if (i === 6 || i === 7) {
                            if (!changed_transform) {
                              const tx = ctrl_ta[6];
                              const ty = ctrl_ta[7];
                              changed_ctrl.dom.attributes.style.transform = "translate3d(" + tx + "px, " + ty + "px, 0px)";
                              changed_transform = true;
                            }
                          }
                        }
                      }
                      let w_pos_ctrl = ctrl_iid * num_data_points_per_ctrl;
                      for (let i2 = 0; i2 < l4; i2++) {
                        ta_current_frame_stored[w_pos_ctrl++] = ctrl_ta[i2];
                      }
                    }
                    c2++;
                  }
                }
              };
              if (frame_num > 1) {
                find_control_numeric_values_changed();
              } else {
                assign_ctrls_ta_subarrays(ta_current_frame_for_user, map_ctrls_in_last_frame, map_current_dom_ctrl_iids);
              }
              let count_add = 0;
              let count_remove = 0;
              if (frame_num === 1) {
              } else {
                map_ctrls_in_this_frame = {};
              }
              if (this.map_controls_being_removed_in_frame) {
                each(map_ctrls_in_last_frame, (ctrl_in_last_frame, ctrl_id) => {
                  if (!this.map_controls_being_removed_in_frame[ctrl_id]) {
                    map_ctrls_in_this_frame[ctrl_id] = ctrl_in_last_frame;
                  }
                });
                count_remove += Object.keys(this.map_controls_being_removed_in_frame).length;
                this.map_controls_being_removed_in_frame = false;
              } else {
                map_ctrls_in_this_frame = map_ctrls_in_last_frame;
              }
              if (this.map_controls_being_added_in_frame) {
                this.map_controls_being_added_in_frame = false;
                each(this.map_controls_being_added_in_frame, (ctrl_added, ctrl_id) => {
                  map_ctrls_in_this_frame[ctrl_id] = ctrl_added;
                  count_add++;
                });
              }
              this.raise("frame", {
                number: frame_num,
                timestamp,
                window_was_resized: was_resized,
                count_ctrls_added: count_add,
                count_ctrls_removed: count_remove,
                map_dom_controls: map_ctrls_in_this_frame,
                count_dom_ctrls,
                ta_dom_controls_numeric_values: ta_current_frame_for_user,
                map_dom_ctrl_iids: map_current_dom_ctrl_iids
              });
              last_timestamp = timestamp;
              window.requestAnimationFrame(frame_process);
              was_resized = false;
              map_ctrls_in_last_frame = map_ctrls_in_this_frame;
            };
            window.requestAnimationFrame(frame_process);
            window.addEventListener("resize", (e) => {
              was_resized = true;
              this.raise("window-resize", e);
            });
            ta_current_frame_stored = create_controls_number_props_ta();
            ta_current_frame_for_user = new Float32Array(ta_current_frame_stored.length);
            ta_user_frame_changes = new Float32Array(ta_current_frame_stored.length);
            ta_current_frame_for_user.set(ta_current_frame_stored);
          });
          const trial_fns_now_unused = () => {
            const create_dims_from_current_ctrls = this.create_dims_from_current_ctrls = () => {
              const {
                next_iid: next_iid2
              } = this;
              const ctrl_length = 6;
              const ta_res = new Float32Array(next_iid2 * ctrl_length);
              let wpos = 0;
              each(map_controls, (ctrl2, id) => {
                const ctrl_iid = ctrl2.iid;
                wpos = ctrl_iid * ctrl_length;
                if (ctrl2.dom && ctrl2.dom.el) {
                  const bcr = ctrl2.dom.el.getBoundingClientRect();
                  ta_res[wpos++] = bcr.left;
                  ta_res[wpos++] = bcr.top;
                  ta_res[wpos++] = bcr.right;
                  ta_res[wpos++] = bcr.bottom;
                  ta_res[wpos++] = bcr.width;
                  ta_res[wpos++] = bcr.height;
                }
              });
              return ta_res;
            };
          };
        }
        "get_ctrl_el"(ctrl2) {
          return this.map_els[ctrl2._id()];
        }
        "register_el"(el) {
          let jsgui_id = el.getAttribute("data-jsgui-id");
          if (jsgui_id) {
            this.map_els[jsgui_id] = el;
          }
        }
        "body"() {
          var doc = this.document;
          var bod = doc.body;
          if (!this._body) {
            var existing_jsgui_id = bod.getAttribute("data-jsgui-id");
            if (!existing_jsgui_id) {
              var ctrl_body = new jsgui2.body({
                "el": document.body,
                "context": this
              });
              ctrl_body.dom.el.setAttribute("jsgui-id", ctrl_body._id());
              this.register_control(ctrl_body);
              this._body = ctrl_body;
            } else {
              if (this.map_controls[existing_jsgui_id]) {
                this._body = this.map_controls[existing_jsgui_id];
              }
            }
          } else {
          }
          return this._body;
        }
      };
      Client_Page_Context.css = `
body .modal {
    position: absolute;
    left: 0px;
    top: 0px;
}
body .overlay {
    position: absolute;
    left: 0px;
    top: 0px;
}
`;
      module.exports = Client_Page_Context;
    }
  });

  // node_modules/jsgui3-client/resource.js
  var require_resource2 = __commonJS({
    "node_modules/jsgui3-client/resource.js"(exports, module) {
      var jsgui2 = require_html();
      var Resource = jsgui2.Resource;
      var fnl = require_fnl();
      var prom_or_cb = fnl.prom_or_cb;
      var stringify = jsgui2.stringify;
      var each = jsgui2.each;
      var arrayify = jsgui2.arrayify;
      var tof = jsgui2.tof;
      var get_a_sig2 = jsgui2.get_a_sig;
      var filter_map_by_regex = jsgui2.filter_map_by_regex;
      var Class = jsgui2.Class;
      var Data_Object = jsgui2.Data_Object;
      var Enhanced_Data_Object = jsgui2.Enhanced_Data_Object;
      var fp = jsgui2.fp;
      var is_defined = jsgui2.is_defined;
      var Collection = jsgui2.Collection;
      var ends_with = function(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
      };
      var Client_Resource = class extends Resource {
        //'fields': {
        //	'url': String
        //},
        // Subscribe?
        // Should likely work more like an observable.
        //  At least it extends evented_class
        constructor(spec = {}) {
          super(spec);
          if (spec.meta) {
            var meta = spec.meta;
            if (meta.url) this.meta.set("url", meta.url);
            if (meta.type_levels) this.meta.set("type_levels", meta.type_levels);
          }
          this.data = new Data_Object();
          this.data.on("change", (property_name, property_value) => {
            this.trigger("change", property_name, property_value);
          });
        }
        // Set as well?
        "get"(path, callback2) {
          return prom_or_cb((resolve, reject) => {
            let ends_dot_json = ends_with(path, ".json");
            let json_url;
            if (!ends_dot_json) {
              json_url = path + ".json";
            } else {
              json_url = path;
            }
            json_url = "resources/" + this.name + "/" + json_url;
            jsgui2.http(json_url, function(err, res2) {
              if (err) {
                reject(err);
              } else {
                resolve(res2);
              }
            });
          }, callback2);
        }
        get status() {
          return (async () => {
            let res2 = await jsgui2.http("/resources/" + this.name + "/status.json");
            return res2;
          })();
        }
        // We don't notify it this way.
        //  Thinking of making a serparate Resource that uses websockets or sockjs. Should continue to have the normal non-sock client-side resource as well.
        ///  Will not make its own HTTP connections.
        // Not that clear how this type of resource will receive these change notifications.
        //  Seems less likely that we will need this function here.
        //  06/06/2015 - about to make the socks resource connection for the client, it's going to allow for real-time updates, while using generally RESTful addressing.
        "notify_change_from_server"(property_name, property_value) {
          var data = this.data;
          this.data._[property_name] = property_value;
          this.data.trigger("change", property_name, property_value);
        }
      };
      module.exports = Client_Resource;
    }
  });

  // node_modules/jsgui3-client/client.js
  var require_client = __commonJS({
    "node_modules/jsgui3-client/client.js"(exports, module) {
      var jsgui2 = require_html();
      jsgui2.Resource_Pool = require_client_resource_pool();
      jsgui2.Client_Page_Context = require_page_context2();
      jsgui2.Client_Resource = require_resource2();
      var fnl = require_fnl();
      var prom_or_cb = fnl.prom_or_cb;
      var { each, tf: tf2 } = jsgui2;
      if (typeof window !== "undefined") {
        let context2;
        jsgui2.http = (url, callback2) => {
          return prom_or_cb((resolve, reject) => {
            let timeout = 2500;
            var oReq = new XMLHttpRequest();
            oReq.timeout = timeout;
            oReq.onreadystatechange = function() {
              if (this.readyState === 4) {
                if (this.status === 200) {
                  var o = JSON.parse(this.responseText);
                  resolve(o);
                } else {
                  reject(this.status);
                }
              }
            };
            oReq.open("GET", url, true);
            oReq.send();
          }, callback2);
        };
        jsgui2.http_post = (url, value2, callback2) => {
          return prom_or_cb((resolve, reject) => {
            var oReq = new XMLHttpRequest();
            oReq.onreadystatechange = function() {
              if (this.readyState === 4) {
                if (this.status === 200) {
                  var o = JSON.parse(this.responseText);
                  resolve(o);
                } else {
                  reject({
                    status: this.status,
                    responseText: this.responseText
                  });
                }
              }
            };
            oReq.open("POST", url, true);
            let o_to_send;
            let tval = tf2(value2);
            if (tval === "s") {
              o_to_send = value2;
            } else if (tval === "B") {
              o_to_send = value2;
            } else if (tval === "a" || tval === "o") {
              const json = JSON.stringify(value2);
              o_to_send = json;
              oReq.setRequestHeader("content-type", "application/json");
            }
            oReq.send(o_to_send);
          }, callback2);
        };
        jsgui2.http_delete = (url, callback2) => {
          return prom_or_cb((resolve, reject) => {
            var oReq = new XMLHttpRequest();
            oReq.onreadystatechange = function() {
              if (this.readyState === 4) {
                if (this.status === 200) {
                  var o = JSON.parse(this.responseText);
                  resolve(o);
                } else {
                  reject(this.status);
                }
              }
            };
            oReq.open("DELETE", url, true);
            oReq.send();
          }, callback2);
        };
        jsgui2.update_standard_Controls = (page_context2) => {
          each(jsgui2.controls, (Control_Subclass, name) => {
            page_context2.update_Controls(name, Control_Subclass);
          });
        };
        let context_data;
        jsgui2.register_server_resources = (o_server_resources) => {
          jsgui2.def_server_resources = o_server_resources;
        };
        jsgui2.register_context_data = (o_context_data) => {
          context_data = o_context_data;
        };
        let activate = () => {
          const { def_server_resources } = jsgui2;
          page_context = new jsgui2.Client_Page_Context({
            "document": document
          });
          context2 = page_context;
          jsgui2.context = page_context;
          if (context_data) {
            Object.assign(page_context, context_data);
          }
          jsgui2.update_standard_Controls(page_context);
          jsgui2.pre_activate(page_context);
          jsgui2.activate(page_context);
          const arr_resources = context2.resource_pool.resources._arr;
          const data_resource = arr_resources[0];
          const activate_server_resource_fn = (obj_def) => {
            const { name, type } = obj_def;
            if (type === "function") {
              const fn_remote_call = async (single_param) => {
                const res_dl = await jsgui2.http_post("/" + name, single_param);
                console.log("res_dl", res_dl);
                return res_dl;
              };
              data_resource[name] = fn_remote_call;
            }
          };
          const activate_server_resource_fns = () => {
            each(def_server_resources, (server_resource_def, name) => {
              activate_server_resource_fn(server_resource_def);
            });
          };
          activate_server_resource_fns();
          jsgui2.raise("activate", {
            context: context2
          });
          page_context.raise("activate", {
            context: context2
          });
        };
        window.addEventListener("load", () => {
          console.log("client.js window onload");
          activate();
        });
      }
      module.exports = jsgui2;
    }
  });

  // ui/appCatalog.js
  var require_appCatalog = __commonJS({
    "ui/appCatalog.js"(exports, module) {
      "use strict";
      function normalizePath(p) {
        if (!p) return "";
        return String(p).replace(/\\/g, "/");
      }
      function getServerIdentity(server) {
        const relativeFile = normalizePath(server && server.relativeFile);
        const absoluteFile = normalizePath(server && server.file);
        const name = server && server.metadata && server.metadata.name ? String(server.metadata.name) : "";
        const description = server && server.metadata && server.metadata.description ? String(server.metadata.description) : "";
        return {
          relativeFile,
          absoluteFile,
          name,
          description,
          haystack: `${relativeFile}
${absoluteFile}
${name}
${description}`.toLowerCase()
        };
      }
      var APP_CARDS = [
        {
          id: "unified-ui",
          title: "Unified UI",
          subtitle: "All dashboards in one shell",
          accent: "gold",
          svgPath: "ui/assets/app-cards/generic.svg",
          sidebarIcon: "ui/assets/sidebar-icons/generic.svg",
          order: 5,
          primaryAction: "start-detached",
          primaryLabel: "\u25B6 Launch (detached)",
          quickLinks: [
            { label: "\u{1F5D3}\uFE0F Scheduler", path: "/scheduler" },
            { label: "\u{1F577}\uFE0F Crawl", path: "/crawl-observer" },
            { label: "\u{1F50E} Data", path: "/data-explorer" }
          ],
          match: ["unifiedapp", "unified-app", "unified ui", "src/ui/server/unifiedApp/server.js"]
        },
        {
          id: "data-explorer",
          title: "Data Explorer",
          subtitle: "URLs \u2022 fetches \u2022 filters \u2022 decisions",
          accent: "emerald",
          svgPath: "ui/assets/app-cards/data-explorer.svg",
          sidebarIcon: "ui/assets/sidebar-icons/data-explorer.svg",
          order: 10,
          match: ["dataexplorerserver", "data-explorer", "ui:data-explorer", "src/ui/server/dataExplorerServer.js", "data explorer"]
        },
        {
          id: "docs-viewer",
          title: "Docs Viewer",
          subtitle: "Docs \u2022 guides \u2022 sessions \u2022 diagrams",
          accent: "sapphire",
          svgPath: "ui/assets/app-cards/docs-viewer.svg",
          sidebarIcon: "ui/assets/sidebar-icons/docs-viewer.svg",
          order: 20,
          match: ["docsviewer", "docs-viewer", "src/ui/server/docsViewer/", "ui:docs", "docs viewer"]
        },
        {
          id: "design-studio",
          title: "Design Studio",
          subtitle: "WLILO \u2022 themes \u2022 components",
          accent: "amethyst",
          svgPath: "ui/assets/app-cards/design-studio.svg",
          sidebarIcon: "ui/assets/sidebar-icons/design-studio.svg",
          order: 30,
          match: ["designstudio", "design-studio", "src/ui/server/designStudio/", "ui:design", "design studio"]
        },
        {
          id: "diagram-atlas",
          title: "Diagram Atlas",
          subtitle: "SVG \u2022 maps \u2022 collision checks",
          accent: "topaz",
          svgPath: "ui/assets/app-cards/diagram-atlas.svg",
          sidebarIcon: "ui/assets/sidebar-icons/diagram-atlas.svg",
          order: 40,
          match: ["diagramatlas", "diagram-atlas", "diagramatlasserver", "src/ui/server/diagramAtlasServer.js", "diagram atlas"]
        },
        {
          id: "geo-import",
          title: "Geo Import",
          subtitle: "NDJSON \u2022 geonames \u2022 shape merges",
          accent: "emerald",
          svgPath: "ui/assets/app-cards/geo-import.svg",
          sidebarIcon: "ui/assets/sidebar-icons/geo-import.svg",
          order: 50,
          match: ["geoimportserver", "geo-import", "geoimportdashboard", "src/ui/server/geoImportServer.js", "geo import dashboard"]
        },
        {
          id: "gazetteer",
          title: "Gazetteer Info",
          subtitle: "Places \u2022 regions \u2022 admin levels",
          accent: "ruby",
          svgPath: "ui/assets/app-cards/gazetteer.svg",
          sidebarIcon: "ui/assets/sidebar-icons/gazetteer.svg",
          order: 60,
          match: ["gazetteerinfoserver", "gazetteer-info", "src/ui/server/gazetteerInfoServer.js", "gazetteer info"]
        }
      ];
      function getAppCardSpecForServer(server) {
        const id = getServerIdentity(server);
        for (const card of APP_CARDS) {
          const hit = card.match.some((m) => id.haystack.includes(String(m).toLowerCase()));
          if (hit) {
            return {
              id: card.id,
              title: card.title,
              subtitle: card.subtitle,
              accent: card.accent,
              svgPath: card.svgPath,
              sidebarIcon: card.sidebarIcon,
              order: card.order,
              primaryAction: card.primaryAction || null,
              primaryLabel: card.primaryLabel || null,
              quickLinks: Array.isArray(card.quickLinks) ? card.quickLinks.slice() : null,
              isMajor: true
            };
          }
        }
        const fallbackTitle = server && server.metadata && server.metadata.name ? String(server.metadata.name) : id.relativeFile ? id.relativeFile.split("/").pop() : "Server";
        return {
          id: "generic",
          title: fallbackTitle || "Server",
          subtitle: server && server.metadata && server.metadata.description ? String(server.metadata.description) : id.relativeFile || "",
          accent: "gold",
          svgPath: "ui/assets/app-cards/generic.svg",
          sidebarIcon: "ui/assets/sidebar-icons/generic.svg",
          order: 999,
          isMajor: false
        };
      }
      function getMajorServersWithCards(servers) {
        if (!Array.isArray(servers)) return [];
        const matches = [];
        for (const server of servers) {
          const spec = getAppCardSpecForServer(server);
          if (spec.isMajor) {
            matches.push({ server, card: spec });
          }
        }
        matches.sort((a, b) => {
          const ao = a.card.order || 999;
          const bo = b.card.order || 999;
          if (ao !== bo) return ao - bo;
          return String(a.card.title || "").localeCompare(String(b.card.title || ""));
        });
        const seen = /* @__PURE__ */ new Set();
        return matches.filter((m) => {
          if (seen.has(m.card.id)) return false;
          seen.add(m.card.id);
          return true;
        });
      }
      module.exports = {
        APP_CARDS,
        getAppCardSpecForServer,
        getMajorServersWithCards
      };
    }
  });

  // ui/controls/serverItemControl.js
  var require_serverItemControl = __commonJS({
    "ui/controls/serverItemControl.js"(exports, module) {
      "use strict";
      var { getAppCardSpecForServer } = require_appCatalog();
      function createServerItemControl(jsgui2, { StringControl }) {
        class ServerItemControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "div",
              __type_name: "server_item"
            };
            super(normalized);
            this.add_class("zs-server-item");
            this._server = spec.server || {};
            this._selected = spec.selected || false;
            this._onSelect = spec.onSelect || null;
            this._onOpenUrl = spec.onOpenUrl || null;
            this._runningUrl = null;
            this._clickHandlerAttached = false;
            this._appSpec = getAppCardSpecForServer(this._server);
            if (!spec.el) {
              this.compose();
            }
            this._syncState();
          }
          compose() {
            const ctx = this.context;
            const isFeatured = this._appSpec && this._appSpec.isMajor;
            if (isFeatured) {
              this.add_class("zs-server-item--featured");
              this.add_class(`zs-server-item--${this._appSpec.accent}`);
            }
            if (isFeatured && this._appSpec.svgPath) {
              const cardImage = new jsgui2.div({ context: ctx, class: "zs-server-item__card-image" });
              const cardImg = new jsgui2.img({
                context: ctx,
                class: "zs-server-item__card-img"
              });
              cardImg.dom.attributes.src = this._appSpec.svgPath;
              cardImg.dom.attributes.alt = this._appSpec.title || "";
              cardImage.add(cardImg);
              this.add(cardImage);
              this._cardImage = cardImage;
            }
            const statusIndicator = new jsgui2.div({ context: ctx, class: "zs-server-item__status" });
            this.add(statusIndicator);
            this._statusEl = statusIndicator;
            const content = new jsgui2.div({ context: ctx, class: "zs-server-item__content" });
            const name = new jsgui2.div({ context: ctx, class: "zs-server-item__name" });
            const displayName = this._getDisplayName();
            name.add(new StringControl({ context: ctx, text: displayName }));
            content.add(name);
            this._nameEl = name;
            const desc = new jsgui2.div({ context: ctx, class: "zs-server-item__desc" });
            const descText = this._getDescription();
            desc.add(new StringControl({ context: ctx, text: descText }));
            content.add(desc);
            this._descEl = desc;
            const urlContainer = new jsgui2.div({ context: ctx, class: "zs-server-item__url-container" });
            urlContainer.add_class("zs-server-item__url-container--hidden");
            const urlIcon = new jsgui2.span({ context: ctx, class: "zs-server-item__url-icon" });
            urlIcon.add(new StringControl({ context: ctx, text: "\u{1F310}" }));
            urlContainer.add(urlIcon);
            const urlText = new jsgui2.span({ context: ctx, class: "zs-server-item__url-text" });
            urlText.add(new StringControl({ context: ctx, text: "" }));
            urlContainer.add(urlText);
            this._urlTextEl = urlText;
            const urlHint = new jsgui2.span({ context: ctx, class: "zs-server-item__url-hint" });
            urlHint.add(new StringControl({ context: ctx, text: "Click to open \u2192" }));
            urlContainer.add(urlHint);
            content.add(urlContainer);
            this._urlContainer = urlContainer;
            this.add(content);
            const score = new jsgui2.div({ context: ctx, class: "zs-server-item__score" });
            score.dom.attributes.title = "Confidence Score";
            score.add(new StringControl({ context: ctx, text: String(this._server.score || 0) }));
            this.add(score);
            this._scoreEl = score;
          }
          _getDisplayName() {
            if (this._server.metadata && this._server.metadata.name) {
              return this._server.metadata.name;
            }
            if (this._server.relativeFile) {
              return this._server.relativeFile.split(/[\\/\\\\]/).pop();
            }
            return "Unknown Server";
          }
          _getDescription() {
            if (this._server.metadata && this._server.metadata.description) {
              return this._server.metadata.description;
            }
            return this._server.relativeFile || "";
          }
          _syncState() {
            if (this._selected) {
              this.add_class("zs-server-item--selected");
            } else {
              this.remove_class("zs-server-item--selected");
            }
            if (this._server.running) {
              this.add_class("zs-server-item--running");
            } else {
              this.remove_class("zs-server-item--running");
            }
            if (this.dom.el) {
              if (this._selected) {
                this.dom.el.classList.add("zs-server-item--selected");
              } else {
                this.dom.el.classList.remove("zs-server-item--selected");
              }
              if (this._server.running) {
                this.dom.el.classList.add("zs-server-item--running");
              } else {
                this.dom.el.classList.remove("zs-server-item--running");
              }
            }
            if (this._urlContainer && this._urlContainer.dom.el) {
              if (this._runningUrl) {
                this._urlContainer.dom.el.classList.remove("zs-server-item__url-container--hidden");
              } else {
                this._urlContainer.dom.el.classList.add("zs-server-item__url-container--hidden");
              }
            }
          }
          setSelected(selected) {
            this._selected = selected;
            this._syncState();
          }
          setRunning(running) {
            this._server.running = running;
            if (!running) {
              this._runningUrl = null;
            }
            this._syncState();
          }
          setRunningUrl(url) {
            this._runningUrl = url;
            if (this._urlTextEl && this._urlTextEl.dom.el) {
              this._urlTextEl.dom.el.textContent = url || "";
            }
            if (this._urlContainer && this._urlContainer.dom.el) {
              if (url) {
                this._urlContainer.dom.el.classList.remove("zs-server-item__url-container--hidden");
              } else {
                this._urlContainer.dom.el.classList.add("zs-server-item__url-container--hidden");
              }
            }
          }
          getServer() {
            return this._server;
          }
          getRunningUrl() {
            return this._runningUrl;
          }
          activate() {
            if (this._clickHandlerAttached) return;
            if (!this.dom || !this.dom.el) return;
            this.dom.el.addEventListener("click", (e) => {
              const urlContainer = this._urlContainer?.dom?.el;
              if (urlContainer && (e.target === urlContainer || urlContainer.contains(e.target))) {
                if (this._runningUrl && this._onOpenUrl) {
                  e.stopPropagation();
                  this._onOpenUrl(this._runningUrl);
                  return;
                }
              }
              if (this._onSelect) {
                this._onSelect(this._server);
              }
            });
            this._clickHandlerAttached = true;
          }
        }
        return ServerItemControl;
      }
      module.exports = { createServerItemControl };
    }
  });

  // ui/controls/serverListControl.js
  var require_serverListControl = __commonJS({
    "ui/controls/serverListControl.js"(exports, module) {
      "use strict";
      function createServerListControl(jsgui2, { ServerItemControl }) {
        class ServerListControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "div",
              __type_name: "server_list"
            };
            super(normalized);
            this.add_class("zs-server-list");
            this._servers = spec.servers || [];
            this._selectedFile = null;
            this._onSelect = spec.onSelect || null;
            this._onOpenUrl = spec.onOpenUrl || null;
            this._itemControls = /* @__PURE__ */ new Map();
            if (!spec.el) {
              this.compose();
            }
          }
          compose() {
            this._renderItems();
          }
          _renderItems() {
            this.clear();
            this._itemControls.clear();
            this._servers.forEach((server) => {
              const item2 = new ServerItemControl({
                context: this.context,
                server,
                selected: server.file === this._selectedFile,
                onSelect: (s) => this._handleSelect(s),
                onOpenUrl: (url) => this._onOpenUrl && this._onOpenUrl(url)
              });
              this.add(item2);
              this._itemControls.set(server.file, item2);
            });
          }
          _handleSelect(server) {
            if (this._selectedFile && this._itemControls.has(this._selectedFile)) {
              this._itemControls.get(this._selectedFile).setSelected(false);
            }
            this._selectedFile = server.file;
            if (this._itemControls.has(server.file)) {
              this._itemControls.get(server.file).setSelected(true);
            }
            if (this._onSelect) {
              this._onSelect(server);
            }
          }
          setServers(servers) {
            console.log("[ServerList] setServers called with", servers.length, "servers");
            this._servers = servers;
            this._renderItems();
            console.log("[ServerList] _renderItems done, itemControls size:", this._itemControls.size);
            if (this.dom.el) {
              console.log("[ServerList] DOM element exists, updating directly");
              this.dom.el.innerHTML = "";
              this._itemControls.forEach((item2) => {
                item2.register_this_and_subcontrols();
                const itemHtml = item2.all_html_render();
                this.dom.el.insertAdjacentHTML("beforeend", itemHtml);
                const itemEl = this.dom.el.querySelector('[data-jsgui-id="' + item2._id() + '"]');
                if (itemEl) {
                  item2.dom.el = itemEl;
                  this.context.map_els[item2._id()] = itemEl;
                  if (item2.rec_desc_ensure_ctrl_el_refs) {
                    item2.rec_desc_ensure_ctrl_el_refs(itemEl);
                  }
                }
              });
              this.activate();
              console.log("[ServerList] DOM updated and activated");
            } else {
              console.log("[ServerList] No DOM element yet - will render on next activation");
            }
          }
          updateServerStatus(filePath, running) {
            if (this._itemControls.has(filePath)) {
              this._itemControls.get(filePath).setRunning(running);
              if (!running) {
                this._itemControls.get(filePath).setRunningUrl(null);
              }
            }
          }
          setServerRunningUrl(filePath, url) {
            if (this._itemControls.has(filePath)) {
              this._itemControls.get(filePath).setRunningUrl(url);
            }
          }
          activate() {
            this._itemControls.forEach((item2) => {
              item2.activate();
            });
          }
        }
        return ServerListControl;
      }
      module.exports = { createServerListControl };
    }
  });

  // ui/controls/serverUrlControl.js
  var require_serverUrlControl = __commonJS({
    "ui/controls/serverUrlControl.js"(exports, module) {
      "use strict";
      function createServerUrlControl(jsgui2, { StringControl }) {
        class ServerUrlControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "div",
              __type_name: "server_url"
            };
            super(normalized);
            this.add_class("zs-server-url");
            this.add_class("zs-server-url--hidden");
            this._url = spec.url || null;
            this._onClick = spec.onClick || null;
            this._visible = spec.visible || false;
            this._clickHandlerAttached = false;
            if (!spec.el) {
              this.compose();
            }
            this._syncState();
          }
          compose() {
            const ctx = this.context;
            const iconContainer = new jsgui2.div({ context: ctx, class: "zs-server-url__icon" });
            const svg = new jsgui2.Control({ context: ctx, tagName: "svg" });
            svg.dom.attributes.viewBox = "0 0 120 120";
            svg.dom.attributes.width = "120";
            svg.dom.attributes.height = "120";
            svg.add_class("zs-server-url__svg");
            const defs = new jsgui2.Control({ context: ctx, tagName: "defs" });
            const outerGradient = new jsgui2.Control({ context: ctx, tagName: "linearGradient" });
            outerGradient.dom.attributes.id = "outerRingGrad";
            outerGradient.dom.attributes.x1 = "0%";
            outerGradient.dom.attributes.y1 = "0%";
            outerGradient.dom.attributes.x2 = "100%";
            outerGradient.dom.attributes.y2 = "100%";
            const stop1 = new jsgui2.Control({ context: ctx, tagName: "stop" });
            stop1.dom.attributes.offset = "0%";
            stop1.dom.attributes["stop-color"] = "#2dd4bf";
            const stop2 = new jsgui2.Control({ context: ctx, tagName: "stop" });
            stop2.dom.attributes.offset = "50%";
            stop2.dom.attributes["stop-color"] = "#10b981";
            const stop3 = new jsgui2.Control({ context: ctx, tagName: "stop" });
            stop3.dom.attributes.offset = "100%";
            stop3.dom.attributes["stop-color"] = "#059669";
            outerGradient.add(stop1);
            outerGradient.add(stop2);
            outerGradient.add(stop3);
            defs.add(outerGradient);
            const innerGradient = new jsgui2.Control({ context: ctx, tagName: "radialGradient" });
            innerGradient.dom.attributes.id = "innerGlowGrad";
            innerGradient.dom.attributes.cx = "30%";
            innerGradient.dom.attributes.cy = "30%";
            const istop1 = new jsgui2.Control({ context: ctx, tagName: "stop" });
            istop1.dom.attributes.offset = "0%";
            istop1.dom.attributes["stop-color"] = "#ffffff";
            const istop2 = new jsgui2.Control({ context: ctx, tagName: "stop" });
            istop2.dom.attributes.offset = "60%";
            istop2.dom.attributes["stop-color"] = "#d1fae5";
            const istop3 = new jsgui2.Control({ context: ctx, tagName: "stop" });
            istop3.dom.attributes.offset = "100%";
            istop3.dom.attributes["stop-color"] = "#34d399";
            innerGradient.add(istop1);
            innerGradient.add(istop2);
            innerGradient.add(istop3);
            defs.add(innerGradient);
            const pulseFilter = new jsgui2.Control({ context: ctx, tagName: "filter" });
            pulseFilter.dom.attributes.id = "glow";
            const feGaussianBlur = new jsgui2.Control({ context: ctx, tagName: "feGaussianBlur" });
            feGaussianBlur.dom.attributes.stdDeviation = "4";
            feGaussianBlur.dom.attributes.result = "coloredBlur";
            pulseFilter.add(feGaussianBlur);
            const feMerge = new jsgui2.Control({ context: ctx, tagName: "feMerge" });
            const feMergeNode1 = new jsgui2.Control({ context: ctx, tagName: "feMergeNode" });
            feMergeNode1.dom.attributes.in = "coloredBlur";
            const feMergeNode2 = new jsgui2.Control({ context: ctx, tagName: "feMergeNode" });
            feMergeNode2.dom.attributes.in = "SourceGraphic";
            feMerge.add(feMergeNode1);
            feMerge.add(feMergeNode2);
            pulseFilter.add(feMerge);
            defs.add(pulseFilter);
            svg.add(defs);
            const outerRing = new jsgui2.Control({ context: ctx, tagName: "circle" });
            outerRing.dom.attributes.cx = "60";
            outerRing.dom.attributes.cy = "60";
            outerRing.dom.attributes.r = "54";
            outerRing.dom.attributes.class = "zs-server-url__outer-ring";
            svg.add(outerRing);
            const middleRing = new jsgui2.Control({ context: ctx, tagName: "circle" });
            middleRing.dom.attributes.cx = "60";
            middleRing.dom.attributes.cy = "60";
            middleRing.dom.attributes.r = "46";
            middleRing.dom.attributes.class = "zs-server-url__middle-ring";
            svg.add(middleRing);
            const innerCircle = new jsgui2.Control({ context: ctx, tagName: "circle" });
            innerCircle.dom.attributes.cx = "60";
            innerCircle.dom.attributes.cy = "60";
            innerCircle.dom.attributes.r = "38";
            innerCircle.dom.attributes.class = "zs-server-url__inner-circle";
            svg.add(innerCircle);
            const checkMark = new jsgui2.Control({ context: ctx, tagName: "path" });
            checkMark.dom.attributes.d = "M42 60 L54 72 L78 48";
            checkMark.dom.attributes.class = "zs-server-url__check";
            svg.add(checkMark);
            for (let i = 0; i < 8; i++) {
              const angle = i * 45 * Math.PI / 180;
              const x1 = 60 + Math.cos(angle) * 48;
              const y1 = 60 + Math.sin(angle) * 48;
              const x2 = 60 + Math.cos(angle) * 56;
              const y2 = 60 + Math.sin(angle) * 56;
              const ray = new jsgui2.Control({ context: ctx, tagName: "line" });
              ray.dom.attributes.x1 = String(x1);
              ray.dom.attributes.y1 = String(y1);
              ray.dom.attributes.x2 = String(x2);
              ray.dom.attributes.y2 = String(y2);
              ray.dom.attributes.class = "zs-server-url__ray";
              svg.add(ray);
            }
            iconContainer.add(svg);
            this.add(iconContainer);
            const urlWrapper = new jsgui2.div({ context: ctx, class: "zs-server-url__wrapper" });
            const label = new jsgui2.div({ context: ctx, class: "zs-server-url__label" });
            label.add(new StringControl({ context: ctx, text: "\u2726 SERVER RUNNING \u2726" }));
            urlWrapper.add(label);
            this._urlText = new jsgui2.div({ context: ctx, class: "zs-server-url__text" });
            this._urlText.add(new StringControl({ context: ctx, text: this._url || "" }));
            urlWrapper.add(this._urlText);
            this.add(urlWrapper);
            const openBtn = new jsgui2.div({ context: ctx, class: "zs-server-url__open-btn" });
            openBtn.add(new StringControl({ context: ctx, text: "OPEN IN BROWSER \u2192" }));
            this.add(openBtn);
          }
          _syncState() {
            if (this._visible && this._url) {
              this.remove_class("zs-server-url--hidden");
            } else {
              this.add_class("zs-server-url--hidden");
            }
          }
          _ensureClickHandler() {
            if (this._clickHandlerAttached) return;
            if (!this.dom.el || !this._onClick) return;
            console.log("[ServerUrlControl] Attaching click handler");
            this.dom.el.addEventListener("click", (e) => {
              e.preventDefault();
              e.stopPropagation();
              console.log("[ServerUrlControl] CLICK! url:", this._url);
              if (this._url && this._onClick) {
                this._onClick(this._url);
              }
            });
            this._clickHandlerAttached = true;
            console.log("[ServerUrlControl] Click handler attached successfully");
          }
          setUrl(url) {
            this._url = url;
            if (this._urlText && this._urlText.dom.el) {
              this._urlText.dom.el.textContent = url || "";
            }
            this._syncState();
            if (this.dom.el) {
              if (url) {
                this.dom.el.classList.remove("zs-server-url--hidden");
                this._ensureClickHandler();
              } else {
                this.dom.el.classList.add("zs-server-url--hidden");
              }
            }
          }
          setVisible(visible) {
            this._visible = visible;
            this._syncState();
            if (this.dom.el) {
              if (visible && this._url) {
                this.dom.el.classList.remove("zs-server-url--hidden");
                this._ensureClickHandler();
              } else {
                this.dom.el.classList.add("zs-server-url--hidden");
              }
            }
          }
          getUrl() {
            return this._url;
          }
          activate() {
            console.log("[ServerUrlControl] activate() called, dom.el:", !!this.dom?.el);
            this._ensureClickHandler();
          }
        }
        return ServerUrlControl;
      }
      module.exports = { createServerUrlControl };
    }
  });

  // ui/controls/logControls.js
  var require_logControls = __commonJS({
    "ui/controls/logControls.js"(exports, module) {
      "use strict";
      function createLogControls(jsgui2, { StringControl }) {
        class LogEntryControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "div",
              __type_name: "log_entry"
            };
            super(normalized);
            this.add_class("zs-log-entry");
            const type = spec.type || "stdout";
            this.add_class(`zs-log-entry--${type}`);
            const text = spec.text || "";
            this.add(new StringControl({ context: this.context, text }));
          }
        }
        class LogViewerControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "div",
              __type_name: "log_viewer"
            };
            super(normalized);
            this.add_class("zs-log-viewer");
            this._logs = spec.logs || [];
            this._showEmpty = spec.showEmpty !== false;
            if (!spec.el) {
              this.compose();
            }
          }
          compose() {
            this._renderLogs();
          }
          _renderLogs() {
            this.clear();
            if (this._logs.length === 0 && this._showEmpty) {
              const empty = new jsgui2.div({ context: this.context, class: "zs-log-viewer__empty" });
              const icon = new jsgui2.div({ context: this.context, class: "zs-log-viewer__empty-icon" });
              icon.add(new StringControl({ context: this.context, text: "\u25C8" }));
              empty.add(icon);
              const text = new jsgui2.div({ context: this.context, class: "zs-log-viewer__empty-text" });
              text.add(new StringControl({ context: this.context, text: "Select a server to view logs" }));
              empty.add(text);
              this.add(empty);
              return;
            }
            this._logs.forEach((log) => {
              const entry = new LogEntryControl({
                context: this.context,
                type: log.type,
                text: log.data
              });
              this.add(entry);
            });
          }
          setLogs(logs) {
            this._logs = logs;
            this._renderLogs();
            if (this.dom.el) {
              this.dom.el.innerHTML = this.all_html_render_inner();
            }
            this._scrollToBottom();
          }
          addLog(type, data) {
            this._logs.push({ type, data });
            if (this._logs.length === 1) {
              this._renderLogs();
              if (this.dom.el) {
                this.dom.el.innerHTML = this.all_html_render_inner();
              }
            } else {
              const entry = new LogEntryControl({
                context: this.context,
                type,
                text: data
              });
              this.add(entry);
              if (this.dom.el) {
                const entryHtml = entry.all_html_render();
                this.dom.el.insertAdjacentHTML("beforeend", entryHtml);
              }
            }
            this._scrollToBottom();
          }
          _scrollToBottom() {
            if (this.dom.el) {
              this.dom.el.scrollTop = this.dom.el.scrollHeight;
            }
          }
          activate() {
            if (super.activate) super.activate();
            if (!this.dom.el) return;
            this.dom.el.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              this._showContextMenu(e.clientX, e.clientY);
            });
          }
          _showContextMenu(x, y) {
            document.querySelectorAll(".zs-context-menu").forEach((el) => el.remove());
            const range = document.createRange();
            range.selectNodeContents(this.dom.el);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            const menu = document.createElement("div");
            menu.className = "zs-context-menu";
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            const copyItem = document.createElement("div");
            copyItem.className = "zs-context-menu__item";
            copyItem.innerHTML = '<span class="zs-context-menu__item-icon">\u{1F4CB}</span> Copy';
            copyItem.addEventListener("click", () => {
              const text = this.dom.el.innerText;
              navigator.clipboard.writeText(text).then(() => {
              });
              menu.remove();
            });
            menu.appendChild(copyItem);
            document.body.appendChild(menu);
            const closeHandler = (e) => {
              if (!menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener("click", closeHandler);
                document.removeEventListener("contextmenu", closeHandler);
              }
            };
            setTimeout(() => {
              document.addEventListener("click", closeHandler);
              document.addEventListener("contextmenu", closeHandler);
            }, 0);
          }
          clear() {
            while (this.content && this.content.length > 0) {
              this.content.pop();
            }
          }
        }
        return { LogEntryControl, LogViewerControl };
      }
      module.exports = { createLogControls };
    }
  });

  // ui/controls/serverLogWindowControl.js
  var require_serverLogWindowControl = __commonJS({
    "ui/controls/serverLogWindowControl.js"(exports, module) {
      "use strict";
      function createServerLogWindowControl(jsgui2, { LogViewerControl }) {
        class ServerLogWindowControl extends jsgui2.Window {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              title: spec.serverName || "Server Logs",
              show_buttons: true,
              __type_name: "server_log_window"
            };
            super(normalized);
            this.add_class("zs-log-window");
            this._serverName = spec.serverName || "Server Logs";
            this._visible = spec.visible !== false;
            this._onClose = spec.onClose || null;
            this._position = spec.position || { x: 50, y: 50 };
            this._size = spec.size || { width: 600, height: 400 };
            this._minimized = false;
            this._maximized = false;
            if (this.ctrl_inner) {
              this._logViewer = new LogViewerControl({
                context: this.context,
                showEmpty: true
              });
              this.ctrl_inner.add(this._logViewer);
            }
            const resizeHandle = new jsgui2.div({ context: this.context, class: "zs-log-window__resize-handle" });
            this.add(resizeHandle);
            this._resizeHandle = resizeHandle;
            if (!this._visible) {
              this.add_class("zs-log-window--hidden");
            }
          }
          activate() {
            if (super.activate) {
              super.activate();
            }
            if (!this.dom.el) return;
            const el = this.dom.el;
            el.style.position = "absolute";
            el.style.left = `${this._position.x}px`;
            el.style.top = `${this._position.y}px`;
            el.style.width = `${this._size.width}px`;
            el.style.height = `${this._size.height}px`;
            if (this._ctrl_fields) {
              const { btn_minimize, btn_maximize, btn_close } = this._ctrl_fields;
              if (btn_minimize && btn_minimize.dom.el) {
                btn_minimize.dom.el.addEventListener("click", () => this.toggleMinimize());
              }
              if (btn_maximize && btn_maximize.dom.el) {
                btn_maximize.dom.el.addEventListener("click", () => this.toggleMaximize());
              }
              if (btn_close && btn_close.dom.el) {
                btn_close.dom.el.addEventListener("click", () => this.close());
              }
            }
            if (this.title_bar && this.title_bar.dom.el) {
              this._setupDragging(this.title_bar.dom.el, el);
            }
            if (this._resizeHandle && this._resizeHandle.dom.el) {
              this._setupResizing(this._resizeHandle.dom.el, el);
            }
            el.addEventListener("mousedown", () => this.bringToFront());
            if (this._logViewer) {
              this._logViewer.activate();
            }
          }
          _setupDragging(titleEl, windowEl) {
            let isDragging = false;
            let dragStart = { x: 0, y: 0 };
            let posStart = { x: 0, y: 0 };
            titleEl.addEventListener("mousedown", (e) => {
              if (e.target.closest("button")) return;
              if (this._maximized) return;
              isDragging = true;
              dragStart = { x: e.clientX, y: e.clientY };
              posStart = { x: this._position.x, y: this._position.y };
              windowEl.classList.add("zs-log-window--dragging");
              this.bringToFront();
              e.preventDefault();
            });
            document.addEventListener("mousemove", (e) => {
              if (!isDragging) return;
              const dx = e.clientX - dragStart.x;
              const dy = e.clientY - dragStart.y;
              this._position.x = Math.max(0, posStart.x + dx);
              this._position.y = Math.max(0, posStart.y + dy);
              windowEl.style.left = `${this._position.x}px`;
              windowEl.style.top = `${this._position.y}px`;
            });
            document.addEventListener("mouseup", () => {
              if (isDragging) {
                isDragging = false;
                windowEl.classList.remove("zs-log-window--dragging");
              }
            });
          }
          _setupResizing(handleEl, windowEl) {
            let isResizing = false;
            let resizeStart = { x: 0, y: 0 };
            let sizeStart = { width: 0, height: 0 };
            handleEl.addEventListener("mousedown", (e) => {
              if (this._maximized) return;
              isResizing = true;
              resizeStart = { x: e.clientX, y: e.clientY };
              sizeStart = { width: this._size.width, height: this._size.height };
              windowEl.classList.add("zs-log-window--resizing");
              e.preventDefault();
              e.stopPropagation();
            });
            document.addEventListener("mousemove", (e) => {
              if (!isResizing) return;
              const dx = e.clientX - resizeStart.x;
              const dy = e.clientY - resizeStart.y;
              this._size.width = Math.max(300, sizeStart.width + dx);
              this._size.height = Math.max(200, sizeStart.height + dy);
              windowEl.style.width = `${this._size.width}px`;
              windowEl.style.height = `${this._size.height}px`;
            });
            document.addEventListener("mouseup", () => {
              if (isResizing) {
                isResizing = false;
                windowEl.classList.remove("zs-log-window--resizing");
              }
            });
          }
          bringToFront() {
            if (super.bring_to_front_z) {
              super.bring_to_front_z();
            } else {
              const windows = document.querySelectorAll(".zs-log-window");
              let maxZ = 100;
              windows.forEach((w) => {
                const z = parseInt(w.style.zIndex || "100", 10);
                if (z > maxZ) maxZ = z;
              });
              this.dom.el.style.zIndex = String(maxZ + 1);
            }
          }
          toggleMinimize() {
            this._minimized = !this._minimized;
            const el = this.dom.el;
            const btn = this._ctrl_fields?.btn_minimize?.dom?.el;
            if (this._minimized) {
              el.classList.add("zs-log-window--minimized");
              if (btn) btn.textContent = "\u2295";
            } else {
              el.classList.remove("zs-log-window--minimized");
              if (btn) btn.textContent = "\u2296";
            }
          }
          toggleMaximize() {
            this._maximized = !this._maximized;
            const el = this.dom.el;
            const btn = this._ctrl_fields?.btn_maximize?.dom?.el;
            if (this._maximized) {
              this._savedPos = { ...this._position };
              this._savedSize = { ...this._size };
              el.classList.add("zs-log-window--maximized");
              if (btn) btn.textContent = "\u25F1";
            } else {
              this._position = this._savedPos || this._position;
              this._size = this._savedSize || this._size;
              el.classList.remove("zs-log-window--maximized");
              el.style.left = `${this._position.x}px`;
              el.style.top = `${this._position.y}px`;
              el.style.width = `${this._size.width}px`;
              el.style.height = `${this._size.height}px`;
              if (btn) btn.textContent = "\u2295";
            }
          }
          show(serverName) {
            if (serverName) {
              this._serverName = serverName;
              if (this.title_bar) {
                const h2 = this.title_bar.content?.find((c2) => c2.__type_name === "h2" || c2.dom?.tagName?.toLowerCase() === "h2");
                if (h2 && h2.dom.el) {
                  h2.dom.el.textContent = serverName;
                }
              }
            }
            this._visible = true;
            this.dom.el.classList.remove("zs-log-window--hidden");
            this.bringToFront();
            this._logViewer.setLogs([]);
          }
          hide() {
            this._visible = false;
            this.dom.el.classList.add("zs-log-window--hidden");
          }
          close() {
            this.hide();
            if (this._onClose) {
              this._onClose();
            }
          }
          isVisible() {
            return this._visible;
          }
          addLog(type, data) {
            this._logViewer.addLog(type, data);
          }
          setLogs(logs) {
            this._logViewer.setLogs(logs);
          }
          clearLogs() {
            this._logViewer.setLogs([]);
          }
          setTitle(title) {
            this._serverName = title;
            if (this.title_bar) {
              const h2 = this.title_bar.content?.find((c2) => c2.__type_name === "h2" || c2.dom?.tagName?.toLowerCase() === "h2");
              if (h2 && h2.dom.el) {
                h2.dom.el.textContent = title;
              }
            }
          }
        }
        return ServerLogWindowControl;
      }
      module.exports = { createServerLogWindowControl };
    }
  });

  // ui/controls/controlButtonControl.js
  var require_controlButtonControl = __commonJS({
    "ui/controls/controlButtonControl.js"(exports, module) {
      "use strict";
      function createControlButtonControl(jsgui2, { StringControl }) {
        class ControlButtonControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "button",
              __type_name: "control_button"
            };
            super(normalized);
            this.add_class("zs-btn");
            if (spec.variant) {
              this.add_class(`zs-btn--${spec.variant}`);
            }
            this._disabled = spec.disabled || false;
            this._onClick = spec.onClick || null;
            this._label = spec.label || "Button";
            if (!spec.el) {
              this.compose();
            }
            this._syncState();
          }
          compose() {
            this.add(new StringControl({ context: this.context, text: this._label }));
          }
          _syncState() {
            if (this._disabled) {
              this.dom.attributes.disabled = "disabled";
              this.add_class("zs-btn--disabled");
            } else {
              delete this.dom.attributes.disabled;
              this.remove_class("zs-btn--disabled");
            }
          }
          setDisabled(disabled) {
            this._disabled = disabled;
            this._syncState();
            if (this.dom.el) {
              this.dom.el.disabled = disabled;
              if (disabled) {
                this.dom.el.classList.add("zs-btn--disabled");
              } else {
                this.dom.el.classList.remove("zs-btn--disabled");
              }
            }
          }
          activate() {
            if (this.dom.el && this._onClick) {
              this.dom.el.addEventListener("click", () => {
                if (!this._disabled) {
                  this._onClick();
                }
              });
            }
          }
        }
        return ControlButtonControl;
      }
      module.exports = { createControlButtonControl };
    }
  });

  // ui/controls/controlPanelControl.js
  var require_controlPanelControl = __commonJS({
    "ui/controls/controlPanelControl.js"(exports, module) {
      "use strict";
      function createControlPanelControl(jsgui2, { ControlButtonControl, StringControl }) {
        class ControlPanelControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "div",
              __type_name: "control_panel"
            };
            super(normalized);
            this.add_class("zs-control-panel");
            this._visible = spec.visible || false;
            this._serverRunning = spec.serverRunning || false;
            this._onStart = spec.onStart || null;
            this._onStop = spec.onStop || null;
            this._onRestart = spec.onRestart || null;
            this._isUiServer = spec.isUiServer === true;
            this._uiClientStatus = spec.uiClientStatus || null;
            this._onRebuildUiClient = spec.onRebuildUiClient || null;
            this._autoRebuildUiClient = spec.autoRebuildUiClient === true;
            this._onToggleAutoRebuildUiClient = spec.onToggleAutoRebuildUiClient || null;
            this._keepRunningAfterExit = spec.keepRunningAfterExit === true;
            this._onToggleKeepRunningAfterExit = spec.onToggleKeepRunningAfterExit || null;
            if (!spec.el) {
              this.compose();
            }
            this._syncState();
          }
          compose() {
            const ctx = this.context;
            this._startBtn = new ControlButtonControl({
              context: ctx,
              label: "\u25B6 Start Server",
              variant: "start",
              disabled: this._serverRunning,
              onClick: () => this._onStart && this._onStart()
            });
            this.add(this._startBtn);
            this._stopBtn = new ControlButtonControl({
              context: ctx,
              label: "\u25A0 Stop Server",
              variant: "stop",
              disabled: !this._serverRunning,
              onClick: () => this._onStop && this._onStop()
            });
            this.add(this._stopBtn);
            this._restartBtn = new ControlButtonControl({
              context: ctx,
              label: "\u21BB Restart",
              variant: "restart",
              disabled: !this._serverRunning,
              onClick: () => this._onRestart && this._onRestart()
            });
            this.add(this._restartBtn);
            this._rebuildUiBtn = new ControlButtonControl({
              context: ctx,
              label: "\u{1F528} Rebuild UI",
              variant: "rebuild",
              disabled: true,
              onClick: () => this._onRebuildUiClient && this._onRebuildUiClient()
            });
            this.add(this._rebuildUiBtn);
            this._autoRebuildWrap = new jsgui2.div({ context: ctx, class: "zs-autorebuild zs-control-panel__autorebuild" });
            this._autoRebuildLabel = new jsgui2.Control({ context: ctx, tagName: "label", class: "zs-autorebuild__label" });
            this._autoRebuildCheckbox = new jsgui2.Control({ context: ctx, tagName: "input", class: "zs-autorebuild__checkbox" });
            this._autoRebuildCheckbox.dom.attributes.type = "checkbox";
            if (this._autoRebuildUiClient) {
              this._autoRebuildCheckbox.dom.attributes.checked = "checked";
            }
            this._autoRebuildText = new jsgui2.span({ context: ctx, class: "zs-autorebuild__text" });
            this._autoRebuildText.add(new StringControl({ context: ctx, text: "Auto rebuild UI on start" }));
            this._autoRebuildLabel.add(this._autoRebuildCheckbox);
            this._autoRebuildLabel.add(this._autoRebuildText);
            this._autoRebuildWrap.add(this._autoRebuildLabel);
            this.add(this._autoRebuildWrap);
            this._keepRunningWrap = new jsgui2.div({ context: ctx, class: "zs-keeprunning zs-control-panel__keeprunning" });
            this._keepRunningLabel = new jsgui2.Control({ context: ctx, tagName: "label", class: "zs-keeprunning__label" });
            this._keepRunningCheckbox = new jsgui2.Control({ context: ctx, tagName: "input", class: "zs-keeprunning__checkbox" });
            this._keepRunningCheckbox.dom.attributes.type = "checkbox";
            if (this._keepRunningAfterExit) {
              this._keepRunningCheckbox.dom.attributes.checked = "checked";
            }
            this._keepRunningText = new jsgui2.span({ context: ctx, class: "zs-keeprunning__text" });
            this._keepRunningText.add(new StringControl({ context: ctx, text: "Keep running after z-server closes" }));
            this._keepRunningLabel.add(this._keepRunningCheckbox);
            this._keepRunningLabel.add(this._keepRunningText);
            this._keepRunningWrap.add(this._keepRunningLabel);
            this.add(this._keepRunningWrap);
            this._syncUiControls();
          }
          _syncUiControls() {
            const isUi = this._isUiServer === true;
            if (this._rebuildUiBtn) {
              if (isUi) {
                this._rebuildUiBtn.remove_class("zs-hidden");
              } else {
                this._rebuildUiBtn.add_class("zs-hidden");
              }
            }
            if (this._autoRebuildWrap) {
              if (isUi) {
                this._autoRebuildWrap.remove_class("zs-hidden");
              } else {
                this._autoRebuildWrap.add_class("zs-hidden");
              }
            }
            this._syncUiClientStatus();
          }
          _syncUiClientStatus() {
            if (!this._rebuildUiBtn) return;
            if (!this._isUiServer) {
              this._rebuildUiBtn.setDisabled(true);
              return;
            }
            const status = this._uiClientStatus;
            if (!status || typeof status !== "object") {
              this._rebuildUiBtn.setDisabled(true);
              return;
            }
            this._rebuildUiBtn.setDisabled(status.needsBuild !== true);
          }
          _syncState() {
            if (this._visible) {
              this.remove_class("zs-control-panel--hidden");
            } else {
              this.add_class("zs-control-panel--hidden");
            }
          }
          setVisible(visible) {
            this._visible = visible;
            this._syncState();
            if (this.dom.el) {
              if (visible) {
                this.dom.el.classList.remove("zs-control-panel--hidden");
              } else {
                this.dom.el.classList.add("zs-control-panel--hidden");
              }
            }
          }
          setServerRunning(running) {
            this._serverRunning = running;
            this._startBtn.setDisabled(running);
            this._stopBtn.setDisabled(!running);
            if (this._restartBtn) this._restartBtn.setDisabled(!running);
          }
          setUiServer(isUiServer) {
            this._isUiServer = isUiServer === true;
            this._syncUiControls();
            if (this.dom.el) {
              const rebuildBtn = this.dom.el.querySelector(".zs-btn--rebuild");
              const wrap = this.dom.el.querySelector(".zs-control-panel__autorebuild");
              if (rebuildBtn) {
                rebuildBtn.classList.toggle("zs-hidden", !this._isUiServer);
              }
              if (wrap) {
                wrap.classList.toggle("zs-hidden", !this._isUiServer);
              }
            }
          }
          setUiClientStatus(status) {
            this._uiClientStatus = status;
            this._syncUiClientStatus();
          }
          setAutoRebuildUiClient(enabled) {
            this._autoRebuildUiClient = enabled === true;
            if (this._autoRebuildCheckbox) {
              if (this._autoRebuildUiClient) {
                this._autoRebuildCheckbox.dom.attributes.checked = "checked";
              } else {
                delete this._autoRebuildCheckbox.dom.attributes.checked;
              }
            }
            if (this.dom.el) {
              const el = this.dom.el.querySelector(".zs-autorebuild__checkbox");
              if (el) el.checked = this._autoRebuildUiClient;
            }
          }
          setKeepRunningAfterExit(enabled) {
            this._keepRunningAfterExit = enabled === true;
            if (this._keepRunningCheckbox) {
              if (this._keepRunningAfterExit) {
                this._keepRunningCheckbox.dom.attributes.checked = "checked";
              } else {
                delete this._keepRunningCheckbox.dom.attributes.checked;
              }
            }
            if (this.dom.el) {
              const el = this.dom.el.querySelector(".zs-keeprunning__checkbox");
              if (el) el.checked = this._keepRunningAfterExit;
            }
          }
          activate() {
            this._startBtn.activate();
            this._stopBtn.activate();
            if (this._restartBtn) this._restartBtn.activate();
            this._rebuildUiBtn.activate();
            if (this.dom.el) {
              const checkbox = this.dom.el.querySelector(".zs-autorebuild__checkbox");
              if (checkbox && !checkbox.__zsBound) {
                checkbox.checked = this._autoRebuildUiClient;
                checkbox.addEventListener("change", () => {
                  const enabled = checkbox.checked === true;
                  this._autoRebuildUiClient = enabled;
                  if (this._onToggleAutoRebuildUiClient) {
                    this._onToggleAutoRebuildUiClient(enabled);
                  }
                });
                checkbox.__zsBound = true;
              }
              const keepRunning = this.dom.el.querySelector(".zs-keeprunning__checkbox");
              if (keepRunning && !keepRunning.__zsBound) {
                keepRunning.checked = this._keepRunningAfterExit;
                keepRunning.addEventListener("change", () => {
                  const enabled = keepRunning.checked === true;
                  this._keepRunningAfterExit = enabled;
                  if (this._onToggleKeepRunningAfterExit) {
                    this._onToggleKeepRunningAfterExit(enabled);
                  }
                });
                keepRunning.__zsBound = true;
              }
            }
          }
        }
        return ControlPanelControl;
      }
      module.exports = { createControlPanelControl };
    }
  });

  // ui/controls/scanningIndicatorControl.js
  var require_scanningIndicatorControl = __commonJS({
    "ui/controls/scanningIndicatorControl.js"(exports, module) {
      "use strict";
      function createScanningIndicatorControl(jsgui2, { StringControl }) {
        class ScanningIndicatorControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "div",
              __type_name: "scanning_indicator"
            };
            super(normalized);
            this.add_class("zs-scanning");
            this._total = 0;
            this._current = 0;
            this._currentFile = "";
            this._isCounting = false;
            this._countTick = 0;
            if (!spec.el) {
              this.compose();
            }
          }
          compose() {
            const ctx = this.context;
            const svg = new jsgui2.Control({ context: ctx, tagName: "svg" });
            svg.dom.attributes.viewBox = "0 0 100 100";
            svg.add_class("zs-scanning__svg");
            const ring = new jsgui2.Control({ context: ctx, tagName: "circle" });
            ring.dom.attributes.cx = "50";
            ring.dom.attributes.cy = "50";
            ring.dom.attributes.r = "45";
            ring.dom.attributes.class = "zs-scanning__ring";
            svg.add(ring);
            const innerRing = new jsgui2.Control({ context: ctx, tagName: "circle" });
            innerRing.dom.attributes.cx = "50";
            innerRing.dom.attributes.cy = "50";
            innerRing.dom.attributes.r = "30";
            innerRing.dom.attributes.class = "zs-scanning__ring-inner";
            svg.add(innerRing);
            const sweep = new jsgui2.Control({ context: ctx, tagName: "path" });
            sweep.dom.attributes.d = "M50 50 L50 5 A45 45 0 0 1 95 50 Z";
            sweep.dom.attributes.class = "zs-scanning__sweep";
            svg.add(sweep);
            const dot = new jsgui2.Control({ context: ctx, tagName: "circle" });
            dot.dom.attributes.cx = "50";
            dot.dom.attributes.cy = "50";
            dot.dom.attributes.r = "4";
            dot.dom.attributes.class = "zs-scanning__dot";
            svg.add(dot);
            this.add(svg);
            const text = new jsgui2.div({ context: ctx, class: "zs-scanning__text" });
            text.add(new StringControl({ context: ctx, text: "SCANNING FOR SERVERS..." }));
            this.add(text);
            this._textEl = text;
            const progressContainer = new jsgui2.div({ context: ctx, class: "zs-scanning__progress-container" });
            const progressBg = new jsgui2.div({ context: ctx, class: "zs-scanning__progress-bg" });
            const progressFill = new jsgui2.div({ context: ctx, class: "zs-scanning__progress-fill" });
            progressBg.add(progressFill);
            this._progressFillEl = progressFill;
            progressContainer.add(progressBg);
            const progressText = new jsgui2.div({ context: ctx, class: "zs-scanning__progress-text" });
            progressText.add(new StringControl({ context: ctx, text: "Counting files..." }));
            progressContainer.add(progressText);
            this._progressTextEl = progressText;
            this.add(progressContainer);
            const subtitle = new jsgui2.div({ context: ctx, class: "zs-scanning__subtitle" });
            subtitle.add(new StringControl({ context: ctx, text: "Analyzing JavaScript files in repository" }));
            this.add(subtitle);
            this._subtitleEl = subtitle;
          }
          setTotal(total) {
            this._total = total;
            this._current = 0;
            this._isCounting = false;
            this._updateProgress();
          }
          startCounting() {
            this._isCounting = true;
            this._current = 0;
            this._total = 0;
            this._currentFile = "";
            this._countTick = 0;
            this._updateCountingProgress();
          }
          setCountingProgress(current, file) {
            this._isCounting = true;
            this._current = current;
            this._currentFile = file || "";
            this._countTick++;
            this._updateCountingProgress();
          }
          setProgress(current, total, file) {
            this._isCounting = false;
            this._current = current;
            this._total = total || this._total;
            this._currentFile = file || "";
            this._updateProgress();
          }
          _updateProgress() {
            if (this._isCounting) {
              this._updateCountingProgress();
              return;
            }
            const percent = this._total > 0 ? this._current / this._total * 100 : 0;
            if (!this._progressFillEl?.dom?.el && this.dom.el) {
              this.ensureDomRefs();
            }
            if (this._progressFillEl && this._progressFillEl.dom.el) {
              this._progressFillEl.dom.el.style.width = `${percent}%`;
            }
            if (this._progressTextEl && this._progressTextEl.dom.el) {
              if (this._total > 0) {
                this._progressTextEl.dom.el.textContent = `${this._current} / ${this._total} files`;
              } else {
                this._progressTextEl.dom.el.textContent = "Counting files...";
              }
            }
            if (this._subtitleEl && this._subtitleEl.dom.el && this._currentFile) {
              const displayFile = this._currentFile.length > 50 ? "..." + this._currentFile.slice(-47) : this._currentFile;
              this._subtitleEl.dom.el.textContent = displayFile;
            } else if (this._subtitleEl && this._subtitleEl.dom.el && !this._currentFile) {
              this._subtitleEl.dom.el.textContent = "Analyzing JavaScript files in repository";
            }
          }
          _updateCountingProgress() {
            const percent = this._countTick % 40 / 40 * 100;
            if (this._progressFillEl && this._progressFillEl.dom.el) {
              this._progressFillEl.dom.el.style.width = `${percent}%`;
            }
            if (this._progressTextEl && this._progressTextEl.dom.el) {
              const countLabel = this._current > 0 ? `Counting files (${this._current})...` : "Counting files...";
              this._progressTextEl.dom.el.textContent = countLabel;
            }
            if (this._subtitleEl && this._subtitleEl.dom.el) {
              if (this._currentFile) {
                const displayFile = this._currentFile.length > 50 ? "..." + this._currentFile.slice(-47) : this._currentFile;
                this._subtitleEl.dom.el.textContent = displayFile;
              } else {
                this._subtitleEl.dom.el.textContent = "Scanning repository...";
              }
            }
          }
          reset() {
            this._total = 0;
            this._current = 0;
            this._currentFile = "";
            this._isCounting = false;
            this._countTick = 0;
            if (this._progressFillEl && this._progressFillEl.dom.el) {
              this._progressFillEl.dom.el.style.width = "0%";
            }
            if (this._progressTextEl && this._progressTextEl.dom.el) {
              this._progressTextEl.dom.el.textContent = "Counting files...";
            }
            if (this._subtitleEl && this._subtitleEl.dom.el) {
              this._subtitleEl.dom.el.textContent = "Analyzing JavaScript files in repository";
            }
          }
          ensureDomRefs() {
            const rootEl = this.dom.el;
            if (!rootEl) return;
            if (this._progressFillEl && !this._progressFillEl.dom.el) {
              const fillEl = rootEl.querySelector(".zs-scanning__progress-fill");
              if (fillEl) this._progressFillEl.dom.el = fillEl;
            }
            if (this._progressTextEl && !this._progressTextEl.dom.el) {
              const textEl = rootEl.querySelector(".zs-scanning__progress-text");
              if (textEl) this._progressTextEl.dom.el = textEl;
            }
            if (this._subtitleEl && !this._subtitleEl.dom.el) {
              const subEl = rootEl.querySelector(".zs-scanning__subtitle");
              if (subEl) this._subtitleEl.dom.el = subEl;
            }
          }
        }
        return ScanningIndicatorControl;
      }
      module.exports = { createScanningIndicatorControl };
    }
  });

  // ui/controls/sidebarControl.js
  var require_sidebarControl = __commonJS({
    "ui/controls/sidebarControl.js"(exports, module) {
      "use strict";
      function createSidebarControl(jsgui2, { ServerListControl, StringControl }) {
        class SidebarControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "aside",
              __type_name: "sidebar"
            };
            super(normalized);
            this.add_class("zs-sidebar");
            this._servers = spec.servers || [];
            this._onSelect = spec.onSelect || null;
            this._onOpenUrl = spec.onOpenUrl || null;
            this._scanVisibility = spec.scanVisibility && typeof spec.scanVisibility === "object" ? spec.scanVisibility : null;
            this._onChangeScanVisibility = spec.onChangeScanVisibility || null;
            if (!spec.el) {
              this.compose();
            }
          }
          compose() {
            const ctx = this.context;
            const header = new jsgui2.div({ context: ctx, class: "zs-sidebar__header" });
            const title = new jsgui2.h2({ context: ctx, class: "zs-sidebar__title" });
            title.add(new StringControl({ context: ctx, text: "\u25C8 Servers" }));
            header.add(title);
            this._filtersWrap = new jsgui2.div({ context: ctx, class: "zs-sidebar__filters" });
            const filtersTitle = new jsgui2.div({ context: ctx, class: "zs-sidebar__filters-title" });
            filtersTitle.add(new StringControl({ context: ctx, text: "Show:" }));
            this._filtersWrap.add(filtersTitle);
            this._filterCheckboxes = {};
            const addFilter = (key2, labelText) => {
              const row = new jsgui2.div({ context: ctx, class: "zs-sidebar__filter" });
              const label = new jsgui2.Control({ context: ctx, tagName: "label", class: "zs-sidebar__filter-label" });
              const checkbox = new jsgui2.Control({ context: ctx, tagName: "input", class: `zs-sidebar__filter-checkbox zs-sidebar__filter-checkbox--${key2}` });
              checkbox.dom.attributes.type = "checkbox";
              checkbox.dom.attributes["data-filter-key"] = key2;
              const text = new jsgui2.span({ context: ctx, class: "zs-sidebar__filter-text" });
              text.add(new StringControl({ context: ctx, text: labelText }));
              label.add(checkbox);
              label.add(text);
              row.add(label);
              this._filtersWrap.add(row);
              this._filterCheckboxes[key2] = checkbox;
            };
            addFilter("ui", "UI servers");
            addFilter("labs", "Lab experiments");
            addFilter("api", "API/back-end");
            addFilter("tools", "Tools");
            addFilter("tests", "Tests");
            addFilter("checks", "Checks");
            addFilter("other", "Other");
            header.add(this._filtersWrap);
            this.add(header);
            this._serverList = new ServerListControl({
              context: ctx,
              servers: this._servers,
              onSelect: (s) => this._onSelect && this._onSelect(s),
              onOpenUrl: (url) => this._onOpenUrl && this._onOpenUrl(url)
            });
            this.add(this._serverList);
            this.setScanVisibility(this._scanVisibility);
          }
          setServers(servers) {
            this._servers = servers;
            this._serverList.setServers(servers);
          }
          setScanVisibility(visibility) {
            this._scanVisibility = visibility && typeof visibility === "object" ? visibility : null;
            if (!this._filterCheckboxes) return;
            for (const [key2, checkbox] of Object.entries(this._filterCheckboxes)) {
              const enabled = this._scanVisibility && this._scanVisibility[key2] === true;
              if (enabled) {
                checkbox.dom.attributes.checked = "checked";
              } else {
                delete checkbox.dom.attributes.checked;
              }
            }
            if (this.dom.el) {
              for (const key2 of Object.keys(this._filterCheckboxes)) {
                const el = this.dom.el.querySelector(`.zs-sidebar__filter-checkbox--${key2}`);
                if (el) el.checked = this._scanVisibility && this._scanVisibility[key2] === true;
              }
            }
          }
          updateServerStatus(filePath, running) {
            this._serverList.updateServerStatus(filePath, running);
          }
          setServerRunningUrl(filePath, url) {
            this._serverList.setServerRunningUrl(filePath, url);
          }
          activate() {
            this._serverList.activate();
            if (this.dom.el) {
              const checkboxes = this.dom.el.querySelectorAll(".zs-sidebar__filter-checkbox");
              for (const checkbox of checkboxes) {
                if (checkbox.__zsBound) continue;
                checkbox.__zsBound = true;
                checkbox.addEventListener("change", () => {
                  const key2 = checkbox.getAttribute("data-filter-key");
                  if (!key2) return;
                  const enabled = checkbox.checked === true;
                  if (!this._scanVisibility || typeof this._scanVisibility !== "object") {
                    this._scanVisibility = {};
                  }
                  this._scanVisibility[key2] = enabled;
                  if (this._onChangeScanVisibility) {
                    this._onChangeScanVisibility({ ...this._scanVisibility });
                  }
                });
              }
            }
          }
        }
        return SidebarControl;
      }
      module.exports = { createSidebarControl };
    }
  });

  // ui/lib/extractUrl.js
  var require_extractUrl = __commonJS({
    "ui/lib/extractUrl.js"(exports, module) {
      "use strict";
      function extractUrl(text) {
        if (!text || typeof text !== "string") return null;
        const urlPatterns = [
          /https?:\/\/localhost:\d+[^\s]*/i,
          /https?:\/\/127\.0\.0\.1:\d+[^\s]*/i,
          /https?:\/\/0\.0\.0\.0:\d+[^\s]*/i,
          /Server (?:running|listening|started) (?:on|at) (https?:\/\/[^\s]+)/i,
          /listening on (https?:\/\/[^\s]+)/i,
          /available at (https?:\/\/[^\s]+)/i
        ];
        for (const pattern of urlPatterns) {
          const match = pattern.exec(text);
          if (match) {
            return match[1] || match[0];
          }
        }
        return null;
      }
      module.exports = { extractUrl };
    }
  });

  // ui/controls/contentAreaControl.js
  var require_contentAreaControl = __commonJS({
    "ui/controls/contentAreaControl.js"(exports, module) {
      "use strict";
      var { extractUrl } = require_extractUrl();
      var { getMajorServersWithCards } = require_appCatalog();
      function escapeHtml(value2) {
        return String(value2 == null ? "" : value2).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&#39;");
      }
      function createContentAreaControl(jsgui2, {
        ControlPanelControl,
        ServerUrlControl,
        ScanningIndicatorControl,
        LogViewerControl,
        StringControl
      }) {
        class ContentAreaControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "main",
              __type_name: "content_area"
            };
            super(normalized);
            this.add_class("zs-content");
            this._defaultTitleText = "Select a Server";
            this._scanningTitleText = "Scanning for servers...";
            this._selectedServer = null;
            this._servers = [];
            this._majorServers = [];
            this._serverByFile = /* @__PURE__ */ new Map();
            this._onStart = spec.onStart || null;
            this._onStop = spec.onStop || null;
            this._onRestart = spec.onRestart || null;
            this._onUrlDetected = spec.onUrlDetected || null;
            this._onOpenUrl = spec.onOpenUrl || null;
            this._onSelectServer = spec.onSelectServer || null;
            this._onQuickStartServer = spec.onQuickStartServer || null;
            this._isScanning = false;
            this._onRebuildUiClient = spec.onRebuildUiClient || null;
            this._onToggleAutoRebuildUiClient = spec.onToggleAutoRebuildUiClient || null;
            this._autoRebuildUiClient = spec.autoRebuildUiClient === true;
            this._onToggleKeepRunningAfterExit = spec.onToggleKeepRunningAfterExit || null;
            this._keepRunningAfterExit = spec.keepRunningAfterExit === true;
            this._detectedUrl = null;
            if (!spec.el) {
              this.compose();
            }
          }
          compose() {
            const ctx = this.context;
            const header = new jsgui2.div({ context: ctx, class: "zs-content__header" });
            this._title = new jsgui2.h1({ context: ctx, class: "zs-content__title" });
            this._title.add(new StringControl({ context: ctx, text: this._defaultTitleText }));
            header.add(this._title);
            this._controlPanel = new ControlPanelControl({
              context: ctx,
              visible: false,
              onStart: () => this._onStart && this._onStart(),
              onStop: () => this._onStop && this._onStop(),
              onRestart: () => this._onRestart && this._onRestart(),
              isUiServer: false,
              onRebuildUiClient: () => this._onRebuildUiClient && this._onRebuildUiClient(),
              autoRebuildUiClient: this._autoRebuildUiClient,
              onToggleAutoRebuildUiClient: (enabled) => {
                this._autoRebuildUiClient = enabled === true;
                if (this._onToggleAutoRebuildUiClient) {
                  this._onToggleAutoRebuildUiClient(this._autoRebuildUiClient);
                }
              },
              keepRunningAfterExit: this._keepRunningAfterExit,
              onToggleKeepRunningAfterExit: (enabled) => {
                this._keepRunningAfterExit = enabled === true;
                if (this._onToggleKeepRunningAfterExit) {
                  this._onToggleKeepRunningAfterExit(this._keepRunningAfterExit);
                }
              }
            });
            header.add(this._controlPanel);
            this.add(header);
            this._serverUrl = new ServerUrlControl({
              context: ctx,
              visible: false,
              onClick: (url) => {
                if (this._onOpenUrl) {
                  this._onOpenUrl(url);
                }
              }
            });
            this.add(this._serverUrl);
            this._overview = new jsgui2.div({ context: ctx, class: "zs-overview" });
            this._overview.add_class("zs-hidden");
            const overviewHeader = new jsgui2.div({ context: ctx, class: "zs-overview__header" });
            const overviewTitle = new jsgui2.div({ context: ctx, class: "zs-overview__title" });
            overviewTitle.add(new StringControl({ context: ctx, text: "Featured Apps" }));
            overviewHeader.add(overviewTitle);
            const overviewHint = new jsgui2.div({ context: ctx, class: "zs-overview__hint" });
            overviewHint.add(new StringControl({ context: ctx, text: "Click a card to select; open if already running." }));
            overviewHeader.add(overviewHint);
            this._overview.add(overviewHeader);
            this._overviewGrid = new jsgui2.div({ context: ctx, class: "zs-app-cards" });
            this._overview.add(this._overviewGrid);
            this.add(this._overview);
            this._scanningIndicator = new ScanningIndicatorControl({ context: ctx });
            this._scanningIndicator.add_class("zs-hidden");
            this.add(this._scanningIndicator);
            this._logViewer = new LogViewerControl({
              context: ctx,
              showEmpty: true
            });
            this.add(this._logViewer);
          }
          setSelectedServer(server) {
            this._selectedServer = server;
            this._detectedUrl = null;
            this._updateOverviewVisibility();
            this._serverUrl.setUrl(null);
            this._serverUrl.setVisible(false);
            const displayName = server.metadata && server.metadata.name ? server.metadata.name : server.relativeFile.split(/[\\/\\\\]/).pop();
            if (this._title.dom.el) {
              this._title.dom.el.textContent = displayName;
            }
            this._controlPanel.setVisible(true);
            this._controlPanel.setServerRunning(server.running || false);
            this._controlPanel.setUiServer(server.hasHtmlInterface === true);
            if (server.running && server.runningUrl) {
              this._detectedUrl = server.runningUrl;
              this._serverUrl.setUrl(server.runningUrl);
              this._serverUrl.setVisible(true);
            }
          }
          setUiClientStatus(status) {
            this._controlPanel.setUiClientStatus(status);
          }
          setAutoRebuildUiClient(enabled) {
            this._autoRebuildUiClient = enabled === true;
            this._controlPanel.setAutoRebuildUiClient(this._autoRebuildUiClient);
          }
          setKeepRunningAfterExit(enabled) {
            this._keepRunningAfterExit = enabled === true;
            this._controlPanel.setKeepRunningAfterExit(this._keepRunningAfterExit);
          }
          setRunningUrl(url) {
            this._detectedUrl = url;
            this._serverUrl.setUrl(url);
            this._serverUrl.setVisible(!!url);
          }
          setServerRunning(running) {
            if (this._selectedServer) {
              this._selectedServer.running = running;
              this._controlPanel.setServerRunning(running);
              if (!running) {
                this._detectedUrl = null;
                this._serverUrl.setUrl(null);
                this._serverUrl.setVisible(false);
              }
            }
          }
          addLog(type, data) {
            this._logViewer.addLog(type, data);
            if (!this._detectedUrl && (type === "stdout" || type === "system")) {
              const url = extractUrl(data);
              if (url && this._selectedServer) {
                this._detectedUrl = url;
                this._serverUrl.setUrl(url);
                this._serverUrl.setVisible(true);
                if (this._onUrlDetected) {
                  this._onUrlDetected(this._selectedServer.file, url);
                }
              }
            }
          }
          setLogs(logs) {
            this._logViewer.setLogs(logs);
            this._detectedUrl = null;
            for (const log of logs) {
              if (log.type === "stdout" || log.type === "system") {
                const url = extractUrl(log.data);
                if (url && this._selectedServer) {
                  this._detectedUrl = url;
                  this._serverUrl.setUrl(url);
                  this._serverUrl.setVisible(true);
                  if (this._onUrlDetected) {
                    this._onUrlDetected(this._selectedServer.file, url);
                  }
                  break;
                }
              }
            }
            if (!this._detectedUrl) {
              this._serverUrl.setUrl(null);
              this._serverUrl.setVisible(false);
            }
          }
          setScanning(isScanning) {
            this._isScanning = isScanning === true;
            if (isScanning) {
              if (this._title?.dom?.el) this._title.dom.el.textContent = this._scanningTitleText;
              this._controlPanel.setVisible(false);
              this._serverUrl.setUrl(null);
              this._serverUrl.setVisible(false);
              this._scanningIndicator.remove_class("zs-hidden");
              this._scanningIndicator.reset();
              this._logViewer.add_class("zs-hidden");
            } else {
              if (!this._selectedServer && this._title?.dom?.el) {
                this._title.dom.el.textContent = this._defaultTitleText;
              }
              this._scanningIndicator.add_class("zs-hidden");
              this._logViewer.remove_class("zs-hidden");
            }
            this._updateOverviewVisibility();
            if (this._scanningIndicator.dom.el && this._logViewer.dom.el) {
              if (isScanning) {
                this._scanningIndicator.dom.el.classList.remove("zs-hidden");
                this._logViewer.dom.el.classList.add("zs-hidden");
                this._scanningIndicator.ensureDomRefs();
              } else {
                this._scanningIndicator.dom.el.classList.add("zs-hidden");
                this._logViewer.dom.el.classList.remove("zs-hidden");
              }
            }
          }
          setServers(servers) {
            this._servers = Array.isArray(servers) ? servers : [];
            this._serverByFile = new Map(this._servers.map((s) => [s.file, s]));
            this._majorServers = getMajorServersWithCards(this._servers);
            this._renderOverviewCards();
            this._updateOverviewVisibility();
          }
          _updateOverviewVisibility() {
            const shouldShow = !this._isScanning && !this._selectedServer;
            if (shouldShow) {
              this._overview?.remove_class?.("zs-hidden");
            } else {
              this._overview?.add_class?.("zs-hidden");
            }
            if (this._overview?.dom?.el) {
              this._overview.dom.el.classList.toggle("zs-hidden", !shouldShow);
            }
          }
          _renderOverviewCards() {
            if (!this._overviewGrid?.dom?.el) return;
            const cards = Array.isArray(this._majorServers) ? this._majorServers : [];
            if (cards.length === 0) {
              this._overviewGrid.dom.el.innerHTML = '<div class="zs-app-cards__empty">No featured apps detected.</div>';
              return;
            }
            const html = cards.map(({ server, card }) => {
              const file = escapeHtml(server && server.file);
              const title = escapeHtml(card && card.title);
              const subtitle = escapeHtml(card && card.subtitle);
              const accent = escapeHtml(card && card.accent);
              const svgPath = escapeHtml(card && card.svgPath);
              const runningUrl = server && server.runningUrl ? String(server.runningUrl) : "";
              const openBtn = runningUrl ? `<button class="zs-app-card__open" data-open-url="${escapeHtml(runningUrl)}" type="button">\u{1F310} Open</button>` : "";
              const primaryAction = card && card.primaryAction ? String(card.primaryAction) : "";
              const primaryLabel = card && card.primaryLabel ? String(card.primaryLabel) : "";
              const primaryBtn = primaryAction && primaryLabel ? `<button class="zs-app-card__primary" data-primary-action="${escapeHtml(primaryAction)}" type="button">${escapeHtml(primaryLabel)}</button>` : "";
              const quickLinks = card && Array.isArray(card.quickLinks) ? card.quickLinks : [];
              const quickBtns = quickLinks.map((q) => {
                const label = q && q.label ? String(q.label) : "";
                const linkPath = q && q.path ? String(q.path) : "";
                if (!label || !linkPath) return "";
                return `<button class="zs-app-card__primary zs-app-card__primary--link" data-primary-action="${escapeHtml(primaryAction)}" data-open-path="${escapeHtml(linkPath)}" type="button">${escapeHtml(label)}</button>`;
              }).filter(Boolean).join("");
              return `
<div class="zs-app-card zs-app-card--${accent}" data-server-file="${file}" tabindex="0" role="button">
  <div class="zs-app-card__top">
    <div class="zs-app-card__svg"><img src="${svgPath}" alt="${title}"></div>
    <div class="zs-app-card__cta">${primaryBtn}${quickBtns}${openBtn}</div>
  </div>
  <div class="zs-app-card__title">${title}</div>
  <div class="zs-app-card__subtitle">${subtitle}</div>
</div>`;
            }).join("\n");
            this._overviewGrid.dom.el.innerHTML = html;
          }
          _activateOverview() {
            if (this._overviewActivated) return;
            if (!this._overviewGrid?.dom?.el) return;
            this._overviewGrid.dom.el.addEventListener("click", (e) => {
              const target = e.target;
              const primaryEl = target && target.closest ? target.closest("[data-primary-action]") : null;
              if (primaryEl) {
                const action = primaryEl.getAttribute("data-primary-action");
                const openPath = primaryEl.getAttribute("data-open-path") || null;
                const cardEl2 = primaryEl.closest ? primaryEl.closest("[data-server-file]") : null;
                const file2 = cardEl2 ? cardEl2.getAttribute("data-server-file") : null;
                const server2 = file2 ? this._serverByFile.get(file2) : null;
                if (action && server2 && this._onQuickStartServer) {
                  e.preventDefault();
                  e.stopPropagation();
                  this._onQuickStartServer(server2, { action, openPath });
                }
                return;
              }
              const openEl = target && target.closest ? target.closest("[data-open-url]") : null;
              if (openEl) {
                const url = openEl.getAttribute("data-open-url");
                if (url && this._onOpenUrl) {
                  e.preventDefault();
                  e.stopPropagation();
                  this._onOpenUrl(url);
                }
                return;
              }
              const cardEl = target && target.closest ? target.closest("[data-server-file]") : null;
              if (!cardEl) return;
              const file = cardEl.getAttribute("data-server-file");
              if (!file) return;
              const server = this._serverByFile.get(file);
              if (server && this._onSelectServer) {
                this._onSelectServer(server);
              }
            });
            this._overviewActivated = true;
          }
          setScanProgress(current, total, file) {
            this._scanningIndicator.setProgress(current, total, file);
          }
          setScanCounting() {
            this._scanningIndicator.startCounting();
          }
          setScanCountingProgress(current, file) {
            this._scanningIndicator.setCountingProgress(current, file);
          }
          setScanTotal(total) {
            this._scanningIndicator.setTotal(total);
          }
          activate() {
            this._controlPanel.activate();
            this._serverUrl.activate();
            this._activateOverview();
          }
        }
        return ContentAreaControl;
      }
      module.exports = { createContentAreaControl };
    }
  });

  // ui/controls/titleBarControl.js
  var require_titleBarControl = __commonJS({
    "ui/controls/titleBarControl.js"(exports, module) {
      "use strict";
      function createTitleBarControl(jsgui2, { StringControl }) {
        class TitleBarControl extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "header",
              __type_name: "title_bar"
            };
            super(normalized);
            this.add_class("zs-title-bar");
            if (!spec.el) {
              this.compose();
            }
          }
          compose() {
            const ctx = this.context;
            const title = new jsgui2.div({ context: ctx, class: "zs-title-bar__title" });
            title.add(new StringControl({ context: ctx, text: "Z-Server // Manager" }));
            this.add(title);
          }
        }
        return TitleBarControl;
      }
      module.exports = { createTitleBarControl };
    }
  });

  // ui/lib/telemetryJsonl.js
  var require_telemetryJsonl = __commonJS({
    "ui/lib/telemetryJsonl.js"(exports, module) {
      "use strict";
      function splitJsonlChunk(buffer, chunk) {
        const prev = buffer ? String(buffer) : "";
        const next = chunk == null ? "" : String(chunk);
        const combined = prev + next;
        const parts = combined.split(/\r?\n/);
        const trailing = parts.pop() || "";
        const lines = parts.filter((line) => line !== "");
        return { lines, buffer: trailing };
      }
      function looksLikeJsonObject(line) {
        const trimmed = String(line || "").trim();
        return trimmed.startsWith("{") && trimmed.endsWith("}");
      }
      function isTelemetryV1(obj2) {
        if (!obj2 || typeof obj2 !== "object") return false;
        if (obj2.v !== 1) return false;
        if (!obj2.event || typeof obj2.event !== "string") return false;
        if (!obj2.level || typeof obj2.level !== "string") return false;
        if (!obj2.server || typeof obj2.server !== "object") return false;
        if (!obj2.server.name || typeof obj2.server.name !== "string") return false;
        if (!obj2.server.runId || typeof obj2.server.runId !== "string") return false;
        return true;
      }
      function formatTelemetryEvent(obj2) {
        const ts = obj2.ts ? String(obj2.ts) : "";
        const level = obj2.level ? String(obj2.level).toUpperCase() : "INFO";
        const event = obj2.event ? String(obj2.event) : "event";
        const msg = obj2.msg ? String(obj2.msg) : "";
        const suffix = msg ? ` - ${msg}` : "";
        return ts ? `${ts} ${level} ${event}${suffix}` : `${level} ${event}${suffix}`;
      }
      function tryFormatTelemetryLine(line) {
        if (!looksLikeJsonObject(line)) return null;
        try {
          const parsed = JSON.parse(String(line));
          if (!isTelemetryV1(parsed)) return null;
          return formatTelemetryEvent(parsed);
        } catch (_) {
          return null;
        }
      }
      module.exports = {
        splitJsonlChunk,
        tryFormatTelemetryLine,
        formatTelemetryEvent,
        isTelemetryV1
      };
    }
  });

  // ui/controls/zServerAppControl.js
  var require_zServerAppControl = __commonJS({
    "ui/controls/zServerAppControl.js"(exports, module) {
      "use strict";
      var { splitJsonlChunk, tryFormatTelemetryLine } = require_telemetryJsonl();
      function createZServerAppControl(jsgui2, { TitleBarControl, SidebarControl, ContentAreaControl }) {
        class ZServerAppControl2 extends jsgui2.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "div",
              __type_name: "zserver_app"
            };
            super(normalized);
            this.add_class("zs-app");
            this._servers = [];
            this._selectedServer = null;
            this._logs = /* @__PURE__ */ new Map();
            this._jsonlBuffers = /* @__PURE__ */ new Map();
            this._scanTotal = 0;
            this._scanCurrent = 0;
            this._scanLastFile = "";
            this._api = spec.api || null;
            this._autoRebuildUiClient = false;
            this._keepRunningAfterExit = false;
            this._scanVisibility = {
              ui: true,
              labs: false,
              api: false,
              tools: false,
              tests: false,
              checks: false,
              other: false
            };
            this._scanInFlight = false;
            this._scanProgressUnsub = null;
            this._debug = false;
            if (!spec.el) {
              this.compose();
            }
          }
          _loadDebugSetting() {
            try {
              const raw = globalThis.localStorage && globalThis.localStorage.getItem("zserver:debug");
              return raw === "1" || raw === "true";
            } catch {
              return false;
            }
          }
          _debugLog(...args) {
            if (this._debug !== true) return;
            console.log(...args);
          }
          _loadAutoRebuildUiClientSetting() {
            try {
              const raw = globalThis.localStorage && globalThis.localStorage.getItem("zserver:autoRebuildUiClient");
              return raw === "1" || raw === "true";
            } catch {
              return false;
            }
          }
          _loadKeepRunningAfterExitSetting() {
            try {
              const raw = globalThis.localStorage && globalThis.localStorage.getItem("zserver:keepRunningAfterExit");
              return raw === "1" || raw === "true";
            } catch {
              return false;
            }
          }
          _loadScanVisibilitySetting() {
            try {
              const raw = globalThis.localStorage && globalThis.localStorage.getItem("zserver:scanVisibility");
              if (!raw) return null;
              const parsed = JSON.parse(raw);
              if (!parsed || typeof parsed !== "object") return null;
              return parsed;
            } catch {
              return null;
            }
          }
          _saveScanVisibilitySetting(visibility) {
            try {
              if (!globalThis.localStorage) return;
              globalThis.localStorage.setItem("zserver:scanVisibility", JSON.stringify(visibility));
            } catch {
            }
          }
          _normalizeScanVisibility(visibility) {
            const defaults = this._scanVisibility;
            const next = { ...defaults, ...visibility && typeof visibility === "object" ? visibility : null };
            for (const key2 of Object.keys(defaults)) {
              next[key2] = next[key2] === true;
            }
            return next;
          }
          _saveAutoRebuildUiClientSetting(enabled) {
            try {
              if (!globalThis.localStorage) return;
              globalThis.localStorage.setItem("zserver:autoRebuildUiClient", enabled ? "1" : "0");
            } catch {
            }
          }
          _saveKeepRunningAfterExitSetting(enabled) {
            try {
              if (!globalThis.localStorage) return;
              globalThis.localStorage.setItem("zserver:keepRunningAfterExit", enabled ? "1" : "0");
            } catch {
            }
          }
          compose() {
            const ctx = this.context;
            this._titleBar = new TitleBarControl({ context: ctx });
            this.add(this._titleBar);
            const container = new jsgui2.div({ context: ctx, class: "zs-container" });
            this._sidebar = new SidebarControl({
              context: ctx,
              servers: this._servers,
              onSelect: (s) => this._selectServer(s),
              onOpenUrl: (url) => this._openInBrowser(url),
              scanVisibility: this._scanVisibility,
              onChangeScanVisibility: (visibility) => this._setScanVisibility(visibility)
            });
            container.add(this._sidebar);
            this._contentArea = new ContentAreaControl({
              context: ctx,
              onStart: () => this._startServer(),
              onStop: () => this._stopServer(),
              onRestart: () => this._restartServer(),
              onUrlDetected: (filePath, url) => this._setServerUrl(filePath, url),
              onOpenUrl: (url) => this._openInBrowser(url),
              onSelectServer: (server) => this._selectServer(server),
              onQuickStartServer: (server, options) => this._quickStartServer(server, options),
              autoRebuildUiClient: this._autoRebuildUiClient,
              onRebuildUiClient: () => this._rebuildUiClient(),
              onToggleAutoRebuildUiClient: (enabled) => this._setAutoRebuildUiClient(enabled),
              keepRunningAfterExit: this._keepRunningAfterExit,
              onToggleKeepRunningAfterExit: (enabled) => this._setKeepRunningAfterExit(enabled)
            });
            container.add(this._contentArea);
            this.add(container);
          }
          async init() {
            if (!this._api) {
              console.error("No electronAPI provided");
              return;
            }
            this._debug = this._loadDebugSetting();
            this._autoRebuildUiClient = this._loadAutoRebuildUiClientSetting();
            this._contentArea.setAutoRebuildUiClient(this._autoRebuildUiClient);
            this._keepRunningAfterExit = this._loadKeepRunningAfterExitSetting();
            if (this._contentArea && typeof this._contentArea.setKeepRunningAfterExit === "function") {
              this._contentArea.setKeepRunningAfterExit(this._keepRunningAfterExit);
            }
            const savedVisibility = this._loadScanVisibilitySetting();
            if (savedVisibility) {
              this._scanVisibility = this._normalizeScanVisibility(savedVisibility);
              if (this._sidebar && typeof this._sidebar.setScanVisibility === "function") {
                this._sidebar.setScanVisibility(this._scanVisibility);
              }
            }
            try {
              if (!this._scanProgressUnsub) {
                this._scanProgressUnsub = this._api.onScanProgress((progress) => {
                  this._debugLog("[ZServerApp] Scan progress:", progress);
                  if (progress.type === "count-start") {
                    this._scanTotal = 0;
                    this._scanCurrent = 0;
                    this._scanLastFile = "";
                    this._contentArea.setScanCounting();
                  } else if (progress.type === "count-progress") {
                    this._scanCurrent = progress.current || 0;
                    this._scanLastFile = progress.file || "";
                    this._contentArea.setScanCountingProgress(progress.current, progress.file);
                  } else if (progress.type === "count") {
                    this._scanTotal = progress.total || 0;
                    this._scanCurrent = 0;
                    this._contentArea.setScanTotal(progress.total);
                  } else if (progress.type === "progress") {
                    this._scanTotal = progress.total || this._scanTotal;
                    this._scanCurrent = progress.current || 0;
                    this._scanLastFile = progress.file || "";
                    this._contentArea.setScanProgress(progress.current, progress.total, progress.file);
                  } else if (progress.type === "complete") {
                    if (this._scanTotal > 0 && this._scanCurrent < this._scanTotal) {
                      this._contentArea.setScanProgress(this._scanTotal, this._scanTotal, this._scanLastFile);
                    }
                  }
                });
              }
              await this._scanAndPopulateServers();
              for (const server of this._servers) {
                if (server.running && server.detectedPort) {
                  const url = `http://localhost:${server.detectedPort}`;
                  this._addLog(server.file, "system", `\u2713 Server detected as already running on port ${server.detectedPort}`);
                  this._addLog(server.file, "system", `\u{1F4CD} URL: ${url}`);
                }
              }
              this._debugLog("[ZServerApp] Servers set on sidebar");
              if (!this._serverLogUnsub) {
                this._serverLogUnsub = this._api.onServerLog(({ filePath, type, data }) => {
                  this._addLog(filePath, type, data);
                });
              }
              if (!this._serverStatusUnsub) {
                this._serverStatusUnsub = this._api.onServerStatusChange((payload) => {
                  this._updateServerStatus(payload);
                });
              }
            } catch (error2) {
              console.error("Failed to scan servers:", error2);
              this._contentArea.addLog("stderr", `Failed to scan servers: ${error2.message}`);
            } finally {
              this._contentArea.setScanning(false);
              this._scanInFlight = false;
            }
          }
          async _scanAndPopulateServers() {
            this._scanTotal = 0;
            this._scanCurrent = 0;
            this._scanLastFile = "";
            this._scanInFlight = true;
            this._contentArea.setScanning(true);
            this._debugLog("[ZServerApp] Starting scan...", this._scanVisibility);
            const scanned = await this._api.scanServers({ visibility: this._scanVisibility });
            for (const server of scanned) {
              if (server && server.running && server.detectedPort) {
                server.runningUrl = `http://localhost:${server.detectedPort}`;
              }
            }
            this._servers = scanned;
            this._debugLog("[ZServerApp] Scan complete, found servers:", this._servers.length);
            this._sidebar.setServers(this._servers);
            this._contentArea.setServers(this._servers);
            if (this._selectedServer && this._selectedServer.file) {
              const match = this._servers.find((s) => s.file === this._selectedServer.file);
              if (match) {
                this._selectServer(match);
              } else {
                this._selectedServer = null;
                this._contentArea.setSelectedServer(null);
                this._contentArea.setLogs([]);
              }
            }
          }
          async _setScanVisibility(visibility) {
            const next = this._normalizeScanVisibility(visibility);
            this._scanVisibility = next;
            this._saveScanVisibilitySetting(next);
            if (this._sidebar && typeof this._sidebar.setScanVisibility === "function") {
              this._sidebar.setScanVisibility(next);
            }
            if (this._scanInFlight) return;
            try {
              await this._scanAndPopulateServers();
            } catch (err) {
              this._contentArea.addLog("stderr", `Failed to rescan servers: ${err.message}`);
            } finally {
              this._contentArea.setScanning(false);
              this._scanInFlight = false;
            }
          }
          _selectServer(server) {
            this._selectedServer = server;
            this._contentArea.setSelectedServer(server);
            const serverLogs = this._logs.get(server.file) || [];
            this._contentArea.setLogs(serverLogs);
            if (server.running && server.runningUrl) {
              this._contentArea.setRunningUrl(server.runningUrl);
              this._sidebar.setServerRunningUrl(server.file, server.runningUrl);
            }
            this._refreshUiClientStatusForSelectedServer();
          }
          async _refreshUiClientStatusForSelectedServer() {
            try {
              if (!this._api || !this._selectedServer) return;
              if (this._selectedServer.hasHtmlInterface !== true) {
                this._contentArea.setUiClientStatus(null);
                return;
              }
              const result = await this._api.getUiClientStatus();
              if (result && result.success && result.status) {
                this._contentArea.setUiClientStatus(result.status);
              }
            } catch (err) {
              this._addLog(this._selectedServer?.file || "system", "stderr", `[ui-client] Status check failed: ${err.message}`);
            }
          }
          _setAutoRebuildUiClient(enabled) {
            this._autoRebuildUiClient = enabled === true;
            this._saveAutoRebuildUiClientSetting(this._autoRebuildUiClient);
            this._contentArea.setAutoRebuildUiClient(this._autoRebuildUiClient);
          }
          _setKeepRunningAfterExit(enabled) {
            this._keepRunningAfterExit = enabled === true;
            this._saveKeepRunningAfterExitSetting(this._keepRunningAfterExit);
            if (this._contentArea && typeof this._contentArea.setKeepRunningAfterExit === "function") {
              this._contentArea.setKeepRunningAfterExit(this._keepRunningAfterExit);
            }
          }
          async _rebuildUiClient() {
            if (!this._selectedServer || !this._api) return;
            if (this._selectedServer.hasHtmlInterface !== true) return;
            this._addLog(this._selectedServer.file, "system", "[ui-client] Rebuild requested...");
            const result = await this._api.rebuildUiClient({ force: true, logToFilePath: this._selectedServer.file });
            if (!result || result.success !== true) {
              this._addLog(this._selectedServer.file, "stderr", `[ui-client] Rebuild failed: ${result?.message || "unknown error"}`);
              return;
            }
            await this._refreshUiClientStatusForSelectedServer();
          }
          _addLog(filePath, type, data) {
            const text = data == null ? "" : String(data);
            const key2 = `${filePath}:${type}`;
            const prevBuffer = this._jsonlBuffers.get(key2) || "";
            const trimmed = text.trim();
            const isLikelyJson = prevBuffer.length > 0 || trimmed.startsWith("{");
            if (isLikelyJson) {
              const { lines, buffer } = splitJsonlChunk(prevBuffer, text);
              if (buffer.length > 2e4) {
                this._jsonlBuffers.set(key2, "");
                this._addLogLine(filePath, type, buffer);
                return;
              }
              this._jsonlBuffers.set(key2, buffer);
              if (lines.length === 0) {
                return;
              }
              lines.forEach((line) => {
                const formatted = tryFormatTelemetryLine(line);
                this._addLogLine(filePath, type, formatted || line);
              });
              return;
            }
            this._addLogLine(filePath, type, text);
          }
          _addLogLine(filePath, type, data) {
            if (!this._logs.has(filePath)) {
              this._logs.set(filePath, []);
            }
            this._logs.get(filePath).push({ type, data });
            const isSelectedServer = this._selectedServer && this._selectedServer.file === filePath;
            this._debugLog(
              "[ZServerApp] _addLog isSelectedServer:",
              isSelectedServer,
              "selected:",
              this._selectedServer?.file,
              "incoming:",
              filePath
            );
            if (isSelectedServer) {
              this._contentArea.addLog(type, data);
              if (type === "stderr" && data.includes("EADDRINUSE")) {
                const portMatch = data.match(/(?:port\s+)?(\d{4,5})/i);
                const port = portMatch ? portMatch[1] : this._selectedServer.metadata?.defaultPort;
                if (port) {
                  const url = `http://localhost:${port}`;
                  this._addLog(filePath, "system", `\u26A0\uFE0F Port ${port} is already in use by another process.`);
                  this._addLog(filePath, "system", `\u{1F4CD} The server might already be running at: ${url}`);
                  this._setServerUrl(filePath, url);
                } else {
                  this._addLog(filePath, "system", "\u26A0\uFE0F Port is already in use. Server may already be running.");
                }
              }
            }
          }
          _setServerUrl(filePath, url) {
            this._sidebar.setServerRunningUrl(filePath, url);
            if (this._selectedServer && this._selectedServer.file === filePath) {
              this._contentArea.setRunningUrl(url);
            }
            const server = this._servers.find((s) => s.file === filePath);
            if (server) {
              server.runningUrl = url;
            }
          }
          _updateServerStatus(updateOrFilePath, runningLegacy) {
            const update = updateOrFilePath && typeof updateOrFilePath === "object" ? updateOrFilePath : { filePath: updateOrFilePath, running: runningLegacy };
            const filePath = update.filePath;
            const running = update.running === true;
            const pid = Number.isFinite(update.pid) ? update.pid : null;
            const port = Number.isFinite(update.port) ? update.port : null;
            const url = typeof update.url === "string" && update.url.trim() ? update.url.trim() : null;
            const server = this._servers.find((s) => s.file === filePath);
            if (!server) return;
            const wasRunning = server.running === true;
            const prevPid = server.pid || null;
            const prevUrl = server.runningUrl || null;
            server.running = running;
            if (running) {
              if (pid) {
                server.pid = pid;
              }
              const nextUrl = url || (port ? `http://localhost:${port}` : null);
              if (nextUrl) {
                server.runningUrl = nextUrl;
                this._sidebar.setServerRunningUrl(filePath, nextUrl);
                if (this._selectedServer && this._selectedServer.file === filePath) {
                  this._contentArea.setRunningUrl(nextUrl);
                }
              }
              if (wasRunning && prevPid && pid && pid !== prevPid) {
                this._addLog(filePath, "system", `Restart detected (PID changed: ${prevPid} \u2192 ${pid})`);
              }
            } else {
              server.pid = null;
              server.runningUrl = null;
            }
            this._sidebar.updateServerStatus(filePath, running);
            if (this._selectedServer && this._selectedServer.file === filePath) {
              this._contentArea.setServerRunning(running);
            }
            if (prevUrl && !running) {
              if (this._selectedServer && this._selectedServer.file === filePath) {
                this._contentArea.setRunningUrl(null);
              }
            }
          }
          async _startServer() {
            if (!this._selectedServer || !this._api) return;
            this._addLog(this._selectedServer.file, "system", "Starting server...");
            const result = await this._api.startServer(this._selectedServer.file, {
              isUiServer: this._selectedServer.hasHtmlInterface === true,
              ensureUiClientBundle: this._autoRebuildUiClient === true,
              keepRunningAfterExit: this._keepRunningAfterExit === true,
              logToFilePath: this._selectedServer.file
            });
            if (result.success) {
              this._selectedServer.running = true;
              this._selectedServer.pid = result.pid;
              this._contentArea.setServerRunning(true);
              this._sidebar.updateServerStatus(this._selectedServer.file, true);
              this._addLog(this._selectedServer.file, "system", `Server started (PID: ${result.pid})`);
            } else {
              if (result.message === "Already running") {
                this._selectedServer.running = true;
                this._contentArea.setServerRunning(true);
                this._sidebar.updateServerStatus(this._selectedServer.file, true);
                const port = this._selectedServer.metadata?.defaultPort;
                const url = port ? `http://localhost:${port}` : null;
                this._addLog(this._selectedServer.file, "system", "\u26A0\uFE0F Server is already running!");
                if (url) {
                  this._setServerUrl(this._selectedServer.file, url);
                  this._addLog(this._selectedServer.file, "system", `\u{1F4CD} Click to open: ${url}`);
                } else {
                  this._addLog(this._selectedServer.file, "system", "Check the server log output for the URL.");
                }
              } else {
                this._addLog(this._selectedServer.file, "stderr", `Failed to start: ${result.message}`);
              }
            }
          }
          async _waitForUrlReachable(baseUrl, { timeoutMs = 15e3, intervalMs = 250 } = {}) {
            if (typeof baseUrl !== "string" || !baseUrl) return false;
            if (typeof globalThis.fetch !== "function") return true;
            if (typeof globalThis.AbortController !== "function") return true;
            const deadline = Date.now() + Math.max(0, timeoutMs);
            while (Date.now() < deadline) {
              try {
                const controller = new AbortController();
                const attemptTimer = setTimeout(() => controller.abort(), 2e3);
                await fetch(baseUrl, {
                  method: "GET",
                  cache: "no-store",
                  signal: controller.signal
                });
                clearTimeout(attemptTimer);
                return true;
              } catch {
              }
              await new Promise((r) => setTimeout(r, intervalMs));
            }
            return false;
          }
          _isUnifiedUiServer(server) {
            if (!server || typeof server.file !== "string") return false;
            const normalized = server.file.replace(/\\/g, "/");
            return normalized.endsWith("/src/ui/server/unifiedApp/server.js");
          }
          async _tryFetchUnifiedCrawlSummary(baseUrl, { timeoutMs = 2500 } = {}) {
            if (typeof baseUrl !== "string" || !baseUrl) return null;
            if (typeof globalThis.fetch !== "function") return null;
            if (typeof globalThis.AbortController !== "function") return null;
            try {
              const controller = new AbortController();
              const attemptTimer = setTimeout(() => controller.abort(), Math.max(250, timeoutMs));
              const res2 = await fetch(`${baseUrl}/api/crawl/summary`, {
                method: "GET",
                cache: "no-store",
                signal: controller.signal
              });
              clearTimeout(attemptTimer);
              if (!res2.ok) return null;
              const json = await res2.json();
              if (!json || json.status !== "ok") return null;
              return json;
            } catch {
              return null;
            }
          }
          async _pickAutoOpenPath(server, baseUrl) {
            if (!this._isUnifiedUiServer(server)) return null;
            const summary = await this._tryFetchUnifiedCrawlSummary(baseUrl);
            const lastError = summary && typeof summary.lastError === "object" ? summary.lastError : null;
            const hasError = Boolean(lastError && lastError.message);
            if (!hasError) return null;
            return "/?app=crawl-status";
          }
          async _quickStartServer(server, options = {}) {
            if (!server || !this._api) return;
            const action = options && typeof options === "object" ? options.action : null;
            const openPath = options && typeof options === "object" && typeof options.openPath === "string" ? options.openPath : null;
            if (action !== "start-detached") {
              this._selectServer(server);
              return;
            }
            this._selectServer(server);
            this._addLog(server.file, "system", "Launching (detached)...");
            const result = await this._api.startServer(server.file, {
              isUiServer: server.hasHtmlInterface === true,
              ensureUiClientBundle: this._autoRebuildUiClient === true,
              keepRunningAfterExit: true,
              logToFilePath: server.file
            });
            if (result && result.success) {
              server.running = true;
              server.pid = result.pid;
              const port = result.port || server.metadata?.defaultPort || server.detectedPort;
              const baseUrl = port ? `http://localhost:${port}` : null;
              if (baseUrl) {
                const ready = await this._waitForUrlReachable(baseUrl);
                if (!ready) {
                  this._addLog(server.file, "system", "\u26A0\uFE0F Server did not respond before timeout; opening anyway...");
                }
              }
              let resolvedOpenPath = openPath;
              if (!resolvedOpenPath && baseUrl) {
                resolvedOpenPath = await this._pickAutoOpenPath(server, baseUrl);
              }
              const url = baseUrl ? `${baseUrl}${resolvedOpenPath || ""}` : null;
              if (url) {
                server.runningUrl = url;
                this._setServerUrl(server.file, url);
                await this._openInBrowser(url);
              }
              this._contentArea.setServerRunning(true);
              this._sidebar.updateServerStatus(server.file, true);
              this._addLog(server.file, "system", `Server started (PID: ${result.pid})`);
            } else {
              const message = result && result.message ? result.message : "Failed to start";
              if (message === "Already running") {
                server.running = true;
                this._contentArea.setServerRunning(true);
                this._sidebar.updateServerStatus(server.file, true);
                const port = server.metadata?.defaultPort || server.detectedPort;
                const baseUrl = port ? `http://localhost:${port}` : null;
                if (baseUrl) {
                  const ready = await this._waitForUrlReachable(baseUrl, { timeoutMs: 5e3 });
                  if (!ready) {
                    this._addLog(server.file, "system", "\u26A0\uFE0F Server did not respond before timeout; opening anyway...");
                  }
                }
                let resolvedOpenPath = openPath;
                if (!resolvedOpenPath && baseUrl) {
                  resolvedOpenPath = await this._pickAutoOpenPath(server, baseUrl);
                }
                const url = baseUrl ? `${baseUrl}${resolvedOpenPath || ""}` : null;
                this._addLog(server.file, "system", "\u26A0\uFE0F Server is already running!");
                if (url) {
                  server.runningUrl = url;
                  this._setServerUrl(server.file, url);
                  await this._openInBrowser(url);
                }
              } else {
                this._addLog(server.file, "stderr", `Failed to start: ${message}`);
              }
            }
          }
          async _stopServer() {
            if (!this._selectedServer || !this._api) return;
            this._addLog(this._selectedServer.file, "system", "Stopping server...");
            const result = await this._api.stopServer(this._selectedServer.file, this._selectedServer.pid);
            if (result.success) {
              this._selectedServer.running = false;
              this._selectedServer.pid = null;
              this._contentArea.setServerRunning(false);
              this._sidebar.updateServerStatus(this._selectedServer.file, false);
              this._addLog(this._selectedServer.file, "system", result.wasExternal ? "External server stopped" : "Server stopped");
            } else {
              this._addLog(this._selectedServer.file, "stderr", `Failed to stop: ${result.message}`);
            }
          }
          async _restartServer() {
            if (!this._selectedServer || !this._api) return;
            const filePath = this._selectedServer.file;
            this._addLog(filePath, "system", "Restarting server...");
            const stopRes = await this._api.stopServer(filePath, this._selectedServer.pid);
            if (!stopRes || stopRes.success !== true) {
              const message2 = stopRes && stopRes.message ? stopRes.message : "unknown";
              this._addLog(filePath, "system", `Stop step: ${message2}`);
            }
            const startRes = await this._api.startServer(filePath, {
              isUiServer: this._selectedServer.hasHtmlInterface === true,
              ensureUiClientBundle: this._autoRebuildUiClient === true,
              keepRunningAfterExit: this._keepRunningAfterExit === true,
              logToFilePath: filePath
            });
            if (startRes && startRes.success) {
              this._selectedServer.running = true;
              this._selectedServer.pid = startRes.pid;
              this._contentArea.setServerRunning(true);
              this._sidebar.updateServerStatus(filePath, true);
              const port = startRes.port || this._selectedServer.metadata?.defaultPort || this._selectedServer.detectedPort;
              const url = port ? `http://localhost:${port}` : null;
              if (url) {
                this._setServerUrl(filePath, url);
              }
              this._addLog(filePath, "system", `Server restarted (PID: ${startRes.pid})`);
              return;
            }
            const message = startRes && startRes.message ? startRes.message : "Failed to start";
            this._addLog(filePath, "stderr", `Restart failed: ${message}`);
          }
          async _openInBrowser(url) {
            if (!this._api || !url) return;
            this._addLog(this._selectedServer?.file || "system", "system", `Opening ${url} in browser...`);
            try {
              const result = await this._api.openInBrowser(url);
              if (result.success) {
                this._addLog(this._selectedServer?.file || "system", "system", `Opened in ${result.browser}`);
              }
            } catch (error2) {
              this._addLog(this._selectedServer?.file || "system", "stderr", `Failed to open browser: ${error2.message}`);
            }
          }
          activate() {
            this._sidebar.activate();
            this._contentArea.activate();
          }
        }
        return ZServerAppControl2;
      }
      module.exports = { createZServerAppControl };
    }
  });

  // ui/controls/zServerControlsFactory.js
  var require_zServerControlsFactory = __commonJS({
    "ui/controls/zServerControlsFactory.js"(exports, module) {
      "use strict";
      var { createServerItemControl } = require_serverItemControl();
      var { createServerListControl } = require_serverListControl();
      var { createServerUrlControl } = require_serverUrlControl();
      var { createLogControls } = require_logControls();
      var { createServerLogWindowControl } = require_serverLogWindowControl();
      var { createControlButtonControl } = require_controlButtonControl();
      var { createControlPanelControl } = require_controlPanelControl();
      var { createScanningIndicatorControl } = require_scanningIndicatorControl();
      var { createSidebarControl } = require_sidebarControl();
      var { createContentAreaControl } = require_contentAreaControl();
      var { createTitleBarControl } = require_titleBarControl();
      var { createZServerAppControl } = require_zServerAppControl();
      function createZServerControls2(jsgui2) {
        if (!jsgui2) {
          throw new Error("jsgui instance is required to build Z-Server controls");
        }
        const StringControl = jsgui2.String_Control;
        const ServerItemControl = createServerItemControl(jsgui2, { StringControl });
        const ServerListControl = createServerListControl(jsgui2, { ServerItemControl });
        const ServerUrlControl = createServerUrlControl(jsgui2, { StringControl });
        const { LogEntryControl, LogViewerControl } = createLogControls(jsgui2, { StringControl });
        const ServerLogWindowControl = createServerLogWindowControl(jsgui2, { LogViewerControl });
        const ControlButtonControl = createControlButtonControl(jsgui2, { StringControl });
        const ControlPanelControl = createControlPanelControl(jsgui2, { ControlButtonControl, StringControl });
        const ScanningIndicatorControl = createScanningIndicatorControl(jsgui2, { StringControl });
        const SidebarControl = createSidebarControl(jsgui2, { ServerListControl, StringControl });
        const ContentAreaControl = createContentAreaControl(jsgui2, {
          ControlPanelControl,
          ServerUrlControl,
          ScanningIndicatorControl,
          LogViewerControl,
          StringControl
        });
        const TitleBarControl = createTitleBarControl(jsgui2, { StringControl });
        const ZServerAppControl2 = createZServerAppControl(jsgui2, {
          TitleBarControl,
          SidebarControl,
          ContentAreaControl
        });
        function buildZServerStyles() {
          return `
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* Z-SERVER MANAGER - INDUSTRIAL LUXURY OBSIDIAN THEME                         */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

:root {
  /* Obsidian Base */
  --zs-bg: #050508;
  --zs-bg-panel: #0a0d14;
  --zs-bg-card: #141824;
  --zs-bg-elevated: #1a1f2e;
  
  /* Gold Accents */
  --zs-gold: #c9a227;
  --zs-gold-dim: #8b7500;
  --zs-gold-bright: #fffacd;
  
  /* Gemstone Accents */
  --zs-emerald: #50c878;
  --zs-emerald-dark: #2e8b57;
  --zs-ruby: #ff6b6b;
  --zs-ruby-dark: #e31837;
  --zs-sapphire: #6fa8dc;
  --zs-sapphire-dark: #0f52ba;
  --zs-amethyst: #da70d6;
  --zs-amethyst-dark: #9966cc;
  --zs-topaz: #ffc87c;
  
  /* Text */
  --zs-text: #f0f4f8;
  --zs-text-muted: #94a3b8;
  --zs-text-dim: #64748b;
  
  /* Typography */
  --zs-font-display: "Georgia", "Times New Roman", serif;
  --zs-font-body: "Inter", "Segoe UI", system-ui, sans-serif;
  --zs-font-mono: "JetBrains Mono", "Consolas", "Monaco", monospace;
  
  /* Shadows */
  --zs-shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.4);
  --zs-shadow-md: 0 4px 16px rgba(0, 0, 0, 0.5);
  --zs-shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.6);
  --zs-shadow-glow-gold: 0 0 20px rgba(201, 162, 39, 0.3);
  --zs-shadow-glow-emerald: 0 0 20px rgba(80, 200, 120, 0.3);
  --zs-shadow-glow-ruby: 0 0 20px rgba(255, 107, 107, 0.3);
  --zs-shadow-glow-amethyst: 0 0 20px rgba(218, 112, 214, 0.3);
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  font-family: var(--zs-font-body);
  background: var(--zs-bg);
  color: var(--zs-text);
  height: 100vh;
  overflow: hidden;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* APP SHELL                                                                   */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: 
    radial-gradient(ellipse at 0% 0%, rgba(201, 162, 39, 0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 100% 0%, rgba(218, 112, 214, 0.05) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 100%, rgba(80, 200, 120, 0.03) 0%, transparent 50%),
    var(--zs-bg);
}

/* Grid overlay */
.zs-app::before {
  content: "";
  position: fixed;
  inset: 0;
  background-image: 
    linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size: 40px 40px;
  pointer-events: none;
  z-index: 0;
}

.zs-app > * {
  position: relative;
  z-index: 1;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* TITLE BAR                                                                   */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-title-bar {
  height: 36px;
  background: linear-gradient(180deg, rgba(20, 24, 36, 0.95), rgba(10, 13, 20, 0.98));
  -webkit-app-region: drag;
  display: flex;
  align-items: center;
  padding: 0 16px;
  border-bottom: 1px solid rgba(201, 162, 39, 0.2);
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.5);
}

.zs-title-bar__title {
  font-family: var(--zs-font-display);
  font-size: 14px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--zs-gold);
  text-shadow: 0 0 10px rgba(201, 162, 39, 0.5);
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* MAIN CONTAINER                                                              */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-container {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* SIDEBAR                                                                     */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-sidebar {
  width: 380px;
  background: linear-gradient(180deg, 
    rgba(20, 24, 36, 0.8) 0%, 
    rgba(10, 13, 20, 0.9) 100%
  );
  border-right: 1px solid rgba(255, 255, 255, 0.05);
  display: flex;
  flex-direction: column;
  backdrop-filter: blur(12px);
}

.zs-sidebar__header {
  padding: 24px 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  background: linear-gradient(180deg, rgba(26, 31, 46, 0.5), transparent);
}

.zs-sidebar__title {
  margin: 0;
  font-family: var(--zs-font-display);
  font-size: 22px;
  font-weight: 400;
  color: var(--zs-gold);
  letter-spacing: 1px;
  text-shadow: 0 0 15px rgba(201, 162, 39, 0.4);
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* SCANNING INDICATOR                                                          */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-scanning {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
  flex: 1;
}

.zs-scanning__svg {
  width: 120px;
  height: 120px;
  margin-bottom: 20px;
}

.zs-scanning__ring {
  fill: none;
  stroke: rgba(201, 162, 39, 0.2);
  stroke-width: 2;
}

.zs-scanning__ring-inner {
  fill: none;
  stroke: rgba(201, 162, 39, 0.1);
  stroke-width: 1;
  stroke-dasharray: 4 4;
  animation: zs-spin-reverse 10s linear infinite;
  transform-origin: 50px 50px;
}

.zs-scanning__sweep {
  fill: url(#radar-gradient); /* Fallback if defs not used */
  fill: rgba(201, 162, 39, 0.2);
  transform-origin: 50px 50px;
  animation: zs-spin 2s linear infinite;
}

.zs-scanning__dot {
  fill: var(--zs-gold);
  filter: drop-shadow(0 0 4px var(--zs-gold));
  animation: zs-pulse-fast 1s ease-in-out infinite;
}

.zs-scanning__text {
  font-family: var(--zs-font-mono);
  font-size: 14px;
  color: var(--zs-gold);
  letter-spacing: 3px;
  animation: zs-pulse 2s ease-in-out infinite;
}

.zs-scanning__subtitle {
  font-family: var(--zs-font-body);
  font-size: 12px;
  color: var(--zs-text-muted);
  margin-top: 8px;
  letter-spacing: 0.5px;
  max-width: 400px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Progress Bar Styles */
.zs-scanning__progress-container {
  width: 100%;
  max-width: 400px;
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.zs-scanning__progress-bg {
  width: 100%;
  height: 8px;
  background: rgba(201, 162, 39, 0.1);
  border: 1px solid rgba(201, 162, 39, 0.3);
  border-radius: 4px;
  overflow: hidden;
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
}

.zs-scanning__progress-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, 
    var(--zs-gold-dim) 0%,
    var(--zs-gold) 50%,
    var(--zs-gold-bright) 100%
  );
  border-radius: 3px;
  transition: width 0.05s ease-out;
  box-shadow: 
    0 0 8px rgba(201, 162, 39, 0.5),
    0 0 20px rgba(201, 162, 39, 0.2);
  position: relative;
}

.zs-scanning__progress-fill::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(255, 255, 255, 0.3) 50%,
    transparent 100%
  );
  animation: zs-shimmer 1.5s infinite;
}

@keyframes zs-shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.zs-scanning__progress-text {
  font-family: var(--zs-font-mono);
  font-size: 12px;
  color: var(--zs-text-muted);
  letter-spacing: 1px;
}

@keyframes zs-spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes zs-spin-reverse {
  from { transform: rotate(360deg); }
  to { transform: rotate(0deg); }
}

@keyframes zs-pulse-fast {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(0.8); }
}

.zs-hidden {
  display: none !important;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* SERVER LIST                                                                 */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-server-list {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* SERVER ITEM                                                                 */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-server-item {
  position: relative;
  background: linear-gradient(135deg, 
    rgba(26, 31, 46, 0.6) 0%, 
    rgba(20, 24, 36, 0.8) 100%
  );
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 8px;
  padding: 16px;
  padding-left: 20px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  overflow: hidden;
}

.zs-server-item::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: var(--zs-text-dim);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.zs-server-item:hover {
  background: linear-gradient(135deg, 
    rgba(40, 46, 66, 0.7) 0%, 
    rgba(26, 31, 46, 0.9) 100%
  );
  border-color: var(--zs-gold-dim);
  transform: translateX(4px);
  box-shadow: var(--zs-shadow-md), var(--zs-shadow-glow-gold);
}

.zs-server-item:hover::before {
  opacity: 1;
  background: var(--zs-gold);
}

/* Selected State */
.zs-server-item--selected {
  background: linear-gradient(135deg, 
    rgba(153, 102, 204, 0.15) 0%, 
    rgba(26, 31, 46, 0.9) 100%
  );
  border-color: var(--zs-amethyst-dark);
  box-shadow: var(--zs-shadow-md), var(--zs-shadow-glow-amethyst);
}

.zs-server-item--selected::before {
  opacity: 1;
  background: var(--zs-amethyst);
}

/* Running State */
.zs-server-item--running::after {
  content: "";
  position: absolute;
  top: 12px;
  right: 60px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--zs-emerald);
  box-shadow: 0 0 8px var(--zs-emerald), 0 0 16px var(--zs-emerald);
  animation: zs-pulse 2s ease-in-out infinite;
}

@keyframes zs-pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.6; transform: scale(0.9); }
}

.zs-server-item__content {
  flex: 1;
  min-width: 0;
}

.zs-server-item__name {
  font-family: var(--zs-font-display);
  font-size: 15px;
  color: var(--zs-text);
  margin-bottom: 6px;
  font-weight: 500;
}

.zs-server-item__desc {
  font-family: var(--zs-font-body);
  font-size: 12px;
  color: var(--zs-text-muted);
  line-height: 1.4;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.zs-server-item__score {
  position: absolute;
  top: 10px;
  right: 12px;
  font-family: var(--zs-font-mono);
  font-size: 10px;
  color: var(--zs-gold-dim);
  border: 1px solid var(--zs-gold-dim);
  padding: 2px 8px;
  border-radius: 4px;
  background: rgba(139, 117, 0, 0.1);
}

.zs-server-item__status {
  display: none;
}

/* Server Item - Inline URL Display */
.zs-server-item__url-container {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
  padding: 10px 14px;
  background: linear-gradient(135deg, 
    rgba(80, 200, 120, 0.15) 0%, 
    rgba(46, 139, 87, 0.1) 100%
  );
  border: 1px solid var(--zs-emerald);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.zs-server-item__url-container:hover {
  background: linear-gradient(135deg, 
    rgba(80, 200, 120, 0.25) 0%, 
    rgba(46, 139, 87, 0.2) 100%
  );
  box-shadow: 0 0 15px rgba(80, 200, 120, 0.3);
  transform: translateX(2px);
}

.zs-server-item__url-container--hidden {
  display: none !important;
}

.zs-server-item__url-icon {
  font-size: 16px;
  filter: drop-shadow(0 0 4px rgba(80, 200, 120, 0.5));
}

.zs-server-item__url-text {
  flex: 1;
  font-family: var(--zs-font-mono);
  font-size: 13px;
  font-weight: 600;
  color: var(--zs-emerald);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.zs-server-item__url-hint {
  font-family: var(--zs-font-body);
  font-size: 10px;
  color: var(--zs-text-muted);
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.zs-server-item__url-container:hover .zs-server-item__url-hint {
  opacity: 1;
  color: var(--zs-emerald);
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* CONTENT AREA                                                                */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: radial-gradient(ellipse at top right, 
    rgba(26, 31, 46, 0.8) 0%, 
    var(--zs-bg) 70%
  );
  padding: 24px;
  overflow: hidden;
}

.zs-content__header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.06);
}

.zs-content__title {
  font-family: var(--zs-font-display);
  font-size: 28px;
  font-weight: 400;
  color: var(--zs-gold);
  margin: 0;
  text-shadow: 0 0 20px rgba(201, 162, 39, 0.3);
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* CONTROL PANEL                                                               */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-control-panel {
  display: flex;
  gap: 12px;
}

.zs-control-panel--hidden {
  display: none;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* BUTTONS                                                                     */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-btn {
  font-family: var(--zs-font-body);
  font-size: 12px;
  font-weight: 500;
  letter-spacing: 1px;
  text-transform: uppercase;
  padding: 10px 24px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.zs-btn::before {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(255,255,255,0.1), transparent);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.zs-btn:hover::before {
  opacity: 1;
}

/* Start Button */
.zs-btn--start {
  background: transparent;
  border: 1px solid var(--zs-emerald-dark);
  color: var(--zs-emerald);
}

.zs-btn--start:hover {
  background: var(--zs-emerald);
  color: var(--zs-bg);
  box-shadow: var(--zs-shadow-glow-emerald);
}

/* Stop Button */
.zs-btn--stop {
  background: transparent;
  border: 1px solid var(--zs-ruby-dark);
  color: var(--zs-ruby);
}

.zs-btn--stop:hover {
  background: var(--zs-ruby);
  color: var(--zs-bg);
  box-shadow: var(--zs-shadow-glow-ruby);
}

/* Disabled State */
.zs-btn--disabled,
.zs-btn:disabled {
  border-color: var(--zs-text-dim);
  color: var(--zs-text-dim);
  cursor: not-allowed;
  opacity: 0.5;
}

.zs-btn--disabled:hover,
.zs-btn:disabled:hover {
  background: transparent;
  box-shadow: none;
}

.zs-btn--disabled::before,
.zs-btn:disabled::before {
  display: none;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* SERVER URL DISPLAY - Industrial Luxury Obsidian + White Leather + Emerald   */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-server-url {
  display: flex;
  align-items: center;
  gap: 28px;
  background: linear-gradient(135deg, 
    rgba(16, 185, 129, 0.12) 0%,
    rgba(5, 150, 105, 0.08) 30%,
    rgba(20, 24, 36, 0.95) 70%,
    rgba(10, 13, 20, 0.98) 100%
  );
  border: 3px solid transparent;
  border-image: linear-gradient(135deg, #34d399 0%, #10b981 50%, #059669 100%) 1;
  border-radius: 16px;
  padding: 24px 32px;
  margin-bottom: 24px;
  cursor: pointer;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  box-shadow: 
    0 0 40px rgba(16, 185, 129, 0.15),
    0 8px 32px rgba(0, 0, 0, 0.4),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

/* White leather texture overlay */
.zs-server-url::before {
  content: "";
  position: absolute;
  inset: 0;
  background: 
    radial-gradient(ellipse at 20% 20%, rgba(255, 255, 255, 0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 80%, rgba(16, 185, 129, 0.1) 0%, transparent 50%);
  opacity: 1;
  pointer-events: none;
}

/* Animated glow border */
.zs-server-url::after {
  content: "";
  position: absolute;
  inset: -3px;
  background: linear-gradient(135deg, #2dd4bf, #10b981, #059669, #10b981, #2dd4bf);
  background-size: 300% 300%;
  border-radius: 18px;
  z-index: -1;
  animation: zs-border-glow 3s ease-in-out infinite;
}

@keyframes zs-border-glow {
  0%, 100% { background-position: 0% 50%; opacity: 0.6; }
  50% { background-position: 100% 50%; opacity: 1; }
}

.zs-server-url:hover {
  transform: translateY(-4px) scale(1.01);
  box-shadow: 
    0 0 60px rgba(16, 185, 129, 0.3),
    0 0 100px rgba(16, 185, 129, 0.15),
    0 16px 48px rgba(0, 0, 0, 0.5),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.zs-server-url:active {
  transform: translateY(-2px) scale(1.005);
}

.zs-server-url--hidden {
  display: none !important;
}

/* Large SVG Icon Container */
.zs-server-url__icon {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.zs-server-url__svg {
  filter: drop-shadow(0 0 20px rgba(16, 185, 129, 0.5));
}

/* Outer ring - obsidian with emerald glow */
.zs-server-url__outer-ring {
  fill: none;
  stroke: url(#outerRingGrad);
  stroke-width: 3;
  opacity: 0.6;
  animation: zs-outer-ring-pulse 2.5s ease-in-out infinite;
  transform-origin: 60px 60px;
}

@keyframes zs-outer-ring-pulse {
  0%, 100% { 
    opacity: 0.4;
    stroke-width: 3;
  }
  50% { 
    opacity: 0.9;
    stroke-width: 4;
  }
}

/* Middle ring - emerald glow */
.zs-server-url__middle-ring {
  fill: none;
  stroke: #10b981;
  stroke-width: 2;
  filter: drop-shadow(0 0 12px #10b981);
  animation: zs-middle-ring-pulse 2s ease-in-out infinite;
  transform-origin: 60px 60px;
}

@keyframes zs-middle-ring-pulse {
  0%, 100% { 
    opacity: 0.5;
    filter: drop-shadow(0 0 8px #10b981);
  }
  50% { 
    opacity: 1;
    filter: drop-shadow(0 0 20px #10b981);
  }
}

/* Inner circle - white leather with emerald tint */
.zs-server-url__inner-circle {
  fill: url(#innerGlowGrad);
  filter: drop-shadow(0 0 15px rgba(52, 211, 153, 0.6));
  animation: zs-inner-breathe 1.8s ease-in-out infinite;
}

@keyframes zs-inner-breathe {
  0%, 100% { 
    filter: drop-shadow(0 0 10px rgba(52, 211, 153, 0.5));
    transform: scale(1);
  }
  50% { 
    filter: drop-shadow(0 0 25px rgba(52, 211, 153, 0.8));
    transform: scale(1.02);
  }
}

/* Check mark - obsidian colored */
.zs-server-url__check {
  fill: none;
  stroke: #0a0d14;
  stroke-width: 5;
  stroke-linecap: round;
  stroke-linejoin: round;
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
}

/* Radiating rays - luxury detail */
.zs-server-url__ray {
  stroke: #34d399;
  stroke-width: 2;
  stroke-linecap: round;
  opacity: 0.4;
  animation: zs-ray-pulse 2s ease-in-out infinite;
}

@keyframes zs-ray-pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.8; }
}

/* URL Text Wrapper */
.zs-server-url__wrapper {
  flex: 1;
  min-width: 0;
}

.zs-server-url__label {
  font-family: var(--zs-font-display);
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 4px;
  color: #34d399;
  margin-bottom: 8px;
  text-shadow: 0 0 20px rgba(52, 211, 153, 0.5);
}

.zs-server-url__text {
  font-family: var(--zs-font-mono);
  font-size: 28px;
  font-weight: 700;
  color: #ffffff;
  text-shadow: 
    0 0 30px rgba(52, 211, 153, 0.4),
    0 2px 4px rgba(0, 0, 0, 0.3);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Open Button */
.zs-server-url__open-btn {
  font-family: var(--zs-font-body);
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: #0a0d14;
  background: linear-gradient(135deg, #34d399 0%, #10b981 50%, #059669 100%);
  padding: 14px 24px;
  border-radius: 8px;
  white-space: nowrap;
  transition: all 0.3s ease;
  box-shadow: 
    0 4px 15px rgba(16, 185, 129, 0.4),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.zs-server-url:hover .zs-server-url__open-btn {
  transform: translateX(4px);
  box-shadow: 
    0 6px 25px rgba(16, 185, 129, 0.5),
    inset 0 1px 0 rgba(255, 255, 255, 0.3);
  background: linear-gradient(135deg, #2dd4bf 0%, #34d399 50%, #10b981 100%);
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* LOG VIEWER                                                                  */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-log-viewer {
  flex: 1;
  background: linear-gradient(135deg, 
    rgba(0, 0, 0, 0.7) 0%, 
    rgba(5, 5, 8, 0.9) 100%
  );
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 8px;
  padding: 16px;
  overflow-y: auto;
  font-family: var(--zs-font-mono);
  font-size: 12px;
  line-height: 1.6;
  box-shadow: inset 0 2px 20px rgba(0, 0, 0, 0.5);
}

.zs-log-viewer__empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--zs-text-dim);
}

.zs-log-viewer__empty-icon {
  font-size: 48px;
  margin-bottom: 16px;
  color: rgba(201, 162, 39, 0.2);
  text-shadow: 0 0 30px rgba(201, 162, 39, 0.1);
}

.zs-log-viewer__empty-text {
  font-family: var(--zs-font-body);
  font-size: 14px;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* LOG ENTRIES                                                                 */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-log-entry {
  padding: 4px 0;
  white-space: pre-wrap;
  word-break: break-all;
  border-left: 2px solid transparent;
  padding-left: 8px;
  margin-left: -8px;
}

.zs-log-entry--stdout {
  color: var(--zs-text-muted);
}

.zs-log-entry--stderr {
  color: #ff8888;
  border-left-color: var(--zs-ruby);
  border-left-width: 3px;
  background: rgba(227, 24, 55, 0.12);
  padding: 8px 12px;
  margin: 4px 0;
  border-radius: 0 4px 4px 0;
  font-weight: 500;
  animation: zs-error-flash 0.5s ease-out;
}

@keyframes zs-error-flash {
  0% { background: rgba(255, 107, 107, 0.3); }
  100% { background: rgba(227, 24, 55, 0.12); }
}

.zs-log-entry--system {
  color: var(--zs-gold);
  font-style: italic;
  border-bottom: 1px solid rgba(201, 162, 39, 0.15);
  padding-bottom: 8px;
  margin-bottom: 8px;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* SERVER LOG WINDOW - Industrial Luxury Obsidian                              */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-log-window {
  position: absolute;
  display: flex;
  flex-direction: column;
  background: linear-gradient(180deg, 
    rgba(20, 24, 36, 0.98) 0%, 
    rgba(10, 13, 20, 0.99) 100%
  );
  border: 1px solid rgba(201, 162, 39, 0.3);
  border-radius: 8px;
  box-shadow: 
    0 8px 32px rgba(0, 0, 0, 0.7),
    0 0 1px rgba(201, 162, 39, 0.5),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
  overflow: hidden;
  z-index: 100;
  backdrop-filter: blur(12px);
  transition: box-shadow 0.2s ease, transform 0.15s ease;
}

.zs-log-window:hover {
  box-shadow: 
    0 12px 48px rgba(0, 0, 0, 0.8),
    0 0 2px rgba(201, 162, 39, 0.6),
    inset 0 1px 0 rgba(255, 255, 255, 0.08);
}

.zs-log-window--hidden {
  display: none !important;
}

.zs-log-window--dragging {
  opacity: 0.9;
  cursor: grabbing;
}

.zs-log-window--resizing {
  opacity: 0.95;
}

.zs-log-window--minimized {
  height: auto !important;
}

.zs-log-window--minimized .inner,
.zs-log-window--minimized .zs-log-window__resize-handle {
  display: none;
}

.zs-log-window--maximized {
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border-radius: 0;
}

/* Override jsgui3 Window default styles */
.zs-log-window.window {
  background: linear-gradient(180deg, 
    rgba(20, 24, 36, 0.98) 0%, 
    rgba(10, 13, 20, 0.99) 100%
  );
}

.zs-log-window .relative {
  display: flex;
  flex-direction: column;
  height: 100%;
}

/* Title bar styling */
.zs-log-window .title.bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: linear-gradient(180deg, 
    rgba(201, 162, 39, 0.15) 0%, 
    rgba(201, 162, 39, 0.05) 100%
  );
  border-bottom: 1px solid rgba(201, 162, 39, 0.3);
  cursor: grab;
  user-select: none;
}

.zs-log-window .title.bar:active {
  cursor: grabbing;
}

.zs-log-window .title.bar h2 {
  margin: 0;
  font-family: var(--zs-font-display);
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--zs-gold);
  text-shadow: 0 0 10px rgba(201, 162, 39, 0.4);
}

/* Window buttons */
.zs-log-window .button-group.right {
  display: flex;
  gap: 8px;
}

.zs-log-window .button-group button {
  width: 24px;
  height: 24px;
  padding: 0;
  border: 1px solid rgba(201, 162, 39, 0.3);
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.3);
  color: var(--zs-gold);
  font-size: 14px;
  line-height: 1;
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.zs-log-window .button-group button:hover {
  background: rgba(201, 162, 39, 0.2);
  border-color: var(--zs-gold);
  transform: scale(1.1);
}

.zs-log-window .button-group button:last-child:hover {
  background: rgba(227, 24, 55, 0.3);
  border-color: var(--zs-ruby);
  color: var(--zs-ruby);
}

/* Inner content area */
.zs-log-window .inner {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: 12px;
}

.zs-log-window .inner .zs-log-viewer {
  flex: 1;
  margin: 0;
  border-radius: 4px;
}

/* Resize handle */
.zs-log-window__resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  width: 16px;
  height: 16px;
  cursor: se-resize;
  background: linear-gradient(135deg, 
    transparent 50%, 
    rgba(201, 162, 39, 0.3) 50%
  );
  border-radius: 0 0 8px 0;
  transition: background 0.15s ease;
}

.zs-log-window__resize-handle:hover {
  background: linear-gradient(135deg, 
    transparent 50%, 
    rgba(201, 162, 39, 0.5) 50%
  );
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* SCROLLBAR                                                                   */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(5, 5, 8, 0.5);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(180deg, var(--zs-gold-dim), #5a4a10);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(180deg, var(--zs-gold), var(--zs-gold-dim));
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* CONTEXT MENU                                                                */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

.zs-context-menu {
  position: fixed;
  background: var(--zs-bg-elevated);
  border: 1px solid var(--zs-gold-dim);
  border-radius: 4px;
  padding: 4px 0;
  min-width: 120px;
  box-shadow: var(--zs-shadow-lg);
  z-index: 1000;
  animation: zs-fade-in 0.1s ease-out;
}

.zs-context-menu__item {
  padding: 8px 16px;
  font-family: var(--zs-font-body);
  font-size: 12px;
  color: var(--zs-text);
  cursor: pointer;
  transition: background 0.1s ease;
  display: flex;
  align-items: center;
  gap: 8px;
}

.zs-context-menu__item:hover {
  background: rgba(201, 162, 39, 0.15);
  color: var(--zs-gold);
}

.zs-context-menu__item-icon {
  font-size: 14px;
}

/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* ANIMATIONS                                                                  */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */

@keyframes zs-fade-in {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

.zs-server-item {
  animation: zs-fade-in 0.4s ease both;
  animation-delay: calc(var(--item-index, 0) * 50ms);
}
`;
        }
        return {
          ServerItemControl,
          ServerListControl,
          LogEntryControl,
          LogViewerControl,
          ServerLogWindowControl,
          ControlButtonControl,
          ControlPanelControl,
          SidebarControl,
          ContentAreaControl,
          TitleBarControl,
          ZServerAppControl: ZServerAppControl2,
          buildZServerStyles
        };
      }
      module.exports = { createZServerControls: createZServerControls2 };
    }
  });

  // renderer.src.js
  if (typeof window !== "undefined") {
    window.page_context = null;
  }
  console.log("[Z-Server] Renderer starting...");
  var jsgui;
  var createZServerControls;
  try {
    jsgui = require_client();
    console.log("[Z-Server] jsgui3-client loaded:", Object.keys(jsgui).slice(0, 10));
    createZServerControls = require_zServerControlsFactory().createZServerControls;
    console.log("[Z-Server] Controls factory loaded");
  } catch (err) {
    console.error("[Z-Server] Failed to load modules:", err.message);
    console.error("[Z-Server] Stack:", err.stack);
  }
  var ZServerAppControl;
  try {
    const controls = createZServerControls(jsgui);
    ZServerAppControl = controls.ZServerAppControl;
    console.log("[Z-Server] ZServerAppControl created");
  } catch (err) {
    console.error("[Z-Server] Failed to create controls:", err.message);
    console.error("[Z-Server] Stack:", err.stack);
  }
  document.addEventListener("DOMContentLoaded", async () => {
    console.log("[Z-Server] DOMContentLoaded fired");
    let context2;
    try {
      context2 = new jsgui.Client_Page_Context();
      console.log("[Z-Server] Context created");
    } catch (err) {
      console.error("[Z-Server] Failed to create context:", err.message);
      console.error("[Z-Server] Stack:", err.stack);
      return;
    }
    let app;
    try {
      app = new ZServerAppControl({
        context: context2,
        api: window.electronAPI
      });
      console.log("[Z-Server] App control created");
    } catch (err) {
      console.error("[Z-Server] Failed to create app:", err);
      return;
    }
    const rootEl = document.getElementById("app-root");
    if (rootEl) {
      try {
        const html = app.all_html_render();
        console.log("[Z-Server] Rendered HTML length:", html.length);
        rootEl.innerHTML = html;
        app.register_this_and_subcontrols();
        console.log("[Z-Server] All controls registered in context, map_controls size:", Object.keys(context2.map_controls).length);
        const appEl = rootEl.querySelector('[data-jsgui-id="' + app._id() + '"]');
        if (appEl) {
          app.dom.el = appEl;
          console.log("[Z-Server] App DOM element linked, id:", app._id());
          app.rec_desc_ensure_ctrl_el_refs(appEl);
          console.log("[Z-Server] Child controls linked to DOM, map_els size:", Object.keys(context2.map_els).length);
        } else {
          console.warn("[Z-Server] Could not find app element with id:", app._id());
        }
        app.activate();
        console.log("[Z-Server] App activated");
        await app.init();
        console.log("[Z-Server] App initialized");
      } catch (err) {
        console.error("[Z-Server] Failed during render/activate:", err);
        console.error("[Z-Server] Stack:", err.stack);
      }
    } else {
      console.error("App root element not found");
    }
  });
})();
