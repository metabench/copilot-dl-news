<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Queues</title>
  <link rel="stylesheet" href="/ui.css"/>
  <link rel="stylesheet" href="/ui-dark.css"/>
  <script type="module" src="/assets/theme/init.js"></script>
  <script type="module" src="/assets/global-nav.js"></script>
  </head>
  <body class="ui-page queues-monitor-page">
  <div data-global-nav data-active="queues" data-variant="bar"></div>
  <main class="ui-container queues-monitor">
    <header class="ui-header">
      <h1 class="ui-header__title">Queues <span id="job" class="pill mono"></span></h1>
    </header>

    <section class="queues-monitor__grid">
      <article class="card card--muted queues-monitor__card">
        <div class="queues-section__header u-flex-between u-items-center">
          <h2 class="queues-section__title">Planner timeline</h2>
          <span id="timelineJob" class="queues-text-muted"></span>
        </div>
        <div id="timelineEmpty" class="muted-block">Waiting for planner activity…</div>
        <ol id="timelineList" class="timeline"></ol>
      </article>
      <article class="card card--muted queues-monitor__card">
        <h2 class="queues-section__title">Goals</h2>
        <div id="goalSummary" class="muted-block">No active goals yet.</div>
        <div id="goalList" class="goal-list"></div>
      </article>
    </section>

    <section class="queues-monitor__grid">
      <article class="card card--muted queues-monitor__card">
        <h2 class="queues-section__title">Queue composition</h2>
        <div id="heatmapEmpty" class="muted-block">Waiting for queue metrics…</div>
        <table id="heatmapTable" class="heatmap-table"></table>
      </article>
      <article class="card card--muted queues-monitor__card">
        <h2 class="queues-section__title">Coverage</h2>
        <div id="coverageBadges" class="coverage-badges"></div>
        <div id="coverageKinds" class="goal-list"></div>
      </article>
    </section>

    <section class="card planner-card" id="plannerCard">
      <div class="queues-section__header u-flex-between u-items-center">
        <h2 class="queues-section__title u-mt-none u-mb-none">Planner stages</h2>
        <button id="clearPlannerBtn" class="ui-button ui-button--secondary">Clear</button>
      </div>
      <div id="plannerEmpty" class="muted-block">No planner stages yet.</div>
      <div id="plannerList" class="planner-list"></div>
    </section>

    <section class="card queues-events">
      <div class="queues-events__controls u-flex u-flex-between u-flex-wrap u-gap-sm">
        <div class="meta">
          <span id="modeLabel">Live queue events</span> (<span id="count">0</span>)
          <span id="persistMeta" class="meta u-ml-sm"></span>
        </div>
        <div class="u-flex u-gap-sm">
          <label class="meta"><input type="checkbox" id="onlyActive"/> Filter to active job</label>
          <select id="jobSelect" class="u-minw-20rem"></select>
          <button id="loadBtn" class="ui-button">Load events</button>
        </div>
      </div>
      <table>
        <thead>
          <tr>
            <th>When</th><th>Action</th><th>URL</th><th>Depth</th><th>Host</th><th>Reason</th><th>Queue size</th><th>Job</th>
          </tr>
        </thead>
        <tbody id="tbody"><tr><td colspan="8" class="muted">Waiting for events…</td></tr></tbody>
      </table>
    </section>
  </main>
  <script>
    (function(){
      const tbody = document.getElementById('tbody');
      const countEl = document.getElementById('count');
      const onlyActive = document.getElementById('onlyActive');
      const jobSpan = document.getElementById('job');
      const jobSelect = document.getElementById('jobSelect');
      const loadBtn = document.getElementById('loadBtn');
      const modeLabel = document.getElementById('modeLabel');
      const persistMeta = document.getElementById('persistMeta');
      const timelineList = document.getElementById('timelineList');
      const timelineEmpty = document.getElementById('timelineEmpty');
      const timelineJob = document.getElementById('timelineJob');
      const goalSummary = document.getElementById('goalSummary');
      const goalList = document.getElementById('goalList');
      const heatmapTable = document.getElementById('heatmapTable');
      const heatmapEmpty = document.getElementById('heatmapEmpty');
      const coverageBadges = document.getElementById('coverageBadges');
      const coverageKinds = document.getElementById('coverageKinds');
      const plannerList = document.getElementById('plannerList');
      const plannerEmpty = document.getElementById('plannerEmpty');
      const clearPlannerBtn = document.getElementById('clearPlannerBtn');

      let activeJob = null;
      let seen = 0;
      let historyMode = false;
      const plannerEvents = [];
      const MAX_PLANNER_EVENTS = 40;

      function formatClock(value) {
        if (!value) return '';
        const date = typeof value === 'string' ? new Date(value) : value;
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
        return date.toLocaleTimeString();
      }

      function formatTimeAgo(value) {
        if (!value) return '';
        const date = typeof value === 'string' ? new Date(value) : value;
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
        const diff = Date.now() - date.getTime();
        if (diff < 0) return 'just now';
        const seconds = Math.floor(diff / 1000);
        if (seconds < 60) return `${seconds}s ago`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;
        const days = Math.floor(hours / 24);
        return `${days}d ago`;
      }

      function summarizeDetails(details) {
        if (!details) return '';
        if (typeof details === 'string') return details.length > 160 ? `${details.slice(0, 160)}…` : details;
        try {
          const compact = JSON.stringify(details);
          return compact.length > 160 ? `${compact.slice(0, 160)}…` : compact;
        } catch (_) {
          return '';
        }
      }

      function addQueueRow(ev) {
        const tr = document.createElement('tr');
        const td = (text = '') => {
          const cell = document.createElement('td');
          cell.textContent = text ?? '';
          return cell;
        };
        const ts = formatClock(new Date());
        tr.appendChild(td(ts));
        tr.appendChild(td(ev.action || ''));
        tr.appendChild(td(ev.url || ''));
        tr.appendChild(td(ev.depth != null ? String(ev.depth) : ''));
        tr.appendChild(td(ev.host || ''));
        tr.appendChild(td(ev.reason || ''));
        tr.appendChild(td(ev.queueSize != null ? String(ev.queueSize) : ''));
        tr.appendChild(td(ev.jobId || ''));
        tbody.appendChild(tr);
      }

      function ensureHeader() {
        if (!tbody.firstChild || tbody.firstChild.children.length !== 8) {
          tbody.innerHTML = '';
        }
      }

      function renderTimeline(timeline, jobId) {
        if (!Array.isArray(timeline) || timeline.length === 0) {
          timelineList.innerHTML = '';
          timelineEmpty.style.display = 'block';
          if (timelineJob) timelineJob.textContent = jobId || '';
          return;
        }
        timelineEmpty.style.display = 'none';
        if (timelineJob) timelineJob.textContent = jobId ? `job ${jobId}` : '';
        timelineList.innerHTML = '';
        const recent = timeline.slice(-8).reverse();
        for (const entry of recent) {
          const li = document.createElement('li');
          const stage = document.createElement('div');
          stage.className = 'stage';
          stage.textContent = entry.stage || 'unknown stage';
          li.appendChild(stage);

          const meta = document.createElement('div');
          meta.className = 'meta';
          const parts = [];
          if (entry.status) parts.push(entry.status);
          if (entry.durationMs != null) parts.push(`${Math.round(entry.durationMs)}ms`);
          if (entry.emittedAt) parts.push(formatTimeAgo(entry.emittedAt));
          else if (entry.startedAt) parts.push(formatTimeAgo(entry.startedAt));
          meta.textContent = parts.join(' · ');
          li.appendChild(meta);

          if (entry.details) {
            const details = document.createElement('div');
            details.className = 'meta';
            details.textContent = summarizeDetails(entry.details);
            li.appendChild(details);
          }

          timelineList.appendChild(li);
        }
      }

      function renderGoals(states, summary) {
        if (!Array.isArray(states) || states.length === 0) {
          goalSummary.textContent = 'No active goals yet.';
          goalList.innerHTML = '';
          return;
        }
        const completed = summary?.completed ?? states.filter((g) => g.completed).length;
        goalSummary.textContent = `${completed}/${states.length} completed`;
        goalList.innerHTML = '';
        const subset = states.slice(0, 6);
        for (const goal of subset) {
          const wrapper = document.createElement('div');
          wrapper.className = 'goal';

          const heading = document.createElement('h3');
          heading.textContent = goal.description || goal.id || 'Goal';
          wrapper.appendChild(heading);

          const status = document.createElement('div');
          status.className = 'meta';
          const pct = Math.max(0, Math.min(100, Math.round((goal.progress || 0) * 100)));
          status.textContent = goal.completed ? 'Completed' : `Progress: ${pct}%`;
          wrapper.appendChild(status);

          const progressBar = document.createElement('div');
          progressBar.className = 'goal-progress';
          const span = document.createElement('span');
          span.style.width = `${pct}%`;
          if (goal.completed) span.style.background = '#16a34a';
          progressBar.appendChild(span);
          wrapper.appendChild(progressBar);

          if (Array.isArray(goal.nextSteps) && goal.nextSteps.length) {
            const steps = document.createElement('div');
            steps.className = 'meta';
            steps.textContent = `Next: ${goal.nextSteps.slice(0, 2).join('; ')}`;
            wrapper.appendChild(steps);
          }

          if (goal.details) {
            const details = document.createElement('div');
            details.className = 'meta';
            details.textContent = summarizeDetails(goal.details);
            wrapper.appendChild(details);
          }

          goalList.appendChild(wrapper);
        }
      }

      function createTh(text) {
        const th = document.createElement('th');
        th.textContent = text;
        return th;
      }

      function createTd(value) {
        const td = document.createElement('td');
        td.textContent = value != null ? String(value) : '';
        return td;
      }

      function renderHeatmap(heatmap) {
        if (!heatmap || !heatmap.cells) {
          heatmapTable.innerHTML = '';
          heatmapEmpty.style.display = 'block';
          return;
        }
        heatmapEmpty.style.display = 'none';
        heatmapTable.innerHTML = '';

        const columns = ['article', 'hub', 'other'];
        const header = document.createElement('tr');
        header.appendChild(createTh('Origin'));
        for (const col of columns) {
          header.appendChild(createTh(col.charAt(0).toUpperCase() + col.slice(1)));
        }
        header.appendChild(createTh('Total'));
        heatmapTable.appendChild(header);

        const entries = Object.entries(heatmap.cells).sort(([a], [b]) => a.localeCompare(b));
        for (const [origin, counts] of entries) {
          const tr = document.createElement('tr');
          tr.appendChild(createTd(origin));
          let rowTotal = 0;
          for (const col of columns) {
            const value = counts?.[col] || 0;
            rowTotal += value;
            tr.appendChild(createTd(value));
          }
          tr.appendChild(createTd(rowTotal));
          heatmapTable.appendChild(tr);
        }

        if (heatmap.depthBuckets) {
          const footerLabel = document.createElement('tr');
          footerLabel.appendChild(createTh('Depth bucket'));
          const depthKeys = ['0', '1', '2', '3+', 'unknown'].filter((key) => Object.prototype.hasOwnProperty.call(heatmap.depthBuckets, key));
          for (const key of depthKeys) {
            footerLabel.appendChild(createTh(key));
          }
          heatmapTable.appendChild(footerLabel);

          const footerValues = document.createElement('tr');
          footerValues.appendChild(createTd('Queued URLs'));
          for (const key of depthKeys) {
            footerValues.appendChild(createTd(heatmap.depthBuckets[key] || 0));
          }
          heatmapTable.appendChild(footerValues);
        }
      }

      function renderCoverage(coverage) {
        coverageBadges.innerHTML = '';
        coverageKinds.innerHTML = '';
        if (!coverage) {
          const note = document.createElement('div');
          note.className = 'muted-block';
          note.textContent = 'No coverage metrics yet.';
          coverageKinds.appendChild(note);
          return;
        }
        if (coverage.depth2) {
          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = `${coverage.depth2.visited} ${coverage.depth2.label || 'depth-2 pages'}`;
          coverageBadges.appendChild(badge);
        }
        if (coverage.hubs) {
          const badge = document.createElement('span');
          badge.className = 'badge';
          const pct = coverage.hubs.percentVisited != null ? `${coverage.hubs.percentVisited}%` : '—';
          badge.textContent = `Hubs visited ${coverage.hubs.visited}/${coverage.hubs.seeded || 0} (${pct})`;
          coverageBadges.appendChild(badge);
        }
        if (Array.isArray(coverage.samples?.visited) && coverage.samples.visited.length) {
          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = `Recent hubs: ${coverage.samples.visited.slice(0, 3).join(', ')}`;
          coverageBadges.appendChild(badge);
        }

        if (Array.isArray(coverage.hubs?.perKind) && coverage.hubs.perKind.length) {
          const subset = coverage.hubs.perKind.slice(0, 6);
          for (const info of subset) {
            const card = document.createElement('div');
            card.className = 'goal';
            const title = document.createElement('h3');
            title.textContent = `${info.kind || 'kind'} coverage`;
            card.appendChild(title);
            const meta = document.createElement('div');
            meta.className = 'meta';
            const pct = info.percent != null ? `${info.percent}%` : '—';
            meta.textContent = `${info.visited}/${info.seeded} visited (${pct})`;
            card.appendChild(meta);
            coverageKinds.appendChild(card);
          }
        } else {
          const note = document.createElement('div');
          note.className = 'muted-block';
          note.textContent = 'No hub breakdown yet.';
          coverageKinds.appendChild(note);
        }
      }

      function renderPlannerEvents() {
        if (!plannerEvents.length) {
          plannerList.innerHTML = '';
          plannerEmpty.style.display = 'block';
          return;
        }
        plannerEmpty.style.display = 'none';
        plannerList.innerHTML = '';
        for (const ev of plannerEvents) {
          const wrapper = document.createElement('div');
          wrapper.className = 'planner-item';
          const details = document.createElement('details');
          const summary = document.createElement('summary');
          const parts = [];
          parts.push(ev.stage || 'stage');
          if (ev.status) parts.push(ev.status);
          if (ev.durationMs != null) parts.push(`${Math.round(ev.durationMs)}ms`);
          if (ev.ts) parts.push(formatTimeAgo(ev.ts));
          summary.textContent = parts.join(' · ');
          details.appendChild(summary);
          if (ev.details) {
            const pre = document.createElement('pre');
            pre.textContent = typeof ev.details === 'string' ? ev.details : JSON.stringify(ev.details, null, 2);
            details.appendChild(pre);
          }
          wrapper.appendChild(details);
          plannerList.appendChild(wrapper);
        }
      }

      function addPlannerEvent(ev) {
        if (!ev) return;
        if (activeJob && ev.jobId && ev.jobId !== activeJob) return;
        const payload = {
          ...ev,
          ts: ev.ts || new Date().toISOString()
        };
        plannerEvents.unshift(payload);
        if (plannerEvents.length > MAX_PLANNER_EVENTS) {
          plannerEvents.length = MAX_PLANNER_EVENTS;
        }
        renderPlannerEvents();
      }

      // Cache for job list to avoid redundant API calls
      let jobsCache = null;
      let jobsCacheTime = 0;
      const JOBS_CACHE_TTL = 5000; // 5 seconds

      async function loadJobs(forceRefresh = false) {
        // Return cached data if still valid
        const now = Date.now();
        if (!forceRefresh && jobsCache && (now - jobsCacheTime) < JOBS_CACHE_TTL) {
          return jobsCache;
        }

        try {
          // Limit to 50 most recent jobs (sufficient for dropdown)
          const res = await fetch('/api/queues?limit=50');
          const data = await res.json();
          const items = Array.isArray(data.items) ? data.items : [];
          
          // Cache the result
          jobsCache = items;
          jobsCacheTime = now;
          jobSelect.innerHTML = '';
          const opt0 = document.createElement('option');
          opt0.value = '';
          opt0.textContent = items.length ? '— Select a job —' : 'No jobs';
          jobSelect.appendChild(opt0);
          for (const j of items) {
            const option = document.createElement('option');
            const label = `${j.id} — ${j.url || ''} (${j.status || 'unknown'}, ${j.events || 0} events)`;
            option.value = j.id;
            option.textContent = label;
            option.dataset.events = String(j.events || 0);
            option.dataset.startedAt = j.startedAt || '';
            option.dataset.endedAt = j.endedAt || '';
            option.dataset.status = j.status || '';
            jobSelect.appendChild(option);
          }
          return items;
        } catch (_) {
          return [];
        }
      }

      function renderPersistMeta(opt) {
        if (!opt) {
          persistMeta.textContent = '';
          return;
        }
        const parts = [];
        if (opt.dataset.status) parts.push(`status=${opt.dataset.status}`);
        if (opt.dataset.startedAt) parts.push(`started=${opt.dataset.startedAt}`);
        if (opt.dataset.endedAt) parts.push(`ended=${opt.dataset.endedAt}`);
        const evs = opt.dataset.events ? `events=${opt.dataset.events}` : '';
        persistMeta.textContent = [parts.join(' · '), evs].filter(Boolean).join(' · ');
      }

      async function loadEvents(jobId) {
        if (!jobId) return;
        try {
          // Limit to 100 events (sufficient for most debugging, reduces payload)
          const res = await fetch(`/api/queues/${encodeURIComponent(jobId)}/events?limit=100`);
          if (!res.ok) return;
          const data = await res.json();
          tbody.innerHTML = '';
          const items = Array.isArray(data.items) ? data.items : [];
          for (const it of items) {
            const tr = document.createElement('tr');
            const td = (text = '') => {
              const el = document.createElement('td');
              el.textContent = text ?? '';
              return el;
            };
            const ts = it.ts ? formatClock(it.ts) : '';
            tr.appendChild(td(ts));
            tr.appendChild(td(it.action || ''));
            tr.appendChild(td(it.url || ''));
            tr.appendChild(td(it.depth != null ? String(it.depth) : ''));
            tr.appendChild(td(it.host || ''));
            tr.appendChild(td(it.reason || ''));
            tr.appendChild(td(it.queueSize != null ? String(it.queueSize) : ''));
            tr.appendChild(td(jobId));
            tbody.appendChild(tr);
          }
          modeLabel.textContent = 'Persisted queue events';
          historyMode = true;
          const opt = jobSelect.options[jobSelect.selectedIndex];
          renderPersistMeta(opt && opt.value ? opt : null);
          activeJob = jobId;
          jobSpan.textContent = activeJob;
        } catch (_) {}
      }

      function handleProgress(payload) {
        if (!payload || typeof payload !== 'object') return;
        if (payload.jobId) {
          activeJob = payload.jobId;
          jobSpan.textContent = activeJob;
        }
        if (!historyMode) {
          modeLabel.textContent = 'Live queue events';
        }
        if (payload.timeline) {
          renderTimeline(payload.timeline, payload.jobId || activeJob);
        } else {
          renderTimeline(null, payload?.jobId || activeJob || null);
        }
        if (payload.goalStates) {
          renderGoals(payload.goalStates, payload.goalSummary || null);
        } else {
          renderGoals([], null);
        }
        if (payload.queueHeatmap) {
          renderHeatmap(payload.queueHeatmap);
        } else {
          renderHeatmap(null);
        }
        if (payload.coverage) {
          renderCoverage(payload.coverage);
        } else {
          renderCoverage(null);
        }
      }

      const evt = new EventSource('/events');
      evt.addEventListener('progress', (e) => {
        try {
          const payload = JSON.parse(e.data);
          handleProgress(payload);
        } catch (_) {}
      });
      evt.addEventListener('queue', (e) => {
        try {
          const q = JSON.parse(e.data);
          if (onlyActive.checked && activeJob && q.jobId && q.jobId !== activeJob) return;
          if (!historyMode) {
            ensureHeader();
            addQueueRow(q);
            seen += 1;
            countEl.textContent = String(seen);
          }
        } catch (_) {}
      });
      evt.addEventListener('planner-stage', (e) => {
        try {
          const payload = JSON.parse(e.data);
          addPlannerEvent(payload);
        } catch (_) {}
      });

      clearPlannerBtn.addEventListener('click', () => {
        plannerEvents.length = 0;
        renderPlannerEvents();
      });

      loadBtn.addEventListener('click', async () => {
        const id = jobSelect.value;
        if (id) {
          loadBtn.disabled = true;
          loadBtn.textContent = 'Loading...';
          try {
            await loadEvents(id);
          } finally {
            loadBtn.disabled = false;
            loadBtn.textContent = 'Load';
          }
        }
      });
      jobSelect.addEventListener('change', () => {
        const opt = jobSelect.options[jobSelect.selectedIndex];
        renderPersistMeta(opt && opt.value ? opt : null);
      });

      loadJobs();
      renderPlannerEvents();
      renderTimeline(null, null);
      renderGoals([], null);
      renderHeatmap(null);
      renderCoverage(null);
    })();
  </script>
</body>
</html>
