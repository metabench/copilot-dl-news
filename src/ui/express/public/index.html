<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>News Crawler UI</title>
    <style>
      :root { --bg:#ffffff; --fg:#111111; --muted:#666666; }
      @media (prefers-color-scheme: dark) {
        :root { --bg:#0b0e12; --fg:#e5e7eb; --muted:#98a2b3; }
      }
      .dark body { --bg:#0b0e12; --fg:#e5e7eb; --muted:#98a2b3; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; background: var(--bg); color: var(--fg); }
  pre { background: #111; color: #0f0; padding: 10px; height: 240px; overflow: auto; }
  /* Allow the logs area to be resized vertically */
  #logs { resize: vertical; min-height: 120px; max-height: 75vh; }
  /* Drag handle for reliable resizing in Chrome */
  .resizer-h { height: 6px; cursor: row-resize; background: linear-gradient(to bottom, #e5e7eb, #cbd5e1); border:1px solid #cbd5e1; border-top: none; }
  .resizing { user-select: none; }
  .row { display: flex; gap: 16px; align-items: flex-end; flex-wrap: wrap; }
      .controls-bar {
        background: #f5f7fa;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 10px 12px;
        margin-bottom: 10px;
      }
      @media (prefers-color-scheme: dark) {
        .controls-bar { background: #151a21; border-color: #2a3441; }
      }
      .row > div { display: flex; flex-direction: column; gap: 4px; }
      /* Let controls wrap nicely on narrow screens */
      .row > div { flex: 1 1 180px; min-width: 140px; }
      .row > div:first-child { flex: 2 1 320px; min-width: 220px; }
  #startUrl, #depth, #maxPages, #refetchIfOlderThan, #concurrency, #requestTimeoutMs, #pacerJitterMinMs, #pacerJitterMaxMs {
        width: 100%;
        box-sizing: border-box;
      }
  .btns { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; align-items: center; flex: 1 1 220px; }
      @media (max-width: 600px) {
        .row > div { flex: 1 1 100%; min-width: 0; }
        .btns button { flex: 1 1 auto; }
      }
      label { display: block; font-size: 12px; color: #555; }
      input, select, button { padding: 6px 8px; }
  .warn { color: #b58900; }
  .bad { color: #dc322f; }
  /* sparkline stroke colors */
  .spark-ok { stroke: #268bd2; }
  .spark-warn { stroke: #b58900; }
  .spark-bad { stroke: #dc322f; }
  .muted { color: var(--muted); }
  /* error lines in logs */
  .log-error { color: #dc322f; }
    </style>
  </head>
  <body>
    <h1>News Crawler</h1>
    <p style="margin-top:-8px; margin-bottom:14px; color:#555; font-size:13px;">
      Quick links:
      <a href="/urls">URLs</a> ·
      <a href="/domain">Domain summary</a> ·
  <a href="/domains">Domains</a> ·
  <a href="/errors">Errors</a> ·
      <a href="/health" target="_blank" rel="noopener">Health</a> ·
      <a href="/metrics" target="_blank" rel="noopener">Metrics</a>
    </p>
    <div class="controls-bar">
      <div class="row">
        <div>
          <label>Start URL</label>
          <input id="startUrl" value="https://www.theguardian.com" size="40" />
        </div>
        <div>
          <label>Depth</label>
          <input id="depth" type="number" value="2" />
        </div>
        <div>
          <label>Max Pages</label>
          <input id="maxPages" type="number" />
        </div>
        <div>
          <label>Re-download cached pages if older than</label>
          <input id="refetchIfOlderThan" type="text" placeholder="e.g., 30m or 6h" />
        </div>
        <div>
          <label>Concurrency</label>
          <input id="concurrency" type="number" value="1" />
        </div>
        <div>
          <label>Timeout (ms)</label>
          <input id="requestTimeoutMs" type="number" placeholder="10000" />
        </div>
        <div>
          <label>Pacer jitter (ms)</label>
          <div>
            <input id="pacerJitterMinMs" type="number" placeholder="25" style="width:90px" /> –
            <input id="pacerJitterMaxMs" type="number" placeholder="50" style="width:90px" />
          </div>
        </div>
        <div>
          <label><input id="slowMode" type="checkbox" /> Slow mode (1 req/s)</label>
        </div>
        <div>
          <label title="Discover and enqueue URLs from the site’s sitemap in addition to the Start URL. Disable to rely only on link traversal."><input id="useSitemap" type="checkbox" /> Use sitemap</label>
        </div>
        <div>
          <label><input id="sitemapOnly" type="checkbox" /> Sitemap only</label>
        </div>
        <div class="btns">
          <button id="startBtn">Start</button>
          <button id="stopBtn">Stop</button>
          <button id="pauseBtn">Pause</button>
          <button id="resumeBtn" disabled>Resume</button>
          <button id="themeBtn" title="Toggle dark mode">Dark</button>
        </div>
      </div>
    </div>
    
    <p>
      <label><input type="checkbox" id="showLogs" /> Show logs</label>
    </p>
  <h3>Progress <span id="eta" class="muted" style="font-weight:normal; font-size:13px;"></span></h3>
  <div id="progress">visited: 0, downloaded: 0, found: 0, saved: 0</div>
  <div id="inflight" style="font-size:13px; color:#333; margin-top:6px;">
    current downloads: 0
    <ul id="inflightList" style="margin:4px 0 0 14px; padding:0; list-style:disc;"></ul>
  </div>
  <div id="cacheInfo" style="color:#555; font-size: 13px; margin-top: 6px;">cached hits: 0</div>
  <div id="metrics" style="font-size:13px; color: #333; margin-top:8px; display:flex; align-items:center; gap:8px;">
    <strong>Metrics:</strong>
  <span id="m_reqps" style="display:flex; align-items:center; gap:6px;"><span id="m_reqps_label">req/s: 0</span>
    <svg id="reqps_spark" width="200" height="36" viewBox="0 0 200 36" preserveAspectRatio="none" style="border:1px solid #ddd; background:#fafafa">
        <title id="reqps_title">req/s sparkline</title>
  <polyline id="reqps_poly" class="spark-ok" fill="none" stroke-width="1" points="" />
      </svg>
    </span>
  <span id="m_dlps" style="margin-left:12px; display:flex; align-items:center; gap:6px;"><span id="m_dlps_label">dl/s (≤15s avg): 0 · MB/s (≤15s avg): 0</span>
    <svg id="dlps_spark" width="200" height="36" viewBox="0 0 200 36" preserveAspectRatio="none" style="border:1px solid #ddd; background:#fafafa">
        <title id="dlps_title">dl/s sparkline</title>
  <polyline id="dlps_poly" class="spark-ok" fill="none" stroke-width="1" points="" />
      </svg>
    </span>
    <span id="m_errpm" style="margin-left:12px;">err/min: 0</span>
    <span id="m_qsize" style="margin-left:12px; display:flex; align-items:center; gap:6px;">queue: 0
      <svg id="q_spark" width="200" height="36" viewBox="0 0 200 36" preserveAspectRatio="none" style="border:1px solid #ddd; background:#fafafa">
        <title id="q_title">queue sparkline</title>
        <polyline id="q_poly" class="spark-ok" fill="none" stroke-width="1" points="" />
      </svg>
    </span>
  <span id="m_domrpm" class="muted" style="margin-left:12px; display:none;">domain rpm: n/a</span>
  <span id="m_domlim" class="muted" style="display:none;">limit: n/a</span>
  <span id="m_dombk" class="muted" style="display:none;">backoff: -</span>
  <span id="m_domrl" class="bad" style="display:none; font-weight:bold; margin-left:12px;">RATE LIMITED</span>
    <span id="m_errs" style="margin-left:12px;">errors: 0</span>
    <span id="cacheGauge" class="muted" style="margin-left:12px;">cache: 1m 0% · 5m 0%</span>
  </div>
  <details id="secErrors" open>
    <summary><strong>Recent errors</strong></summary>
    <div id="errorsPanel" style="margin-top:6px; font-size:13px;">
      <div id="errorsList" class="muted">Loading…</div>
    </div>
  </details>
  <details id="secDomains" open style="margin-top:10px;">
    <summary><strong>Recent Domains</strong></summary>
    <div id="domains" class="meta" style="font-size:13px; color:#333; margin:6px 0 10px;">Loading…</div>
  </details>
  <details id="secLogs" open style="margin-top:10px;">
    <summary><strong>Logs</strong></summary>
    <div id="logsToolbar" style="display:flex; align-items:center; gap:8px; margin:6px 0; font-size:12px; color:#555;">
      <span>font:</span>
      <button id="logsFontMinus" type="button" title="Smaller" style="padding:2px 6px;">A-</button>
      <button id="logsFontPlus" type="button" title="Larger" style="padding:2px 6px;">A+</button>
      <span id="logsFontVal" class="muted"></span>
    </div>
    <pre id="logs"></pre>
    <div id="logsResizer" class="resizer-h" title="Drag to resize logs"></div>
  </details>
  <div id="healthStrip" style="margin-top:10px; font-size:13px;">
  <span id="badgeRobots" class="muted">robots: …</span>
  <span id="badgeSitemap" class="muted" style="margin-left:12px;">sitemap: 0 / 0</span>
    <span id="badgeDb" class="muted" style="margin-left:12px;">db: …</span>
    <span id="badgeDisk" class="muted" style="margin-left:12px;">disk: …</span>
  </div>
  <p><a href="/urls">View saved article URLs</a></p>
    <script>
  const logs = document.getElementById('logs');
  const logsResizer = document.getElementById('logsResizer');
  const logsFontMinus = document.getElementById('logsFontMinus');
  const logsFontPlus = document.getElementById('logsFontPlus');
  const logsFontVal = document.getElementById('logsFontVal');
  const secErrors = document.getElementById('secErrors');
  const secDomains = document.getElementById('secDomains');
  const secLogs = document.getElementById('secLogs');
  const progress = document.getElementById('progress');
  const mReqps = document.getElementById('m_reqps');
  const mDlps = document.getElementById('m_dlps');
  const mReqpsLabel = document.getElementById('m_reqps_label');
  const mDlpsLabel = document.getElementById('m_dlps_label');
  const mErrpm = document.getElementById('m_errpm');
  const mQsize = document.getElementById('m_qsize');
  const mErrs = document.getElementById('m_errs');
  const mDomRpm = document.getElementById('m_domrpm');
  const mDomLim = document.getElementById('m_domlim');
  const mDomBk = document.getElementById('m_dombk');
  const mDomRl = document.getElementById('m_domrl');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const domains = document.getElementById('domains');
  const inflightDiv = document.getElementById('inflight');
  const inflightList = document.getElementById('inflightList');
  const qPoly = document.getElementById('q_poly');
  const qTitle = document.getElementById('q_title');
  const themeBtn = document.getElementById('themeBtn');
  const etaEl = document.getElementById('eta');
  const cacheGauge = document.getElementById('cacheGauge');
  const badgeDb = document.getElementById('badgeDb');
  const badgeDisk = document.getElementById('badgeDisk');
  const badgeRobots = document.getElementById('badgeRobots');
  const badgeSitemap = document.getElementById('badgeSitemap');
  const badgeCpu = document.createElement('span');
  const badgeMem = document.createElement('span');
  const badgeWal = document.createElement('span');
  badgeCpu.className = 'muted';
  badgeMem.className = 'muted';
  badgeWal.className = 'muted';
  try {
    badgeCpu.style.marginLeft = '12px';
    badgeMem.style.marginLeft = '12px';
    badgeWal.style.marginLeft = '12px';
    const hs = document.getElementById('healthStrip');
    hs.appendChild(badgeCpu);
    hs.appendChild(badgeMem);
    hs.appendChild(badgeWal);
  } catch(_) {}
  let evt;
  let cacheHits = 0;
  // rolling window samples of network and cache (and bytes)
  let trafficSamples = []; // [{t, net, cache, bytes}]
      // Restore saved logs height
      (function(){
        const savedH = parseInt(localStorage.getItem('logsH')||'', 10);
        if (!isNaN(savedH) && savedH >= 120) {
          logs.style.height = savedH + 'px';
        }
      })();
      // Logs font size controls with persistence
      (function(){
        if (!logs) return;
        const clamp = (v) => Math.max(10, Math.min(28, v|0));
        const getSize = () => {
          const cs = parseInt((getComputedStyle(logs).fontSize||'').replace('px',''), 10);
          return isNaN(cs) ? 16 : cs;
        };
        const saved = parseInt(localStorage.getItem('logsFontSize')||'', 10);
        const base = getSize();
        const sz = clamp(isNaN(saved) ? base : saved);
        logs.style.fontSize = sz + 'px';
        if (logsFontVal) logsFontVal.textContent = sz + 'px';
        const setSz = (v) => {
          const n = clamp(v);
          logs.style.fontSize = n + 'px';
          localStorage.setItem('logsFontSize', String(n));
          if (logsFontVal) logsFontVal.textContent = n + 'px';
        };
        if (logsFontMinus) logsFontMinus.onclick = () => setSz((parseInt(localStorage.getItem('logsFontSize')||'',10)||getSize()) - 1);
        if (logsFontPlus) logsFontPlus.onclick = () => setSz((parseInt(localStorage.getItem('logsFontSize')||'',10)||getSize()) + 1);
      })();
      // Drag-to-resize for logs area (works even if CSS resize is ignored)
      (function(){
        if (!logsResizer) return;
        let startY = 0, startH = 0, active = false;
        const onMove = (e) => {
          if (!active) return;
          const dy = e.clientY - startY;
          const maxH = Math.max(200, Math.floor(window.innerHeight * 0.75));
          const newH = Math.min(maxH, Math.max(120, startH + dy));
          logs.style.height = newH + 'px';
        };
        const onUp = () => {
          if (!active) return;
          active = false;
          document.body.classList.remove('resizing');
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
          const h = parseInt(getComputedStyle(logs).height, 10);
          if (!isNaN(h)) localStorage.setItem('logsH', String(h));
        };
        logsResizer.addEventListener('mousedown', (e) => {
          startY = e.clientY;
          startH = parseInt(getComputedStyle(logs).height, 10) || logs.clientHeight || 240;
          active = true;
          document.body.classList.add('resizing');
          window.addEventListener('mousemove', onMove);
          window.addEventListener('mouseup', onUp);
          e.preventDefault();
        });
      })();
      // Batch log updates to avoid frequent DOM writes (structured to allow styling)
      let logEntries = []; // { text, isErr }
      let flushTimer = null;
      function scheduleFlush() {
        if (flushTimer) return;
        flushTimer = setTimeout(() => {
          try {
            const frag = document.createDocumentFragment();
            for (const ent of logEntries) {
              const span = document.createElement('span');
              span.textContent = ent.text;
              if (ent.isErr) span.classList.add('log-error');
              frag.appendChild(span);
            }
            logs.appendChild(frag);
            logs.scrollTop = logs.scrollHeight;
          } catch (_) {
            // Fallback to plain text append if something goes wrong
            try { logs.textContent += logEntries.map(e => e.text).join(''); } catch (_) {}
          }
          logEntries = [];
          flushTimer = null;
        }, 200);
      }
      function attachHandlers(es) {
        es.addEventListener('log', (e) => {
          try {
            const j = JSON.parse(e.data);
            const line = String(j.line||'');
            const isErr = j.stream === 'stderr' || /\berror\b|\bfailed\b|\bexception\b/i.test(line);
            // Lines from server already include trailing \n
            logEntries.push({ text: isErr ? line.replace(/$/m, '') : line, isErr });
            scheduleFlush();
          } catch (_) {}
        });
        es.addEventListener('error', (e) => {
          try {
            const obj = JSON.parse(e.data);
            const msg = obj.message || (obj.code ? `HTTP ${obj.code}` : 'Error');
            const url = obj.url || '';
            logEntries.push({ text: `[ERROR] ${msg} ${url}\n`, isErr: true });
            scheduleFlush();
          } catch (_) {}
        });
      // Throttle progress UI to ~5 FPS
      let lastProgressAt = 0;
  es.addEventListener('progress', (e) => {
        const now = Date.now();
        if (now - lastProgressAt < 200) return;
        lastProgressAt = now;
  try {
          const p = JSON.parse(e.data);
          progress.textContent = `visited: ${p.visited||0}, downloaded: ${p.downloaded||0}, found: ${p.found||0}, saved: ${p.saved||0}`;
          // toggle pause/resume buttons
          if (typeof p.paused === 'boolean') {
            pauseBtn.disabled = !!p.paused;
            resumeBtn.disabled = !p.paused;
          }
          // Show current in-flight downloads
          const count = p.currentDownloadsCount || (Array.isArray(p.currentDownloads) ? p.currentDownloads.length : 0) || 0;
          inflightDiv.firstChild.nodeValue = `current downloads: ${count}`;
          if (Array.isArray(p.currentDownloads)) {
            const groups = new Map();
            for (const d of p.currentDownloads) {
              let host = '';
              try { host = new URL(d.url).hostname.toLowerCase(); } catch (_) { host = ''; }
              if (!groups.has(host)) groups.set(host, []);
              groups.get(host).push(d);
            }
            const lines = [];
            // Per-host limiter info from progress
            const lim = (p && p.perHostLimits) ? p.perHostLimits : {};
            for (const [host, arr] of groups.entries()) {
              const items = arr.slice(0, 3).map(d => {
                const age = typeof d.ageMs === 'number' ? ` ${(Math.round(d.ageMs/100)/10).toFixed(1)}s` : '';
                const u = String(d.url||'').replace(/^https?:\/\//,'');
                return `<a href="/url?url=${encodeURIComponent(d.url)}">${u}</a><span style="color:#666;">${age}</span>`;
              }).join(' · ');
              // Build rate-limited badge if applicable
              let badge = '';
              try {
                const info = lim[host];
                if (info && info.rateLimited) {
                  const tip = [`limit: ${info.limit ?? 'n/a'}/min`, info.intervalMs!=null?`interval: ~${info.intervalMs}ms`:null, info.backoffMs!=null?`backoff: ~${Math.ceil(info.backoffMs/1000)}s`:null].filter(Boolean).join(' \n');
                  badge = ` <span class="bad" title="${tip}">RATE LIMITED</span>`;
                }
              } catch(_) {}
              lines.push(`<li><strong>${host||'(unknown)'}</strong>${badge} — ${arr.length} ${items ? '· ' + items : ''}</li>`);
            }
            inflightList.innerHTML = lines.join('');
          }
          // simple rate calc client-side
          window.__lastProgress = window.__lastProgress || { t: now, visited: 0, downloaded: 0, errors: 0 };
          const lp = window.__lastProgress;
          const dt = Math.max(0.001, (now - lp.t) / 1000);
          const dv = (p.visited||0) - (lp.visited||0);
          const dd = (p.downloaded||0) - (lp.downloaded||0);
          const de = (p.errors||0) - (lp.errors||0);
          mReqpsLabel.textContent = `req/s: ${(dv/dt).toFixed(2)}`;
          // dl/s shown below as a ≤15s average to avoid flicker
          mErrpm.textContent = `err/min: ${((de*(60/dt))||0).toFixed(2)}`;
          mQsize.firstChild.nodeValue = `queue: ${p.queueSize||0}`;
          // update queue sparkline from progress
          window.__q_series = window.__q_series || [];
          const qSeries = window.__q_series;
          qSeries.push(Math.max(0, p.queueSize||0));
          if (qSeries.length > 70) qSeries.shift();
          (function drawQ(){
            const svgW = 200, svgH = 36;
            const min = 0;
            const max = Math.max(1, Math.max(...qSeries));
            const n = qSeries.length;
            const stepX = n > 1 ? (svgW - 2) / (n - 1) : 0;
            const pts = qSeries.map((v, i) => {
              const x = 1 + i * stepX;
              const y = svgH - 1 - ((v - min) / (max - min)) * (svgH - 2);
              return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');
            qPoly.setAttribute('points', pts);
            const last = qSeries[qSeries.length-1] ?? 0;
            qTitle.textContent = `queue latest=${last} samples=${qSeries.length}`;
            qPoly.classList.toggle('spark-bad', last > 2000);
            qPoly.classList.toggle('spark-warn', last > 500 && last <= 2000);
            qPoly.classList.toggle('spark-ok', last <= 500);
          })();
          mErrs.textContent = `errors: ${p.errors||0}`;
          // robots/sitemap badges
          if (typeof p.robotsLoaded === 'boolean') {
            badgeRobots.textContent = 'robots: ' + (p.robotsLoaded ? 'ok' : 'none');
          }
          if (typeof p.sitemapCount === 'number' || typeof p.sitemapEnqueued === 'number') {
            const c = p.sitemapCount || 0;
            const enq = p.sitemapEnqueued || 0;
            badgeSitemap.textContent = `sitemap: ${enq} / ${c}`;
          }
          // Domain RPM, limit, and backoff
          if (p && (p.domainRpm != null || p.domainLimit != null || p.domainBackoffMs != null || p.domainRateLimited != null)) {
            if (p.domainRpm != null) {
              mDomRpm.style.display = '';
              mDomRpm.textContent = `domain rpm: ${p.domainRpm}`;
            }
            if (p.domainLimit != null) {
              mDomLim.style.display = '';
              const iv = (p.domainIntervalMs!=null)? ` (~${p.domainIntervalMs}ms)` : '';
              mDomLim.textContent = `limit: ${p.domainLimit}/min${iv}`;
              mDomLim.title = `limit per minute: ${p.domainLimit}${iv?`\ninterval: ~${p.domainIntervalMs}ms`:''}`;
            }
            if (p.domainBackoffMs != null) {
              mDomBk.style.display = '';
              const secs = Math.ceil((p.domainBackoffMs||0)/1000);
              mDomBk.textContent = secs > 0 ? `backoff: ${secs}s` : 'backoff: -';
              mDomBk.title = secs > 0 ? `backoff remaining: ~${secs}s` : '';
            }
            if (p.domainRateLimited != null) {
              const on = !!p.domainRateLimited;
              mDomRl.style.display = on ? '' : 'none';
              if (on) mDomRl.title = 'Domain pacing/backoff active';
            }
          }
          // Track rolling traffic for cache gauge and bandwidth
          const prev = window.__lastProgress || { t: now, visited: 0, downloaded: 0, errors: 0, bytes: 0 };
          const dt2 = Math.max(0.001, (now - prev.t) / 1000);
          const dvTot = (p.visited||0) - (prev.visited||0);
          const dNet = Math.max(0, (p.downloaded||0) - (prev.downloaded||0));
          const dCache = Math.max(0, dvTot - dNet);
          const dBytes = Math.max(0, (p.bytes||0) - (prev.bytes||0));
          trafficSamples.push({ t: now, net: dNet, cache: dCache, bytes: dBytes });
          const prune = (ms) => { const cut = now - ms; return trafficSamples.filter(s => s.t >= cut); };
          trafficSamples = prune(5*60*1000);
          const sumWindow = (ms) => {
            const cut = now - ms; let n=0,c=0; for (const s of trafficSamples) { if (s.t >= cut) { n+=s.net; c+=s.cache; } }
            const tot = n + c; return { ratio: tot>0 ? (c/tot) : 0 };
          };
          const r1 = sumWindow(60*1000).ratio; const r5 = sumWindow(5*60*1000).ratio;
          cacheGauge.textContent = `cache: 1m ${(r1*100).toFixed(0)}% · 5m ${(r5*100).toFixed(0)}%`;
          // Update dl/s and sparkline using a helper so we can also refresh on a timer
          window.__lastProgress = { t: now, visited: p.visited||0, downloaded: p.downloaded||0, errors: p.errors||0, bytes: p.bytes||0 };
          updateDlpsUi(now, p.queueSize||0);
        } catch (_) {}
      });

      // Optional: poll /metrics and colorize gauges
      async function refreshServerMetrics() {
        try {
          const r = await fetch('/metrics');
          if (!r.ok) return;
          const text = await r.text();
          const map = {};
          for (const line of text.split(/\n+/)) {
            const m = line.match(/^(crawler_[a-z_]+)\s+([0-9.]+)/);
            if (m) map[m[1]] = parseFloat(m[2]);
          }
          const reqps = map['crawler_requests_per_second'] ?? null;
          const dlps = map['crawler_downloads_per_second'] ?? null;
          const errpm = map['crawler_error_rate_per_min'] ?? null;
          const qsize = map['crawler_queue_size'] ?? null;
          const errs = map['crawler_errors_total'] ?? null;
          if (reqps != null) mReqpsLabel.textContent = `req/s: ${reqps.toFixed(2)}`;
          // Update sparkline with a rolling buffer of req/s
          window.__reqps_series = window.__reqps_series || [];
          if (reqps != null) {
            const series = window.__reqps_series;
            series.push(Math.max(0, reqps));
            if (series.length > 70) series.shift(); // ~70 samples
            // draw
            const svgW = 200, svgH = 36;
            const min = 0;
            const max = Math.max(1, Math.max(...series));
            const n = series.length;
            const stepX = n > 1 ? (svgW - 2) / (n - 1) : 0;
            const pts = series.map((v, i) => {
              const x = 1 + i * stepX;
              const y = svgH - 1 - ((v - min) / (max - min)) * (svgH - 2);
              return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');
            document.getElementById('reqps_poly').setAttribute('points', pts);
            const last = series[series.length-1] ?? 0;
            document.getElementById('reqps_title').textContent = `req/s latest=${last.toFixed(2)} samples=${series.length}`;
            const rp = document.getElementById('reqps_poly');
            rp.classList.toggle('spark-bad', last < 0.1);
            rp.classList.toggle('spark-warn', last >= 0.1 && last < 0.5);
            rp.classList.toggle('spark-ok', last >= 0.5);
          }
          // Do not override smoothed dl/s label here; the progress handler maintains both label and sparkline
          if (errpm != null) mErrpm.textContent = `err/min: ${errpm.toFixed(2)}`;
          if (qsize != null) mQsize.firstChild.nodeValue = `queue: ${qsize}`;
          if (errs != null) mErrs.textContent = `errors: ${errs}`;
          // color rules
          mErrpm.classList.toggle('warn', (errpm ?? 0) > 1 && (errpm ?? 0) <= 5);
          mErrpm.classList.toggle('bad', (errpm ?? 0) > 5);
          mQsize.classList.toggle('warn', (qsize ?? 0) > 500 && (qsize ?? 0) <= 2000);
          mQsize.classList.toggle('bad', (qsize ?? 0) > 2000);
        } catch (_) {}
      }
      setInterval(refreshServerMetrics, 2000);

      // Recompute dl/s and ETA periodically so it decays during idle periods
      function updateDlpsUi(nowTs, qsize) {
        try {
          const now = nowTs || Date.now();
          const sumWindowNet = (ms) => { const cut = now - ms; let n=0; for (const s of trafficSamples) { if (s.t >= cut) { n+=s.net; } } return n; };
          const sumWindowBytes = (ms) => { const cut = now - ms; let b=0; for (const s of trafficSamples) { if (s.t >= cut) { b+= (s.bytes||0); } } return b; };
          const firstSampleTime = trafficSamples.length ? trafficSamples[0].t : now;
          const winSec = Math.max(0.001, Math.min(15, (now - firstSampleTime)/1000));
          const dlps = sumWindowNet(winSec*1000) / winSec;
          const mbs = (sumWindowBytes(winSec*1000) / winSec) / (1024*1024);
          const q = Math.max(0, qsize || (window.__lastProgress ? (window.__lastProgress.queueSize || 0) : 0));
          if (dlps > 0 && q > 0) {
            const secs = Math.round(q / dlps);
            const mins = Math.floor(secs/60), s = secs % 60;
            etaEl.textContent = `ETA ~ ${mins}m ${s}s`;
          } else {
            etaEl.textContent = '';
          }
          mDlpsLabel.textContent = `dl/s (≤15s avg): ${dlps.toFixed(2)} · MB/s (≤15s avg): ${mbs.toFixed(2)}`;
          // Keep sparkline moving by sampling current dlps
          window.__dlps_series = window.__dlps_series || [];
          const series = window.__dlps_series;
          series.push(Math.max(0, dlps));
          if (series.length > 70) series.shift();
          const svgW = 200, svgH = 36;
          const min = 0;
          const max = Math.max(1, Math.max(...series));
          const n = series.length;
          const stepX = n > 1 ? (svgW - 2) / (n - 1) : 0;
          const pts = series.map((v, i) => {
            const x = 1 + i * stepX;
            const y = svgH - 1 - ((v - min) / (max - min)) * (svgH - 2);
            return `${x.toFixed(1)},${y.toFixed(1)}`;
          }).join(' ');
          document.getElementById('dlps_poly').setAttribute('points', pts);
          const last = series[series.length-1] ?? 0;
          document.getElementById('dlps_title').textContent = `dl/s (≤15s avg) latest=${last.toFixed(2)} samples=${series.length}`;
          const dp = document.getElementById('dlps_poly');
          dp.classList.toggle('spark-bad', last < 0.1);
          dp.classList.toggle('spark-warn', last >= 0.1 && last < 0.5);
          dp.classList.toggle('spark-ok', last >= 0.5);
        } catch(_) {}
      }
      setInterval(() => updateDlpsUi(Date.now()), 1000);
      // Load recent domains for navigation
      (async function loadDomains(){
        try {
          const r = await fetch('/api/recent-domains?limit=20');
          if (!r.ok) {
            let reason = `HTTP ${r.status}`;
            try { const j = await r.json(); if (j && j.error) reason = j.error; } catch(_) {}
            domains.textContent = 'Failed to load (' + reason + ')';
            return;
          }
          const j = await r.json();
          if (!Array.isArray(j.domains) || j.domains.length === 0) { domains.textContent = 'No recent domains.'; return; }
          domains.innerHTML = j.domains.map(d => {
            const h = d.host;
            const url = `/domain?host=${encodeURIComponent(h)}`;
            return `<a href="${url}">${h}</a> <span class="muted">(${d.article_count} articles)</span>`;
          }).join(' · ');
        } catch (e) { domains.textContent = 'Failed to load (network)'; }
      })();
      // Load recent errors panel
      (async function loadErrors(){
        try {
          const r = await fetch('/api/recent-errors');
          if (!r.ok) return;
          const j = await r.json();
          const el = document.getElementById('errorsList');
          if (!Array.isArray(j.errors) || j.errors.length === 0) { el.textContent = 'No recent errors.'; return; }
          el.innerHTML = j.errors.map(e => {
            const host = e.host || '(unknown)';
            const link = `/urls?host=${encodeURIComponent(host)}&status=${encodeURIComponent(e.status)}&dir=desc&details=1`;
            const items = (e.examples||[]).map(x => `<a href="/url?url=${encodeURIComponent(x.url)}">example</a>`).join(' · ');
            return `<div><a href="${link}"><span class="muted">${e.status}</span> ${host}</a> — ${e.count} ${items ? '· ' + items : ''}</div>`;
          }).join('');
        } catch {}
      })();
        es.addEventListener('done', (e) => {
        try {
          const key = `done:${e.data}`;
          if (!window.__seenDone) window.__seenDone = new Set();
          if (window.__seenDone.has(key)) return;
          window.__seenDone.add(key);
        } catch(_) {}
        logs.textContent += `\nDONE: ${e.data}\n`;
      });
        es.addEventListener('cache', (e) => {
        try {
          const c = JSON.parse(e.data);
          cacheHits += 1;
          const src = c.source || 'cache';
          const age = typeof c.ageSeconds === 'number' ? `${c.ageSeconds}s` : 'unknown';
          document.getElementById('cacheInfo').textContent = `cached hits: ${cacheHits} (last from ${src}, age ${age})`;
          // Also surface cache activity in the Logs panel so users see immediate action
          try {
            const url = c.url || '';
            const line = `CACHE hit (${src}, age ${age}) ${url}\n`;
            // reuse log buffer batching
            logEntries.push({ text: line, isErr: false });
            scheduleFlush();
          } catch (_) {}
        } catch (_) {}
      });
      }

      function openEventStream(withLogs) {
        if (evt) try { evt.close(); } catch (_) {}
        evt = new EventSource(`/events?logs=${withLogs ? '1' : '0'}`);
        attachHandlers(evt);
      }

  // Initialize logs toggle from localStorage (default ON if unset)
  (function initLogsToggle(){
    const pref = localStorage.getItem('showLogs');
    const enabled = (pref == null) ? true : (pref === '1');
    if (pref == null) localStorage.setItem('showLogs', '1');
    document.getElementById('showLogs').checked = enabled;
    if (!enabled) logs.textContent = 'Logs are disabled. Enable "Show logs" to stream stdout/stderr here.';
    openEventStream(enabled);
  })();
  // Persist key controls
  (function persistControls(){
  const ids = ['startUrl','depth','maxPages','refetchIfOlderThan','concurrency','requestTimeoutMs','pacerJitterMinMs','pacerJitterMaxMs','slowMode','useSitemap','sitemapOnly'];
    for (const id of ids) {
      const el = document.getElementById(id);
      if (!el) continue;
      const key = `ctrl_${id}`;
      const val = localStorage.getItem(key);
      if (val != null) {
        if (el.type === 'checkbox') el.checked = val === '1';
        else el.value = val;
      }
      el.addEventListener('change', () => {
        localStorage.setItem(key, el.type === 'checkbox' ? (el.checked ? '1' : '0') : el.value);
        // Enforce sitemap-only implies useSitemap
        if (id === 'sitemapOnly') {
          const useEl = document.getElementById('useSitemap');
          if (el.checked) {
            useEl.checked = true;
            useEl.disabled = true;
            localStorage.setItem('ctrl_useSitemap', '1');
          } else {
            useEl.disabled = false;
          }
        }
      });
      el.addEventListener('input', () => {
        if (el.type !== 'checkbox') localStorage.setItem(key, el.value);
      });
    }
    // Apply initial disable state on load
    try {
      const so = document.getElementById('sitemapOnly');
      const useEl = document.getElementById('useSitemap');
      if (so && useEl && so.checked) { useEl.checked = true; useEl.disabled = true; }
    } catch (_) {}
  })();
      document.getElementById('startBtn').onclick = async () => {
        const body = {
          startUrl: document.getElementById('startUrl').value,
          depth: parseInt(document.getElementById('depth').value, 10),
          maxPages: document.getElementById('maxPages').value ? parseInt(document.getElementById('maxPages').value, 10) : undefined,
          refetchIfOlderThan: document.getElementById('refetchIfOlderThan').value || undefined,
          concurrency: parseInt(document.getElementById('concurrency').value, 10),
          slow: document.getElementById('slowMode').checked,
          requestTimeoutMs: document.getElementById('requestTimeoutMs').value ? parseInt(document.getElementById('requestTimeoutMs').value, 10) : undefined,
          pacerJitterMinMs: document.getElementById('pacerJitterMinMs').value ? parseInt(document.getElementById('pacerJitterMinMs').value, 10) : undefined,
          pacerJitterMaxMs: document.getElementById('pacerJitterMaxMs').value ? parseInt(document.getElementById('pacerJitterMaxMs').value, 10) : undefined,
  // Enforce: if sitemapOnly is checked, useSitemap must be true
  useSitemap: (function(){ const u = document.getElementById('useSitemap'); const so = document.getElementById('sitemapOnly'); return so.checked ? true : u.checked; })(),
  sitemapOnly: document.getElementById('sitemapOnly').checked,
  // sitemapMaxUrls removed: we cap sitemap by maxPages server-side
        };
        const btn = document.getElementById('startBtn');
        const prevLabel = btn.textContent;
        btn.disabled = true; btn.textContent = 'Starting…';
        try {
          const r = await fetch('/api/crawl', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          let payload = null;
          try { payload = await r.json(); } catch (_) { /* ignore */ }
          if (!r.ok) {
            const detail = payload?.error || `HTTP ${r.status}`;
            logs.textContent += `\nStart failed: ${detail}\n`;
          } else {
            logs.textContent += `\nStarted: ${JSON.stringify(payload)}\n`;
          }
        } catch (e) {
          logs.textContent += `\nStart error: ${e?.message || e}\n`;
        } finally {
          btn.disabled = false; btn.textContent = prevLabel;
        }
      };
      document.getElementById('stopBtn').onclick = async () => {
        try {
          const r = await fetch('/api/stop', { method: 'POST' });
          let j = null; try { j = await r.json(); } catch (_) {}
          if (!r.ok) logs.textContent += `\nStop failed: HTTP ${r.status}\n`;
          else logs.textContent += `\nStop requested: ${JSON.stringify(j)}\n`;
        } catch (e) {
          logs.textContent += `\nStop error: ${e?.message || e}\n`;
        }
      };
      pauseBtn.onclick = async () => {
        try {
          const r = await fetch('/api/pause', { method: 'POST' });
          let j = null; try { j = await r.json(); } catch (_) {}
          if (!r.ok) logs.textContent += `\nPause failed: HTTP ${r.status}\n`;
          else {
            logs.textContent += `\nPause requested: ${JSON.stringify(j)}\n`;
            if (j && (j.paused === true || j.ok === true)) { pauseBtn.disabled = true; resumeBtn.disabled = false; }
          }
        } catch (e) { logs.textContent += `\nPause error: ${e?.message || e}\n`; }
      };
      resumeBtn.onclick = async () => {
        try {
          const r = await fetch('/api/resume', { method: 'POST' });
          let j = null; try { j = await r.json(); } catch (_) {}
          if (!r.ok) logs.textContent += `\nResume failed: HTTP ${r.status}\n`;
          else {
            logs.textContent += `\nResume requested: ${JSON.stringify(j)}\n`;
            if (j && (j.paused === false || j.ok === true)) { pauseBtn.disabled = false; resumeBtn.disabled = true; }
          }
        } catch (e) { logs.textContent += `\nResume error: ${e?.message || e}\n`; }
      };
      document.getElementById('showLogs').onchange = (e) => {
        const enabled = e.target.checked;
        localStorage.setItem('showLogs', enabled ? '1' : '0');
        if (!enabled) logs.textContent = 'Logs are disabled. Enable "Show logs" to stream stdout/stderr here.';
        else logs.textContent = '';
        openEventStream(enabled);
      };

      // Persist open/closed state of collapsible panels
      (function persistPanels(){
        const pairs = [ ['secErrors', secErrors], ['secDomains', secDomains], ['secLogs', secLogs] ];
        for (const [key, el] of pairs) {
          const v = localStorage.getItem(key);
          if (v === '0') el.open = false;
          el.addEventListener('toggle', () => {
            localStorage.setItem(key, el.open ? '1' : '0');
          });
        }
      })();

      // Theme toggle persisted
      (function initTheme(){
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') document.documentElement.classList.add('dark');
        themeBtn.addEventListener('click', () => {
          document.documentElement.classList.toggle('dark');
          const isDark = document.documentElement.classList.contains('dark');
          localStorage.setItem('theme', isDark ? 'dark' : 'light');
        });
      })();

      // Health strip: sizes
      (async function loadHealth(){
        try {
          const r = await fetch('/api/system-health');
          if (r.ok) {
            const j = await r.json();
            const fmt = (b)=> b==null? 'n/a' : (b >= 1073741824 ? (b/1073741824).toFixed(2)+' GB' : (b/1048576).toFixed(1)+' MB');
            badgeDb.textContent = 'db: ' + fmt(j.dbSizeBytes);
            badgeDisk.textContent = 'disk: ' + fmt(j.freeDiskBytes);
            if (j && j.cpu) {
              const pct = (j.cpu.percent != null) ? j.cpu.percent : (j.cpu.percentOfOneCore != null ? j.cpu.percentOfOneCore : null);
              if (pct != null) badgeCpu.textContent = 'cpu: ' + pct.toFixed(1) + '%';
            }
            if (j && j.memory) {
              badgeMem.textContent = 'mem: ' + fmt(j.memory.rss);
            }
            if (j && (j.walAutocheckpoint != null || j.journalMode != null)) {
              const jm = j.journalMode ? ('jm=' + j.journalMode) : '';
              const wal = (typeof j.walAutocheckpoint === 'number') ? ('auto_cp=' + j.walAutocheckpoint) : '';
              const both = [jm, wal].filter(Boolean).join(' ');
              badgeWal.textContent = both ? ('sqlite: ' + both) : 'sqlite: n/a';
            }
          }
        } catch (_) {}
      })();
    </script>
  </body>
  </html>
