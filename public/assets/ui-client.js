"use strict";
(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // src/ui/client/consoleNoiseFilter.js
  var require_consoleNoiseFilter = __commonJS({
    "src/ui/client/consoleNoiseFilter.js"(exports, module) {
      "use strict";
      var DEFAULT_PATTERNS = Object.freeze([
        "jsgui html-core pre_activate",
        "jsgui html-core activate",
        "&&& no corresponding control",
        "jsgui.def_server_resources",
        "Missing context.map_Controls for type",
        "Data_Model_View_Model_Control pre_activate complete",
        "Data_Model_View_Model_Control this.data.model change"
      ]);
      function isBrowserRuntime() {
        return typeof window !== "undefined" && typeof console !== "undefined";
      }
      function readDisableFlag() {
        if (typeof globalThis === "undefined") return false;
        return globalThis.__COPILOT_DISABLE_CONSOLE_FILTER__ === true;
      }
      function readDebugFlag() {
        if (typeof globalThis === "undefined") return false;
        return globalThis.JSGUI_DEBUG === true || globalThis.__JSGUI_DEBUG__ === true || globalThis.__COPILOT_UI_DEBUG__ === true;
      }
      function shouldSuppress(patterns, args) {
        if (!args || !args.length) return false;
        for (let i = 0; i < args.length; i += 1) {
          const value2 = args[i];
          if (typeof value2 !== "string") continue;
          for (let p = 0; p < patterns.length; p += 1) {
            const pattern = patterns[p];
            if (pattern && value2.includes(pattern)) {
              return true;
            }
          }
        }
        return false;
      }
      function installConsoleNoiseFilter2(options = {}) {
        if (!isBrowserRuntime()) {
          return { installed: false, reason: "not-browser" };
        }
        if (typeof globalThis !== "undefined" && globalThis.__COPILOT_CONSOLE_NOISE_FILTER_INSTALLED__) {
          return { installed: true, alreadyInstalled: true };
        }
        if (readDisableFlag()) {
          return { installed: false, reason: "disabled" };
        }
        if (readDebugFlag()) {
          return { installed: false, reason: "debug" };
        }
        const patterns = Array.isArray(options.patterns) && options.patterns.length ? options.patterns : DEFAULT_PATTERNS;
        const methods = Array.isArray(options.methods) && options.methods.length ? options.methods : ["log", "warn"];
        const originals = {};
        methods.forEach((method) => {
          const fn = console[method];
          if (typeof fn !== "function") return;
          originals[method] = fn.bind(console);
          console[method] = (...args) => {
            if (shouldSuppress(patterns, args)) {
              return;
            }
            return originals[method](...args);
          };
        });
        if (typeof globalThis !== "undefined") {
          globalThis.__COPILOT_CONSOLE_NOISE_FILTER_INSTALLED__ = true;
          globalThis.__COPILOT_CONSOLE_NOISE_FILTER_STATE__ = {
            patterns: patterns.slice(),
            methods: methods.slice()
          };
        }
        return { installed: true, patternsCount: patterns.length, methods };
      }
      module.exports = {
        DEFAULT_PATTERNS,
        installConsoleNoiseFilter: installConsoleNoiseFilter2
      };
    }
  });

  // ../lang-mini/lang-mini.js
  var require_lang_mini = __commonJS({
    "../lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              if (ctu == false) break;
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
              if (ctu === false) break;
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "null": "N",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          }
          first = false;
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        if (arr.some((subArray) => subArray.length === 0)) {
          return [];
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          const mfp_fn_call_shallow_sig = (() => {
            if (!a2 || a2.length === 0) return "";
            let res3 = "";
            for (let i = 0; i < a2.length; i++) {
              if (i > 0) res3 = res3 + ",";
              res3 = res3 + ltf(a2[i]);
            }
            return res3;
          })();
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else if (mfp_fn_call_shallow_sig && inner_map_sig_fns[mfp_fn_call_shallow_sig]) {
              return inner_map_sig_fns[mfp_fn_call_shallow_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else if (t === "date") {
              return new Date(obj2.getTime());
            } else if (t === "regex") {
              return new RegExp(obj2.source, obj2.flags);
            } else if (t === "buffer") {
              if (typeof Buffer !== "undefined" && Buffer.from) {
                return Buffer.from(obj2);
              } else if (obj2 && typeof obj2.slice === "function") {
                return obj2.slice(0);
              } else {
                return obj2;
              }
            } else if (t === "error") {
              const cloned_error = new obj2.constructor(obj2.message);
              cloned_error.name = obj2.name;
              cloned_error.stack = obj2.stack;
              each(obj2, (value2, key2) => {
                if (key2 !== "message" && key2 !== "name" && key2 !== "stack") {
                  cloned_error[key2] = clone(value2);
                }
              });
              return cloned_error;
            } else if (t === "object") {
              const res2 = {};
              each(obj2, (value2, key2) => {
                res2[key2] = clone(value2);
              });
              return res2;
            } else {
              return obj2;
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                } else if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return new ctr(input_array);
          } else if (length) {
            return new ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str, 10);
          if (!isNaN(p2) && p2.toString() === str) {
            return p2;
          }
          return void 0;
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        const t_value = typeof value2;
                        is_valid = data_type.validate(value2);
                        if (t_value === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                        console.log("t_value", t_value);
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    } else {
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var KEYWORD_LITERALS = /* @__PURE__ */ new Set(["true", "false", "null", "undefined"]);
      var KEYWORD_OPERATORS = /* @__PURE__ */ new Set(["typeof", "void", "delete", "in", "instanceof"]);
      var MULTI_CHAR_OPERATORS = [
        "===",
        "!==",
        "==",
        "!=",
        "<=",
        ">=",
        "&&",
        "||",
        "??",
        "++",
        "--",
        "+=",
        "-=",
        "*=",
        "/=",
        "%=",
        "&=",
        "|=",
        "^=",
        "<<",
        ">>",
        ">>>",
        "**"
      ];
      var SINGLE_CHAR_OPERATORS = /* @__PURE__ */ new Set(["+", "-", "*", "/", "%", "=", "!", "<", ">", "&", "|", "^", "~"]);
      var PUNCTUATION_CHARS = /* @__PURE__ */ new Set(["(", ")", "{", "}", "[", "]", ",", ":", "?", "."]);
      var GLOBAL_SCOPE = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var DEFAULT_ALLOWED_GLOBALS = ["Math"];
      var EXPRESSION_PARSER_DEFAULTS = {
        cache: true,
        cacheSize: 64,
        cacheKeyResolver: null,
        maxExpressionLength: 1e4,
        maxMemberDepth: 2,
        helpers: {},
        allowedFunctions: [],
        allowedGlobals: DEFAULT_ALLOWED_GLOBALS,
        allowCall: null,
        strict: false
      };
      var NORMALIZED_OPTIONS_FLAG = /* @__PURE__ */ Symbol("ExpressionParserOptions");
      var DISALLOWED_IDENTIFIERS = /* @__PURE__ */ new Set(["this", "new"]);
      var ExpressionParserError = class extends Error {
        constructor(code, message, details = {}) {
          super(message);
          this.name = "ExpressionParserError";
          this.code = code;
          this.details = details;
        }
      };
      var ExpressionCache = class {
        constructor(limit = 0) {
          this.limit = Math.max(0, limit || 0);
          this.map = /* @__PURE__ */ new Map();
        }
        get(key2) {
          if (!this.limit || !this.map.has(key2)) {
            return void 0;
          }
          const value2 = this.map.get(key2);
          this.map.delete(key2);
          this.map.set(key2, value2);
          return value2;
        }
        set(key2, value2) {
          if (!this.limit) {
            return;
          }
          if (this.map.has(key2)) {
            this.map.delete(key2);
          }
          this.map.set(key2, value2);
          while (this.map.size > this.limit) {
            const oldestKey = this.map.keys().next().value;
            this.map.delete(oldestKey);
          }
        }
        clear() {
          this.map.clear();
        }
        get size() {
          return this.map.size;
        }
      };
      var Tokenizer = class {
        constructor(expression) {
          this.expression = typeof expression === "string" ? expression : String(expression || "");
          this.length = this.expression.length;
          this.position = 0;
          this.line = 1;
          this.column = 1;
        }
        tokenize() {
          const tokens = [];
          if (!this.expression.trim()) {
            return tokens;
          }
          while (!this.isAtEnd()) {
            this.skipWhitespace();
            if (this.isAtEnd()) break;
            const ch = this.peek();
            if (this.isIdentifierStart(ch)) {
              tokens.push(this.tokenizeIdentifier());
            } else if (this.isDigit(ch) || ch === "." && this.isDigit(this.peek(1))) {
              tokens.push(this.tokenizeNumber());
            } else if (ch === '"' || ch === "'") {
              tokens.push(this.tokenizeString());
            } else if (this.isOperatorStart(ch)) {
              tokens.push(this.tokenizeOperator());
            } else if (PUNCTUATION_CHARS.has(ch)) {
              tokens.push(this.tokenizePunctuation());
            } else {
              this.throwError("TOKEN_INVALID_CHAR", `Unexpected character: ${ch}`);
            }
          }
          return tokens;
        }
        isAtEnd() {
          return this.position >= this.length;
        }
        skipWhitespace() {
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (/\s/.test(ch)) {
              this.advance();
              continue;
            }
            if (ch === "/" && this.peek(1) === "/") {
              while (!this.isAtEnd() && this.peek() !== "\n") {
                this.advance();
              }
              continue;
            }
            if (ch === "/" && this.peek(1) === "*") {
              this.advance();
              this.advance();
              while (!this.isAtEnd()) {
                if (this.peek() === "*" && this.peek(1) === "/") {
                  this.advance();
                  this.advance();
                  break;
                }
                this.advance();
              }
              continue;
            }
            break;
          }
        }
        peek(offset2 = 0) {
          if (this.position + offset2 >= this.length) return "\0";
          return this.expression[this.position + offset2];
        }
        advance() {
          if (this.isAtEnd()) {
            return "\0";
          }
          const char = this.expression[this.position++];
          if (char === "\n") {
            this.line += 1;
            this.column = 1;
          } else {
            this.column += 1;
          }
          return char;
        }
        getLocationSnapshot() {
          return { index: this.position, line: this.line, column: this.column };
        }
        createToken(type, value2, start, end) {
          return { type, value: value2, start, end };
        }
        throwError(code, message) {
          throw new ExpressionParserError(code, message, { location: this.getLocationSnapshot() });
        }
        isIdentifierStart(ch) {
          return /[A-Za-z_$]/.test(ch);
        }
        isIdentifierPart(ch) {
          return /[A-Za-z0-9_$]/.test(ch);
        }
        isDigit(ch) {
          return /[0-9]/.test(ch);
        }
        isOperatorStart(ch) {
          if (ch === "." && this.peek(1) === "." && this.peek(2) === ".") {
            this.throwError("SYNTAX_UNSUPPORTED", "Spread syntax is not supported");
          }
          if (ch === "?" && this.peek(1) === "?") {
            return true;
          }
          return SINGLE_CHAR_OPERATORS.has(ch);
        }
        tokenizeIdentifier() {
          const start = this.getLocationSnapshot();
          let value2 = "";
          while (!this.isAtEnd() && this.isIdentifierPart(this.peek())) {
            value2 += this.advance();
          }
          const end = this.getLocationSnapshot();
          if (KEYWORD_LITERALS.has(value2)) {
            return this.createToken("KEYWORD", value2, start, end);
          }
          if (KEYWORD_OPERATORS.has(value2)) {
            return this.createToken("OPERATOR", value2, start, end);
          }
          return this.createToken("IDENTIFIER", value2, start, end);
        }
        tokenizeNumber() {
          const start = this.getLocationSnapshot();
          let value2 = "";
          let hasDot = false;
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (this.isDigit(ch)) {
              value2 += this.advance();
            } else if (ch === "." && !hasDot) {
              hasDot = true;
              value2 += this.advance();
            } else {
              break;
            }
          }
          const end = this.getLocationSnapshot();
          return this.createToken("NUMBER", Number(value2), start, end);
        }
        tokenizeString() {
          const quote = this.advance();
          const start = this.getLocationSnapshot();
          let value2 = "";
          while (!this.isAtEnd()) {
            const ch = this.advance();
            if (ch === quote) {
              return this.createToken("STRING", value2, start, this.getLocationSnapshot());
            }
            if (ch === "\\") {
              const next = this.advance();
              switch (next) {
                case "n":
                  value2 += "\n";
                  break;
                case "r":
                  value2 += "\r";
                  break;
                case "t":
                  value2 += "	";
                  break;
                case "\\":
                  value2 += "\\";
                  break;
                case '"':
                  value2 += '"';
                  break;
                case "'":
                  value2 += "'";
                  break;
                default:
                  value2 += next;
              }
            } else {
              value2 += ch;
            }
          }
          this.throwError("TOKEN_UNTERMINATED_STRING", "Unterminated string literal");
        }
        tokenizeOperator() {
          const remaining = this.expression.slice(this.position);
          const start = this.getLocationSnapshot();
          for (const op of MULTI_CHAR_OPERATORS) {
            if (remaining.startsWith(op)) {
              if (op === "=>") {
                this.throwError("SYNTAX_UNSUPPORTED", "Arrow functions are not supported");
              }
              this.position += op.length;
              this.column += op.length;
              return this.createToken("OPERATOR", op, start, this.getLocationSnapshot());
            }
          }
          const ch = this.advance();
          if (ch === "=" && this.peek() === ">") {
            this.throwError("SYNTAX_UNSUPPORTED", "Arrow functions are not supported");
          }
          if (!SINGLE_CHAR_OPERATORS.has(ch) && ch !== "?") {
            this.throwError("TOKEN_UNEXPECTED_OPERATOR", "Unexpected operator");
          }
          return this.createToken("OPERATOR", ch, start, this.getLocationSnapshot());
        }
        tokenizePunctuation() {
          const start = this.getLocationSnapshot();
          const ch = this.advance();
          if (ch === "." && this.peek() === "." && this.peek(1) === ".") {
            this.throwError("SYNTAX_UNSUPPORTED", "Spread syntax is not supported");
          }
          return this.createToken("PUNCTUATION", ch, start, this.getLocationSnapshot());
        }
      };
      var Parser = class {
        constructor(tokens, options = {}) {
          this.tokens = tokens;
          this.pos = 0;
          this.maxMemberDepth = options.maxMemberDepth || EXPRESSION_PARSER_DEFAULTS.maxMemberDepth;
          const disallowed = new Set(DISALLOWED_IDENTIFIERS);
          if (options.disallowedIdentifiers) {
            options.disallowedIdentifiers.forEach((identifier) => disallowed.add(identifier));
          }
          this.disallowedIdentifiers = disallowed;
        }
        parse() {
          if (!this.tokens.length) {
            throw new ExpressionParserError("EMPTY_EXPRESSION", "Empty expression");
          }
          const ast = this.parseExpression();
          if (!this.isAtEnd()) {
            this.error("UNEXPECTED_TOKEN", `Unexpected token: ${this.peek().value}`, this.peek());
          }
          return ast;
        }
        parseExpression() {
          return this.parseConditionalExpression();
        }
        parseConditionalExpression() {
          let expr = this.parseLogicalOrExpression();
          if (this.matchPunctuation("?")) {
            const consequent = this.parseExpression();
            this.consume("PUNCTUATION", ":");
            const alternate = this.parseExpression();
            expr = {
              type: "ConditionalExpression",
              test: expr,
              consequent,
              alternate
            };
          }
          return expr;
        }
        parseLogicalOrExpression() {
          let expr = this.parseLogicalAndExpression();
          while (this.matchOperator("||")) {
            const operator = this.previous().value;
            const right = this.parseLogicalAndExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseLogicalAndExpression() {
          let expr = this.parseNullishExpression();
          while (this.matchOperator("&&")) {
            const operator = this.previous().value;
            const right = this.parseNullishExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseNullishExpression() {
          let expr = this.parseEqualityExpression();
          while (this.matchOperator("??")) {
            const operator = this.previous().value;
            const right = this.parseEqualityExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseEqualityExpression() {
          let expr = this.parseRelationalExpression();
          while (this.matchOperator("===", "!==", "==", "!=")) {
            const operator = this.previous().value;
            const right = this.parseRelationalExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseRelationalExpression() {
          let expr = this.parseShiftExpression();
          while (this.matchOperator("<", ">", "<=", ">=", "instanceof", "in")) {
            const operator = this.previous().value;
            const right = this.parseShiftExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseShiftExpression() {
          let expr = this.parseAdditiveExpression();
          while (this.matchOperator("<<", ">>", ">>>")) {
            const operator = this.previous().value;
            const right = this.parseAdditiveExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseAdditiveExpression() {
          let expr = this.parseMultiplicativeExpression();
          while (this.matchOperator("+", "-")) {
            const operator = this.previous().value;
            const right = this.parseMultiplicativeExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseMultiplicativeExpression() {
          let expr = this.parseUnaryExpression();
          while (this.matchOperator("*", "/", "%")) {
            const operator = this.previous().value;
            const right = this.parseUnaryExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseUnaryExpression() {
          if (this.matchOperator("+", "-", "!", "~", "typeof", "void", "delete")) {
            const operator = this.previous().value;
            const argument = this.parseUnaryExpression();
            return { type: "UnaryExpression", operator, argument };
          }
          return this.parseLeftHandSideExpression();
        }
        parseLeftHandSideExpression() {
          let expr = this.parsePrimaryExpression();
          while (true) {
            if (this.matchPunctuation(".")) {
              const operatorToken = this.previous();
              const property = this.consumePropertyIdentifier();
              const depth = this.getChainDepth(expr) + 1;
              this.assertMemberDepth(depth, operatorToken);
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: false
              };
              this.setChainDepth(expr, depth);
            } else if (this.matchPunctuation("[")) {
              const operatorToken = this.previous();
              const property = this.parseExpression();
              this.consume("PUNCTUATION", "]");
              const depth = this.getChainDepth(expr) + 1;
              this.assertMemberDepth(depth, operatorToken);
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: true
              };
              this.setChainDepth(expr, depth);
            } else if (this.matchPunctuation("(")) {
              const args = this.parseArguments();
              expr = {
                type: "CallExpression",
                callee: expr,
                arguments: args
              };
              this.setChainDepth(expr, this.getChainDepth(expr.callee));
            } else {
              break;
            }
          }
          return expr;
        }
        parsePrimaryExpression() {
          const token = this.peek();
          if (!token) {
            this.error("UNEXPECTED_END", "Unexpected end of expression", token);
          }
          if (token.type === "NUMBER" || token.type === "STRING") {
            this.advance();
            return { type: "Literal", value: token.value };
          }
          if (token.type === "KEYWORD") {
            this.advance();
            return { type: "Literal", value: this.literalFromKeyword(token.value) };
          }
          if (token.type === "IDENTIFIER") {
            this.advance();
            this.assertIdentifierAllowed(token);
            return { type: "Identifier", value: token.value };
          }
          if (this.matchPunctuation("(")) {
            const expr = this.parseExpression();
            this.consume("PUNCTUATION", ")");
            return expr;
          }
          if (this.matchPunctuation("[")) {
            const elements = [];
            if (!this.check("PUNCTUATION", "]")) {
              do {
                elements.push(this.parseExpression());
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "]");
            return { type: "ArrayExpression", elements };
          }
          if (this.matchPunctuation("{")) {
            const properties = [];
            if (!this.check("PUNCTUATION", "}")) {
              do {
                const key2 = this.parsePropertyKey();
                this.consume("PUNCTUATION", ":");
                const value2 = this.parseExpression();
                properties.push({ key: key2, value: value2 });
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "}");
            return { type: "ObjectExpression", properties };
          }
          this.error("UNEXPECTED_TOKEN", `Unexpected token: ${token.value}`, token);
        }
        parsePropertyKey() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          this.error("INVALID_OBJECT_KEY", "Invalid object property key", token);
        }
        parseArguments() {
          const args = [];
          if (!this.check("PUNCTUATION", ")")) {
            do {
              args.push(this.parseExpression());
            } while (this.matchPunctuation(","));
          }
          this.consume("PUNCTUATION", ")");
          return args;
        }
        literalFromKeyword(value2) {
          switch (value2) {
            case "true":
              return true;
            case "false":
              return false;
            case "null":
              return null;
            case "undefined":
              return void 0;
            default:
              return value2;
          }
        }
        consume(type, value2) {
          if (this.check(type, value2)) {
            return this.advance();
          }
          const expected = value2 ? `${type} '${value2}'` : type;
          this.error("MISSING_TOKEN", `Expected ${expected}`, this.peek());
        }
        check(type, value2) {
          if (this.isAtEnd()) return false;
          const token = this.peek();
          if (token.type !== type) return false;
          if (typeof value2 === "undefined") return true;
          return token.value === value2;
        }
        matchOperator(...operators) {
          if (this.check("OPERATOR") && operators.includes(this.peek().value)) {
            this.advance();
            return true;
          }
          return false;
        }
        matchPunctuation(value2) {
          if (this.check("PUNCTUATION", value2)) {
            this.advance();
            return true;
          }
          return false;
        }
        consumePropertyIdentifier() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          this.error("INVALID_PROPERTY", "Expected property name", token);
        }
        buildBinaryExpression(operator, left, right) {
          return { type: "BinaryExpression", operator, left, right };
        }
        buildLogicalExpression(operator, left, right) {
          return { type: "LogicalExpression", operator, left, right };
        }
        getChainDepth(node) {
          if (!node || typeof node !== "object") {
            return 0;
          }
          return node.__chainDepth || 0;
        }
        setChainDepth(node, depth) {
          if (!node || typeof node !== "object") {
            return;
          }
          Object.defineProperty(node, "__chainDepth", {
            value: depth,
            enumerable: false,
            configurable: true
          });
        }
        assertMemberDepth(depth, token) {
          if (depth > this.maxMemberDepth) {
            this.error("MEMBER_DEPTH_EXCEEDED", `Member access depth ${depth} exceeds maximum of ${this.maxMemberDepth}`, token);
          }
        }
        assertIdentifierAllowed(token) {
          if (this.disallowedIdentifiers.has(token.value)) {
            this.error("DISALLOWED_IDENTIFIER", `Identifier '${token.value}' is not allowed in expressions`, token);
          }
        }
        error(code, message, token) {
          throw new ExpressionParserError(code, message, token ? { location: token.start } : void 0);
        }
        advance() {
          if (!this.isAtEnd()) {
            this.pos += 1;
          }
          return this.tokens[this.pos - 1];
        }
        peek() {
          if (this.isAtEnd()) return null;
          return this.tokens[this.pos];
        }
        previous() {
          return this.tokens[this.pos - 1];
        }
        isAtEnd() {
          return this.pos >= this.tokens.length;
        }
      };
      var Evaluator = class {
        constructor(context2 = {}, options = {}) {
          this.context = context2 || {};
          this.helpers = options.helpers || {};
          this.strict = options.strict || false;
          this.allowCall = options.allowCall || null;
          this.allowedFunctions = new Set(options.allowedFunctions || []);
          this.allowedGlobals = new Set(options.allowedGlobals || []);
          Object.values(this.helpers).forEach((value2) => {
            if (typeof value2 === "function") {
              this.allowedFunctions.add(value2);
            }
          });
        }
        evaluate(node) {
          switch (node.type) {
            case "Literal":
              return node.value;
            case "Identifier":
              return this.evaluateIdentifier(node);
            case "MemberExpression":
              return this.evaluateMemberExpression(node);
            case "CallExpression":
              return this.evaluateCallExpression(node);
            case "UnaryExpression":
              return this.evaluateUnaryExpression(node);
            case "BinaryExpression":
              return this.evaluateBinaryExpression(node);
            case "LogicalExpression":
              return this.evaluateLogicalExpression(node);
            case "ArrayExpression":
              return node.elements.map((element) => this.evaluate(element));
            case "ObjectExpression":
              return this.evaluateObjectExpression(node);
            case "ConditionalExpression":
              return this.evaluateConditionalExpression(node);
            default:
              throw new ExpressionParserError("UNSUPPORTED_NODE", `Unsupported AST node type: ${node.type}`);
          }
        }
        evaluateIdentifier(node) {
          const name = node.value;
          if (Object.prototype.hasOwnProperty.call(this.helpers, name)) {
            return this.helpers[name];
          }
          if (this.context && Object.prototype.hasOwnProperty.call(this.context, name)) {
            return this.context[name];
          }
          if (this.allowedGlobals.has(name) && name in GLOBAL_SCOPE) {
            return GLOBAL_SCOPE[name];
          }
          if (this.strict) {
            throw new ExpressionParserError("UNDEFINED_IDENTIFIER", `Undefined identifier: ${name}`);
          }
          console.error(`Undefined identifier: ${name}`);
          return void 0;
        }
        evaluateMemberExpression(node) {
          const object = this.evaluate(node.object);
          if (object === null || object === void 0) {
            throw new ExpressionParserError("NULL_MEMBER_ACCESS", "Cannot read property of null or undefined");
          }
          const property = node.computed ? this.evaluate(node.property) : node.property.type === "Identifier" ? node.property.value : node.property.value;
          return object[property];
        }
        evaluateCallExpression(node) {
          let callee;
          let thisArg;
          if (node.callee.type === "MemberExpression") {
            const object = this.evaluate(node.callee.object);
            if (object === null || object === void 0) {
              throw new ExpressionParserError("NULL_MEMBER_CALL", "Cannot call property of null or undefined");
            }
            const property = node.callee.computed ? this.evaluate(node.callee.property) : node.callee.property.type === "Identifier" ? node.callee.property.value : node.callee.property.value;
            callee = object[property];
            thisArg = object;
          } else {
            callee = this.evaluate(node.callee);
            thisArg = void 0;
          }
          if (typeof callee !== "function") {
            throw new ExpressionParserError("CALL_NON_FUNCTION", "Attempted to call a non-function");
          }
          if (!this.isCallAllowed(callee, thisArg)) {
            throw new ExpressionParserError("CALL_NOT_ALLOWED", "Function call not allowed by policy");
          }
          const args = node.arguments.map((arg) => this.evaluate(arg));
          return callee.apply(thisArg, args);
        }
        isCallAllowed(fn, thisArg) {
          if (this.allowCall) {
            const decision = this.allowCall(fn, thisArg);
            if (decision === true) return true;
            if (decision === false) return false;
          }
          return this.allowedFunctions.has(fn);
        }
        evaluateUnaryExpression(node) {
          let argumentValue;
          if (node.operator === "delete") {
            argumentValue = node.argument;
          } else if (node.operator === "typeof" && node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
            argumentValue = void 0;
          } else {
            argumentValue = this.evaluate(node.argument);
          }
          switch (node.operator) {
            case "+":
              return +argumentValue;
            case "-":
              return -argumentValue;
            case "!":
              return !argumentValue;
            case "~":
              return ~argumentValue;
            case "typeof":
              if (node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
                return "undefined";
              }
              return typeof argumentValue;
            case "void":
              return void argumentValue;
            case "delete":
              return this.performDelete(node.argument);
            default:
              throw new ExpressionParserError("UNSUPPORTED_UNARY", `Unsupported unary operator: ${node.operator}`);
          }
        }
        isIdentifierDefined(name) {
          return Object.prototype.hasOwnProperty.call(this.helpers, name) || this.context && Object.prototype.hasOwnProperty.call(this.context, name) || this.allowedGlobals.has(name) && name in GLOBAL_SCOPE;
        }
        performDelete(argument) {
          if (argument.type === "Identifier" && this.context && typeof this.context === "object") {
            return delete this.context[argument.value];
          }
          if (argument.type === "MemberExpression") {
            const target = this.evaluate(argument.object);
            if (target === null || target === void 0) {
              return true;
            }
            const property = argument.computed ? this.evaluate(argument.property) : argument.property.type === "Identifier" ? argument.property.value : argument.property.value;
            return delete target[property];
          }
          this.evaluate(argument);
          return true;
        }
        evaluateBinaryExpression(node) {
          const left = this.evaluate(node.left);
          const right = this.evaluate(node.right);
          switch (node.operator) {
            case "+":
              return left + right;
            case "-":
              return left - right;
            case "*":
              return left * right;
            case "/":
              return left / right;
            case "%":
              return left % right;
            case "==":
              return left == right;
            case "!=":
              return left != right;
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "in":
              return left in right;
            case "instanceof":
              return left instanceof right;
            default:
              throw new ExpressionParserError("UNSUPPORTED_BINARY", `Unsupported binary operator: ${node.operator}`);
          }
        }
        evaluateLogicalExpression(node) {
          switch (node.operator) {
            case "&&": {
              const left = this.evaluate(node.left);
              return left ? this.evaluate(node.right) : left;
            }
            case "||": {
              const left = this.evaluate(node.left);
              return left ? left : this.evaluate(node.right);
            }
            case "??": {
              const left = this.evaluate(node.left);
              return left !== null && left !== void 0 ? left : this.evaluate(node.right);
            }
            default:
              throw new ExpressionParserError("UNSUPPORTED_LOGICAL", `Unsupported logical operator: ${node.operator}`);
          }
        }
        evaluateObjectExpression(node) {
          const obj2 = {};
          node.properties.forEach((property) => {
            const key2 = this.evaluatePropertyKey(property.key);
            obj2[key2] = this.evaluate(property.value);
          });
          return obj2;
        }
        evaluatePropertyKey(node) {
          if (node.type === "Identifier") {
            return node.value;
          }
          return node.value;
        }
        evaluateConditionalExpression(node) {
          const test = this.evaluate(node.test);
          return test ? this.evaluate(node.consequent) : this.evaluate(node.alternate);
        }
      };
      var ExpressionParser = class {
        constructor(options = {}) {
          this.options = normalizeOptions(null, options);
          const cacheLimit = this.options.cache !== false ? this.options.cacheSize : 0;
          this.astCache = new ExpressionCache(cacheLimit);
          this.valueCache = new ExpressionCache(cacheLimit);
        }
        tokenize(expression) {
          return new Tokenizer(expression).tokenize();
        }
        parse(expression, overrideOptions) {
          const options = this.ensureNormalizedOptions(overrideOptions);
          this.ensureExpressionLength(expression, options);
          const useCache = this.shouldUseCache(options);
          if (useCache) {
            const cachedAst = this.astCache.get(expression);
            if (cachedAst) {
              return cachedAst;
            }
          }
          const tokens = this.tokenize(expression);
          if (!tokens.length) {
            throw new ExpressionParserError("EMPTY_EXPRESSION", "Empty expression");
          }
          const parser = new Parser(tokens, options);
          const ast = parser.parse();
          Object.defineProperty(ast, "tokens", {
            value: tokens,
            enumerable: false,
            configurable: true
          });
          if (useCache) {
            this.astCache.set(expression, ast);
          }
          return ast;
        }
        evaluate(expression, context2 = {}, overrideOptions = {}) {
          const mergedOptions = this.mergeOptions(overrideOptions);
          const useCache = this.shouldUseCache(mergedOptions);
          if (useCache) {
            const cached = this.getCachedValue(expression, context2, mergedOptions);
            if (cached.hit) {
              return cached.value;
            }
          }
          const ast = this.parse(expression, mergedOptions);
          const evaluator = new Evaluator(context2, mergedOptions);
          const result = evaluator.evaluate(ast);
          if (useCache) {
            this.storeCachedValue(expression, context2, result, mergedOptions);
          }
          return result;
        }
        compile(expression, overrideOptions = {}) {
          const baseOptions = this.mergeOptions(overrideOptions);
          const ast = this.parse(expression, baseOptions);
          return (context2 = {}, runtimeOptions = {}) => {
            const invocationOptions = this.mergeOptions(runtimeOptions, baseOptions);
            const evaluator = new Evaluator(context2, invocationOptions);
            return evaluator.evaluate(ast);
          };
        }
        shouldUseCache(options) {
          return options.cache !== false && options.cacheSize > 0;
        }
        ensureNormalizedOptions(options) {
          if (options && options[NORMALIZED_OPTIONS_FLAG]) {
            return options;
          }
          if (!options) {
            return this.options;
          }
          return this.mergeOptions(options);
        }
        ensureExpressionLength(expression, options) {
          if (expression.length > options.maxExpressionLength) {
            throw new ExpressionParserError(
              "EXPRESSION_TOO_LONG",
              `Expression exceeds maximum length of ${options.maxExpressionLength} characters`
            );
          }
        }
        mergeOptions(override = {}, baseOptions) {
          const base = baseOptions && baseOptions[NORMALIZED_OPTIONS_FLAG] ? baseOptions : baseOptions || this.options;
          return normalizeOptions(base, override);
        }
        getCachedValue(expression, context2, options) {
          const bucket = this.valueCache.get(expression);
          if (!bucket) {
            return { hit: false };
          }
          if (this.isObjectLike(context2)) {
            if (bucket.objectCache && bucket.objectCache.has(context2)) {
              return { hit: true, value: bucket.objectCache.get(context2) };
            }
            return { hit: false };
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return { hit: false };
          }
          if (bucket.primitiveCache && bucket.primitiveCache.has(key2)) {
            return { hit: true, value: bucket.primitiveCache.get(key2) };
          }
          return { hit: false };
        }
        storeCachedValue(expression, context2, value2, options) {
          if (!this.shouldUseCache(options)) {
            return;
          }
          let bucket = this.valueCache.get(expression);
          if (!bucket) {
            bucket = { objectCache: /* @__PURE__ */ new WeakMap(), primitiveCache: /* @__PURE__ */ new Map() };
            this.valueCache.set(expression, bucket);
          }
          if (this.isObjectLike(context2)) {
            bucket.objectCache.set(context2, value2);
            return;
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return;
          }
          bucket.primitiveCache.set(key2, value2);
        }
        resolvePrimitiveKey(context2, options) {
          if (options.cacheKeyResolver) {
            return options.cacheKeyResolver(context2);
          }
          return context2;
        }
        isObjectLike(value2) {
          return value2 !== null && (typeof value2 === "object" || typeof value2 === "function");
        }
        getCacheStats() {
          return {
            astEntries: this.astCache.size,
            valueEntries: this.valueCache.size
          };
        }
      };
      function normalizeOptions(baseOptions, overrideOptions = {}) {
        const base = baseOptions && baseOptions[NORMALIZED_OPTIONS_FLAG] ? baseOptions : { ...EXPRESSION_PARSER_DEFAULTS, ...baseOptions || {} };
        const helpers = { ...base.helpers || {}, ...overrideOptions.helpers || {} };
        const allowedFunctions = /* @__PURE__ */ new Set([
          ...base.allowedFunctions || [],
          ...overrideOptions.allowedFunctions || []
        ]);
        const allowedGlobals = /* @__PURE__ */ new Set([
          ...base.allowedGlobals || DEFAULT_ALLOWED_GLOBALS,
          ...overrideOptions.allowedGlobals || []
        ]);
        const normalized = {
          ...EXPRESSION_PARSER_DEFAULTS,
          ...base,
          ...overrideOptions,
          helpers,
          allowedFunctions: Array.from(allowedFunctions),
          allowedGlobals: Array.from(allowedGlobals)
        };
        Object.defineProperty(normalized, NORMALIZED_OPTIONS_FLAG, {
          value: true,
          enumerable: false
        });
        return normalized;
      }
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type,
        ExpressionParser,
        ExpressionParserError
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // ../lang-mini/lib-lang-mini.js
  var require_lib_lang_mini = __commonJS({
    "../lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // ../lang-tools/collective.js
  var require_collective = __commonJS({
    "../lang-tools/collective.js"(exports, module) {
      var { each, is_array } = require_lib_lang_mini();
      var collective = (arr) => {
        if (is_array(arr)) {
          const target = {};
          const handler2 = {
            get(target2, prop, receiver) {
              if (arr.length > 0 && arr[0] && typeof arr[0][prop] === "function") {
                return (...a) => {
                  const res3 = [];
                  each(arr, (item2) => {
                    res3.push(item2[prop](...a));
                  });
                  return res3;
                };
              }
              if (prop in arr) {
                const val = arr[prop];
                if (typeof val === "function") return val.bind(arr);
                return val;
              }
              const res2 = [];
              each(arr, (item2) => {
                res2.push(item2[prop]);
              });
              return res2;
            }
          };
          const proxy2 = new Proxy(target, handler2);
          return proxy2;
        } else {
          console.trace();
          throw "NYI";
        }
      };
      module.exports = collective;
    }
  });

  // ../lang-tools/Data_Model/Data_Model.js
  var require_Data_Model = __commonJS({
    "../lang-tools/Data_Model/Data_Model.js"(exports, module) {
      var { Evented_Class } = require_lib_lang_mini();
      var Data_Model = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          this.__data_model = true;
          if (spec && spec.context) {
            this.context = spec.context;
          }
          if (spec && spec.name) {
            this.name = spec.name;
          }
          this.__type = "data_model";
        }
      };
      module.exports = Data_Model;
    }
  });

  // ../lang-tools/Data_Model/new/tools.js
  var require_tools = __commonJS({
    "../lang-tools/Data_Model/new/tools.js"(exports, module) {
      var Data_Model = require_Data_Model();
      var { tof } = require_lib_lang_mini();
      var more_general_equals = (that2, other) => {
        const t_that = tof(that2), t_other = tof(other);
        if (t_that !== t_other) return false;
        if (t_that === "number" || t_that === "string" || t_that === "boolean" || t_that === "undefined" || t_that === "null") {
          return Object.is(that2, other);
        }
        if (t_that === "array") {
          if (!Array.isArray(other) || that2.length !== other.length) return false;
          for (let i = 0; i < that2.length; i++) {
            if (!more_general_equals(that2[i], other[i])) return false;
          }
          return true;
        }
        if (that2 instanceof Data_Model && other instanceof Data_Model) {
          if (typeof that2.toJSON === "function" && typeof other.toJSON === "function") {
            return that2.toJSON() === other.toJSON();
          }
          if (that2 === other) return true;
          return false;
        }
        if (t_that === "object" && "value" in that2) {
          return more_general_equals(that2.value, other);
        }
        if (t_that === "object") {
          const keysA = Object.keys(that2);
          const keysB = Object.keys(other);
          if (keysA.length !== keysB.length) return false;
          for (const k of keysA) {
            if (!Object.prototype.hasOwnProperty.call(other, k)) return false;
            if (!more_general_equals(that2[k], other[k])) return false;
          }
          return true;
        }
        return Object.is(that2, other);
      };
      module.exports = {
        more_general_equals
      };
    }
  });

  // ../lang-tools/b-plus-tree/stiffarray.js
  var require_stiffarray = __commonJS({
    "../lang-tools/b-plus-tree/stiffarray.js"(exports, module) {
      var StiffArray = function(capacity) {
        var m_public = {
          items: new Array(capacity),
          // internal storage array
          count: 0,
          // items count
          first: function() {
            if (this.count == 0) throw "StiffArray.first()";
            return this.items[0];
          },
          last: function() {
            if (this.count == 0) throw "StiffArray.last()";
            return this.items[this.count - 1];
          },
          add: function(item2) {
            if (this.count >= capacity) throw "StiffArray.add()";
            this.items[this.count++] = item2;
          },
          add_from: function(source) {
            if (this.count + source.count > capacity) throw "StiffArray.add_from()";
            for (var i = 0; i < source.count; i++) this.items[this.count++] = source.items[i];
          },
          insert: function(index, item2) {
            if (index < 0 || index > this.count) throw "StiffArray.insert(): index";
            if (this.count >= capacity) throw "StiffArray.insert(): overflow";
            for (var i = this.count; i > index; i--) this.items[i] = this.items[i - 1];
            this.items[index] = item2;
            this.count++;
          },
          removeAt: function(index) {
            if (index < 0 || index >= this.count) throw "StiffArray.removeAt()";
            this.count--;
            for (var i = index; i < this.count; i++) this.items[i] = this.items[i + 1];
          },
          removeFirst: function() {
            this.removeAt(0);
          },
          removeLast: function() {
            this.removeAt(this.count - 1);
          },
          copy_from: function(source, index, count) {
            for (var i = 0; i < count; i++) {
              this.items[i] = source.items[i + index];
            }
            this.count = count;
          },
          search_first: function(item2) {
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              if (this.items[index] < item2) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first < this.count) {
              return { found: this.items[first] == item2, index: first };
            }
            return { found: false, index: first };
          },
          search_last: function(item2) {
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              if (item2 >= this.items[index]) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first > 0 && first <= this.count) {
              if (this.items[first - 1] == item2) {
                return { found: true, index: first - 1 };
              }
            }
            return { found: false, index: first };
          },
          search_last_prefix: function(prefix) {
            var prefix_length = prefix.length;
            var check_prefix = function(item3) {
              if (prefix_length > item3.length) return false;
              return item3.substr(0, prefix_length) == prefix;
            };
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              var item2 = this.items[index];
              if (prefix > item2 || check_prefix(item2)) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first > 0 && first <= this.count) {
              if (check_prefix(this.items[first - 1])) {
                return { found: true, index: first - 1 };
              }
            }
            return { found: false, index: first };
          },
          toString: function() {
            return this.items.slice(0, this.count).toString();
          }
        };
        return m_public;
      };
      module.exports = StiffArray;
    }
  });

  // ../lang-tools/b-plus-tree/b-plus-tree.js
  var require_b_plus_tree = __commonJS({
    "../lang-tools/b-plus-tree/b-plus-tree.js"(exports, module) {
      var StiffArray = require_stiffarray();
      var B_Plus_Node = function(nodeCapacity) {
        var m_public = {
          isLeaf: false,
          parent: null,
          keys: new StiffArray(nodeCapacity + 1),
          // +1: to allow temporary owerflow
          children: new StiffArray(nodeCapacity + 2)
          // +2: children.length == keys.length + 1
        };
        return m_public;
      };
      var B_Plus_Leaf = function(nodeCapacity) {
        var m_public = {
          isLeaf: true,
          parent: null,
          keys: new StiffArray(nodeCapacity + 1),
          values: new StiffArray(nodeCapacity + 1),
          //
          // leafs chain:
          prevLeaf: null,
          nextLeaf: null
        };
        return m_public;
      };
      var FindInfo = (key2, value2, isPrefixSearch) => {
        isPrefixSearch = !!isPrefixSearch;
        var isKeyPresent = key2 != void 0;
        var isValuePresent = value2 != void 0;
        var prefixLength = 0;
        if (isPrefixSearch) {
          if (typeof key2 != "string") {
            isPrefixSearch = false;
          } else {
            prefixLength = key2.length;
          }
        }
        return {
          key: key2,
          // key to find (if present)
          value: value2,
          // value to find (if present)
          isPrefixSearch,
          // prefix search mode
          leaf: null,
          // found leaf
          index: -1,
          // found leaf item index
          isKeyPresent,
          // function () { return this.key !== undefined; }, // is the search criteria contains key
          isValuePresent,
          // function () { return this.value !== undefined; }, // is the search criteria contains value
          foundKey: function() {
            return this.leaf.keys.items[this.index];
          },
          // found items's key
          foundValue: function() {
            return this.leaf.values.items[this.index];
          },
          // found item's value
          //
          prefix_length: prefixLength,
          // prefix length
          check_prefix: function() {
            if (!isPrefixSearch) return false;
            if (this.index >= this.leaf.keys.count) return false;
            var keyToCheck = this.foundKey();
            if (this.prefix_length > keyToCheck.length) return false;
            return keyToCheck.substr(0, this.prefix_length) == this.key;
          }
        };
      };
      var B_Plus_Tree = function(nodeCapacity) {
        if (nodeCapacity === void 0) nodeCapacity = 10;
        if (nodeCapacity < 4) throw "B_Plus_Tree(): node capacity must be >= 4";
        var m_public = {
          // tree root:
          root: new B_Plus_Leaf(nodeCapacity),
          //
          // leafs chain:
          firstLeaf: null,
          //
          lastLeaf: null,
          //
          // ---------------------
          //     editing:
          // ---------------------
          //
          // clear the tree:
          clear: function() {
            p_Clear();
          },
          //
          // insert(key, value)
          // insert([key, value])
          insert: function(key2, value2) {
            if (arguments.length == 2) {
              return p_Insert(key2, value2);
            } else {
              return p_Insert(key2[0], key2[1]);
            }
          },
          //
          // remove(key) - remove all values with given key
          // remove(key, value) - remove one value occurrence
          remove: function(key2, value2) {
            if (arguments.length == 2) {
              return p_Remove(key2, value2);
            } else {
              p_RemoveKey(key2);
            }
          },
          //
          // ---------------------
          //       finding:
          // ---------------------
          //
          // findFirst() - find the very first item
          // findFirst(key) - find the first item for the given key
          // findFirst(key, value) - find the first key+value occurrence
          //
          // returns the FindInfo object:
          //    key: key,     // key to find (if present)
          //    value: value, // value to find (if present)
          //
          //    leaf: null,   // the current found leaf
          //    index: -1,    // the current found index
          //
          //    foundKey():   // the current found key
          //    foundValue(): // the current found value
          //
          findFirst: function(key2, value2) {
            return p_FindFirst(key2, value2);
          },
          //
          // find first key matching the prefix:
          findFirstPrefix: function(prefix) {
            return p_FindFirst(prefix, void 0, true);
          },
          //
          // find next search conditions occurence
          findNext: function(findInfo) {
            return p_FindNext(findInfo);
          },
          //
          // findLast() - find the very last item
          // findLast(key) - find the last item for the given key
          // findLast(key, value) - find the last key+value occurrence
          findLast: function(key2, value2) {
            return p_FindLast(key2, value2);
          },
          //
          // find last key matching the prefix:
          findLastPrefix: function(prefix) {
            return p_FindLast(prefix, void 0, true);
          },
          //
          // find previous search conditions occurence
          findPrevious: function(findInfo) {
            return p_FindPrev(findInfo);
          },
          //
          // ---------------------
          // dictionary-like usage:
          // ---------------------
          //
          // get one value by key (or null):
          getValue: function(key2) {
            return p_GetValue(key2);
          },
          // set one value by key (insert or update):
          setValue: function(key2, value2) {
            p_SetValue(key2, value2);
          },
          //
          //
          // ---------------------
          //   other functions:
          // ---------------------
          //
          // count() - count all values
          // count(key) - count values with the given key
          count: function(key2) {
            if (arguments.length == 1) {
              return p_CountKey(key2);
            } else {
              return p_Count();
            }
          },
          //
          // tree capacity:
          getCapacity: function() {
            return m_nodeMaxCount;
          },
          //
          // ---------------------
          // additional functions:
          // ---------------------
          //
          // iterate through each key + value pair
          // callback is function(key, value)
          "each": function(callback2) {
            return p_each(callback2);
          },
          //
          // get all keys
          "keys": function() {
            return p_keys();
          },
          //
          // get all [key, value] pairs
          "keys_and_values": function() {
            return p_keys_and_values();
          },
          //
          //
          // get keys and values by prefix
          "get_by_prefix": function(prefix) {
            return p_get_by_prefix(prefix);
          },
          //
          // get keys by prefix
          "get_keys_by_prefix": function(prefix) {
            return p_get_keys_by_prefix(prefix);
          },
          //
          // get values at key...
          "get_values_by_key": function(key2) {
            return p_get_values_by_key(key2);
          }
        };
        m_public.firstLeaf = m_public.root;
        m_public.lastLeaf = m_public.root;
        var m_nodeMaxCount = nodeCapacity;
        var m_nodeMinCount = Math.floor(m_nodeMaxCount / 2);
        var p_Clear = function() {
          m_public.root = new B_Plus_Leaf(m_nodeMaxCount);
          m_public.firstLeaf = m_public.root;
          m_public.lastLeaf = m_public.root;
        };
        var p_keys = function() {
          var res2 = [];
          _p_each_key(function(key2) {
            res2.push(key2);
          });
          return res2;
        };
        var p_keys_and_values = function() {
          var res2 = [];
          p_each(function(key2, value2) {
            res2.push([key2, value2]);
          });
          return res2;
        };
        var _p_each_key = function(callback2) {
          var findInfo = p_FindFirst();
          while (findInfo != null) {
            var fk = findInfo.foundKey();
            callback2(fk);
            findInfo = p_FindNext(findInfo);
          }
        };
        var p_each = function(callback2) {
          var findInfo = p_FindFirst();
          var doStop = false;
          while (findInfo != null) {
            var fk = findInfo.foundKey();
            var fv = findInfo.foundValue();
            callback2(fk, fv, function() {
              doStop = true;
            });
            if (doStop) {
              findInfo = null;
            } else {
              findInfo = p_FindNext(findInfo);
            }
          }
        };
        var p_Insert = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          var leaf = searchResult.node;
          leaf.keys.insert(searchResult.index, key2);
          leaf.values.insert(searchResult.index, value2);
          if (leaf.keys.count > m_nodeMaxCount) {
            if (leaf.prevLeaf != null && leaf.prevLeaf.keys.count < m_nodeMaxCount && leaf.prevLeaf.parent == leaf.parent) {
              rotateAmongLeavesToLeft(leaf.prevLeaf, leaf);
            } else if (leaf.nextLeaf != null && leaf.nextLeaf.keys.count < m_nodeMaxCount && leaf.nextLeaf.parent == leaf.parent) {
              rotateAmongLeavesToRight(leaf, leaf.nextLeaf);
            } else {
              splitLeaf(leaf);
            }
          }
        };
        var splitLeaf = function(leaf) {
          var leftCount = m_nodeMinCount;
          var rightCount = leaf.keys.count - leftCount;
          var newRightLeaf = new B_Plus_Leaf(m_nodeMaxCount);
          newRightLeaf.parent = leaf.parent;
          newRightLeaf.keys.copy_from(leaf.keys, leftCount, rightCount);
          newRightLeaf.values.copy_from(leaf.values, leftCount, rightCount);
          leaf.keys.count = leftCount;
          leaf.values.count = leftCount;
          newRightLeaf.nextLeaf = leaf.nextLeaf;
          if (newRightLeaf.nextLeaf != null) newRightLeaf.nextLeaf.prevLeaf = newRightLeaf;
          newRightLeaf.prevLeaf = leaf;
          leaf.nextLeaf = newRightLeaf;
          if (m_public.lastLeaf == leaf) m_public.lastLeaf = newRightLeaf;
          if (leaf.parent != null) {
            var leafIndex = calcChildIndex(leaf.parent, leaf);
            insertToParent(leaf.parent, newRightLeaf, newRightLeaf.keys.first(), leafIndex + 1);
          } else {
            createNewRoot(leaf, newRightLeaf, newRightLeaf.keys.first());
          }
        };
        var createNewRoot = function(nodeLeft, nodeRight, key2) {
          var newRoot = new B_Plus_Node(m_nodeMaxCount);
          newRoot.keys.add(key2);
          newRoot.children.add(nodeLeft);
          newRoot.children.add(nodeRight);
          nodeLeft.parent = newRoot;
          nodeRight.parent = newRoot;
          m_public.root = newRoot;
        };
        var insertToParent = function(parentNode, newChildNode, newChildFirstKey, newChildIndex) {
          parentNode.keys.insert(newChildIndex - 1, newChildFirstKey);
          parentNode.children.insert(newChildIndex, newChildNode);
          newChildNode.parent = parentNode;
          if (parentNode.keys.count > m_nodeMaxCount) {
            splitNode(parentNode);
          }
        };
        var splitNode = function(node) {
          var newLeftCount = m_nodeMinCount;
          var newRightCount = m_nodeMaxCount - newLeftCount;
          var middleKey = node.keys.items[newLeftCount];
          var newRightNode = new B_Plus_Node(m_nodeMaxCount);
          newRightNode.keys.copy_from(node.keys, newLeftCount + 1, newRightCount);
          newRightNode.children.copy_from(node.children, newLeftCount + 1, newRightCount + 1);
          node.keys.count = newLeftCount;
          node.children.count = newLeftCount + 1;
          for (var i = 0; i < newRightNode.children.count; i++) newRightNode.children.items[i].parent = newRightNode;
          if (node.parent == null) {
            createNewRoot(node, newRightNode, middleKey);
          } else {
            var nodeIndex = calcChildIndex(node.parent, node);
            insertToParent(node.parent, newRightNode, middleKey, nodeIndex + 1);
          }
        };
        var p_Remove = function(key2, value2) {
          var searchResult = searchLeafValue(key2, value2);
          if (!searchResult.found) return false;
          removeFromLeaf(searchResult.node, searchResult.index);
          return true;
        };
        var p_RemoveKey = function(key2) {
          while (true) {
            var searchResult = searchLeaf(key2);
            if (!searchResult.found) break;
            removeFromLeaf(searchResult.node, searchResult.index);
          }
        };
        var removeFromLeaf = function(leaf, index) {
          leaf.keys.removeAt(index);
          leaf.values.removeAt(index);
          if (leaf.keys.count < m_nodeMinCount) {
            if (leaf.prevLeaf != null && leaf.parent == leaf.prevLeaf.parent && leaf.prevLeaf.keys.count > m_nodeMinCount) {
              rotateAmongLeavesToRight(leaf.prevLeaf, leaf);
            } else if (leaf.nextLeaf != null && leaf.parent == leaf.nextLeaf.parent && leaf.nextLeaf.keys.count > m_nodeMinCount) {
              rotateAmongLeavesToLeft(leaf, leaf.nextLeaf);
            } else {
              mergeLeaf(leaf);
            }
          }
          return true;
        };
        var mergeLeaf = function(leaf) {
          if (leaf.parent == null) {
            return;
          }
          var leftCount = m_nodeMaxCount + 1;
          var rightCount = m_nodeMaxCount + 1;
          if (leaf.prevLeaf != null && leaf.prevLeaf.parent == leaf.parent) {
            leftCount = leaf.prevLeaf.keys.count;
          }
          if (leaf.nextLeaf != null && leaf.nextLeaf.parent == leaf.parent) {
            rightCount = leaf.nextLeaf.keys.count;
          }
          if (leftCount < rightCount) {
            if (leftCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): leftCount";
            mergeLeaves(leaf.prevLeaf, leaf);
          } else {
            if (rightCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): rightCount";
            mergeLeaves(leaf, leaf.nextLeaf);
          }
        };
        var mergeLeaves = function(leafLeft, leafRight) {
          leafLeft.keys.add_from(leafRight.keys);
          leafLeft.values.add_from(leafRight.values);
          leafLeft.nextLeaf = leafRight.nextLeaf;
          if (leafLeft.nextLeaf != null) leafLeft.nextLeaf.prevLeaf = leafLeft;
          if (m_public.lastLeaf == leafRight) m_public.lastLeaf = leafLeft;
          var parent = leafRight.parent;
          var leafRightIndex = calcChildIndex(parent, leafRight);
          parent.keys.removeAt(leafRightIndex - 1);
          parent.children.removeAt(leafRightIndex);
          if (parent.keys.count < m_nodeMinCount) {
            mergeNode(parent);
          }
          ;
        };
        var mergeNode = function(node) {
          var parent = node.parent;
          if (node.parent == null) {
            if (node.keys.count == 0) {
              m_public.root = node.children.items[0];
              m_public.root.parent = null;
            }
            return;
          }
          var nodeIndex = calcChildIndex(parent, node);
          var leftSibling = nodeIndex > 0 ? parent.children.items[nodeIndex - 1] : null;
          var rightSibling = nodeIndex + 1 < parent.children.count ? parent.children.items[nodeIndex + 1] : null;
          if (leftSibling != null && leftSibling.keys.count > m_nodeMinCount) {
            rotateAmongNodesToRight(leftSibling, node);
            return;
          }
          if (rightSibling != null && rightSibling.keys.count > m_nodeMinCount) {
            rotateAmongNodesToLeft(node, rightSibling);
            return;
          }
          var leftCount = m_nodeMaxCount + 1;
          var rightCount = m_nodeMaxCount + 1;
          if (leftSibling != null) {
            leftCount = leftSibling.keys.count;
          }
          if (rightSibling != null) {
            rightCount = rightSibling.keys.count;
          }
          if (leftCount < rightCount) {
            if (leftSibling == null) throw "B_Plus_Tree.mergeNode(): leftSibling";
            mergeNodes(leftSibling, node, nodeIndex);
          } else {
            if (rightSibling == null) throw "B_Plus_Tree.mergeNode(): rightSibling";
            mergeNodes(node, rightSibling, nodeIndex + 1);
          }
        };
        var mergeNodes = function(nodeLeft, nodeRight, nodeRightIndex) {
          var parent = nodeLeft.parent;
          for (var i = 0; i < nodeRight.children.count; i++) nodeRight.children.items[i].parent = nodeLeft;
          nodeLeft.keys.add(nodeLeft.parent.keys.items[nodeRightIndex - 1]);
          nodeLeft.keys.add_from(nodeRight.keys);
          nodeLeft.children.add_from(nodeRight.children);
          parent.keys.removeAt(nodeRightIndex - 1);
          parent.children.removeAt(nodeRightIndex);
          if (parent.keys.count < m_nodeMinCount) {
            mergeNode(parent);
          }
          ;
        };
        var p_FindFirst = function(key2, value2, isPrefixSearch) {
          var findInfo = FindInfo(key2, value2, isPrefixSearch);
          if (findInfo.isKeyPresent) {
            if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindFirst(): arguments error: isPrefixSearch, but value is present";
            var searchResult = findInfo.isValuePresent ? searchLeafValue(key2, value2) : searchLeaf(key2);
            findInfo.leaf = searchResult.node;
            findInfo.index = searchResult.index;
            if (!searchResult.found) {
              if (!findInfo.check_prefix()) {
                return null;
              }
            }
          } else {
            if (findInfo.isValuePresent) throw "B_Plus_Tree.findFirst(): arguments error: key is not present, but value is present";
            findInfo.leaf = m_public.firstLeaf;
            findInfo.index = 0;
            if (findInfo.leaf.keys.count <= 0) return null;
          }
          return findInfo;
        };
        var p_FindLast = function(key2, value2, isPrefixSearch) {
          var findInfo = new FindInfo(key2, value2, isPrefixSearch);
          if (findInfo.isKeyPresent) {
            if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindLast(): arguments error: isPrefixSearch, but value is present";
            if (findInfo.isPrefixSearch) {
              var searchResult = searchLastLeafByPrefix(key2);
              findInfo.leaf = searchResult.node;
              findInfo.index = searchResult.index;
              if (!searchResult.found) {
                return null;
              }
            } else {
              var searchResult = findInfo.isValuePresent ? searchLastLeafValue(key2, value2) : searchLastLeaf(key2);
              findInfo.leaf = searchResult.node;
              findInfo.index = searchResult.index;
              if (!searchResult.found) {
                return null;
              }
            }
          } else {
            if (findInfo.isValuePresent) throw "B_Plus_Tree.findLast(): arguments error: key is not present, but value is present";
            findInfo.leaf = m_public.lastLeaf;
            findInfo.index = findInfo.leaf.keys.count - 1;
            if (findInfo.index < 0) return null;
          }
          return findInfo;
        };
        var findGoToNext = function(findInfo) {
          findInfo.index++;
          if (findInfo.index >= findInfo.leaf.keys.count) {
            findInfo.leaf = findInfo.leaf.nextLeaf;
            findInfo.index = 0;
          }
          return findInfo.leaf != null;
        };
        var findGoToPrev = function(findInfo) {
          findInfo.index--;
          if (findInfo.index < 0) {
            findInfo.leaf = findInfo.leaf.prevLeaf;
            if (findInfo.leaf == null) return false;
            findInfo.index = findInfo.leaf.keys.count - 1;
          }
          return true;
        };
        var p_FindNext = function(findInfo) {
          while (true) {
            if (!findGoToNext(findInfo)) return null;
            if (findInfo.isPrefixSearch) {
              if (!findInfo.check_prefix()) return null;
            } else {
              if (findInfo.isKeyPresent && findInfo.key != findInfo.foundKey()) return null;
            }
            if (findInfo.isValuePresent) {
              if (findInfo.value == findInfo.foundValue()) return findInfo;
            } else {
              return findInfo;
            }
          }
        };
        var p_FindPrev = function(findInfo) {
          while (true) {
            if (!findGoToPrev(findInfo)) return null;
            if (findInfo.isPrefixSearch) {
              if (!findInfo.check_prefix()) return null;
            } else {
              if (findInfo.isKeyPresent && findInfo.key != findInfo.foundKey()) return null;
            }
            if (findInfo.isValuePresent) {
              if (findInfo.value == findInfo.foundValue()) return findInfo;
            } else {
              return findInfo;
            }
          }
        };
        var p_get_values_by_key = function(key2) {
          var res2 = [];
          var findInfo = p_FindFirst(key2);
          while (findInfo != null) {
            res2.push(findInfo.foundValue());
            findInfo = p_FindNext(findInfo);
          }
          return res2;
        };
        var p_get_by_prefix = function(prefix) {
          var res2 = [];
          var findInfo = m_public.findFirstPrefix(prefix);
          while (findInfo != null) {
            res2.push([findInfo.foundKey(), findInfo.foundValue()]);
            findInfo = m_public.findNext(findInfo);
          }
          return res2;
        };
        var p_get_keys_by_prefix = function(prefix) {
          var res2 = [];
          var findInfo = m_public.findFirstPrefix(prefix);
          while (findInfo != null) {
            res2.push(findInfo.foundKey());
            findInfo = m_public.findNext(findInfo);
          }
          return res2;
        };
        var p_GetValue = function(key2) {
          var searchResult = searchLeaf(key2);
          if (!searchResult.found) return null;
          return searchResult.node.values.items[searchResult.index];
        };
        var p_SetValue = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          if (searchResult.found) {
            removeFromLeaf(searchResult.node, searchResult.index);
          }
          p_Insert(key2, value2);
        };
        var p_Count = function() {
          var result = 0;
          var leaf = m_public.firstLeaf;
          while (leaf != null) {
            result += leaf.keys.count;
            leaf = leaf.nextLeaf;
          }
          return result;
        };
        var p_CountKey = function(key2) {
          var result = 0;
          var findInfo = m_public.findFirst(key2);
          while (findInfo != null) {
            result++;
            findInfo = m_public.findNext(findInfo);
          }
          return result;
        };
        var rotateAmongNodesToLeft = function(leftNode, rightNode) {
          var parent = rightNode.parent;
          var rightIndex = calcChildIndex(parent, rightNode);
          leftNode.keys.add(parent.keys.items[rightIndex - 1]);
          parent.keys.items[rightIndex - 1] = rightNode.keys.first();
          rightNode.keys.removeFirst();
          rightNode.children.first().parent = leftNode;
          leftNode.children.add(rightNode.children.first());
          rightNode.children.removeFirst();
        };
        var rotateAmongNodesToRight = function(leftNode, rightNode) {
          var parent = rightNode.parent;
          var rightIndex = calcChildIndex(parent, rightNode);
          rightNode.keys.insert(0, parent.keys.items[rightIndex - 1]);
          parent.keys.items[rightIndex - 1] = leftNode.keys.last();
          leftNode.keys.removeLast();
          rightNode.children.insert(0, leftNode.children.last());
          rightNode.children.first().parent = rightNode;
          leftNode.children.removeLast();
        };
        var rotateAmongLeavesToLeft = function(leftLeaf, rightLeaf) {
          var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
          leftLeaf.keys.add(rightLeaf.keys.first());
          leftLeaf.values.add(rightLeaf.values.first());
          rightLeaf.keys.removeFirst();
          rightLeaf.values.removeFirst();
          rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
        };
        var rotateAmongLeavesToRight = function(leftLeaf, rightLeaf) {
          var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
          rightLeaf.keys.insert(0, leftLeaf.keys.last());
          rightLeaf.values.insert(0, leftLeaf.values.last());
          leftLeaf.keys.removeLast();
          leftLeaf.values.removeLast();
          rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
        };
        var calcChildIndex = function(node, child) {
          var key2 = child.keys.first();
          var searchResult = node.keys.search_first(key2);
          if (!searchResult.found) {
            if (node.children.items[searchResult.index] != child) throw "B_PlusTree.calcChildIndex(): 1";
            return searchResult.index;
          }
          var index = searchResult.index;
          for (; ; ) {
            if (node.children.items[index] == child) return index;
            index++;
            if (index >= node.children.count) break;
            if (node.keys.items[index - 1] != key2) break;
          }
          throw "B_PlusTree.calcChildIndex(): 2";
        };
        var searchLeaf = function(key2) {
          var doSearchLeaf = function(node, key3) {
            var searchResult = node.keys.search_first(key3);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultLeft = doSearchLeaf(node.children.items[searchResult.index], key3);
              if (resultLeft.found) return resultLeft;
              return doSearchLeaf(node.children.items[searchResult.index + 1], key3);
            } else {
              return doSearchLeaf(node.children.items[searchResult.index], key3);
            }
          };
          return doSearchLeaf(m_public.root, key2);
        };
        var searchLastLeaf = function(key2) {
          var doSearchLastLeaf = function(node, key3) {
            var searchResult = node.keys.search_last(key3);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultRight = doSearchLastLeaf(node.children.items[searchResult.index + 1], key3);
              if (resultRight.found) return resultRight;
              return doSearchLastLeaf(node.children.items[searchResult.index], key3);
            } else {
              return doSearchLastLeaf(node.children.items[searchResult.index], key3);
            }
          };
          return doSearchLastLeaf(m_public.root, key2);
        };
        var searchLastLeafByPrefix = function(prefix) {
          var doSearchLastLeafByPrefix = function(node, prefix2) {
            var searchResult = node.keys.search_last_prefix(prefix2);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultRight = doSearchLastLeafByPrefix(node.children.items[searchResult.index + 1], prefix2);
              if (resultRight.found) return resultRight;
              return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix2);
            } else {
              return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix2);
            }
          };
          return doSearchLastLeafByPrefix(m_public.root, prefix);
        };
        var searchLeafValue = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          if (!searchResult.found) return searchResult;
          var valueFound = false;
          var leaf = searchResult.node;
          var index = searchResult.index;
          for (; ; ) {
            if (index >= leaf.values.count) {
              leaf = leaf.nextLeaf;
              if (leaf == null) break;
              index = 0;
            }
            if (leaf.keys.items[index] != key2) break;
            if (leaf.values.items[index] == value2) {
              valueFound = true;
              break;
            }
            index++;
          }
          return { node: leaf, found: valueFound, index };
        };
        var searchLastLeafValue = function(key2, value2) {
          var searchResult = searchLastLeaf(key2);
          if (!searchResult.found) return searchResult;
          var valueFound = false;
          var leaf = searchResult.node;
          var index = searchResult.index;
          for (; ; ) {
            if (index < 0) {
              leaf = leaf.prevLeaf;
              if (leaf == null) break;
              index = leaf.values.count - 1;
            }
            if (leaf.keys.items[index] != key2) break;
            if (leaf.values.items[index] == value2) {
              valueFound = true;
              break;
            }
            index--;
          }
          return { node: leaf, found: valueFound, index };
        };
        return m_public;
      };
      B_Plus_Tree.FindInfo = FindInfo;
      module.exports = B_Plus_Tree;
    }
  });

  // ../lang-tools/Data_Model/new/Immutable_Data_Model.js
  var require_Immutable_Data_Model = __commonJS({
    "../lang-tools/Data_Model/new/Immutable_Data_Model.js"(exports, module) {
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = class extends Data_Model {
        constructor(...a) {
          super(...a);
        }
      };
      module.exports = Immutable_Data_Model;
    }
  });

  // ../lang-tools/Data_Model/new/Validation_Result.js
  var require_Validation_Result = __commonJS({
    "../lang-tools/Data_Model/new/Validation_Result.js"(exports, module) {
      var Validation_Result = class {
      };
      module.exports = Validation_Result;
    }
  });

  // ../lang-tools/Data_Model/new/Validation_Success.js
  var require_Validation_Success = __commonJS({
    "../lang-tools/Data_Model/new/Validation_Success.js"(exports, module) {
      var Validation_Result = require_Validation_Result();
      var Validation_Success = class extends Validation_Result {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Validation_Success;
    }
  });

  // ../lang-tools/Data_Model/new/Validation_Failure.js
  var require_Validation_Failure = __commonJS({
    "../lang-tools/Data_Model/new/Validation_Failure.js"(exports, module) {
      var Validation_Result = require_Validation_Result();
      var Validation_Failure = class extends Validation_Result {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Validation_Failure;
    }
  });

  // ../lang-tools/Data_Model/new/setup_base_data_value_value_property.js
  var require_setup_base_data_value_value_property = __commonJS({
    "../lang-tools/Data_Model/new/setup_base_data_value_value_property.js"(exports, module) {
      var Validation_Success = require_Validation_Success();
      var Validation_Failure = require_Validation_Failure();
      var setup_base_data_value_value_property = (data_value) => {
        let local_js_value;
        const set_value_with_valid_and_changed_value = (valid_and_changed_value) => {
          const old = local_js_value;
          local_js_value = valid_and_changed_value;
          data_value.raise("change", {
            name: "value",
            old,
            value: local_js_value
          });
        };
        const create_validation_error = (validation, value2) => {
          const failure = validation instanceof Validation_Failure ? validation : new Validation_Failure({ value: value2 });
          const error2 = new Error("Validation failed for value assignment");
          error2.validation = failure;
          error2.value = value2;
          return error2;
        };
        Object.defineProperty(data_value, "value", {
          configurable: true,
          get() {
            return local_js_value;
          },
          set(value2) {
            if (data_value.transform_validate_value) {
              const obj_transform_and_validate_value_results = data_value.transform_validate_value(value2);
              const validation = obj_transform_and_validate_value_results && obj_transform_and_validate_value_results.validation;
              if (!(validation instanceof Validation_Success)) {
                throw create_validation_error(validation, value2);
              }
              const next_value = Object.prototype.hasOwnProperty.call(obj_transform_and_validate_value_results, "transformed_value") ? obj_transform_and_validate_value_results.transformed_value : obj_transform_and_validate_value_results.value;
              if (!Object.is(local_js_value, next_value)) {
                set_value_with_valid_and_changed_value(next_value);
              }
            } else {
              if (!Object.is(local_js_value, value2)) {
                set_value_with_valid_and_changed_value(value2);
              }
            }
          }
        });
      };
      module.exports = setup_base_data_value_value_property;
    }
  });

  // ../lang-tools/Data_Model/new/Base_Data_Value.js
  var require_Base_Data_Value = __commonJS({
    "../lang-tools/Data_Model/new/Base_Data_Value.js"(exports, module) {
      var jsgui = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var { is_defined, input_processors, field, tof, each } = jsgui;
      var setup_base_data_value_value_property = require_setup_base_data_value_value_property();
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var Base_Data_Value = class extends Data_Model {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          this.__type = "data_value";
          this._relationships = {};
          const { data_type, context: context2 } = this;
          setup_base_data_value_value_property(this);
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        // Maybe see about immutable mode Data_Values / Data_Models.
        //   Or do make the immutable versions of all of them!!!
        //     And could make core functionality for both the immutable and mutable versions.
        //       Mutability Independent Code.
        // Immutable_Data_Integer does seem like it would in principle be (really?) simple.
        /*
            toImmutable() {
                // May be slightly difficult / tricky / complex.
                const {context, data_type, value} = this;
        
                // Create the new item...
                // Needs to copy the inner value....?
        
                const res = new Immutable_Data_Value({
                    context, data_type, value
                });
                return res;
            }
            */
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          return JSON.stringify(this.get());
        }
        // Need to copy / clone the ._ value
        /*
            'clone'() {
        
                //return this.toImmutable();
            }
            */
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
            return this.__id;
          }
          return void 0;
        }
      };
      module.exports = Base_Data_Value;
    }
  });

  // ../lang-tools/Data_Model/new/Value_Set_Attempt.js
  var require_Value_Set_Attempt = __commonJS({
    "../lang-tools/Data_Model/new/Value_Set_Attempt.js"(exports, module) {
      var Value_Set_Attempt = class {
        constructor(spec = {}) {
          Object.assign(this, spec);
        }
      };
      module.exports = Value_Set_Attempt;
    }
  });

  // ../lang-tools/Data_Model/new/Immutable_Base_Data_Value.js
  var require_Immutable_Base_Data_Value = __commonJS({
    "../lang-tools/Data_Model/new/Immutable_Base_Data_Value.js"(exports, module) {
      var jsgui = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var { is_defined, input_processors, field, tof, each } = jsgui;
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var Immutable_Base_Data_Value = class extends Immutable_Data_Model {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          this.__type = "data_value";
          this._relationships = {};
          const { data_type, context: context2 } = this;
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        // Maybe see about immutable mode Data_Values / Data_Models.
        //   Or do make the immutable versions of all of them!!!
        //     And could make core functionality for both the immutable and mutable versions.
        //       Mutability Independent Code.
        // Immutable_Data_Integer does seem like it would in principle be (really?) simple.
        /*
            toImmutable() {
                // May be slightly difficult / tricky / complex.
                const {context, data_type, value} = this;
        
                // Create the new item...
                // Needs to copy the inner value....?
        
                const res = new Immutable_Data_Value({
                    context, data_type, value
                });
                return res;
            }
            */
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          return JSON.stringify(this.get());
        }
        // Need to copy / clone the ._ value
        /*
            'clone'() {
        
                //return this.toImmutable();
            }
            */
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "Immutable_Base_Data_Value should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
      };
      module.exports = Immutable_Base_Data_Value;
    }
  });

  // ../lang-tools/Data_Model/new/Immutable_Data_Value.js
  var require_Immutable_Data_Value = __commonJS({
    "../lang-tools/Data_Model/new/Immutable_Data_Value.js"(exports, module) {
      var jsgui = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var Immutable_Base_Data_Value = require_Immutable_Base_Data_Value();
      var throw_immutable_assignment = () => {
        throw new TypeError("Cannot modify immutable Data_Value");
      };
      var { is_defined, input_processors, field, tof, each } = jsgui;
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var ldarkPurple = (x) => `\x1B[38;5;54m${x}\x1B[0m`;
      var Immutable_Data_Value = class _Immutable_Data_Value extends Immutable_Base_Data_Value {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          this.__immutable = true;
          this.__type_name = "data_value";
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          const { data_type, context: context2 } = this;
          if (data_type) {
            const to_local_js_value = (value2) => {
              if (value2 !== void 0) {
                const t = tof(value2);
                if (t === "number" || t === "string" || t === "boolean") {
                  return value2;
                } else {
                  if (t === "array") {
                    const l2 = value2.length;
                    const res2 = new Array(l2);
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = to_local_js_value(value2[c2]);
                    }
                    return res2;
                  } else if (t === "data_value") {
                    return value2.toImmutable();
                  } else {
                    console.log("to_local_js_value value", value2);
                    console.log("t", t);
                    console.trace();
                    throw "NYI";
                  }
                }
              }
            };
            const local_js_value = to_local_js_value(spec.value);
            Object.defineProperty(this, "value", {
              get() {
                return local_js_value;
              },
              set: throw_immutable_assignment
            });
          } else {
            let value2;
            if (spec.value instanceof Array) {
              value2 = spec.value.map((x) => {
                if (x instanceof Data_Model) {
                  return x.toImmutable();
                } else {
                  return x;
                }
              });
            } else {
              value2 = spec.value;
            }
            Object.defineProperty(this, "value", {
              get() {
                return value2;
              },
              set: throw_immutable_assignment
            });
          }
          this.__type = "data_value";
          this._relationships = {};
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        toImmutable() {
          const { context: context2, data_type, value: value2 } = this;
          const res2 = new _Immutable_Data_Value({
            context: context2,
            data_type,
            value: value2
          });
          return res2;
        }
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          const t_value = tof(this.value);
          if (t_value === "string") {
            return JSON.stringify(this.value);
          } else if (t_value === "number") {
            return this.value + "";
          } else if (t_value === "boolean") {
            this.value ? "true" : "false";
          } else if (t_value === "array") {
            let res2 = "[";
            const l2 = this.value.length;
            for (let c2 = 0; c2 < l2; c2++) {
              const item2 = this.value[c2];
              if (c2 > 0) res2 += ",";
              if (item2.toJSON) {
                res2 += item2.toJSON();
              } else {
                res2 += JSON.stringify(item2);
              }
            }
            res2 = res2 + "]";
            return res2;
          } else if (t_value === "data_value") {
            return this.value.toJSON();
          } else if (t_value === "undefined") {
            return "null";
          } else if (t_value === "null") {
            return "null";
          } else {
            console.log("toJSON this.value", this.value);
            console.log("t_value", t_value);
            console.trace();
            throw "NYI";
          }
        }
        // Need to copy / clone the ._ value
        "clone"() {
          return this.toImmutable();
        }
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "Data_Value should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
        "toObject"() {
          return this._;
        }
      };
      if (util) {
        Immutable_Data_Value.prototype[util.inspect.custom] = function(depth, opts) {
          const { value: value2 } = this;
          if (value2 instanceof Array) {
            let res2 = ldarkPurple("[ ");
            let first = true;
            each(value2, (item2) => {
              if (!first) {
                res2 = res2 + ldarkPurple(", ");
              } else {
                first = false;
              }
              if (item2 instanceof Data_Model) {
                const item_value = item2.value;
                res2 = res2 + ldarkPurple(item_value);
              } else [
                res2 = res2 + ldarkPurple(item2)
              ];
            });
            res2 = res2 + ldarkPurple(" ]");
            return res2;
          } else {
            return ldarkPurple(this.value);
          }
        };
      }
      module.exports = Immutable_Data_Value;
    }
  });

  // ../lang-tools/Data_Model/new/setup_data_value_data_type_set.js
  var require_setup_data_value_data_type_set = __commonJS({
    "../lang-tools/Data_Model/new/setup_data_value_data_type_set.js"(exports, module) {
      var jsgui = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Base_Data_Value = require_Base_Data_Value();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var Immutable_Data_Value = require_Immutable_Data_Value();
      var { is_defined, input_processors, field, tof, each, is_array } = jsgui;
      var Validation_Success = require_Validation_Success();
      var setup_data_value_data_type_set = (data_value, data_type) => {
        let local_js_value;
        const validation_success = (value2, transformed_value) => {
          const res2 = {
            validation: new Validation_Success(),
            value: value2
          };
          if (transformed_value !== void 0) {
            res2.transformed_value = transformed_value;
          }
          return res2;
        };
        const unwrap_data_value = (value2) => value2 instanceof Base_Data_Value ? value2.value : value2;
        const is_functional_data_type = (dt) => !!dt && typeof dt.validate === "function";
        const define_string_value_property = () => {
          if (!Object.getOwnPropertyDescriptor(data_value, "value")) {
            Object.defineProperty(data_value, "value", {
              get() {
                return local_js_value;
              },
              set(value2) {
                const old_value = local_js_value;
                const immu = data_value.toImmutable();
                const value_equals_current = immu.equals(value2);
                if (!value_equals_current) {
                  const t_value = tof(value2);
                  let made_change = false;
                  if (t_value === "string") {
                    if (local_js_value instanceof Base_Data_Value) {
                      console.log("existing local_js_value instanceof Data_Value");
                      console.log("local_js_value.value", local_js_value.value);
                      console.log("local_js_value.data_type.name", local_js_value.data_type.name);
                      console.trace();
                      throw "NYI";
                    } else if (local_js_value === void 0) {
                      local_js_value = value2;
                      made_change = true;
                    } else if (typeof local_js_value === "string") {
                      local_js_value = value2;
                      made_change = true;
                    } else {
                      console.trace();
                      throw "stop";
                    }
                  } else {
                    if (value2 instanceof Base_Data_Value) {
                      console.log("t_value", t_value);
                      console.log("value", value2);
                      console.trace();
                      throw "stop";
                    } else {
                      const tval = tof(value2);
                      if (tval === "number") {
                        local_js_value = value2 + "";
                        made_change = true;
                      } else {
                        console.log("-- INVALID TYPE --");
                        console.log("tof(old_value)", tof(old_value));
                        console.log("tof(value)", tof(value2));
                        data_value.raise("validate", {
                          valid: false,
                          reason: "Invalid Type",
                          value: value2,
                          old: local_js_value
                        });
                      }
                    }
                  }
                  if (made_change) {
                    const my_e = {
                      name: "value",
                      old: old_value,
                      value: local_js_value
                    };
                    data_value.raise("change", my_e);
                  }
                }
              }
            });
          } else {
            const transform_string_value = (raw) => {
              const candidate = unwrap_data_value(raw);
              if (candidate === void 0 || candidate === null) {
                return validation_success(candidate);
              }
              if (typeof candidate === "string") {
                return validation_success(candidate);
              }
              if (typeof candidate === "number" || typeof candidate === "boolean") {
                return validation_success(candidate, candidate + "");
              }
              return {
                validation: false,
                value: candidate
              };
            };
            data_value.transform_validate_value = transform_string_value;
          }
        };
        const define_number_value_property = () => {
          const transform_number_value = (raw) => {
            const candidate = unwrap_data_value(raw);
            if (candidate === void 0 || candidate === null) {
              return validation_success(candidate);
            }
            if (typeof candidate === "number") {
              if (Number.isNaN(candidate)) {
                return {
                  validation: false,
                  value: candidate
                };
              }
              return validation_success(candidate);
            }
            if (typeof candidate === "string") {
              const trimmed = candidate.trim();
              if (trimmed.length === 0) {
                return {
                  validation: false,
                  value: candidate
                };
              }
              const parsed = Number(trimmed);
              if (!Number.isNaN(parsed)) {
                return validation_success(candidate, parsed);
              }
              return {
                validation: false,
                value: candidate
              };
            }
            return {
              validation: false,
              value: candidate
            };
          };
          data_value.transform_validate_value = transform_number_value;
        };
        const define_data_type_typed_value_property = () => {
          const descriptor = Object.getOwnPropertyDescriptor(data_value, "value");
          if (descriptor) {
            const transform_data_type_value = (raw) => {
              const candidate = unwrap_data_value(raw);
              if (data_type.validate(candidate)) {
                return validation_success(candidate);
              }
              if (typeof candidate === "string" && typeof data_type.parse_string === "function") {
                const parsed = data_type.parse_string(candidate);
                if (parsed !== void 0 && data_type.validate(parsed)) {
                  return validation_success(candidate, parsed);
                }
              }
              return {
                validation: false,
                value: candidate
              };
            };
            data_value.transform_validate_value = transform_data_type_value;
            return;
          }
          const {
            wrap_properties,
            property_names,
            property_data_types,
            wrap_value_inner_values,
            value_js_type,
            abbreviated_property_names,
            named_property_access,
            numbered_property_access,
            parse_string
          } = data_type;
          let num_properties;
          if (property_names && property_data_types) {
            if (property_names.length === property_data_types.length) {
              num_properties = property_names.length;
              if (numbered_property_access) {
              }
            }
          } else if (property_names) {
            num_properties = property_names.length;
          }
          let _current_immutable_value, _previous_immutable_value;
          let prev_outer_value, current_outer_value;
          let _numbered_property_access_has_been_set_up = false, _named_property_access_has_been_set_up = false;
          Object.defineProperty(data_value, "value", {
            get() {
              return local_js_value;
            },
            set(value2) {
              const immu = data_value.toImmutable();
              const value_equals_current = immu.equals(value2);
              if (value_equals_current) {
              } else {
                const passed_first_validation = data_type.validate(value2);
                let passed_validation = passed_first_validation;
                if (!passed_first_validation) {
                  const t_value = tof(value2);
                  if (t_value === "string" && data_type.parse_string) {
                    const parsed_value = data_type.parse_string(value2);
                    if (parsed_value !== void 0) {
                      if (data_type.validate(parsed_value)) {
                        if (!immu.equals(parsed_value)) {
                          value2 = parsed_value;
                          passed_validation = true;
                        }
                      }
                    }
                  }
                }
                if (passed_validation) {
                  data_value.raise("validate", {
                    valid: true,
                    value: value2
                  });
                } else {
                  data_value.raise("validate", {
                    valid: false,
                    value: value2
                  });
                }
                if (passed_validation) {
                  const do_actual_set = (value3) => {
                    const array_specific_value_processing = () => {
                      if (value_js_type === Array) {
                        let t = tof(local_js_value);
                        if (t === "undefined") {
                          const create_array_with_wrapped_items = () => {
                            if (num_properties) {
                              if (wrap_value_inner_values) {
                                if (property_data_types) {
                                  let i = 0;
                                  if (value3.__immutable) {
                                    const l2 = value3.length;
                                    const arr_wrapped_value_values = new Array(l2);
                                    const value_value = value3.value;
                                    do_actual_set(value_value);
                                  } else {
                                    if (value3 instanceof Data_Value) {
                                      const arr_wrapped_value_values = new Array(num_properties);
                                      const arr_dv_value = value3.value;
                                      console.log("arr_dv_value", arr_dv_value);
                                      console.trace();
                                      throw "stop";
                                    } else if (is_array(value3)) {
                                      const arr_wrapped_value_values = value3.map((value4) => {
                                        const property_index = i;
                                        let property_name;
                                        if (property_names) {
                                          property_name = property_names[property_index];
                                        }
                                        const wrapped_value = new Data_Value({ context, value: value4, data_type: property_data_types[i] });
                                        wrapped_value.on("change", (e) => {
                                          const { name } = e;
                                          if (name === "value") {
                                            current_outer_value = data_value.toImmutable();
                                            const my_e2 = {
                                              name,
                                              event_originator: wrapped_value,
                                              parent_event: e,
                                              value: current_outer_value
                                            };
                                            if (property_name) {
                                              my_e2.property_name = property_name;
                                            }
                                            my_e2.property_index = property_index;
                                            data_value.raise("change", my_e2);
                                            prev_outer_value = current_outer_value;
                                          }
                                        });
                                        i++;
                                        return wrapped_value;
                                      });
                                      local_js_value = arr_wrapped_value_values;
                                      const my_e = {
                                        name: "value",
                                        old: _previous_immutable_value,
                                        value: data_value.toImmutable()
                                      };
                                      data_value.raise("change", my_e);
                                    }
                                  }
                                } else {
                                  let i = 0;
                                  const arr_wrapped_value_values = value3.map((value4) => {
                                    const property_index = i;
                                    let property_name;
                                    if (property_names) {
                                      property_name = property_names[property_index];
                                    }
                                    const wrapped_value = new Data_Value({ context, value: value4 });
                                    wrapped_value.on("change", (e) => {
                                      const { name } = e;
                                      if (name === "value") {
                                        const my_e = {
                                          name,
                                          event_originator: wrapped_value,
                                          parent_event: e,
                                          value: data_value.toImmutable()
                                        };
                                        if (property_name) {
                                          my_e.property_name = property_name;
                                        }
                                        my_e.property_index = property_index;
                                        data_value.raise("change", my_e);
                                      }
                                    });
                                    i++;
                                    return wrapped_value;
                                  });
                                  local_js_value = arr_wrapped_value_values;
                                }
                              } else {
                                local_js_value = value3;
                              }
                            } else {
                              console.trace();
                              throw "stop - number of properties not found";
                            }
                          };
                          create_array_with_wrapped_items();
                        } else if (t === "array") {
                          const t_value = tof(value3);
                          if (t_value === "data_value") {
                            if (is_array(value3.value)) {
                              if (value3.value.length === local_js_value.length) {
                                each(value3.value, (inner_value, idx) => {
                                  if (inner_value instanceof Data_Model) {
                                    const matching_local_inner_value = local_js_value[idx];
                                    if (inner_value.equals(matching_local_inner_value)) {
                                    } else {
                                      matching_local_inner_value.value = inner_value;
                                    }
                                  } else {
                                    console.trace();
                                    throw "NYI";
                                  }
                                });
                              } else {
                                console.trace();
                                throw "NYI";
                              }
                            } else {
                              console.trace();
                              throw "NYI";
                            }
                          } else {
                            if (t_value === "array") {
                              if (local_js_value.length === value3.length) {
                                const l2 = value3.length;
                                let all_local_js_items_are_data_model = true, c2 = 0;
                                do {
                                  const local_item = local_js_value[c2];
                                  if (!(local_item instanceof Data_Model)) {
                                    all_local_js_items_are_data_model = false;
                                  }
                                  c2++;
                                } while (all_local_js_items_are_data_model && c2 < l2);
                                if (all_local_js_items_are_data_model) {
                                  let c3 = 0;
                                  do {
                                    const local_item = local_js_value[c3];
                                    local_item.value = value3[c3];
                                    c3++;
                                  } while (c3 < l2);
                                } else {
                                  console.trace();
                                  throw "NYI";
                                }
                              } else {
                                console.trace();
                                throw "NYI";
                              }
                            } else {
                              console.log("value", value3);
                              console.trace();
                              throw "NYI";
                            }
                          }
                        } else {
                        }
                      } else {
                      }
                    };
                    array_specific_value_processing();
                    const general_value_processing = () => {
                      if (local_js_value instanceof Base_Data_Value) {
                        console.log("existing local_js_value instanceof Data_Value");
                        console.log("local_js_value.value", local_js_value.value);
                        console.log("local_js_value.data_type.name", local_js_value.data_type.name);
                        console.trace();
                        throw "NYI";
                      } else if (local_js_value instanceof Array) {
                        if (value3 instanceof Data_Model) {
                          if (value3.equals(local_js_value)) {
                          } else {
                            console.log("value", value3);
                            console.log("local_js_value", local_js_value);
                            console.trace();
                            throw "NYI";
                          }
                        } else if (value3 instanceof Array) {
                          if (property_names.length === value3.length) {
                            if (property_data_types) {
                              const num_properties2 = property_names.length;
                              for (let i_property = 0; i_property < num_properties2; i_property++) {
                                const name = property_names[i_property];
                                const data_type2 = property_data_types[i_property];
                                if (local_js_value[i_property] instanceof Data_Value) {
                                  local_js_value[i_property].value = value3[i_property];
                                } else {
                                  console.trace();
                                  throw "NYI";
                                }
                              }
                              if (numbered_property_access && !_numbered_property_access_has_been_set_up) {
                                for (let i_property = 0; i_property < num_properties2; i_property++) {
                                  const name = property_names[i_property];
                                  const data_type2 = property_data_types[i_property];
                                  Object.defineProperty(data_value, i_property, {
                                    get() {
                                      return local_js_value[i_property];
                                    },
                                    set(value4) {
                                      const item_already_there = local_js_value[i_property];
                                      if (item_already_there instanceof Data_Model) {
                                        item_already_there.value = value4;
                                      } else {
                                        console.log("item_already_there", item_already_there);
                                        console.trace();
                                        throw "stop";
                                      }
                                      if (value4 instanceof Data_Model) {
                                      } else {
                                      }
                                    }
                                  });
                                }
                                Object.defineProperty(data_value, "length", {
                                  get() {
                                    return local_js_value.length;
                                  }
                                });
                                _numbered_property_access_has_been_set_up = true;
                              }
                              if (named_property_access && !_named_property_access_has_been_set_up) {
                                if (numbered_property_access) {
                                  if (property_names) {
                                    for (let i_property = 0; i_property < num_properties2; i_property++) {
                                      const name = property_names[i_property];
                                      const data_type2 = property_data_types[i_property];
                                      Object.defineProperty(data_value, name, {
                                        get() {
                                          return local_js_value[i_property];
                                        },
                                        set(value4) {
                                          const item_already_there = local_js_value[i_property];
                                          if (item_already_there instanceof Data_Model) {
                                            item_already_there.value = value4;
                                          } else {
                                            console.log("item_already_there", item_already_there);
                                            console.trace();
                                            throw "stop";
                                          }
                                        }
                                      });
                                    }
                                  }
                                  if (abbreviated_property_names) {
                                    for (let i_property = 0; i_property < num_properties2; i_property++) {
                                      const name = abbreviated_property_names[i_property];
                                      const data_type2 = property_data_types[i_property];
                                      Object.defineProperty(data_value, name, {
                                        get() {
                                          return local_js_value[i_property];
                                        },
                                        set(value4) {
                                          const item_already_there = local_js_value[i_property];
                                          if (item_already_there instanceof Data_Model) {
                                            item_already_there.value = value4;
                                          } else {
                                            console.log("item_already_there", item_already_there);
                                            console.trace();
                                            throw "stop";
                                          }
                                          if (value4 instanceof Data_Model) {
                                          } else {
                                          }
                                        }
                                      });
                                    }
                                  }
                                }
                                _named_property_access_has_been_set_up = true;
                              }
                            }
                          } else {
                            console.trace();
                            throw "NYI";
                          }
                        } else {
                          console.log("value", value3);
                          console.log("local_js_value", local_js_value);
                          console.log("value_equals_current", value_equals_current);
                          console.log("immu", immu);
                          console.trace();
                          throw "NYI";
                        }
                      } else {
                        if (value3 instanceof Data_Model) {
                          if (value3.data_type === data_value.data_type) {
                            const tvv = tof(value3.value);
                            if (tvv === "number" || tvv === "string" || tvv === "boolean") {
                              local_js_value = value3.value;
                            } else {
                              console.trace();
                              throw "NYI";
                            }
                          } else {
                            console.trace();
                            throw "NYI";
                          }
                        } else {
                          local_js_value = value3;
                        }
                        data_value.raise("change", {
                          name: "value",
                          old: immu,
                          value: value3
                        });
                        prev_outer_value = current_outer_value;
                      }
                    };
                    general_value_processing();
                  };
                  do_actual_set(value2);
                } else {
                }
              }
            }
          });
        };
        if (data_type === String) {
          define_string_value_property();
        } else if (data_type === Number) {
          define_number_value_property();
        } else if (is_functional_data_type(data_type)) {
          define_data_type_typed_value_property();
        } else {
          console.trace();
          throw "NYI";
        }
      };
      module.exports = setup_data_value_data_type_set;
    }
  });

  // ../lang-tools/Data_Model/new/Data_Value.js
  var require_Data_Value = __commonJS({
    "../lang-tools/Data_Model/new/Data_Value.js"(exports, module) {
      var jsgui = require_lib_lang_mini();
      var { more_general_equals } = require_tools();
      var Base_Data_Value = require_Base_Data_Value();
      var Value_Set_Attempt = require_Value_Set_Attempt();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var Immutable_Data_Value = require_Immutable_Data_Value();
      var { is_defined, input_processors, tof, each, is_array, Data_Type } = jsgui;
      var setup_data_value_data_type_set = require_setup_data_value_data_type_set();
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var lpurple = (x) => "\x1B[38;5;129m" + x + "\x1B[0m";
      var Data_Value2 = class _Data_Value extends Base_Data_Value {
        constructor(spec = {}) {
          const spec_is_plain_object = spec !== null && typeof spec === "object" && !Array.isArray(spec);
          const actual_spec = spec_is_plain_object ? spec : { value: spec };
          super(actual_spec);
          const initial_value_is_present = Object.prototype.hasOwnProperty.call(actual_spec, "value");
          const initial_value = initial_value_is_present ? actual_spec.value : void 0;
          const { data_type } = this;
          if (data_type) {
            setup_data_value_data_type_set(this, data_type);
            if (initial_value_is_present && is_defined(initial_value)) {
              this.value = initial_value;
            }
          } else {
            if (initial_value_is_present) {
              this.value = actual_spec.value;
            }
          }
          const attempt_set_value = this.attempt_set_value = (value2) => {
            const get_local_js_value_copy = () => {
              const lv = this.value;
              const tljsv = tof(lv);
              if (tljsv === "undefined" || tljsv === "string" || tljsv === "number" || tljsv === "array" || tljsv === "object" || tljsv === "data_value") {
                return lv;
              } else {
                return lv;
              }
            };
            const old_local_js_value = get_local_js_value_copy();
            const old_equals_new = more_general_equals(old_local_js_value, value2);
            if (old_equals_new === true) {
              return new Value_Set_Attempt({ success: false, equal_values: true });
            }
            try {
              this.value = value2;
            } catch (error2) {
              return new Value_Set_Attempt({ success: false, value: old_local_js_value, error: error2 });
            }
            const new_local_js_value = get_local_js_value_copy();
            const changed = !more_general_equals(old_local_js_value, new_local_js_value);
            return new Value_Set_Attempt({
              success: changed,
              old: old_local_js_value,
              value: new_local_js_value
            });
          };
          this.__type = "data_value";
          this._relationships = {};
        }
        toImmutable() {
          const { context: context2, data_type, value: value2 } = this;
          const res2 = new Immutable_Data_Value({
            context: context2,
            data_type,
            value: value2
          });
          return res2;
        }
        "toObject"() {
          return this._;
        }
        "set"(val) {
          this.value = val;
        }
        "get"() {
          return this.value;
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        "toString"() {
          return this.get() + "";
        }
        "toJSON"() {
          const t_value = tof(this.value);
          if (t_value === "string") {
            return JSON.stringify(this.value);
          } else if (t_value === "number") {
            return this.value + "";
          } else if (t_value === "boolean") {
            this.value ? "true" : "false";
          } else if (t_value === "array") {
            return JSON.stringify(this.value);
          } else if (t_value === "data_value") {
            return this.value.toJSON();
          } else if (t_value === "undefined") {
            return "null";
          } else if (t_value === "null") {
            return "null";
          } else {
            console.log("toJSON this.value", this.value);
            console.log("t_value", t_value);
            console.trace();
            throw "NYI";
          }
        }
        "clone"() {
          console.trace();
          throw "NYI";
          var res2 = new _Data_Value({
            "value": this._
          });
          return res2;
        }
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
            return this.__id;
          }
          return void 0;
        }
      };
      var ensure_sync_state = (data_value) => {
        if (!data_value.__sync_state) {
          Object.defineProperty(data_value, "__sync_state", {
            value: {
              updatingFrom: /* @__PURE__ */ new Set()
            },
            enumerable: false
          });
        }
        return data_value.__sync_state;
      };
      var has_defined_value = (data_value) => typeof data_value.value !== "undefined";
      var copy_initial_value = (from, to) => {
        const source_state = ensure_sync_state(from);
        source_state.updatingFrom.add(to);
        try {
          to.value = from.value;
        } finally {
          source_state.updatingFrom.delete(to);
        }
      };
      var propagate_sync_value = (source, target) => {
        source.on("change", (e) => {
          if (e.name !== "value") {
            return;
          }
          const { updatingFrom } = ensure_sync_state(target);
          if (updatingFrom.has(source)) {
            return;
          }
          updatingFrom.add(source);
          try {
            target.value = e.value;
          } finally {
            updatingFrom.delete(source);
          }
        });
      };
      var align_initial_values = (a, b) => {
        const a_has_value = has_defined_value(a);
        const b_has_value = has_defined_value(b);
        if (a_has_value && !b_has_value) {
          copy_initial_value(a, b);
        } else if (!a_has_value && b_has_value) {
          copy_initial_value(b, a);
        }
      };
      Data_Value2.sync = (a, b) => {
        if (a instanceof Base_Data_Value && b instanceof Base_Data_Value) {
          propagate_sync_value(a, b);
          propagate_sync_value(b, a);
          align_initial_values(a, b);
        } else {
          console.trace();
          throw "Unexpected types";
        }
      };
      if (util) {
        Data_Value2.prototype[util.inspect.custom] = function(depth, opts) {
          const { value: value2 } = this;
          const tv = tof(value2);
          if (tv === "number" || tv === "string" || tv === "boolean") {
            return lpurple(value2);
          } else {
            if (value2 instanceof Array) {
              let res2 = lpurple("[ ");
              let first = true;
              each(value2, (item2) => {
                if (!first) {
                  res2 = res2 + lpurple(", ");
                } else {
                  first = false;
                }
                if (item2 instanceof Data_Model) {
                  const item_value = item2.value;
                  res2 = res2 + lpurple(item_value);
                } else [
                  res2 = res2 + lpurple(item2)
                ];
              });
              res2 = res2 + lpurple(" ]");
              return res2;
            } else if (value2 instanceof Data_Model) {
              return value2[util.inspect.custom]();
            } else {
              return lpurple(this.value);
            }
          }
        };
      }
      module.exports = Data_Value2;
    }
  });

  // ../lang-tools/Data_Model/Mini_Context.js
  var require_Mini_Context = __commonJS({
    "../lang-tools/Data_Model/Mini_Context.js"(exports, module) {
      var Mini_Context = class {
        // Need quite a simple mechanism to get IDs for objects.
        // They will be typed objects/
        constructor(spec) {
          const map_typed_counts = /* @__PURE__ */ Object.create(null);
          this.new_id = (str_type = "item") => {
            const current = map_typed_counts[str_type] || 0;
            map_typed_counts[str_type] = current + 1;
            return `${str_type}_${current}`;
          };
        }
        "make"(abstract_object) {
          if (abstract_object._abstract) {
            var constructor = abstract_object.constructor;
            var aos = abstract_object._spec;
            aos.abstract = null;
            aos.context = this;
            var res2 = new constructor(aos);
            return res2;
          } else {
            throw "Object must be abstract, having ._abstract == true";
          }
        }
      };
      module.exports = Mini_Context;
    }
  });

  // ../lang-tools/Data_Model/new/Data_Object.js
  var require_Data_Object = __commonJS({
    "../lang-tools/Data_Model/new/Data_Object.js"(exports, module) {
      var jsgui = require_lib_lang_mini();
      var { each, tof, is_defined, get_a_sig, ll_get } = jsgui;
      var Mini_Context = require_Mini_Context();
      var Data_Model = require_Data_Model();
      var Data_Value2 = require_Data_Value();
      jsgui.__data_id_method = "init";
      var Data_Object = class extends Data_Model {
        constructor(spec = {}, fields) {
          super(spec);
          this._ = this._ || {};
          if (spec.id) {
            this.__id = spec.id;
          }
          if (spec.__id) {
            this.__id = spec.__id;
          }
          this.__type_name = spec.__type_name || "data_object";
          if (fields) this.set_fields_from_spec(fields, spec);
          this.__data_object = true;
          if (spec.abstract === true) {
            this._abstract = true;
            var tSpec = tof(spec);
            if (tSpec == "function") {
              this._type_constructor = spec;
            } else if (tSpec == "object") {
              this._spec = spec;
            }
          } else {
            var t_spec = tof(spec);
            this.__type = "data_object";
            if (t_spec === "object" || t_spec === "control") {
              if (spec.context) {
                this.context = spec.context;
              }
              if (spec.id) {
                this.__id = spec.id;
              }
              if (spec._id) {
                this.__id = spec._id;
              }
              if (spec.__id) {
                this.__id = spec.__id;
              }
            } else if (t_spec == "data_object") {
              if (spec.context) this.context = spec.context;
            }
            if (is_defined(spec.parent)) {
              this.parent = spec.parent;
            }
            if (this.context) {
              this.init_default_events();
            }
            const reserved_keys = {
              "context": true,
              "id": true,
              "_id": true,
              "__id": true,
              "parent": true,
              "__type": true,
              "__type_name": true,
              "abstract": true,
              "data_def": true,
              "load_array": true,
              "items": true,
              "fn_index": true,
              "constraint": true,
              "index_by": true,
              "accepts": true
            };
            if (t_spec === "object" && spec) {
              Object.keys(spec).forEach((key2) => {
                if (reserved_keys[key2] || key2.startsWith("__")) return;
                this.set(key2, spec[key2], true);
              });
            }
          }
        }
        "set_fields_from_spec"(fields, spec) {
          const normalized = [];
          if (Array.isArray(fields)) {
            each(fields, (field) => {
              if (Array.isArray(field)) {
                normalized.push(field);
              } else if (typeof field === "object" && field.name) {
                normalized.push([field.name, field.type, field.default]);
              }
            });
          } else if (typeof fields === "object") {
            each(fields, (val, key2) => {
              if (Array.isArray(val)) {
                normalized.push([key2, val[0], val[1]]);
              } else {
                normalized.push([key2, val]);
              }
            });
          }
          each(normalized, (field) => {
            const field_name = field[0];
            const field_default = field[2];
            let value_to_set;
            if (spec && typeof spec[field_name] !== "undefined") {
              value_to_set = spec[field_name];
            } else if (typeof field_default !== "undefined") {
              value_to_set = field_default;
            }
            if (typeof value_to_set !== "undefined") {
              if (typeof this.set === "function") {
                this.set(field_name, value_to_set, true);
              } else {
                this._[field_name] = value_to_set;
              }
            }
          });
        }
        "init_default_events"() {
        }
        /*
             'data_def': fp(function(a, sig) {
             if (sig == '[o]') {
             // create the new data_def constraint.
        
        
             }
             }),
             */
        "keys"() {
          return Object.keys(this._);
        }
        // fromJSON
        "toJSON"() {
          var res2 = [];
          res2.push("Data_Object(" + JSON.stringify(this._) + ")");
          return res2.join("");
        }
        // using_fields_connection()
        //  will search up the object heirachy, to see if the Data_Objects fields need to be connected through the use of functions.
        //  that will make the fields easy to change by calling a function. Should make things much faster to access than when programming with Backbone.
        // then will connect the fields with connect_fields()
        /*
        'using_fields_connection'() {
            var res = false;
            iterate_ancestor_classes(this.constructor, function (a_class, stop) {
                if (is_defined(a_class._connect_fields)) {
                    res = a_class._connect_fields;
                    stop();
                }
            });
            return res;
        }
        */
        // using _relationships or whatever
        get parent() {
          return this._parent;
        }
        set parent(value2) {
          return this._parent = value2;
        }
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (this._abstract) {
              return void 0;
            } else if (!is_defined(this.__id)) {
              return void 0;
            }
          }
          return this.__id;
        }
        // Problems with name (fields).
        //  Fields are given as a description of the fields.
        //   Gets more complicated when we have a function to access the fields as well.
        //   What if we want to override that function?
        // Will call it field
        //  18/12/2016 - Getting rid of this confusion, will mostly remove / greatly simplify field functionality.
        //  Just need to know which fields any class has, keeping track of this will use some data structures like Sorted_KVS,
        //   but not much complex code within this part.
        // Not so sure what a field function will do right now.
        //  Does not seem like such an essential part of the API.
        //   Can just define the fields, then they act a bit differently.
        //   Have field handling in Data_Object.
        //   Collection would have the same field capabilities. Fields should not be so important anyway.
        // 18/12/2016 Will remove constraints, then make them much more functional.
        //  Go through the keys....
        "each"(callback2) {
          each(this._, callback2);
        }
        // could make this polymorphic so that it
        //   sibling_index I think.
        "position_within"(parent) {
          var p_id = parent._id();
          if (this._parents && is_defined(this._parents[p_id])) {
            var parent_rel_info = this._parents[p_id];
            var pos_within = parent_rel_info[1];
            return pos_within;
          }
        }
        // Maybe just 'remove' function.
        //  This may be needed with multiple parents, which are not being used at the moment.
        // ???? late 2023
        "remove_from"(parent) {
          var p_id = parent._id();
          if (this._parents && is_defined(this._parents[p_id])) {
            var parent = this._parents[p_id][0];
            var pos_within = this._parents[p_id][1];
            var item2 = parent._arr[pos_within];
            parent.remove(pos_within);
            delete this._parents[p_id];
          }
        }
        //  
        // Maybe only do this with the fields anyway
        "load_from_spec"(spec, arr_item_names) {
          console.trace();
          throw "Deprecated in new Data_Object version";
          each(arr_item_names, (v) => {
            var spec_item = spec[v];
            if (is_defined(spec_item)) {
              this.set(v, spec_item);
            }
          });
        }
        // They will be treated as values in many cases anyway.
        //  Will turn them to different types of object where possible.
        /*
            'value'() {
                var a = arguments; a.l = arguments.length; var sig = get_a_sig(a, 1);
                // could operate like both get and set, but does not return data_objects, returns the value itself.
                var name;
                //var res;
                if (sig === '[s]') {
                    name = a[0];
                    var possibly_dobj = this.get(name);
                    //var t_obj = tof(possibly_dobj);
        
                    if (possibly_dobj) {
                        if (possibly_dobj.value && typeof possibly_dobj.value === 'function') {
                            return possibly_dobj.value();
                        } else {
                            return possibly_dobj;
                        }
                    }
                }
            }
            */
        // Get could be greatly simplified as well.
        //  Input and output processing will be more streamlined in a functional way.
        // 19/12/2016 - Not using get or set nearly as much anyway.
        "get"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          var do_typed_processing = false;
          if (do_typed_processing) {
            if (a.l === 0) {
              var output_obj = jsgui.output_processors[this.__type_name](this._);
              return output_obj;
            } else {
              console.log("a", a);
              console.trace();
              throw "not yet implemented";
            }
          } else {
            if (sig == "[s,f]") {
              throw "Asyncronous access not allowed on Data_Object get.";
              var res2 = this.get(a[0]);
              var callback2 = a[1];
              if (typeof res2 == "function") {
                res2(callback2);
              } else {
                return res2;
              }
            } else if (sig == "[s]") {
              var res2 = ll_get(this, a[0]);
              return res2;
            } else if (a.l === 0) {
              return this._;
            }
          }
        }
        "ensure_data_value"(property_name, default_value) {
          if (this._abstract) return void 0;
          if (!property_name || typeof property_name !== "string") throw "property_name expected: string";
          if (property_name.indexOf(".") > -1 && property_name !== ".") throw "ensure_data_value does not support dotted paths (yet)";
          const has_key = this._ && Object.prototype.hasOwnProperty.call(this._, property_name);
          const existing = has_key ? this._[property_name] : void 0;
          if (existing && existing.__data_value) return existing;
          const initial_value = has_key ? existing : default_value;
          const dv = new Data_Value2({
            value: initial_value
          });
          this._[property_name] = dv;
          return dv;
        }
        // Or don't use / support get and set for the moment?
        //   Only use property / field access?
        //   Define property, with getter and setter, seems like a more cleanly defined system.
        // May see about making a new simplified implementation of this and running it through tests.
        //   Though the new Data_Value seems like the more appropriate way for the moment.
        // May look into seeing where Data_Value is used in the current system too.
        //   Could see about further incorportating its use (in places).
        //'set': fp(function(a, sig) {
        "set"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (this._abstract) return false;
          var that2 = this, res2;
          var input_processors = jsgui.input_processors;
          if (a.l === 2 || a.l === 3) {
            var property_name = a[0], value2 = a[1];
            var ta2 = tof(a[2]);
            var silent = false;
            var source;
            if (ta2 == "string" || ta2 == "boolean") {
              silent = a[2];
            }
            if (ta2 == "control") {
              source = a[2];
            }
            if (!this._initializing && this._map_read_only && this._map_read_only[property_name]) {
              throw 'Property "' + property_name + '" is read-only.';
            } else {
              var split_pn = property_name.split(".");
              if (split_pn.length > 1 && property_name != ".") {
                var spn_first = split_pn[0];
                var spn_arr_next = split_pn.slice(1);
                var data_object_next = this.get(spn_first);
                if (data_object_next) {
                  res2 = data_object_next.set(spn_arr_next.join("."), value2);
                  if (!silent) {
                    const bubbled_stored = this.get(property_name);
                    var e_change = {
                      "name": property_name,
                      // Back-compat: bubbled events historically provided the input value.
                      "value": value2,
                      // MVVM-friendly additions:
                      "data_value": bubbled_stored && bubbled_stored.__data_value ? bubbled_stored : void 0,
                      "raw_value": bubbled_stored && bubbled_stored.__data_value ? bubbled_stored.value : bubbled_stored && typeof bubbled_stored.value === "function" ? bubbled_stored.value() : value2,
                      "bubbled": true
                    };
                    if (source) {
                      e_change.source = source;
                    }
                    this.raise_event("change", e_change);
                  }
                } else {
                  throw "No data object at this level.";
                }
              } else {
                var data_object_next = this.get(property_name);
                const had_existing = is_defined(data_object_next) && data_object_next !== null;
                const incoming_is_node = value2 && (value2.__data_object || value2.__data_value || value2.__data_grid);
                const existing_is_data_value = data_object_next && data_object_next.__data_value;
                const existing_is_data_object = data_object_next && data_object_next.__data_object;
                const incoming_t = tof(value2);
                let stored;
                if (existing_is_data_value) {
                  data_object_next.set(value2);
                  stored = data_object_next;
                  res2 = data_object_next;
                } else if (existing_is_data_object && incoming_t === "object" && value2 !== null && !incoming_is_node && incoming_t !== "array") {
                  data_object_next.set(value2);
                  stored = data_object_next;
                  res2 = data_object_next;
                } else {
                  if (incoming_is_node) {
                    stored = value2;
                  } else {
                    if (!had_existing) {
                      stored = this.ensure_data_value(property_name);
                      stored.set(value2);
                    } else {
                      stored = value2;
                    }
                  }
                  this._[property_name] = stored;
                  res2 = stored;
                }
                if (!silent) {
                  var e_change = {
                    "name": property_name,
                    // Back-compat: historically sometimes emitted Data_Value (when creating) and sometimes raw JS value (when updating).
                    "value": !had_existing ? stored : stored && stored.__data_value ? stored.value : stored && typeof stored.value === "function" ? stored.value() : stored,
                    // MVVM-friendly additions:
                    "data_value": stored && stored.__data_value ? stored : void 0,
                    "raw_value": stored && stored.__data_value ? stored.value : stored && typeof stored.value === "function" ? stored.value() : stored
                  };
                  if (source) {
                    e_change.source = source;
                  }
                  this.raise_event("change", e_change);
                }
                return had_existing ? res2 : value2;
              }
            }
          } else {
            var value2 = a[0];
            var property_name = a[1];
            var input_processor = input_processors[this.__type_name];
            if (input_processor) {
              var processed_input = input_processor(value2);
              value2 = processed_input;
              this._[property_name] = value2;
              this.raise_event("change", {
                "value": value2
              });
              return value2;
            } else {
              if (sig === "[D]") {
                this._[property_name] = value2;
                this.raise_event("change", [property_name, value2]);
                return value2;
              } else if (sig === "[o]") {
                res2 = {};
                each(a[0], function(v, i) {
                  res2[i] = that2.set(i, v);
                });
                return res2;
              } else if (sig === "[c]") {
                this._[property_name] = value2;
                this.raise_event("change", [property_name, value2]);
                return value2;
              }
            }
          }
        }
        "has"(property_name) {
          return is_defined(this.get(property_name));
        }
      };
      jsgui.map_classes = jsgui.map_classes || {};
      var dobj = (obj2, data_def) => {
        var cstr = Data_Object;
        var res2;
        if (data_def) {
          res2 = new cstr({
            "data_def": data_def
          });
        } else {
          res2 = new cstr({});
        }
        var tobj = tof(obj2);
        if (tobj == "object") {
          var res_set = res2.set;
          each(obj2, (v, i) => {
            res_set.call(res2, i, v);
          });
        }
        return res2;
      };
      Data_Object.dobj = dobj;
      Data_Object.Mini_Context = Mini_Context;
      module.exports = Data_Object;
    }
  });

  // ../lang-tools/sorted-kvs.js
  var require_sorted_kvs = __commonJS({
    "../lang-tools/sorted-kvs.js"(exports, module) {
      var jsgui = require_lib_lang_mini();
      var mapify = jsgui.mapify;
      var B_Plus_Tree = require_b_plus_tree();
      var Sorted_KVS = class {
        constructor(spec) {
          spec = spec || {};
          if (typeof spec.unique_keys !== "undefined") this.unique_keys = spec.unique_keys;
          this.tree = B_Plus_Tree(12);
        }
        "clear"() {
          this.tree.clear();
        }
        /*
        	'put': mapify(function (key, value) {
        		// inserting a bunch of things at once... could that be done more efficiently, such as in one traversal?
        		//  sort the items, then can skip through the tree a bit quicker?
        
        
        		var insert_res = this.tree.insert(key, value);
        		// with tree.insert - nice if we can keep the treenode as a result.
        		//  the tree does not store objects in the node.
        		//   could make the tree node hold a reference to the object?
        
        		//console.log('put insert_res ' + insert_res);
        		//this.dict[key] = value;
        	}),
        	*/
        "out"(key2) {
          this.tree.remove(key2);
        }
        "get"(key2) {
          return this.tree.get_values_by_key(key2);
        }
        "has"(key2) {
          return this.key_count(key2) > 0;
        }
        "get_cursor"() {
        }
        "keys"() {
          return this.tree.keys();
        }
        "keys_and_values"() {
          return this.tree.keys_and_values();
        }
        /*
        	 'values': function() {
        	 var keys = this.keys();
        	 var res = [];
        	 var that = this;
        	 console.log('keys.length ' + keys.length );
        	 console.log('keys ' + jsgui.stringify(keys));
        
        	 each(keys, function(i, v) {
        	 res.push(that.dict[v]);
        	 });
        	 return res;
        	 },
        	 */
        "key_count"(key2) {
          if (typeof key2 !== "undefined") {
            return this.tree.count(key2);
          } else {
            return this.tree.count();
          }
        }
        "get_keys_by_prefix"(prefix) {
          return this.tree.get_keys_by_prefix(prefix);
        }
        "each"(callback2) {
          return this.tree.each(callback2);
        }
        "get_by_prefix"(prefix) {
          return this.tree.get_by_prefix(prefix);
        }
      };
      Sorted_KVS.prototype.put = mapify(function(key2, value2) {
        var insert_res = this.tree.insert(key2, value2);
      });
      module.exports = Sorted_KVS;
    }
  });

  // ../lang-tools/Data_Model/new/Collection.js
  var require_Collection = __commonJS({
    "../lang-tools/Data_Model/new/Collection.js"(exports, module) {
      var lang = require_lib_lang_mini();
      var Data_Value2 = require_Data_Value();
      var Data_Object = require_Data_Object();
      var Sorted_KVS = require_sorted_kvs();
      var dobj = Data_Object.dobj;
      var Constraint = Data_Object.Constraint;
      var each = lang.each;
      var tof = lang.tof;
      var is_defined = lang.is_defined;
      var stringify = lang.stringify;
      var get_a_sig = lang.get_a_sig;
      var native_constructor_tof = lang.native_constructor_tof;
      var dop = Data_Object.prototype;
      var Collection = class _Collection extends Data_Object {
        constructor(spec = {}, arr_values) {
          super(spec);
          this.__type = "collection";
          this.__type_name = "collection";
          var t_spec = tof(spec);
          if (spec.abstract === true) {
            if (t_spec === "function") {
              this.constraint(spec);
            }
          } else {
            this._relationships = this._relationships || {};
            this._arr_idx = 0;
            this._arr = [];
            this.index = new Sorted_KVS();
            this.fn_index = spec.fn_index;
            if (t_spec === "array") {
              spec = {
                "load_array": spec
              };
            } else {
              if (t_spec === "function") {
                if (spec.abstract === true) {
                  this._abstract = true;
                } else {
                }
              } else if (t_spec === "string") {
                var map_native_constructors = {
                  "array": Array,
                  "boolean": Boolean,
                  "number": Number,
                  "string": String,
                  "object": Object
                };
                var nc = map_native_constructors[spec];
                if (nc) {
                  spec = {
                    "constraint": nc
                  };
                  if (nc == String) {
                    spec.index_by = "value";
                  }
                }
              }
            }
            if (is_defined(spec.items)) {
              spec.load_array = spec.load_array || spec.items;
            }
            if (arr_values) {
              spec.load_array = arr_values;
            }
            if (is_defined(spec.accepts)) {
              this._accepts = spec.accepts;
            }
            if (lang.__data_id_method === "init") {
              if (this.context) {
                this.__id = this.context.new_id(this.__type_name || this.__type);
                this.context.map_objects[this.__id] = this;
              } else {
              }
            }
            if (!this.__type) {
            }
            if (spec.load_array) {
              this.load_array(spec.load_array);
            }
          }
        }
        // maybe use fp, and otherwise apply with the same params and context.
        "set"(value2) {
          var tval = tof(value2);
          if (tval === "data_object" || tval === "data_value" || tval === "data_model") {
            this.clear();
            return this.push(value2);
          } else if (tval === "array") {
            this.clear();
            each(value2, (v, i) => {
              this.push(v);
            });
          } else {
            if (tval === "collection") {
              throw "stop";
              this.clear();
              value2.each(function(v, i) {
                that.push(v);
              });
            } else if (tval === "string" || tval === "number" || tval === "boolean" || tval === "null" || tval === "undefined") {
              this.clear();
              return this.push(value2);
            } else {
              const Data_Object2 = require_Data_Object();
              return Data_Object2.prototype.set.call(this, value2);
            }
          }
        }
        "clear"() {
          this._arr_idx = 0;
          this._arr = [];
          this.index.clear();
          this.raise("change", {
            "name": "clear"
          });
        }
        "stringify"() {
          var res2 = [];
          if (this._abstract) {
            var ncto = native_constructor_tof(this._type_constructor);
            res2.push("~Collection(");
            if (ncto) {
              res2.push(ncto);
            } else {
            }
            res2.push(")");
          } else {
            res2.push("Collection(");
            var first = true;
            this.each(function(v, i) {
              if (!first) {
                res2.push(", ");
              } else {
                first = false;
              }
              res2.push(stringify(v));
            });
            res2.push(")");
          }
          return res2.join("");
        }
        "toString"() {
          return stringify(this._arr);
        }
        "toObject"() {
          var res2 = [];
          this.each(function(v, i) {
            res2.push(v.toObject());
          });
          return res2;
        }
        "each"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig == "[f]") {
            return each(this._arr, a[0]);
          } else {
            if (sig == "[X,f]") {
              var index = a[0];
              var callback2 = a[1];
              return index.each(callback2);
            } else {
              if (a.l == 2) {
                return each(this._arr, a[0], a[1]);
              }
            }
          }
        }
        "_id"() {
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
          }
          return this.__id;
        }
        "length"() {
          return this._arr.length;
        }
        get len() {
          return this._arr.length;
        }
        "find"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (a.l == 1) {
            var pos = this.index.get(a[0])[0];
            var item2 = this._arr[pos];
            return item2;
          }
          if (sig == "[o,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[s,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[a,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[s,o]") {
            var propertyName = a[0];
            var query = a[1];
            var foundItems = [];
            each(this, (item3, index) => {
              if (item3.get) {
                var itemProperty = item3.get(propertyName);
              } else {
                var itemProperty = item3[propertyName];
              }
              var tip = tof(itemProperty);
              var tip2;
              var ip2;
              if (tip === "data_value") {
                var ip2 = itemProperty.value;
                tip2 = tof(ip2);
              } else {
                ip2 = itemProperty;
                tip2 = tip;
              }
              if (tip2 === "array") {
                each(ip2, (v, i) => {
                  var matches = obj_matches_query_obj(v, query);
                  if (matches) {
                    foundItems.push(v);
                  }
                });
              }
              ;
            });
            var res2 = new _Collection(foundItems);
            return res2;
          }
        }
        // get seems like the way to get unique values.
        "get"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig == "[n]" || sig == "[i]") {
            return this._arr[a[0]];
          }
          if (sig == "[s]") {
            var ix_sys = this.index_system;
            var res2;
            if (ix_sys) {
              var pui = ix_sys._primary_unique_index;
              res2 = pui.get(a[0])[0];
            }
            if (res2) {
              return res2;
            }
            return Data_Object.prototype.get.apply(this, a);
          }
        }
        "insert"(item2, pos) {
          this._arr.splice(pos, 0, item2);
          this.raise("change", {
            "name": "insert",
            "item": item2,
            "value": item2,
            "pos": pos
          });
        }
        swap(item2, replacement) {
          let r_parent = replacement.parent;
          let repl_pos = replacement.parent.content.remove(replacement);
          let i_parent = item2.parent;
          let item_pos = item2.parent.content.remove(item2);
          let item_index;
          i_parent.content.insert(replacement, item_pos);
          r_parent.content.insert(item2, repl_pos);
        }
        // may have efficiencies for adding and removing multiple items at once.
        //  can be sorted for insertion into index with more rapid algorithmic time.
        "remove"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig === "[n]") {
            var pos = a[0];
            var item2 = this._arr[pos];
            var spliced_pos = pos;
            this._arr.splice(pos, 1);
            this._arr_idx--;
            var e = {
              "target": this,
              "value": item2,
              "position": spliced_pos,
              "name": "remove"
            };
            this.raise("change", e);
            return pos;
          } else if (sig === "[s]") {
            var key2 = a[0];
            var obj2 = this.index_system.find([
              ["value", key2]
            ]);
            var my_id = this.__id;
            var item_pos_within_this = obj2[0]._relationships[my_id];
            this._arr.splice(item_pos_within_this, 1);
            for (var c2 = item_pos_within_this, l2 = this._arr.length; c2 < l2; c2++) {
              var item2 = this._arr[c2];
              item2._relationships[my_id]--;
            }
            var e = {
              "target": this,
              "value": obj2[0],
              "position": item_pos_within_this,
              "name": "remove"
            };
            this.raise("change", e);
          } else {
            let item_index;
            const item3 = a[0];
            let arr = this._arr, l3 = arr.length;
            if (typeof item3 === "number") {
              item_index = item3;
            } else {
              let found = false, c3 = 0;
              while (!found && c3 < l3) {
                found = arr[c3] === item3;
                if (found) {
                  item_index = c3;
                }
                c3++;
              }
              if (is_defined(item_index)) {
                return this.remove(item_index);
              }
            }
          }
        }
        "has"(obj_key) {
          if (this.get_index(obj_key) === void 0) {
            return false;
          } else {
            return true;
          }
        }
        "get_index"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig === "[s]") {
            if (this.index_system) {
              return this.index_system.search(a[0]);
            } else {
              if (this._arr.length === 0) {
                return void 0;
              } else {
                for (let c2 = 0; c2 < this._arr.length; c2++) {
                  const item2 = this._arr[c2];
                  if ((item2 == null ? void 0 : item2.name) === a[0]) {
                    return c2;
                  }
                }
                return void 0;
              }
            }
          } else {
            console.trace();
            throw "Expected [s]";
          }
        }
        // More fp way of indexing.
        "index_by"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          console.log("Indexing not implemented (like this)");
          console.trace();
        }
        "push"(value2) {
          const { silent } = this;
          let tv = tof(value2);
          let fn_index = this.fn_index;
          let idx_key, has_idx_key = false, pos;
          if (fn_index) {
            idx_key = fn_index(value2);
            has_idx_key = true;
          }
          if (tv === "object" || tv === "function") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "data_value") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "collection") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "data_object" || tv === "control" || tv === "data_model") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "array") {
            const new_coll = new _Collection(value2);
            pos = this._arr.length;
            this._arr.push(new_coll);
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          }
          if (tv === "string" || tv === "number" || tv === "boolean" || tv === "null" || tv === "undefined") {
            const dv = new Data_Value2({
              "value": value2
            });
            pos = this._arr.length;
            this._arr.push(dv);
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          }
          if (has_idx_key) {
            this.index.put(idx_key, pos);
          }
          return value2;
        }
        "load_array"(arr) {
          for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
            this.push(arr[c2]);
          }
          this.raise("load");
        }
        "values"() {
          var a = arguments;
          a.l = a.length;
          if (a.l === 0) {
            return this._arr;
          } else {
            var stack = new Error().stack;
            throw "not yet implemented";
          }
        }
        "value"() {
          const res2 = [];
          this.each((v, i) => {
            if (v && typeof v.value !== "undefined") {
              res2.push(v.value);
            } else {
              res2.push(v);
            }
          });
          return res2;
        }
      };
      var p = Collection.prototype;
      p.add = function(value2) {
        return this.push(value2);
      };
      module.exports = Collection;
    }
  });

  // ../lang-tools/doubly-linked-list.js
  var require_doubly_linked_list = __commonJS({
    "../lang-tools/doubly-linked-list.js"(exports, module) {
      var Node = class {
        constructor(spec) {
          this.neighbours = spec.neighbours || [];
          this.value = spec.value;
        }
        "previous"() {
          return this.neighbours[0];
        }
        "next"() {
          return this.neighbours[1];
        }
      };
      var Doubly_Linked_List = class {
        constructor(spec) {
          this.first = null;
          this.last = null;
          this.length = 0;
        }
        "each_node"(callback2) {
          var node = this.first;
          var ctu = true;
          var stop = function() {
            ctu = false;
          };
          while (node && ctu) {
            callback2(node, stop);
            node = node.neighbours[1];
          }
        }
        "each"(callback2) {
          this.each_node(function(node, stop) {
            callback2(node.value, stop);
          });
        }
        "remove"(node) {
          if (node.neighbours[0]) {
            node.neighbours[0].neighbours[1] = node.neighbours[1];
          } else {
            this.first = node.neighbours[1];
          }
          if (node.neighbours[1]) {
            node.neighbours[1].neighbours[0] = node.neighbours[0];
          } else {
            this.last = node.neighbours[0];
          }
          node.neighbours = [];
          if (node.parent == this) {
            delete node.parent;
            this.length--;
          }
        }
        // check to see if the item is a 'node' object.
        //  if it is, can insert it as a node, otherwise create the node object and insert it.
        //   a bit like wrapping values in Data_Value.
        "insert_beginning"(val) {
          if (val instanceof Node) {
            if (this.first == null) {
              this.first = val;
              this.last = val;
              val.neighbours = [];
              if (val.parent != this) {
                val.parent = this;
                this.length++;
              }
            } else {
              this.insert_before(val, this.first);
            }
            return val;
          } else {
            var node = new Node({ "value": val });
            return this.insert_beginning(node);
          }
        }
        // could use a nodify function.
        //  or ensure_data_wrapper
        "insert_before"(val, node) {
          if (val instanceof Node) {
            val.neighbours = [node.neighbours[0], node];
            if (node.neighbours[0] == null) {
              this.first = val;
            } else {
              node.neighbours[0].neighbours[1] = val;
            }
            node.neighbours[0] = val;
            if (val.parent != this) {
              val.parent = this;
              this.length++;
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.insert_before(new_node, node);
          }
        }
        "insert_after"(val, node) {
          if (val instanceof Node) {
            val.neighbours = [node, node.neighbours[1]];
            if (node.neighbours[1] == null) {
              this.last = val;
            } else {
              node.neighbours[1].neighbours[0] = val;
            }
            node.neighbours[1] = val;
            if (val.parent != this) {
              val.parent = this;
              this.length++;
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.insert_after(new_node, node);
          }
        }
        // not wrapping the item in a node?
        // want one where we are not pushing nodes, but items stored in nodes.
        //  Perhaps this is a Data_Value?
        // Or a doubly_linked_node.
        // Doubly_Linked_Node could take the form [prev, item, next]
        //  [prev, item, key, next]? probably not
        //  Maybe we could put more private variables, such as 'neighbours' as a var within the init statement.
        "push"(val) {
          if (val instanceof Node) {
            if (this.last == null) {
              this.insert_beginning(val);
            } else {
              return this.insert_after(val, this.last);
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.push(new_node);
          }
        }
      };
      Doubly_Linked_List.Node = Node;
      module.exports = Doubly_Linked_List;
    }
  });

  // ../lang-tools/ordered-kvs.js
  var require_ordered_kvs = __commonJS({
    "../lang-tools/ordered-kvs.js"(exports, module) {
      var Doubly_Linked_List = require_doubly_linked_list();
      var Ordered_KVS = class {
        constructor() {
          this.dll = new Doubly_Linked_List();
          this.node_map = {};
        }
        "length"() {
          return this.dll.length;
        }
        "put"(key2, value2) {
          return this.push(key2, value2);
        }
        "get"(key2) {
          var kvs_node = this.node_map[key2];
          if (kvs_node) {
            return kvs_node.value;
          } else {
            return void 0;
          }
        }
        "push"(key2, value2) {
          var node = this.dll.push(value2);
          node.key = key2;
          this.node_map[key2] = node;
        }
        "out"(key2) {
          var node = this.node_map[key2];
          delete this.node_map[key2];
          this.dll.remove(node);
        }
        "each"(callback2) {
          this.dll.each_node(function(node, stop) {
            callback2(node.key, node.value, stop);
          });
        }
        "values"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push(value2);
          });
          return res2;
        }
        "keys"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push(key2);
          });
          return res2;
        }
        "keys_and_values"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push([key2, value2]);
          });
          return res2;
        }
        // will not need to deal with nodes on the user level.
        // want to be able to add and remove items, normally items will get pushed to the end of the list.
        // will provide a key and value in order to do this.
      };
      module.exports = Ordered_KVS;
    }
  });

  // ../lang-tools/ordered-string-list.js
  var require_ordered_string_list = __commonJS({
    "../lang-tools/ordered-string-list.js"(exports, module) {
      var Ordered_String_List = class {
        constructor() {
          var arr = [];
          var dict_indexes = {};
          var reindex_dict_indexes = function() {
            dict_indexes = {};
            for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
              dict_indexes[arr[c2]] = c2;
            }
          };
          this.has = function(value2) {
            return typeof dict_indexes[value2] !== "undefined";
          };
          this.put = function(value2) {
            if (this.has(value2)) {
            } else {
              var index = arr.length;
              arr.push(value2);
              dict_indexes[value2] = index;
            }
          };
          this.out = function(value2) {
            if (this.has(value2)) {
              var idx = dict_indexes[value2];
              arr.splice(idx, 1);
              delete dict_indexes[value2];
              for (var c2 = idx, l2 = arr.length; c2 < l2; c2++) {
                var i = arr[c2];
                dict_indexes[i]--;
              }
            }
          };
          this.toggle = function(value2) {
            if (this.has(value2)) {
              this.out(value2);
            } else {
              this.put(value2);
            }
          };
          this.move_value = function(value2, index) {
            if (this.has(value2) && dict_indexes[value2] != index) {
              var old_index = dict_indexes[value2];
              arr.splice(old_index, 1);
              arr.splice(index, 0, value2);
              if (index < old_index) {
                dict_indexes[arr[index]] = index;
                for (var c2 = index + 1; c2 <= old_index; c2++) {
                  dict_indexes[arr[c2]]++;
                }
              } else if (index > old_index) {
                dict_indexes[arr[index]] = index;
                for (var c2 = old_index; c2 < index; c2++) {
                  dict_indexes[arr[c2]]--;
                }
              }
            }
          };
          this._index_scan = function() {
            for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
              console.log("c " + c2 + " arr[c] " + arr[c2] + " idx " + dict_indexes[arr[c2]]);
            }
            ;
          };
          this.toString = function() {
            var res2 = arr.join(" ");
            return res2;
          };
          this.toString.stringify = true;
          this.set = (function(val) {
            if (typeof val === "string") {
              arr = val.split(" ");
              reindex_dict_indexes();
            }
          });
          var a = arguments;
          if (a.length == 1) {
            var spec = a[0];
            if (typeof spec === "string") {
              this.set(spec);
            }
          }
        }
      };
      module.exports = Ordered_String_List;
    }
  });

  // ../lang-tools/Data_Model/Collection.js
  var require_Collection2 = __commonJS({
    "../lang-tools/Data_Model/Collection.js"(exports, module) {
      module.exports = require_Collection();
    }
  });

  // ../lang-tools/util.js
  var require_util = __commonJS({
    "../lang-tools/util.js"(exports, module) {
      var jsgui = require_lib_lang_mini();
      var Collection = require_Collection2();
      var j = jsgui;
      var each = j.each;
      var tof = j.tof;
      var atof = j.atof;
      var is_defined = j.is_defined;
      var fp = j.fp;
      var arrayify = j.arrayify;
      var mapify = j.mapify;
      var get_item_sig = j.get_item_sig;
      var vectorify = function(n_fn) {
        var fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            var res2 = a[0];
            for (var c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig == "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              var ats = atof(a);
              if (ats[0] == "array") {
                if (ats[1] == "number") {
                  var res2 = [], n = a[1];
                  each(a[0], function(v, i) {
                    res2.push(fn_res(v, n));
                  });
                  return res2;
                }
                if (ats[1] == "array") {
                  if (ats[0].length != ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    var res2 = [], arr2 = a[1];
                    each(a[0], function(v, i) {
                      res2.push(fn_res(v, arr2[i]));
                    });
                    return res2;
                  }
                }
              }
            }
          }
        });
        return fn_res;
      };
      var n_add = function(n1, n2) {
        return n1 + n2;
      };
      var n_subtract = function(n1, n2) {
        return n1 - n2;
      };
      var n_multiply = function(n1, n2) {
        return n1 * n2;
      };
      var n_divide = function(n1, n2) {
        return n1 / n2;
      };
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var execute_on_each_simple = function(items, fn) {
        var res2 = [], that2 = this;
        each(items, function(i, v) {
          res2.push(fn.call(that2, i));
        });
        return res2;
      };
      var filter_map_by_regex = function(map, regex) {
        var res2 = {};
        each(map, function(v, i) {
          if (i.match(regex)) {
            res2[i] = v;
          }
        });
        return res2;
      };
      var npx = arrayify(function(value2) {
        var res2, a = arguments, t = tof(a[0]);
        if (t === "string") {
          res2 = a[0];
        } else if (t === "number") {
          res2 = a[0] + "px";
        }
        return res2;
      });
      var no_px = arrayify(fp(function(a, sig) {
        var re = /px$/, res2;
        if (sig == "[s]" && re.test(a[0])) {
          res2 = parseInt(a[0]);
        } else {
          res2 = a[0];
        }
        ;
        return res2;
      }));
      var arr_ltrb = ["left", "top", "right", "bottom"];
      var str_arr_mapify = function(fn) {
        var res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              var s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              var res22 = {}, that2 = this;
              each(a[0], function(i, v) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var arr_hex_chars = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F"
      ];
      var dict_hex_to_bin = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15
      };
      var str_hex_to_int = function(str_hex) {
        str_hex = str_hex.toUpperCase();
        var i = str_hex.length;
        var res2 = 0, exp = 1;
        while (i--) {
          var i_part = dict_hex_to_bin[str_hex.charAt(i)];
          var ip2 = i_part * exp;
          res2 = res2 + ip2;
          exp = exp * 16;
        }
        ;
        return res2;
      };
      var byte_int_to_str_hex_2 = function(byte_int) {
        var a = Math.floor(byte_int / 16), b = byte_int % 16, sa = arr_hex_chars[a], sb = arr_hex_chars[b], res2 = sa + sb;
        return res2;
      };
      var arr_rgb_to_str_hex_6 = function(arr_rgb) {
        var r = byte_int_to_str_hex_2(arr_rgb[0]);
        var res2 = r + byte_int_to_str_hex_2(arr_rgb[1]) + byte_int_to_str_hex_2(arr_rgb[2]);
        return res2;
      };
      var arr_rgb_to_css_hex_6 = function(arr_rgb) {
        return "#" + arr_rgb_to_str_hex_6(arr_rgb);
      };
      var input_processors = {};
      var validators = {
        "number": function(value2) {
          return tof(value2) == "number";
        }
      };
      var extend = jsgui.extend;
      var fp = jsgui.fp;
      var stringify = jsgui.stringify;
      var tof = jsgui.tof;
      var data_types_info = {
        "color": ["indexed_array", [
          ["red", "number"],
          ["green", "number"],
          ["blue", "number"]
        ]],
        "oltrb": ["optional_array", ["left", "top", "right", "bottom"]]
      };
      jsgui.data_types_info = data_types_info;
      var color_preprocessor_parser = fp(function(a, sig) {
        if (sig == "[s]") {
          var input = a[0];
          var rx_hex = /(#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2}))/;
          var m = input.match(rx_hex);
          if (m) {
            var r = jsgui.str_hex_to_int(m[2]);
            var g = jsgui.str_hex_to_int(m[3]);
            var b = jsgui.str_hex_to_int(m[4]);
            var res2 = [r, g, b];
            return res2;
          }
        }
      });
      input_processors["optional_array"] = fp(function(a, sig) {
        if (a.l == 2) {
          var oa_params = a[0], input = a[1];
          if (tof(input) == "array") {
            if (input.length <= oa_params.length) {
              return input;
            }
          } else {
            return input;
          }
        }
        if (a.l == 3) {
          var oa_params = a[0], items_data_type_name = a[1], input = a[2];
          var input_processor_for_items = jsgui.input_processors[items_data_type_name];
          if (tof(input) == "array") {
            if (input.length <= oa_params.length) {
              var res2 = [];
              each(input, function(i, v) {
                res2.push(input_processor_for_items(v));
              });
              return res2;
            }
          } else {
            return input_processor_for_items(input);
          }
        }
      });
      input_processors["indexed_array"] = fp(function(a, sig) {
        console.log("indexed_array sig", sig);
        if (a.l == 2) {
          var ia_params = a[0], input = a[1];
          if (tof(input) == "array") {
            if (input.length <= ia_params.length) {
              return input;
            }
          }
        }
        if (a.l == 3) {
          var ia_params = a[0], items_data_type_name = a[1], input = a[2];
          var input_processor_for_items = jsgui.input_processors[items_data_type_name];
          if (tof(input) == "array") {
            if (input.length <= ia_params.length) {
              var res2 = [];
              each(input, function(i, v) {
                res2.push(input_processor_for_items(v));
              });
              return res2;
            }
          }
        }
      });
      input_processors["n_units"] = function(str_units, input) {
        if (tof(input) == "number") {
          return [input, str_units];
        }
        if (tof(input) == "string") {
          var rx_n_units = /^(\d+)(\w+)$/;
          var match = input.match(rx_n_units);
          if (match) {
            return [parseInt(match[1]), match[2]];
          }
          rx_n_units = /^(\d*\.\d+)(\w+)$/;
          match = input.match(rx_n_units);
          if (match) {
            return [parseFloat(match[1]), match[2]];
          }
        }
      };
      var dti_color = jsgui.data_types_info["color"];
      input_processors["color"] = function(input) {
        var res2;
        console.log("processing color input: " + stringify(input));
        var input_sig = get_item_sig(input, 2);
        if (input_sig == "[s]") {
          res2 = color_preprocessor_parser(input[0]);
        }
        if (input_sig == "[n,n,n]") {
          res2 = input;
        }
        console.log("res " + stringify(res2));
        console.log("color input_processors output", res2);
        return res2;
      };
      jsgui.output_processors["color"] = function(jsgui_color) {
        var res2 = jsgui.arr_rgb_to_css_hex_6(jsgui_color);
        return res2;
      };
      var group = function() {
        var a = arguments;
        if (a.length == 1 && tof(a[0]) == "array") {
          return group.apply(this, a[0]);
        }
        var res2;
        for (var c2 = 0, l2 = a.length; c2 < l2; c2++) {
          var item2 = a[c2];
          if (c2 == 0) {
            res2 = new Collection({ "context": item2.context });
          }
          res2.push(item2);
        }
        var C = a[0].constructor;
        var p = C.prototype;
        var i;
        for (i in p) {
          var tpi = tof(p[i]);
          if (tpi == "function") {
            (function(i2) {
              if (i2 != "each" && i2 != "get" && i2 != "add_event_listener") {
                res2[i2] = function() {
                  var a2 = arguments;
                  res2.each(function(v, i22) {
                    v[i2].apply(v, a2);
                  });
                };
              }
            })(i);
          }
        }
        return res2;
      };
      var true_vals = function(map) {
        var res2 = [];
        for (var i in map) {
          if (map[i]) res2.push(map[i]);
        }
        return res2;
      };
      var normalize_path = function(path) {
        if (Array.isArray(path)) return path.slice();
        if (path === null || path === void 0) return [];
        if (typeof path !== "string") return [path];
        var cleaned = path.replace(/\[(.+?)\]/g, ".$1");
        return cleaned.split(".").map((part) => {
          return part.trim();
        }).filter((part) => part).map((part) => {
          var unquoted = part;
          if (unquoted[0] === '"' && unquoted[unquoted.length - 1] === '"' || unquoted[0] === "'" && unquoted[unquoted.length - 1] === "'") {
            unquoted = unquoted.slice(1, -1);
          }
          if (/^-?\d+$/.test(unquoted)) {
            return parseInt(unquoted, 10);
          }
          return unquoted;
        });
      };
      var path_get = function(target, path, default_value) {
        var parts = normalize_path(path);
        var current = target;
        for (var i = 0, l2 = parts.length; i < l2; i++) {
          if (current === null || current === void 0) return default_value;
          current = current[parts[i]];
        }
        if (current === void 0) return default_value;
        return current;
      };
      var path_set = function(target, path, value2, options) {
        options = options || {};
        var parts = normalize_path(path);
        if (!parts.length) {
          return { updated: false, value: target, old_value: void 0 };
        }
        var current = target;
        var last_index = parts.length - 1;
        for (var i = 0; i < last_index; i++) {
          if (current === null || current === void 0) {
            return { updated: false, value: target, old_value: void 0 };
          }
          var key2 = parts[i];
          if (current[key2] === void 0 || current[key2] === null) {
            if (options.create === false) {
              return { updated: false, value: target, old_value: void 0 };
            }
            var next_key = parts[i + 1];
            current[key2] = typeof next_key === "number" ? [] : {};
          }
          current = current[key2];
        }
        if (current === null || typeof current !== "object") {
          return { updated: false, value: target, old_value: void 0 };
        }
        var final_key = parts[last_index];
        var old_value = current[final_key];
        current[final_key] = value2;
        return { updated: true, old_value, value: value2, target };
      };
      var create_dependency_graph = function() {
        var map_dependencies = /* @__PURE__ */ new Map();
        var map_dependents = /* @__PURE__ */ new Map();
        var normalize_deps = function(deps) {
          if (!deps) return [];
          if (Array.isArray(deps)) return deps;
          return [deps];
        };
        var add_dependency = function(node, deps) {
          var deps_arr = normalize_deps(deps);
          var dep_set = map_dependencies.get(node);
          if (!dep_set) {
            dep_set = /* @__PURE__ */ new Set();
            map_dependencies.set(node, dep_set);
          }
          deps_arr.forEach((dep) => {
            if (dep === void 0 || dep === null) return;
            dep_set.add(dep);
            var dependent_set = map_dependents.get(dep);
            if (!dependent_set) {
              dependent_set = /* @__PURE__ */ new Set();
              map_dependents.set(dep, dependent_set);
            }
            dependent_set.add(node);
          });
        };
        var remove = function(node) {
          var deps = map_dependencies.get(node);
          if (deps) {
            deps.forEach((dep) => {
              var dependents = map_dependents.get(dep);
              if (dependents) {
                dependents.delete(node);
                if (!dependents.size) map_dependents.delete(dep);
              }
            });
            map_dependencies.delete(node);
          }
        };
        var set_dependencies = function(node, deps) {
          remove(node);
          add_dependency(node, deps);
        };
        var get_dependencies = function(node) {
          var deps = map_dependencies.get(node);
          return deps ? Array.from(deps) : [];
        };
        var get_dependents = function(node) {
          var dependents = map_dependents.get(node);
          return dependents ? Array.from(dependents) : [];
        };
        var clear = function() {
          map_dependencies.clear();
          map_dependents.clear();
        };
        return {
          add: add_dependency,
          remove,
          set_dependencies,
          get_dependencies,
          get_dependents,
          clear
        };
      };
      var create_watch_list = function() {
        var watchers = /* @__PURE__ */ new Set();
        var add = function(unsubscribe_fn) {
          if (typeof unsubscribe_fn === "function") {
            watchers.add(unsubscribe_fn);
          }
          return unsubscribe_fn;
        };
        var remove = function(unsubscribe_fn) {
          if (watchers.has(unsubscribe_fn)) {
            watchers.delete(unsubscribe_fn);
            unsubscribe_fn();
          }
        };
        var clear = function() {
          watchers.forEach((unsubscribe_fn) => {
            unsubscribe_fn();
          });
          watchers.clear();
        };
        var size = function() {
          return watchers.size;
        };
        return {
          add,
          remove,
          clear,
          size
        };
      };
      var Ui16toUi32 = (ui16) => {
        let res2 = new Uint32Array(ui16.length / 2);
        let dv = new DataView(ui16.buffer);
        let l2 = ui16.length;
        let hl = l2 / 2;
        let resw = 0;
        for (let c2 = 0; c2 < hl; c2++) {
          res2[resw++] = dv.getUint32(c2 * 4);
        }
        return res2;
      };
      var Ui32toUi16 = (ui32) => {
        let res2 = new Uint16Array(ui32.length * 2);
        let dv = new DataView(ui32.buffer);
        let l2 = ui32.length;
        let resw = 0;
        for (let c2 = 0; c2 < l2; c2++) {
          res2[resw++] = dv.getUint16(c2 * 4 + 2);
          res2[resw++] = dv.getUint16(c2 * 4);
        }
        console.log("res", res2);
        return res2;
      };
      var util = {
        "Ui16toUi32": Ui16toUi32,
        "Ui32toUi16": Ui32toUi16,
        "vectorify": vectorify,
        "v_add": v_add,
        "v_subtract": v_subtract2,
        "v_multiply": v_multiply,
        "v_divide": v_divide,
        "vector_magnitude": vector_magnitude,
        "distance_between_points": distance_between_points,
        "execute_on_each_simple": execute_on_each_simple,
        "mapify": mapify,
        "filter_map_by_regex": filter_map_by_regex,
        "atof": atof,
        "npx": npx,
        "no_px": no_px,
        "str_arr_mapify": str_arr_mapify,
        "arr_ltrb": arr_ltrb,
        "true_vals": true_vals,
        "normalize_path": normalize_path,
        "path_get": path_get,
        "path_set": path_set,
        "create_dependency_graph": create_dependency_graph,
        "create_watch_list": create_watch_list,
        "validators": validators,
        "__data_id_method": "lazy",
        "str_hex_to_int": str_hex_to_int,
        "arr_rgb_to_css_hex_6": arr_rgb_to_css_hex_6,
        "group": group
      };
      module.exports = util;
    }
  });

  // ../lang-tools/lang.js
  var require_lang = __commonJS({
    "../lang-tools/lang.js"(exports, module) {
      var lang_mini = require_lib_lang_mini();
      var collective = require_collective();
      var { more_general_equals } = require_tools();
      lang_mini.equals = more_general_equals;
      lang_mini.collective = collective;
      lang_mini.collect = collective;
      var Evented_Class = lang_mini.Evented_Class;
      var B_Plus_Tree = require_b_plus_tree();
      var Collection = require_Collection();
      var Data_Object = require_Data_Object();
      var Data_Value2 = require_Data_Value();
      var Data_Model = require_Data_Model();
      var Immutable_Data_Value = require_Immutable_Data_Value();
      var Immutable_Data_Model = require_Immutable_Data_Model();
      var Doubly_Linked_List = require_doubly_linked_list();
      var Ordered_KVS = require_ordered_kvs();
      var Ordered_String_List = require_ordered_string_list();
      var Sorted_KVS = require_sorted_kvs();
      var util = require_util();
      lang_mini.util = util;
      lang_mini.B_Plus_Tree = B_Plus_Tree;
      lang_mini.Collection = Collection;
      lang_mini.Data_Object = Data_Object;
      lang_mini.Data_Value = Data_Value2;
      lang_mini.Immutable_Data_Model = Immutable_Data_Model;
      lang_mini.Immutable_Data_Value = Immutable_Data_Value;
      lang_mini.Data_Model = Data_Model;
      lang_mini.Doubly_Linked_List = Doubly_Linked_List;
      lang_mini.Ordered_KVS = Ordered_KVS;
      lang_mini.Ordered_String_List = Ordered_String_List;
      lang_mini.Sorted_KVS = Sorted_KVS;
      var ec = new Evented_Class();
      Object.assign(ec, lang_mini);
      module.exports = ec;
    }
  });

  // ../jsgui3-html/html-core/lang_tools_compat.js
  var require_lang_tools_compat = __commonJS({
    "../jsgui3-html/html-core/lang_tools_compat.js"(exports, module) {
      var lang_tools = require_lang();
      var {
        Data_Object: Base_Data_Object,
        Data_Value: Data_Value2,
        tof
      } = lang_tools;
      var data_object_set_patched = false;
      var data_value_id_patched = false;
      var data_object_fields_patched = false;
      var collection_data_model_push_patched = false;
      var needs_patch_cached = null;
      var unwrap_value = (value2) => {
        if (value2 && value2.__data_value) {
          return value2.value;
        }
        return value2;
      };
      var ensure_property_access = (obj2, prop_name2) => {
        if (typeof prop_name2 !== "string") return;
        if (prop_name2.indexOf(".") !== -1) return;
        if (prop_name2.startsWith("_") || prop_name2.startsWith("__")) return;
        const existing_descriptor = Object.getOwnPropertyDescriptor(obj2, prop_name2);
        if (existing_descriptor) {
          if (typeof existing_descriptor.get === "function" || typeof existing_descriptor.set === "function") return;
          if (typeof existing_descriptor.value === "function") return;
        } else {
          if (prop_name2 in obj2) return;
        }
        Object.defineProperty(obj2, prop_name2, {
          enumerable: true,
          configurable: true,
          get() {
            if (typeof obj2.get === "function") {
              return unwrap_value(obj2.get(prop_name2));
            }
          },
          set(value2) {
            if (typeof obj2.set === "function") {
              obj2.set(prop_name2, value2);
            } else {
              obj2[prop_name2] = value2;
            }
          }
        });
      };
      var patch_data_object_set = () => {
        if (data_object_set_patched) return;
        data_object_set_patched = true;
        const original_set = Base_Data_Object.prototype.set;
        Base_Data_Object.prototype.set = function() {
          const a = arguments;
          const prop_name2 = a[0];
          if (typeof prop_name2 === "string" && a.length >= 2) {
            const value2 = a[1];
            const silent_arg = a[2];
            const silent = typeof silent_arg === "boolean" || typeof silent_arg === "string" ? !!silent_arg : false;
            const old_raw = typeof this.get === "function" ? this.get(prop_name2) : this[prop_name2];
            const old_val = unwrap_value(old_raw);
            const has_existing = typeof old_raw !== "undefined";
            let safe_value = value2;
            if (value2 === null && !has_existing) {
              safe_value = new Data_Value2({ value: null });
            }
            if (!silent) {
              original_set.call(this, prop_name2, safe_value, true);
              const stored_after_set = typeof this.get === "function" ? this.get(prop_name2) : void 0;
              if (stored_after_set && stored_after_set.__data_value && !stored_after_set.context && this.context) {
                stored_after_set.context = this.context;
              }
              ensure_property_access(this, prop_name2);
              const new_raw = typeof this.get === "function" ? this.get(prop_name2) : value2;
              const new_val = unwrap_value(new_raw);
              if (typeof this.raise_event === "function") {
                this.raise_event("change", {
                  name: prop_name2,
                  old: old_val,
                  value: new_val
                });
              }
              return new_val;
            } else {
              const res2 = original_set.call(this, prop_name2, safe_value, true);
              const stored_after_set = typeof this.get === "function" ? this.get(prop_name2) : void 0;
              if (stored_after_set && stored_after_set.__data_value && !stored_after_set.context && this.context) {
                stored_after_set.context = this.context;
              }
              ensure_property_access(this, prop_name2);
              return res2;
            }
          }
          return original_set.apply(this, a);
        };
      };
      var patch_data_object_set_light = () => {
        if (data_object_set_patched) return;
        data_object_set_patched = true;
        const original_set = Base_Data_Object.prototype.set;
        Base_Data_Object.prototype.set = function() {
          const a = arguments;
          const prop_name2 = a[0];
          const res2 = original_set.apply(this, a);
          if (typeof prop_name2 === "string" && a.length >= 2) {
            ensure_property_access(this, prop_name2);
          }
          return res2;
        };
      };
      var patch_data_value_id = () => {
        if (data_value_id_patched) return;
        data_value_id_patched = true;
        const original_id = Data_Value2.prototype._id;
        if (typeof original_id !== "function") return;
        Data_Value2.prototype._id = function() {
          if (this.__id) return this.__id;
          if (this.context) {
            return original_id.call(this);
          }
          return void 0;
        };
      };
      var patch_collection_data_model_push = () => {
        if (collection_data_model_push_patched) return;
        collection_data_model_push_patched = true;
        const { Collection } = lang_tools;
        if (!Collection || !Collection.prototype || typeof Collection.prototype.push !== "function") return;
        const original_push = Collection.prototype.push;
        Collection.prototype.push = function(value2) {
          const tv = tof(value2);
          if (tv === "data_model") {
            const { silent } = this;
            const fn_index = this.fn_index;
            let idx_key;
            let has_idx_key = false;
            if (fn_index) {
              idx_key = fn_index(value2);
              has_idx_key = true;
            }
            const pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              this.raise("change", {
                target: this,
                item: value2,
                value: value2,
                position: pos,
                name: "insert"
              });
            }
            if (has_idx_key && this.index && typeof this.index.put === "function") {
              this.index.put(idx_key, pos);
            }
            return value2;
          }
          return original_push.call(this, value2);
        };
        Collection.prototype.add = Collection.prototype.push;
      };
      var normalize_fields_spec = (fields) => {
        if (!fields) return [];
        if (Array.isArray(fields)) return fields;
        if (typeof fields === "object") {
          return Object.keys(fields).map((key2) => [key2, fields[key2]]);
        }
        return [];
      };
      var patch_set_fields_from_spec = () => {
        if (data_object_fields_patched) return;
        data_object_fields_patched = true;
        Base_Data_Object.prototype.set_fields_from_spec = function(fields, spec = {}) {
          const normalized = normalize_fields_spec(fields);
          normalized.forEach((field_def) => {
            const field_name = field_def[0];
            if (typeof field_name !== "string") return;
            const has_value = spec && Object.prototype.hasOwnProperty.call(spec, field_name);
            const default_value = field_def.length >= 3 ? field_def[2] : void 0;
            const value_to_set = has_value ? spec[field_name] : default_value;
            if (typeof value_to_set === "undefined") return;
            if (typeof this.set === "function") {
              try {
                this.set(field_name, value_to_set, true);
              } catch (e) {
                this[field_name] = value_to_set;
              }
            } else {
              this[field_name] = value_to_set;
            }
            ensure_property_access(this, field_name);
          });
        };
      };
      var Data_Object_Compat = class extends Base_Data_Object {
        constructor(spec = {}, fields) {
          super(spec, fields);
          const reserved_keys = /* @__PURE__ */ new Set([
            "context",
            "id",
            "__id",
            "_id",
            "__type_name",
            "__type",
            "parent",
            "abstract"
          ]);
          if (spec && typeof spec === "object" && !Array.isArray(spec)) {
            Object.keys(spec).forEach((key2) => {
              if (reserved_keys.has(key2)) return;
              if (key2.startsWith("__")) return;
              let v = spec[key2];
              try {
                this.set(key2, v, true);
                ensure_property_access(this, key2);
              } catch (e) {
                this[key2] = v;
              }
            });
          }
        }
      };
      var detect_needs_patch = () => {
        if (needs_patch_cached !== null) return needs_patch_cached;
        const with_suppressed_console_trace = (fn) => {
          const orig_trace = console.trace;
          console.trace = () => {
          };
          try {
            return fn();
          } finally {
            console.trace = orig_trace;
          }
        };
        const requirements = {
          needs_heavy_set_patch: false,
          needs_accessors_patch: false,
          needs_data_value_id_patch: false,
          needs_data_object_compat: false,
          needs_set_fields_patch: false,
          needs_collection_data_model_patch: false
        };
        try {
          const inst = new Base_Data_Object({ a: 1 });
          const got = typeof inst.get === "function" ? inst.get("a") : void 0;
          const got_val = got && got.__data_value ? got.value : got;
          if (got_val !== 1) {
            requirements.needs_data_object_compat = true;
          }
        } catch (e) {
          requirements.needs_data_object_compat = true;
        }
        try {
          const inst = new Base_Data_Object();
          if (typeof inst.set === "function") {
            inst.set("n", null, true);
          } else {
            requirements.needs_heavy_set_patch = true;
          }
        } catch (e) {
          requirements.needs_heavy_set_patch = true;
        }
        if (!requirements.needs_heavy_set_patch) {
          try {
            const inst = new Base_Data_Object();
            inst.set("dv", new Data_Value2({ value: 2 }), true);
            inst.set("dv", 3, true);
          } catch (e) {
            requirements.needs_heavy_set_patch = true;
          }
        }
        if (!requirements.needs_heavy_set_patch) {
          try {
            const inst = new Base_Data_Object({ a: 1 });
            let evt;
            inst.on("change", (e) => {
              evt = e;
            });
            inst.set("a", 2);
            const old_is_data_value = evt && evt.old && evt.old.__data_value;
            const value_is_data_value = evt && evt.value && evt.value.__data_value;
            if (!evt || !Object.prototype.hasOwnProperty.call(evt, "old") || old_is_data_value || value_is_data_value) {
              requirements.needs_heavy_set_patch = true;
            }
          } catch (e) {
            requirements.needs_heavy_set_patch = true;
          }
        }
        if (!requirements.needs_heavy_set_patch) {
          try {
            const inst = new Base_Data_Object();
            inst.set("x", 1, true);
            const desc = Object.getOwnPropertyDescriptor(inst, "x");
            if (!desc || typeof desc.get !== "function" || typeof desc.set !== "function") {
              requirements.needs_accessors_patch = true;
            } else {
              inst.x = 2;
              const got = inst.get("x");
              const got_val = got && got.__data_value ? got.value : got;
              if (got_val !== 2) requirements.needs_accessors_patch = true;
            }
          } catch (e) {
            requirements.needs_accessors_patch = true;
          }
        }
        try {
          const dv = new Data_Value2({ value: 1 });
          if (typeof dv._id === "function") dv._id();
        } catch (e) {
          requirements.needs_data_value_id_patch = true;
        }
        if (typeof Base_Data_Object.prototype.set_fields_from_spec === "function") {
          try {
            with_suppressed_console_trace(() => {
              new Base_Data_Object({}, [["__compat_test", String]]);
            });
          } catch (e) {
            requirements.needs_set_fields_patch = true;
          }
        }
        try {
          const { Collection, Data_Object } = lang_tools;
          if (Collection && Data_Object) {
            const col = new Collection({});
            col.add(new Data_Object({}));
            if (typeof col.length === "function" && col.length() === 0) {
              requirements.needs_collection_data_model_patch = true;
            }
          }
        } catch (e) {
          requirements.needs_collection_data_model_patch = true;
        }
        needs_patch_cached = requirements;
        return requirements;
      };
      var apply_patches_if_needed = () => {
        const requirements = detect_needs_patch();
        if (requirements.needs_heavy_set_patch) {
          patch_data_object_set();
        } else if (requirements.needs_accessors_patch) {
          patch_data_object_set_light();
        }
        if (requirements.needs_data_value_id_patch) {
          patch_data_value_id();
        }
        if (requirements.needs_set_fields_patch) {
          patch_set_fields_from_spec();
        }
        if (requirements.needs_data_object_compat) {
          lang_tools.Data_Object = Data_Object_Compat;
        }
        if (requirements.needs_collection_data_model_patch) {
          patch_collection_data_model_push();
        }
      };
      var patch_lang_tools = () => {
        apply_patches_if_needed();
        return lang_tools;
      };
      apply_patches_if_needed();
      module.exports = {
        Base_Data_Object,
        Data_Object_Compat,
        patch_lang_tools,
        unwrap_value,
        ensure_property_access
      };
    }
  });

  // ../jsgui3-html/html-core/text-node.js
  var require_text_node = __commonJS({
    "../jsgui3-html/html-core/text-node.js"(exports, module) {
      var { tof, Evented_Class } = require_lang();
      var escape_html_replacements = [
        [/&/g, "&amp;"],
        [/</g, "&lt;"],
        [/>/g, "&gt;"],
        [/"/g, "&quot;"],
        //"
        [/'/g, "&#x27;"],
        //'
        [/\//g, "&#x2F;"]
      ];
      var escape_html = (str) => {
        if (tof(str) == "data_value") str = str.get();
        var single_replacement;
        for (var c2 = 0, l2 = escape_html_replacements.length; c2 < l2; c2++) {
          single_replacement = escape_html_replacements[c2];
          str = str.replace(single_replacement[0], single_replacement[1]);
        }
        return str;
      };
      var textNode = class extends Evented_Class {
        //class textNode extends Control {
        constructor(spec) {
          super();
          if (typeof spec === "string") {
            spec = {
              "text": spec
            };
          }
          spec = spec || {};
          spec.__type_name = spec.__type_name || "text_node";
          spec.nodeType = 3;
          if (spec.el) {
            this.dom = {
              el: spec.el
            };
          } else {
            this.dom = {};
          }
          if (spec.sibling_index) this.sibling_index = spec.sibling_index;
          if (typeof spec.text !== "undefined") {
            this._text = spec.text;
          }
          this.on("change", (e_change) => {
            if (this.dom.el) {
              this.dom.el.nodeValue = e_change.value;
            }
          });
        }
        activate() {
          if (!this.__active) {
            this.__active = true;
          }
        }
        get text() {
          return this._text;
        }
        set text(value2) {
          this._text = value2;
          this.raise("change", {
            "name": "text",
            "value": value2
          });
        }
        "all_html_render"() {
          return this.nx ? this._text || "" : escape_html(this._text || "") || "";
        }
        // getter and setter for the text itself?
        //  A variety of properties will use getters and setters so that the updates get noted.
      };
      module.exports = textNode;
    }
  });

  // ../jsgui3-html/node_modules/lang-mini/lang-mini.js
  var require_lang_mini2 = __commonJS({
    "../jsgui3-html/node_modules/lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              if (ctu == false) break;
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
              if (ctu === false) break;
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "null": "N",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          }
          first = false;
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        if (arr.some((subArray) => subArray.length === 0)) {
          return [];
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else {
              return Object.assign({}, obj2);
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                } else if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return new ctr(input_array);
          } else if (length) {
            return new ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str, 10);
          if (!isNaN(p2) && p2.toString() === str) {
            return p2;
          }
          return void 0;
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        const t_value = typeof value2;
                        is_valid = data_type.validate(value2);
                        if (t_value === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                        console.log("t_value", t_value);
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    } else {
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // ../jsgui3-html/node_modules/lang-mini/lib-lang-mini.js
  var require_lib_lang_mini2 = __commonJS({
    "../jsgui3-html/node_modules/lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini2();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // ../jsgui3-html/node_modules/fnl/fn-io-transform.js
  var require_fn_io_transform = __commonJS({
    "../jsgui3-html/node_modules/fnl/fn-io-transform.js"(exports, module) {
      var { deep_sig } = require_lib_lang_mini2();
      var isArguments = (item2) => Object.prototype.toString.call(item2) === "[object Arguments]";
      var fn_transformation = (fn, map_transformations) => {
        const input_transformations = map_transformations.i;
        const output_transformations = map_transformations.o;
        const fn_res = function() {
          const args = arguments;
          if (args.length === 2 && typeof args[1] === "function") {
            let [a, cb_transform_exec_events] = args;
            if (isArguments(a)) {
              if (a.length === 1) {
                a = a[0];
              }
            }
            const sig_called_with = deep_sig(a);
            const sig_arguments = deep_sig(arguments);
            const exec_fn = () => {
              cb_transform_exec_events({
                "name": "exec-start"
                //,
                //sig: evt_output_transform.sig,
                //value: evt_output_transform.value
              });
              const fn_res2 = fn.call(null, a);
              cb_transform_exec_events({
                "name": "exec-complete"
                //,
                //sig: evt_output_transform.sig,
                //value: evt_output_transform.value
              });
              const sig_fn_res = deep_sig(fn_res2);
              if (output_transformations) {
                if (output_transformations[sig_fn_res]) {
                  output_transformations[sig_fn_res].call(null, fn_res2, (evt_output_transform) => {
                    cb_transform_exec_events({
                      "name": "complete",
                      sig: evt_output_transform.sig,
                      value: evt_output_transform.value
                    });
                  });
                } else {
                  cb_transform_exec_events({
                    "name": "complete",
                    sig: sig_fn_res,
                    value: fn_res2
                  });
                }
              } else {
                cb_transform_exec_events({
                  "name": "complete",
                  sig: sig_fn_res,
                  value: fn_res2
                });
              }
            };
            const skip_fn = () => {
              cb_transform_exec_events({
                "name": "complete",
                //sig: sig_fn_res,
                value: a,
                skipped: true
              });
            };
            if (input_transformations) {
              let do_skip = false;
              if (fn.skip) {
                do_skip = fn.skip(a);
              }
              if (do_skip) {
                skip_fn();
              } else {
                if (fn.map_sigs && fn.map_sigs[sig_called_with]) {
                  exec_fn();
                } else {
                  if (input_transformations[sig_called_with]) {
                    cb_transform_exec_events({
                      "name": "input-transform-start"
                    });
                    input_transformations[sig_called_with].call(null, a, (evt_input_transform) => {
                      const { name, sig, value: value2, io_sigs } = evt_input_transform;
                      if (name === "complete") {
                        a = value2;
                        evt_input_transform.name = "input-transform-complete";
                        cb_transform_exec_events(evt_input_transform);
                        exec_fn();
                      } else {
                        console.trace();
                        throw "NYI";
                      }
                    });
                  } else {
                    exec_fn();
                  }
                }
              }
            } else {
              exec_fn();
            }
          } else {
            throw "Expected args: normal_args, cb_transform_event";
          }
        };
        if (fn.name) fn_res.name = fn.name;
        if (fn.main) fn_res.main = fn.main;
        if (fn.skip) fn_res.skip = fn.skip;
        return fn_res;
      };
      module.exports = fn_transformation;
    }
  });

  // ../jsgui3-html/node_modules/fnl/monitor-item.js
  var require_monitor_item = __commonJS({
    "../jsgui3-html/node_modules/fnl/monitor-item.js"(exports, module) {
      var { tf: tf2, deep_sig, each, def } = require_lib_lang_mini2();
      var monitor_item = (item2, cb_evt_monitoring) => {
        const ti = tf2(item2);
        if (ti === "A") {
          const l2 = item2.length;
          for (let c2 = 0; c2 < l2; c2++) {
            const arg = item2[c2];
            ((arg2, c3) => {
              monitor_item(arg2, (evt_arg_monitor) => {
                evt_arg_monitor.arg_index = c3;
                cb_evt_monitoring(evt_arg_monitor);
              });
            })(arg, c2);
          }
        } else if (ti === "s") {
          cb_evt_monitoring({
            name: "complete",
            t: "s",
            bytes: item2.length * 2
          });
        } else if (ti === "o") {
          cb_evt_monitoring({
            name: "complete",
            t: "o"
            //,
            //bytes: item.length * 2
          });
        } else if (ti === "R") {
          const rs = item2;
          let bytes = 0;
          const ms_start = Date.now();
          let content_length, bytes_remaining;
          const { headers } = item2;
          if (headers && headers["content-length"]) {
            content_length = parseInt(headers["content-length"], 10);
            bytes_remaining = content_length;
          }
          const o_evt = {
            name: "available",
            t: "R",
            ms: ms_start,
            headers
            //,
            //bytes: item.length * 2
          };
          if (def(content_length)) {
            o_evt.content_length = content_length;
          }
          cb_evt_monitoring(o_evt);
          rs.on("data", (data) => {
            bytes += data.length;
            bytes_remaining -= data.length;
            const ms = Date.now();
            const ms_taken = ms - ms_start;
            const byte_rate = bytes / (ms_taken / 1e3);
            const est_remaining = bytes_remaining / byte_rate * 1e3;
            const proportion = bytes / content_length;
            const ms_est_complete = ms + est_remaining;
            cb_evt_monitoring({
              name: "data",
              t: "B",
              bytes: data.length,
              bytes_total: bytes,
              byte_rate,
              content_length,
              bytes_remaining,
              ms_est_remaining: est_remaining,
              ms_est_complete,
              ms_taken,
              proportion
            });
          });
          rs.on("end", () => {
            const ms_complete = Date.now();
            const ms_taken = ms_complete - ms_start;
            const byte_rate = bytes / (ms_taken / 1e3);
            cb_evt_monitoring({
              name: "complete",
              ms: ms_complete,
              ms_taken,
              t: "R",
              "bytes": bytes,
              byte_rate
              //,
              //bytes: item.length * 2
            });
          });
          rs.on("error", (err) => {
            cb_evt_monitoring({
              name: "error",
              value: err,
              t: "R"
              //,
              //bytes: item.length * 2
            });
          });
        } else if (ti === "B") {
          cb_evt_monitoring({
            name: "complete",
            t: "B",
            bytes: item2.length
          });
        } else if (ti === "a") {
          cb_evt_monitoring({
            name: "complete",
            t: "a"
          });
        } else {
          console.log("ti", ti);
          console.trace();
          throw "stop";
        }
      };
      module.exports = monitor_item;
    }
  });

  // ../jsgui3-html/node_modules/fnl/default-arg-transformations.js
  var require_default_arg_transformations = __commonJS({
    "../jsgui3-html/node_modules/fnl/default-arg-transformations.js"(exports, module) {
      var { deep_sig } = require_lib_lang_mini2();
      var transformations = {
        "O": (obs, cb_events) => {
          obs.then((res2) => {
            const sig = deep_sig(res2);
            if (cb_events) cb_events({
              name: "complete",
              io_sigs: ["O", sig],
              sig,
              value: res2
            });
          }, (err) => {
          });
        },
        "p": (p, cb_events) => {
          p.then((res2) => {
            const sig = deep_sig(res2);
            if (cb_events) cb_events({
              name: "complete",
              io_sigs: ["p", sig],
              sig,
              value: res2
            });
          }, (err) => {
          });
        },
        "R": (input_readable_stream, cb_events) => {
          const chunks = [];
          const ms_start = Date.now();
          input_readable_stream.on("data", (data) => {
            chunks.push(data);
          });
          input_readable_stream.on("end", () => {
            const ms_complete = Date.now();
            const buf = Buffer.concat(chunks);
            const ms_taken = ms_complete - ms_start;
            const byte_rate = buf.length / (ms_taken / 1e3);
            if (cb_events) cb_events({
              name: "complete",
              sig: "B",
              io_sigs: ["R", "B"],
              value: buf,
              bytes: buf.length,
              ms: ms_complete,
              ms_taken,
              byte_rate
            });
          });
          input_readable_stream.on("error", (err) => {
            console.log("error reading stream for param transformation in stages()");
            error(err);
          });
        }
        // this level: param sig required
        // this level: param sig given: function to transform
        // promise resolution here?
      };
      module.exports = transformations;
    }
  });

  // ../jsgui3-html/node_modules/fnl/fnl.js
  var require_fnl = __commonJS({
    "../jsgui3-html/node_modules/fnl/fnl.js"(exports, module) {
      var { each, Evented_Class, get_a_sig, get_truth_map_from_arr, tof, tf: tf2, mfp, deep_sig, clone, def, is_array } = require_lib_lang_mini2();
      var fn_io_transform = require_fn_io_transform();
      var log = () => {
      };
      var nce = (obs, next, complete, error2) => {
        obs.on("next", next);
        obs.on("complete", complete);
        obs.on("error", error2);
        return obs;
      };
      var monitor_item = require_monitor_item();
      var tm_status_strings = {
        "init": true,
        "ok": true,
        "complete": true,
        "error": true,
        "paused": true
      };
      var observable = function(fn_inner, opts) {
        const a = arguments;
        const l2 = a.length;
        const sig = get_a_sig(a);
        let _opts, _fn_inner;
        if (sig === "[f]" || sig === "[f,u]") {
          _opts = {};
          _fn_inner = a[0];
        } else if (sig === "[f,o]") {
          _fn_inner = a[0];
          _opts = a[1];
        } else if (sig === "[o,f]") {
          _opts = a[0];
          _fn_inner = a[1];
        } else {
          if (sig === "[O]" || sig === "[O,u]") {
            return a[0];
          } else {
            console.log("sig", sig);
            console.trace();
            throw "NYI";
          }
        }
        const obs_res = ((opts2, fn_inner2) => {
          const ms_start = Date.now();
          const ms_since_start = () => Date.now() - ms_start;
          const res2 = new Evented_Class();
          const io = res2.io = new Evented_Class();
          let llog = [];
          let _status = "init";
          Object.defineProperty(res2, "ms_start", {
            value: ms_start,
            writable: false
          });
          let ms_ok, ms_complete, ms_error;
          let ms_to_ok, ms_to_complete, ms_to_error;
          const map_status_data = {};
          const map_ms_reached_status = {};
          let stage_number = -1;
          let stage_name = "init";
          const log2 = (data) => {
            const log_item = [Date.now(), data];
            llog.push(log_item);
            res2.raise("log", log_item);
          };
          const status = (str_status, data) => {
            if (tm_status_strings[str_status]) {
              const old_status = _status;
              if (!map_ms_reached_status[str_status]) {
                map_ms_reached_status[str_status] = Date.now();
              }
              map_status_data[str_status] = data;
              _status = str_status;
              res2.raise("status", {
                old: old_status,
                value: str_status,
                data
              });
            } else {
              console.trace();
              log2("str_status", str_status);
              throw "invalid str_status " + str_status;
            }
          };
          let _stage;
          let current_stage_info;
          Object.defineProperty(res2, "log", {
            get() {
              return llog;
            }
          });
          Object.defineProperty(res2, "status", {
            get() {
              return _status;
            }
          });
          let had_next = false, had_complete = false, had_error = false;
          setTimeout(() => {
            const res_fn_inner = fn_inner2((data) => {
              let passes = true;
              had_next = true;
              if (!had_complete && !had_error) {
                if (this.filters) {
                  for (let filter of this.filters) {
                    passes = filter(data);
                    if (!passes) break;
                  }
                }
              } else {
                if (had_complete) {
                  console.warn('Observable can not raise "next" event after having raised its "complete" event.');
                }
                if (had_error) {
                  console.warn('Observable can not raise "next" event after having raised its "error" event.');
                }
              }
              if (passes) {
                res2.raise("next", data);
                res2.raise("data", data);
              }
            }, (last_data) => {
              if (!had_complete && !had_error) {
                had_complete = true;
                const tld = tf2(last_data);
                const ms_complete2 = Date.now();
                res2.ms_complete = ms_complete2;
                res2.ms_taken = ms_complete2 - ms_start;
                if (tld !== "u") {
                  if (tld === "R") {
                    io.ongoing = true;
                    last_data.on("complete", () => {
                      io.ongoing = false;
                      io.raise("complete");
                    });
                  } else {
                    res2.raise("complete", last_data);
                    io.raise("complete");
                  }
                } else {
                  res2.raise("complete");
                }
              } else {
                if (had_complete) {
                  console.warn('WARNING: Observable can not raise "complete" event after having raised it already.');
                }
                if (had_error) {
                  console.warn('WARNING: Observable can not raise "complete" event after having raised its "error" event.');
                }
              }
            }, (error2) => {
              if (!had_complete && !had_error) {
                had_error = true;
                res2.raise("error", error2);
              } else {
                if (had_complete) {
                  console.warn('WARNING: Observable can not raise "error" event after having raised its "complete" event.');
                }
                if (had_error) {
                  console.warn('WARNING: Observable can not raise "error" event after having raised it already.');
                }
              }
            }, status, log2) || [];
            if (is_array(res_fn_inner)) {
              const [stop, pause, resume] = res_fn_inner;
              if (stop) res2.stop = stop;
              if (pause) res2.pause = pause;
              if (resume) res2.resume = resume;
              if (pause && resume) {
                res2.delay = (ms) => {
                  pause();
                  res2.raise("paused");
                  setTimeout(() => {
                    res2.resume();
                    res2.raise("resumed");
                  }, ms);
                };
              }
            }
          }, 0);
          res2.next = (handler) => {
            res2.on("next", handler);
            return res2;
          };
          res2.data = res2.next;
          res2.complete = (handler) => {
            res2.on("complete", handler);
            return res2;
          };
          res2.on("complete", (data) => {
            status("complete");
            const store_res = () => {
              if (data) {
                if (data.data) {
                  res2.res = data.data;
                } else {
                  res2.res = data;
                }
              }
            };
          });
          res2.done = res2.end = res2.complete;
          res2.error = (handler) => {
            res2.on("error", handler);
            return res2;
          };
          res2.then = (handler) => {
            let res_all = [];
            res2.next((data) => {
              res_all.push(data);
              had_next = true;
            });
            if (res2.completed) {
              if (res2.singular_result) {
                handler(res_all[0]);
              } else {
                handler(res_all);
              }
            } else {
              res2.complete((last) => {
                if (had_next && res_all.length > 0) {
                  if (res2.singular_result) {
                    handler(res_all[0]);
                  } else {
                    handler(res_all);
                  }
                } else {
                  handler(last);
                }
              });
            }
          };
          res2.__type_name = "observable";
          res2._is_obs = res2._is_observable = true;
          res2._ = new Evented_Class();
          res2.meta = (k, v) => {
            if (v === void 0) {
            } else {
              res2._[key] = value;
              res2._.raise("change", {
                key: k,
                value: v
              });
            }
          };
          return res2;
        })(_opts, _fn_inner);
        return obs_res;
      };
      observable._ = {
        name: "observable",
        return_type: "observable",
        async: true
      };
      var obsfilter = (obs, next_filter) => observable((next, complete, error2) => {
        obs.on("next", (data) => {
          if (next_filter(data)) {
            next(data);
          }
        });
        obs.on("complete", (data) => {
          if (data) {
            complete(data);
          } else {
            complete();
          }
        });
        obs.on("error", (err) => {
          error2(err);
        });
      });
      var obsmap = (obs, fn_map) => observable((next, complete, error2) => {
        obs.on("next", (data) => next(fn_map(data)));
        obs.on("complete", complete);
        obs.on("error", error2);
      });
      var obsalias = (obs_like, mapping) => {
        let next, complete, error2;
        const tmapping = tof(mapping);
        if (tmapping === "array") {
          [next, complete, error2] = mapping;
        } else if (tmapping === "object") {
          next = mapping.next;
          complete = mapping.complete;
          error2 = mapping.error;
        }
        return observable((n, c2, e) => {
          if (next) {
            obs_like.on(next, n);
          } else {
            obs_like.on("next", n);
          }
          if (complete) {
            obs_like.on(complete, c2);
          } else {
            obs_like.on("complete", c2);
          }
          if (error2) {
            obs_like.on(error2, e);
          } else {
            obs_like.on("error", e);
          }
        });
      };
      var obscollect = (obs, fn_collect, arr_res) => {
        obs.on("next", (data) => {
          const item_res = fn_collect(data);
          arr_res.push(item_res);
        });
        return obs;
      };
      var obspool = () => {
        console.trace();
        throw "out of order";
      };
      var seq = (q_obs) => {
        return observable((next, complete, error2) => {
          let c2 = 0, obs_q_item;
          let process2 = () => {
            if (c2 < q_obs.length) {
              let q_item = q_obs[c2];
              obs_q_item = q_item[1].apply(q_item[0], q_item[2]);
              obs_q_item.on("next", (data) => {
                next(data);
              });
              obs_q_item.on("error", (error3) => {
                error3(error3);
              });
              obs_q_item.on("complete", (data) => {
                c2++;
                process2();
              });
            } else {
              complete();
            }
          };
          process2();
          let stop = () => {
            obs_q_item.stop();
            complete();
          };
          let pause = () => {
            obs_q_item.pause();
          };
          let resume = () => {
            obs_q_item.resume();
          };
          return [stop, pause, resume];
        });
      };
      var obs_to_cb = (obs, callback2) => {
        let _obs = observable(obs);
        let arr_all = [];
        _obs.on("next", (data) => arr_all.push(data));
        _obs.on("error", (err) => callback2(err));
        _obs.on("complete", (last) => {
          if (typeof last !== "undefined") {
            callback2(null, last, arr_all);
          } else {
            callback2(null, arr_all);
          }
        });
      };
      var unpage = (obs) => {
        return observable((next, complete, error2) => {
          obs.on("next", (arr_data) => {
            if ("unpaged" in arr_data) {
              let unpaged = arr_data.unpaged;
              for (let c2 = 0, l2 = unpaged.length; c2 < l2; c2++) {
                next(unpaged[c2]);
              }
            } else {
              for (let c2 = 0, l2 = arr_data.length; c2 < l2; c2++) {
                next(arr_data[c2]);
              }
            }
          });
          obs.on("complete", () => {
            complete();
          });
          obs.on("error", (err) => error2(err));
          return [];
        });
      };
      var obs_or_cb = (obs, callback2, always_plural) => {
        if (callback2) {
          obs_to_cb(obs, callback2);
        } else {
          return observable(obs, always_plural);
        }
      };
      var sig_obs_or_cb = (a, inner) => {
        let a2;
        let callback2;
        if (typeof a[a.length - 1] === "function") {
          a2 = Array.prototype.slice.call(a, 0, -1);
          callback2 = a[a.length - 1];
        } else if (typeof a[a.length - 1] === "undefined") {
          a2 = Array.prototype.slice.call(a, 0, -1);
        } else {
          a2 = Array.prototype.slice.call(a);
        }
        let sig = get_a_sig(a2);
        let obs = observable((next, complete, error2) => {
          return inner(a2, sig, next, complete, error2, a2.length);
        });
        return obs_or_cb(obs, callback2);
      };
      var cb_to_prom_or_cb = (inner_with_cb, opt_cb) => {
        if (typeof opt_cb !== "undefined") {
          inner_with_cb(opt_cb);
        } else {
          return new Promise((resolve, reject) => {
            inner_with_cb((err, res2) => {
              if (err) {
                reject(err);
              } else {
                resolve(res2);
              }
            });
          });
        }
      };
      var prom_or_cb = (prom2, opt_cb) => {
        let _prom;
        if (prom2 instanceof Promise) {
          _prom = prom2;
        } else {
          _prom = new Promise(prom2);
        }
        if (opt_cb) {
          _prom.then((res2) => {
            opt_cb(null, res2);
          }, (err) => {
            opt_cb(err);
          });
        } else {
          return _prom;
        }
      };
      var prom = (prom2) => {
        if (prom2 instanceof Promise) {
          return prom2;
        } else {
          return new Promise(prom2);
        }
      };
      var is_obs = (obj2) => {
        return obj2.is_obs === true;
      };
      var is_prom = (obj2) => {
        return obj2 instanceof Promise || obj2.is_obs === true;
      };
      var obs_prom_arr_item = (obj2, obs, prom2, arr, item2) => {
        if (obj2.is_obs === true) {
          return obs(obj2);
        } else {
          if (obj2 instanceof Promise) {
            return prom2(obj2);
          } else {
            if (Array.isArray(obj2)) {
              return arr(obj2);
            } else {
              return item2(obj2);
            }
          }
        }
      };
      var arg_transformation = require_default_arg_transformations();
      var transform_stage_input = {
        "R": arg_transformation.R
      };
      var stages = mfp({
        name: "stages",
        return_type: "function"
        // function that returns an observable.
      }, function() {
        const a = arguments, l2 = a.length;
        const sig = get_a_sig(a);
        let arr_stages;
        let num_stages;
        let fn_inner;
        const prepare_arr_fns = (ofns) => {
          const input_ofns2 = (ofns2) => {
            const map_stage_reserved_names = {
              _raise_stage_event: true
            };
            const res2 = [];
            const o_filtered_stage_fns = {};
            let num_stages2 = 0;
            let last_stage_name;
            each(ofns2, (fn_stage, stage_name) => {
              if (!map_stage_reserved_names[stage_name]) {
                o_filtered_stage_fns[stage_name] = fn_stage;
                num_stages2++;
                last_stage_name = stage_name;
              }
            });
            each(o_filtered_stage_fns, (fn_stage, stage_name) => {
              const is_last_stage = stage_name === last_stage_name;
              const map_sigs = fn_stage.map_sigs;
              if (Object.keys(fn_stage).length === 0) {
                const io_transform = {};
                if (!is_last_stage) {
                  io_transform.o = {
                    p: arg_transformation.p
                  };
                }
                const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                io_transformed_stage.name = stage_name;
                res2.push([stage_name, io_transformed_stage]);
              } else {
                if (map_sigs) {
                  const io_transform = {
                    i: transform_stage_input
                  };
                  io_transform.o = {
                    "p": arg_transformation.p,
                    "O": arg_transformation.O
                  };
                  const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                  io_transformed_stage.name = stage_name;
                  res2.push([stage_name, io_transformed_stage]);
                } else {
                  const io_transform = {};
                  io_transform.o = {
                    "p": arg_transformation.p,
                    "O": arg_transformation.O
                  };
                  const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                  io_transformed_stage.name = stage_name;
                  res2.push([stage_name, io_transformed_stage]);
                }
              }
            });
            return res2;
          };
          return input_ofns2(ofns);
        };
        const prepare = () => {
          if (sig === "[a]") {
            valid = true;
            each(a[0], (stage) => {
              if (get_a_sig(stage) === "[s,f]") {
                const [stage_name, fn_stage] = stage;
                if (!fn_stage.name) fn_stage.name = stage_name;
              } else {
                valid = false;
                console.trace();
                throw "expected stage to be specified as an array [s,f]";
              }
            });
            if (valid) {
              arr_stages = prepare_arr_fns(a[0]);
              num_stages = arr_stages.length;
            }
          } else if (sig === "[o]") {
            input_ofns(a[0]);
          } else if (sig === "[f]") {
            arr_stages = prepare_arr_fns(a[0]());
            num_stages = arr_stages.length;
          } else {
            console.trace();
            throw "stages expected an array or object (may become more flexible in the future)";
          }
        };
        const ms_pre_prepare = Date.now();
        let res_prepare = prepare();
        const ms_prep_time = Date.now() - ms_pre_prepare;
        if (res_prepare) {
          log("ms_prep_time", ms_prep_time);
          return res_prepare;
        }
        const arr_stages_info = new Array(arr_stages.length);
        each(arr_stages, (arr_stage, i) => {
          const stage_name = arr_stage[0];
          arr_stages_info[i] = {
            name: stage_name
          };
        });
        const process2 = () => {
          const res2 = function() {
            const a2 = arguments, l22 = a2.length;
            const sig2 = get_a_sig(a2);
            let next_apply_args = a2.length === 0 ? void 0 : a2;
            const obs_res = observable((next, complete, error2, status, log2, stage) => {
              const log_stage_events = [];
              obs_res.log_stage_events = log_stage_events;
              const map_stage_events_by_name = {};
              let ms_last_stage_event;
              let c2 = 0;
              const cb_stage_event = (name, evt) => {
                evt = evt || {
                  name
                };
                const now = Date.now();
                evt.ms = now;
                evt.i_stage = c2;
                evt.stage_name = arr_stages2[c2][0];
                if (ms_last_stage_event) {
                  evt.ms_since_last = now - ms_last_stage_event;
                }
                ms_last_stage_event = now;
                log_stage_events.push(evt);
                map_stage_events_by_name[name] = evt;
                if (name === "have-response") {
                  obs_res.ms_latency = now - map_stage_events_by_name["make-request"].ms;
                }
                obs_res.raise("stage", evt);
              };
              const t12 = Date.now();
              const new_obj_fns = a[0](cb_stage_event);
              const newly_prepared_stages = prepare_arr_fns(new_obj_fns);
              const arr_stages2 = newly_prepared_stages;
              const reprep_time = Date.now() - t12;
              log2("reprep_time", reprep_time);
              const res_input = obs_res.input = {};
              const res_output = obs_res.output = {};
              const res_stages = obs_res.stages = clone(arr_stages_info);
              monitor_item(a2, (evt_input_args) => {
                const event_name = evt_input_args.name;
              });
              let i_last_unskipped_stage = -1;
              let exec_is_complete = false;
              const process_next = () => {
                const have_next_stage = !!arr_stages2[c2];
                const i_stage = c2;
                log2("have_next_stage", have_next_stage);
                if (have_next_stage) {
                  const stage_name = arr_stages2[c2][0];
                  const fn_stage = arr_stages2[c2][1];
                  const is_main_stage = fn_stage.main === true;
                  const is_last_stage = c2 === arr_stages2.length - 1;
                  const res_stage = res_stages[c2];
                  const res_prev_stage = res_stages[c2 - 1];
                  const res_next_stage = res_stages[c2 + 1];
                  res_stage.ms_start = Date.now();
                  if (is_main_stage) {
                    res_stage.main = true;
                  }
                  let fn_ready_args;
                  const exec_fn = () => {
                    const i_stage2 = c2;
                    console.log("calling exec_fn " + stage_name);
                    console.trace();
                    const stage_res = fn_stage.call(this, fn_ready_args, (transform_call_event) => {
                      const { name, sig: sig3, value: value2 } = transform_call_event;
                      if (name === "complete") {
                        if (transform_call_event.skipped === true) {
                          res_stage.skipped = true;
                        } else {
                          if (i_stage2 > i_last_unskipped_stage) i_last_unskipped_stage = i_stage2;
                          let content_length;
                          monitor_item(value2, (evt_stage_res) => {
                            const cl_evt = clone(evt_stage_res);
                            const event_name = evt_stage_res.name;
                            if (event_name === "complete") {
                              console.log("c", c2);
                              console.log("stage item complete");
                              const ms_output_complete = Date.now();
                              const ms_taken = ms_output_complete - res_stage.ms_start;
                              res_stage.ms_output_complete = ms_output_complete;
                              if (res_stage.ms_output_start) {
                                const ms_output_taken = res_stage.ms_output_taken = ms_output_complete - res_stage.ms_output_start;
                                if (ms_output_taken > 0) {
                                  if (res_stage.bytes_out) {
                                    const output_rate = res_stage.bytes_out / (ms_output_taken / 1e3);
                                    res_stage.output_rate = output_rate;
                                    if (is_main_stage) {
                                      obs_res.main_rate = output_rate;
                                    }
                                  }
                                }
                              }
                              res_stage.ms_taken = ms_taken;
                              console.log("c", c2);
                              console.log("i_stage", i_stage2);
                              console.log("is_last_stage", is_last_stage);
                            } else if (event_name === "available") {
                              if (evt_stage_res.content_length) {
                                res_stage.content_length = evt_stage_res.content_length;
                                if (is_main_stage) {
                                  content_length = obs_res.content_length = evt_stage_res.content_length;
                                }
                              }
                              res_stage.ms_output_start = Date.now();
                            } else if (event_name === "data") {
                              const { bytes, bytes_total, byte_rate, content_length: content_length2, bytes_remaining, ms_est_remaining, ms_est_complete, ms_taken, proportion } = evt_stage_res;
                              const ms_processing_output = ms_taken;
                              const out_rate = byte_rate;
                              res_stage.bytes_out = bytes_total;
                              if (res_stage.bytes_in) {
                                res_stage.bytes_oi_ratio = res_stage.bytes_out / res_stage.bytes_in;
                              }
                              if (is_main_stage) {
                                obs_res.main_bytes_out = bytes_total;
                                obs_res.main_output_rate = out_rate;
                              }
                              if (i_last_unskipped_stage === i_stage2) {
                                obs_res.bytes_out = bytes_total;
                                obs_res.output_rate = out_rate;
                                if (def(proportion)) obs_res.proportion = proportion;
                                if (def(bytes_remaining)) obs_res.bytes_remaining = bytes_remaining;
                                if (def(ms_est_remaining)) obs_res.ms_est_remaining = ms_est_remaining;
                                if (def(ms_est_complete)) obs_res.ms_est_complete = ms_est_complete;
                              }
                              if (res_next_stage) {
                                res_next_stage.bytes_in = res_next_stage.bytes_in || 0;
                                res_next_stage.bytes_in += cl_evt.bytes;
                              }
                            } else {
                              log2("event_name", event_name);
                              console.trace();
                              throw "stop";
                            }
                          });
                        }
                        next_apply_args = value2;
                        c2++;
                        log2("pre process next stage");
                        process_next();
                      } else {
                        log2("transform_call_event", transform_call_event);
                        if (name === "input-transform-complete") {
                          const ms_input_transform_complete = Date.now();
                          res_stage.ms_input_transform_complete = ms_input_transform_complete;
                          res_stage.ms_input_transform_taken = ms_input_transform_complete - res_stage.ms_input_transform_start;
                        } else if (name === "input-transform-start") {
                          res_stage.ms_input_transform_start = Date.now();
                        } else if (name === "exec-start") {
                          res_stage.ms_exec_start = Date.now();
                        } else if (name === "exec-complete") {
                          const ms_exec_complete = Date.now();
                          res_stage.ms_exec_complete = ms_exec_complete;
                          res_stage.ms_exec_taken = ms_exec_complete - res_stage.ms_exec_start;
                        } else {
                          log2("name", name);
                          log2("transform_call_event", transform_call_event);
                          console.trace();
                          throw "stop";
                        }
                      }
                    });
                  };
                  fn_ready_args = next_apply_args;
                  log2("pre exec_fn");
                  exec_fn();
                } else {
                  const tsr = tf2(next_apply_args);
                  c2++;
                  log2("tsr", tsr);
                  console.log("the stages exec is complete");
                  console.log("i_last_unskipped_stage", i_last_unskipped_stage);
                  exec_is_complete = true;
                  complete(next_apply_args);
                }
              };
              process_next();
            });
            return obs_res;
          };
          res2.is_staged = true;
          res2.return_type = "observable";
          return res2;
        };
        return process2();
      });
      module.exports = {
        "observable": observable,
        "nce": nce,
        "obs": observable,
        "obsalias": obsalias,
        "obscollect": obscollect,
        "obsfilter": obsfilter,
        "obspool": obspool,
        "obsmap": obsmap,
        "seq": seq,
        "sequence": seq,
        "sig_obs_or_cb": sig_obs_or_cb,
        "cb_to_prom_or_cb": cb_to_prom_or_cb,
        "prom_or_cb": prom_or_cb,
        "prom": prom,
        "obs_or_cb": obs_or_cb,
        "unpage": unpage,
        "is_obs": is_obs,
        "is_prom": is_prom,
        "obs_prom_arr_item": obs_prom_arr_item,
        "stages": stages
      };
      if (__require.main === module) {
        console.log("running fnl as main");
        const make_timer_obs = () => observable((next, complete, error2) => {
          let c2 = 2;
          let paused = false;
          let cease = () => {
            clearInterval(ivl);
          };
          let stop = () => {
            clearInterval(ivl);
            complete();
          };
          let ivl = setInterval(() => {
            if (!paused) {
              let v = c2 * 2;
              next({
                "v": v
              });
              c2++;
              if (c2 > 6) {
                error2(new Error("A problem"));
                cease();
              }
              if (c2 > 8) {
                stop();
              }
            }
          }, 1e3);
          return [stop, () => {
            paused = true;
          }, () => {
            paused = false;
          }];
        });
        let obs = make_timer_obs();
        let test_obs = () => {
          obs.on("paused", () => log("* paused"));
          obs.on("resumed", () => log("* resumed"));
          obs.on("error", (err) => log("* error", err));
          obs.next((data) => {
            log("data", data);
          });
        };
        test_obs();
        let test_then = () => {
          (async () => {
            let res2 = await obs;
            log("awaited res", res2);
          })();
        };
        log("stages", stages);
        let test_split = () => {
          obs.on("paused", () => log("* paused"));
          obs.on("resumed", () => log("* resumed"));
          let [obs1, obs2] = obs.split((data) => data.v % 3 === 0);
          obs1.on("next", (data) => log("obs1 data", data));
          obs2.on("next", (data) => log("obs2 data", data));
        };
        let test_filter = () => {
          obs.filter((data) => {
            return data.v !== 8;
          }).filter((data) => {
            return data.v % 3 !== 0;
          });
          obs.next((data) => {
            if (data === 8) {
              obs.delay(5e3);
              obs.pause();
              log("paused");
              setTimeout(() => {
                log("wait over");
                obs.resume();
              }, 2e3);
            }
          }).end(() => {
            log("end");
          });
        };
      } else {
      }
    }
  });

  // ../jsgui3-html/node_modules/obext/node_modules/lang-mini/lang-mini.js
  var require_lang_mini3 = __commonJS({
    "../jsgui3-html/node_modules/obext/node_modules/lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              if (ctu == false) break;
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
              if (ctu === false) break;
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "null": "N",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          }
          first = false;
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        if (arr.some((subArray) => subArray.length === 0)) {
          return [];
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          const mfp_fn_call_shallow_sig = (() => {
            if (!a2 || a2.length === 0) return "";
            let res3 = "";
            for (let i = 0; i < a2.length; i++) {
              if (i > 0) res3 = res3 + ",";
              res3 = res3 + ltf(a2[i]);
            }
            return res3;
          })();
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else if (mfp_fn_call_shallow_sig && inner_map_sig_fns[mfp_fn_call_shallow_sig]) {
              return inner_map_sig_fns[mfp_fn_call_shallow_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else if (t === "date") {
              return new Date(obj2.getTime());
            } else if (t === "regex") {
              return new RegExp(obj2.source, obj2.flags);
            } else if (t === "buffer") {
              if (typeof Buffer !== "undefined" && Buffer.from) {
                return Buffer.from(obj2);
              } else if (obj2 && typeof obj2.slice === "function") {
                return obj2.slice(0);
              } else {
                return obj2;
              }
            } else if (t === "error") {
              const cloned_error = new obj2.constructor(obj2.message);
              cloned_error.name = obj2.name;
              cloned_error.stack = obj2.stack;
              each(obj2, (value2, key2) => {
                if (key2 !== "message" && key2 !== "name" && key2 !== "stack") {
                  cloned_error[key2] = clone(value2);
                }
              });
              return cloned_error;
            } else if (t === "object") {
              const res2 = {};
              each(obj2, (value2, key2) => {
                res2[key2] = clone(value2);
              });
              return res2;
            } else {
              return obj2;
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                } else if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return new ctr(input_array);
          } else if (length) {
            return new ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str, 10);
          if (!isNaN(p2) && p2.toString() === str) {
            return p2;
          }
          return void 0;
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        const t_value = typeof value2;
                        is_valid = data_type.validate(value2);
                        if (t_value === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                        console.log("t_value", t_value);
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    } else {
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var KEYWORD_LITERALS = /* @__PURE__ */ new Set(["true", "false", "null", "undefined"]);
      var KEYWORD_OPERATORS = /* @__PURE__ */ new Set(["typeof", "void", "delete", "in", "instanceof"]);
      var MULTI_CHAR_OPERATORS = [
        "===",
        "!==",
        "==",
        "!=",
        "<=",
        ">=",
        "&&",
        "||",
        "??",
        "++",
        "--",
        "+=",
        "-=",
        "*=",
        "/=",
        "%=",
        "&=",
        "|=",
        "^=",
        "<<",
        ">>",
        ">>>",
        "**"
      ];
      var SINGLE_CHAR_OPERATORS = /* @__PURE__ */ new Set(["+", "-", "*", "/", "%", "=", "!", "<", ">", "&", "|", "^", "~"]);
      var PUNCTUATION_CHARS = /* @__PURE__ */ new Set(["(", ")", "{", "}", "[", "]", ",", ":", "?", "."]);
      var GLOBAL_SCOPE = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var DEFAULT_ALLOWED_GLOBALS = ["Math"];
      var EXPRESSION_PARSER_DEFAULTS = {
        cache: true,
        cacheSize: 64,
        cacheKeyResolver: null,
        maxExpressionLength: 1e4,
        maxMemberDepth: 2,
        helpers: {},
        allowedFunctions: [],
        allowedGlobals: DEFAULT_ALLOWED_GLOBALS,
        allowCall: null,
        strict: false
      };
      var NORMALIZED_OPTIONS_FLAG = /* @__PURE__ */ Symbol("ExpressionParserOptions");
      var DISALLOWED_IDENTIFIERS = /* @__PURE__ */ new Set(["this", "new"]);
      var ExpressionParserError = class extends Error {
        constructor(code, message, details = {}) {
          super(message);
          this.name = "ExpressionParserError";
          this.code = code;
          this.details = details;
        }
      };
      var ExpressionCache = class {
        constructor(limit = 0) {
          this.limit = Math.max(0, limit || 0);
          this.map = /* @__PURE__ */ new Map();
        }
        get(key2) {
          if (!this.limit || !this.map.has(key2)) {
            return void 0;
          }
          const value2 = this.map.get(key2);
          this.map.delete(key2);
          this.map.set(key2, value2);
          return value2;
        }
        set(key2, value2) {
          if (!this.limit) {
            return;
          }
          if (this.map.has(key2)) {
            this.map.delete(key2);
          }
          this.map.set(key2, value2);
          while (this.map.size > this.limit) {
            const oldestKey = this.map.keys().next().value;
            this.map.delete(oldestKey);
          }
        }
        clear() {
          this.map.clear();
        }
        get size() {
          return this.map.size;
        }
      };
      var Tokenizer = class {
        constructor(expression) {
          this.expression = typeof expression === "string" ? expression : String(expression || "");
          this.length = this.expression.length;
          this.position = 0;
          this.line = 1;
          this.column = 1;
        }
        tokenize() {
          const tokens = [];
          if (!this.expression.trim()) {
            return tokens;
          }
          while (!this.isAtEnd()) {
            this.skipWhitespace();
            if (this.isAtEnd()) break;
            const ch = this.peek();
            if (this.isIdentifierStart(ch)) {
              tokens.push(this.tokenizeIdentifier());
            } else if (this.isDigit(ch) || ch === "." && this.isDigit(this.peek(1))) {
              tokens.push(this.tokenizeNumber());
            } else if (ch === '"' || ch === "'") {
              tokens.push(this.tokenizeString());
            } else if (this.isOperatorStart(ch)) {
              tokens.push(this.tokenizeOperator());
            } else if (PUNCTUATION_CHARS.has(ch)) {
              tokens.push(this.tokenizePunctuation());
            } else {
              this.throwError("TOKEN_INVALID_CHAR", `Unexpected character: ${ch}`);
            }
          }
          return tokens;
        }
        isAtEnd() {
          return this.position >= this.length;
        }
        skipWhitespace() {
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (/\s/.test(ch)) {
              this.advance();
              continue;
            }
            if (ch === "/" && this.peek(1) === "/") {
              while (!this.isAtEnd() && this.peek() !== "\n") {
                this.advance();
              }
              continue;
            }
            if (ch === "/" && this.peek(1) === "*") {
              this.advance();
              this.advance();
              while (!this.isAtEnd()) {
                if (this.peek() === "*" && this.peek(1) === "/") {
                  this.advance();
                  this.advance();
                  break;
                }
                this.advance();
              }
              continue;
            }
            break;
          }
        }
        peek(offset2 = 0) {
          if (this.position + offset2 >= this.length) return "\0";
          return this.expression[this.position + offset2];
        }
        advance() {
          if (this.isAtEnd()) {
            return "\0";
          }
          const char = this.expression[this.position++];
          if (char === "\n") {
            this.line += 1;
            this.column = 1;
          } else {
            this.column += 1;
          }
          return char;
        }
        getLocationSnapshot() {
          return { index: this.position, line: this.line, column: this.column };
        }
        createToken(type, value2, start, end) {
          return { type, value: value2, start, end };
        }
        throwError(code, message) {
          throw new ExpressionParserError(code, message, { location: this.getLocationSnapshot() });
        }
        isIdentifierStart(ch) {
          return /[A-Za-z_$]/.test(ch);
        }
        isIdentifierPart(ch) {
          return /[A-Za-z0-9_$]/.test(ch);
        }
        isDigit(ch) {
          return /[0-9]/.test(ch);
        }
        isOperatorStart(ch) {
          if (ch === "." && this.peek(1) === "." && this.peek(2) === ".") {
            this.throwError("SYNTAX_UNSUPPORTED", "Spread syntax is not supported");
          }
          if (ch === "?" && this.peek(1) === "?") {
            return true;
          }
          return SINGLE_CHAR_OPERATORS.has(ch);
        }
        tokenizeIdentifier() {
          const start = this.getLocationSnapshot();
          let value2 = "";
          while (!this.isAtEnd() && this.isIdentifierPart(this.peek())) {
            value2 += this.advance();
          }
          const end = this.getLocationSnapshot();
          if (KEYWORD_LITERALS.has(value2)) {
            return this.createToken("KEYWORD", value2, start, end);
          }
          if (KEYWORD_OPERATORS.has(value2)) {
            return this.createToken("OPERATOR", value2, start, end);
          }
          return this.createToken("IDENTIFIER", value2, start, end);
        }
        tokenizeNumber() {
          const start = this.getLocationSnapshot();
          let value2 = "";
          let hasDot = false;
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (this.isDigit(ch)) {
              value2 += this.advance();
            } else if (ch === "." && !hasDot) {
              hasDot = true;
              value2 += this.advance();
            } else {
              break;
            }
          }
          const end = this.getLocationSnapshot();
          return this.createToken("NUMBER", Number(value2), start, end);
        }
        tokenizeString() {
          const quote = this.advance();
          const start = this.getLocationSnapshot();
          let value2 = "";
          while (!this.isAtEnd()) {
            const ch = this.advance();
            if (ch === quote) {
              return this.createToken("STRING", value2, start, this.getLocationSnapshot());
            }
            if (ch === "\\") {
              const next = this.advance();
              switch (next) {
                case "n":
                  value2 += "\n";
                  break;
                case "r":
                  value2 += "\r";
                  break;
                case "t":
                  value2 += "	";
                  break;
                case "\\":
                  value2 += "\\";
                  break;
                case '"':
                  value2 += '"';
                  break;
                case "'":
                  value2 += "'";
                  break;
                default:
                  value2 += next;
              }
            } else {
              value2 += ch;
            }
          }
          this.throwError("TOKEN_UNTERMINATED_STRING", "Unterminated string literal");
        }
        tokenizeOperator() {
          const remaining = this.expression.slice(this.position);
          const start = this.getLocationSnapshot();
          for (const op of MULTI_CHAR_OPERATORS) {
            if (remaining.startsWith(op)) {
              if (op === "=>") {
                this.throwError("SYNTAX_UNSUPPORTED", "Arrow functions are not supported");
              }
              this.position += op.length;
              this.column += op.length;
              return this.createToken("OPERATOR", op, start, this.getLocationSnapshot());
            }
          }
          const ch = this.advance();
          if (ch === "=" && this.peek() === ">") {
            this.throwError("SYNTAX_UNSUPPORTED", "Arrow functions are not supported");
          }
          if (!SINGLE_CHAR_OPERATORS.has(ch) && ch !== "?") {
            this.throwError("TOKEN_UNEXPECTED_OPERATOR", "Unexpected operator");
          }
          return this.createToken("OPERATOR", ch, start, this.getLocationSnapshot());
        }
        tokenizePunctuation() {
          const start = this.getLocationSnapshot();
          const ch = this.advance();
          if (ch === "." && this.peek() === "." && this.peek(1) === ".") {
            this.throwError("SYNTAX_UNSUPPORTED", "Spread syntax is not supported");
          }
          return this.createToken("PUNCTUATION", ch, start, this.getLocationSnapshot());
        }
      };
      var Parser = class {
        constructor(tokens, options = {}) {
          this.tokens = tokens;
          this.pos = 0;
          this.maxMemberDepth = options.maxMemberDepth || EXPRESSION_PARSER_DEFAULTS.maxMemberDepth;
          const disallowed = new Set(DISALLOWED_IDENTIFIERS);
          if (options.disallowedIdentifiers) {
            options.disallowedIdentifiers.forEach((identifier) => disallowed.add(identifier));
          }
          this.disallowedIdentifiers = disallowed;
        }
        parse() {
          if (!this.tokens.length) {
            throw new ExpressionParserError("EMPTY_EXPRESSION", "Empty expression");
          }
          const ast = this.parseExpression();
          if (!this.isAtEnd()) {
            this.error("UNEXPECTED_TOKEN", `Unexpected token: ${this.peek().value}`, this.peek());
          }
          return ast;
        }
        parseExpression() {
          return this.parseConditionalExpression();
        }
        parseConditionalExpression() {
          let expr = this.parseLogicalOrExpression();
          if (this.matchPunctuation("?")) {
            const consequent = this.parseExpression();
            this.consume("PUNCTUATION", ":");
            const alternate = this.parseExpression();
            expr = {
              type: "ConditionalExpression",
              test: expr,
              consequent,
              alternate
            };
          }
          return expr;
        }
        parseLogicalOrExpression() {
          let expr = this.parseLogicalAndExpression();
          while (this.matchOperator("||")) {
            const operator = this.previous().value;
            const right = this.parseLogicalAndExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseLogicalAndExpression() {
          let expr = this.parseNullishExpression();
          while (this.matchOperator("&&")) {
            const operator = this.previous().value;
            const right = this.parseNullishExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseNullishExpression() {
          let expr = this.parseEqualityExpression();
          while (this.matchOperator("??")) {
            const operator = this.previous().value;
            const right = this.parseEqualityExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseEqualityExpression() {
          let expr = this.parseRelationalExpression();
          while (this.matchOperator("===", "!==", "==", "!=")) {
            const operator = this.previous().value;
            const right = this.parseRelationalExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseRelationalExpression() {
          let expr = this.parseShiftExpression();
          while (this.matchOperator("<", ">", "<=", ">=", "instanceof", "in")) {
            const operator = this.previous().value;
            const right = this.parseShiftExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseShiftExpression() {
          let expr = this.parseAdditiveExpression();
          while (this.matchOperator("<<", ">>", ">>>")) {
            const operator = this.previous().value;
            const right = this.parseAdditiveExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseAdditiveExpression() {
          let expr = this.parseMultiplicativeExpression();
          while (this.matchOperator("+", "-")) {
            const operator = this.previous().value;
            const right = this.parseMultiplicativeExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseMultiplicativeExpression() {
          let expr = this.parseUnaryExpression();
          while (this.matchOperator("*", "/", "%")) {
            const operator = this.previous().value;
            const right = this.parseUnaryExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseUnaryExpression() {
          if (this.matchOperator("+", "-", "!", "~", "typeof", "void", "delete")) {
            const operator = this.previous().value;
            const argument = this.parseUnaryExpression();
            return { type: "UnaryExpression", operator, argument };
          }
          return this.parseLeftHandSideExpression();
        }
        parseLeftHandSideExpression() {
          let expr = this.parsePrimaryExpression();
          while (true) {
            if (this.matchPunctuation(".")) {
              const operatorToken = this.previous();
              const property = this.consumePropertyIdentifier();
              const depth = this.getChainDepth(expr) + 1;
              this.assertMemberDepth(depth, operatorToken);
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: false
              };
              this.setChainDepth(expr, depth);
            } else if (this.matchPunctuation("[")) {
              const operatorToken = this.previous();
              const property = this.parseExpression();
              this.consume("PUNCTUATION", "]");
              const depth = this.getChainDepth(expr) + 1;
              this.assertMemberDepth(depth, operatorToken);
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: true
              };
              this.setChainDepth(expr, depth);
            } else if (this.matchPunctuation("(")) {
              const args = this.parseArguments();
              expr = {
                type: "CallExpression",
                callee: expr,
                arguments: args
              };
              this.setChainDepth(expr, this.getChainDepth(expr.callee));
            } else {
              break;
            }
          }
          return expr;
        }
        parsePrimaryExpression() {
          const token = this.peek();
          if (!token) {
            this.error("UNEXPECTED_END", "Unexpected end of expression", token);
          }
          if (token.type === "NUMBER" || token.type === "STRING") {
            this.advance();
            return { type: "Literal", value: token.value };
          }
          if (token.type === "KEYWORD") {
            this.advance();
            return { type: "Literal", value: this.literalFromKeyword(token.value) };
          }
          if (token.type === "IDENTIFIER") {
            this.advance();
            this.assertIdentifierAllowed(token);
            return { type: "Identifier", value: token.value };
          }
          if (this.matchPunctuation("(")) {
            const expr = this.parseExpression();
            this.consume("PUNCTUATION", ")");
            return expr;
          }
          if (this.matchPunctuation("[")) {
            const elements = [];
            if (!this.check("PUNCTUATION", "]")) {
              do {
                elements.push(this.parseExpression());
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "]");
            return { type: "ArrayExpression", elements };
          }
          if (this.matchPunctuation("{")) {
            const properties = [];
            if (!this.check("PUNCTUATION", "}")) {
              do {
                const key2 = this.parsePropertyKey();
                this.consume("PUNCTUATION", ":");
                const value2 = this.parseExpression();
                properties.push({ key: key2, value: value2 });
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "}");
            return { type: "ObjectExpression", properties };
          }
          this.error("UNEXPECTED_TOKEN", `Unexpected token: ${token.value}`, token);
        }
        parsePropertyKey() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          this.error("INVALID_OBJECT_KEY", "Invalid object property key", token);
        }
        parseArguments() {
          const args = [];
          if (!this.check("PUNCTUATION", ")")) {
            do {
              args.push(this.parseExpression());
            } while (this.matchPunctuation(","));
          }
          this.consume("PUNCTUATION", ")");
          return args;
        }
        literalFromKeyword(value2) {
          switch (value2) {
            case "true":
              return true;
            case "false":
              return false;
            case "null":
              return null;
            case "undefined":
              return void 0;
            default:
              return value2;
          }
        }
        consume(type, value2) {
          if (this.check(type, value2)) {
            return this.advance();
          }
          const expected = value2 ? `${type} '${value2}'` : type;
          this.error("MISSING_TOKEN", `Expected ${expected}`, this.peek());
        }
        check(type, value2) {
          if (this.isAtEnd()) return false;
          const token = this.peek();
          if (token.type !== type) return false;
          if (typeof value2 === "undefined") return true;
          return token.value === value2;
        }
        matchOperator(...operators) {
          if (this.check("OPERATOR") && operators.includes(this.peek().value)) {
            this.advance();
            return true;
          }
          return false;
        }
        matchPunctuation(value2) {
          if (this.check("PUNCTUATION", value2)) {
            this.advance();
            return true;
          }
          return false;
        }
        consumePropertyIdentifier() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          this.error("INVALID_PROPERTY", "Expected property name", token);
        }
        buildBinaryExpression(operator, left, right) {
          return { type: "BinaryExpression", operator, left, right };
        }
        buildLogicalExpression(operator, left, right) {
          return { type: "LogicalExpression", operator, left, right };
        }
        getChainDepth(node) {
          if (!node || typeof node !== "object") {
            return 0;
          }
          return node.__chainDepth || 0;
        }
        setChainDepth(node, depth) {
          if (!node || typeof node !== "object") {
            return;
          }
          Object.defineProperty(node, "__chainDepth", {
            value: depth,
            enumerable: false,
            configurable: true
          });
        }
        assertMemberDepth(depth, token) {
          if (depth > this.maxMemberDepth) {
            this.error("MEMBER_DEPTH_EXCEEDED", `Member access depth ${depth} exceeds maximum of ${this.maxMemberDepth}`, token);
          }
        }
        assertIdentifierAllowed(token) {
          if (this.disallowedIdentifiers.has(token.value)) {
            this.error("DISALLOWED_IDENTIFIER", `Identifier '${token.value}' is not allowed in expressions`, token);
          }
        }
        error(code, message, token) {
          throw new ExpressionParserError(code, message, token ? { location: token.start } : void 0);
        }
        advance() {
          if (!this.isAtEnd()) {
            this.pos += 1;
          }
          return this.tokens[this.pos - 1];
        }
        peek() {
          if (this.isAtEnd()) return null;
          return this.tokens[this.pos];
        }
        previous() {
          return this.tokens[this.pos - 1];
        }
        isAtEnd() {
          return this.pos >= this.tokens.length;
        }
      };
      var Evaluator = class {
        constructor(context2 = {}, options = {}) {
          this.context = context2 || {};
          this.helpers = options.helpers || {};
          this.strict = options.strict || false;
          this.allowCall = options.allowCall || null;
          this.allowedFunctions = new Set(options.allowedFunctions || []);
          this.allowedGlobals = new Set(options.allowedGlobals || []);
          Object.values(this.helpers).forEach((value2) => {
            if (typeof value2 === "function") {
              this.allowedFunctions.add(value2);
            }
          });
        }
        evaluate(node) {
          switch (node.type) {
            case "Literal":
              return node.value;
            case "Identifier":
              return this.evaluateIdentifier(node);
            case "MemberExpression":
              return this.evaluateMemberExpression(node);
            case "CallExpression":
              return this.evaluateCallExpression(node);
            case "UnaryExpression":
              return this.evaluateUnaryExpression(node);
            case "BinaryExpression":
              return this.evaluateBinaryExpression(node);
            case "LogicalExpression":
              return this.evaluateLogicalExpression(node);
            case "ArrayExpression":
              return node.elements.map((element) => this.evaluate(element));
            case "ObjectExpression":
              return this.evaluateObjectExpression(node);
            case "ConditionalExpression":
              return this.evaluateConditionalExpression(node);
            default:
              throw new ExpressionParserError("UNSUPPORTED_NODE", `Unsupported AST node type: ${node.type}`);
          }
        }
        evaluateIdentifier(node) {
          const name = node.value;
          if (Object.prototype.hasOwnProperty.call(this.helpers, name)) {
            return this.helpers[name];
          }
          if (this.context && Object.prototype.hasOwnProperty.call(this.context, name)) {
            return this.context[name];
          }
          if (this.allowedGlobals.has(name) && name in GLOBAL_SCOPE) {
            return GLOBAL_SCOPE[name];
          }
          if (this.strict) {
            throw new ExpressionParserError("UNDEFINED_IDENTIFIER", `Undefined identifier: ${name}`);
          }
          console.error(`Undefined identifier: ${name}`);
          return void 0;
        }
        evaluateMemberExpression(node) {
          const object = this.evaluate(node.object);
          if (object === null || object === void 0) {
            throw new ExpressionParserError("NULL_MEMBER_ACCESS", "Cannot read property of null or undefined");
          }
          const property = node.computed ? this.evaluate(node.property) : node.property.type === "Identifier" ? node.property.value : node.property.value;
          return object[property];
        }
        evaluateCallExpression(node) {
          let callee;
          let thisArg;
          if (node.callee.type === "MemberExpression") {
            const object = this.evaluate(node.callee.object);
            if (object === null || object === void 0) {
              throw new ExpressionParserError("NULL_MEMBER_CALL", "Cannot call property of null or undefined");
            }
            const property = node.callee.computed ? this.evaluate(node.callee.property) : node.callee.property.type === "Identifier" ? node.callee.property.value : node.callee.property.value;
            callee = object[property];
            thisArg = object;
          } else {
            callee = this.evaluate(node.callee);
            thisArg = void 0;
          }
          if (typeof callee !== "function") {
            throw new ExpressionParserError("CALL_NON_FUNCTION", "Attempted to call a non-function");
          }
          if (!this.isCallAllowed(callee, thisArg)) {
            throw new ExpressionParserError("CALL_NOT_ALLOWED", "Function call not allowed by policy");
          }
          const args = node.arguments.map((arg) => this.evaluate(arg));
          return callee.apply(thisArg, args);
        }
        isCallAllowed(fn, thisArg) {
          if (this.allowCall) {
            const decision = this.allowCall(fn, thisArg);
            if (decision === true) return true;
            if (decision === false) return false;
          }
          return this.allowedFunctions.has(fn);
        }
        evaluateUnaryExpression(node) {
          let argumentValue;
          if (node.operator === "delete") {
            argumentValue = node.argument;
          } else if (node.operator === "typeof" && node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
            argumentValue = void 0;
          } else {
            argumentValue = this.evaluate(node.argument);
          }
          switch (node.operator) {
            case "+":
              return +argumentValue;
            case "-":
              return -argumentValue;
            case "!":
              return !argumentValue;
            case "~":
              return ~argumentValue;
            case "typeof":
              if (node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
                return "undefined";
              }
              return typeof argumentValue;
            case "void":
              return void argumentValue;
            case "delete":
              return this.performDelete(node.argument);
            default:
              throw new ExpressionParserError("UNSUPPORTED_UNARY", `Unsupported unary operator: ${node.operator}`);
          }
        }
        isIdentifierDefined(name) {
          return Object.prototype.hasOwnProperty.call(this.helpers, name) || this.context && Object.prototype.hasOwnProperty.call(this.context, name) || this.allowedGlobals.has(name) && name in GLOBAL_SCOPE;
        }
        performDelete(argument) {
          if (argument.type === "Identifier" && this.context && typeof this.context === "object") {
            return delete this.context[argument.value];
          }
          if (argument.type === "MemberExpression") {
            const target = this.evaluate(argument.object);
            if (target === null || target === void 0) {
              return true;
            }
            const property = argument.computed ? this.evaluate(argument.property) : argument.property.type === "Identifier" ? argument.property.value : argument.property.value;
            return delete target[property];
          }
          this.evaluate(argument);
          return true;
        }
        evaluateBinaryExpression(node) {
          const left = this.evaluate(node.left);
          const right = this.evaluate(node.right);
          switch (node.operator) {
            case "+":
              return left + right;
            case "-":
              return left - right;
            case "*":
              return left * right;
            case "/":
              return left / right;
            case "%":
              return left % right;
            case "==":
              return left == right;
            case "!=":
              return left != right;
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "in":
              return left in right;
            case "instanceof":
              return left instanceof right;
            default:
              throw new ExpressionParserError("UNSUPPORTED_BINARY", `Unsupported binary operator: ${node.operator}`);
          }
        }
        evaluateLogicalExpression(node) {
          switch (node.operator) {
            case "&&": {
              const left = this.evaluate(node.left);
              return left ? this.evaluate(node.right) : left;
            }
            case "||": {
              const left = this.evaluate(node.left);
              return left ? left : this.evaluate(node.right);
            }
            case "??": {
              const left = this.evaluate(node.left);
              return left !== null && left !== void 0 ? left : this.evaluate(node.right);
            }
            default:
              throw new ExpressionParserError("UNSUPPORTED_LOGICAL", `Unsupported logical operator: ${node.operator}`);
          }
        }
        evaluateObjectExpression(node) {
          const obj2 = {};
          node.properties.forEach((property) => {
            const key2 = this.evaluatePropertyKey(property.key);
            obj2[key2] = this.evaluate(property.value);
          });
          return obj2;
        }
        evaluatePropertyKey(node) {
          if (node.type === "Identifier") {
            return node.value;
          }
          return node.value;
        }
        evaluateConditionalExpression(node) {
          const test = this.evaluate(node.test);
          return test ? this.evaluate(node.consequent) : this.evaluate(node.alternate);
        }
      };
      var ExpressionParser = class {
        constructor(options = {}) {
          this.options = normalizeOptions(null, options);
          const cacheLimit = this.options.cache !== false ? this.options.cacheSize : 0;
          this.astCache = new ExpressionCache(cacheLimit);
          this.valueCache = new ExpressionCache(cacheLimit);
        }
        tokenize(expression) {
          return new Tokenizer(expression).tokenize();
        }
        parse(expression, overrideOptions) {
          const options = this.ensureNormalizedOptions(overrideOptions);
          this.ensureExpressionLength(expression, options);
          const useCache = this.shouldUseCache(options);
          if (useCache) {
            const cachedAst = this.astCache.get(expression);
            if (cachedAst) {
              return cachedAst;
            }
          }
          const tokens = this.tokenize(expression);
          if (!tokens.length) {
            throw new ExpressionParserError("EMPTY_EXPRESSION", "Empty expression");
          }
          const parser = new Parser(tokens, options);
          const ast = parser.parse();
          Object.defineProperty(ast, "tokens", {
            value: tokens,
            enumerable: false,
            configurable: true
          });
          if (useCache) {
            this.astCache.set(expression, ast);
          }
          return ast;
        }
        evaluate(expression, context2 = {}, overrideOptions = {}) {
          const mergedOptions = this.mergeOptions(overrideOptions);
          const useCache = this.shouldUseCache(mergedOptions);
          if (useCache) {
            const cached = this.getCachedValue(expression, context2, mergedOptions);
            if (cached.hit) {
              return cached.value;
            }
          }
          const ast = this.parse(expression, mergedOptions);
          const evaluator = new Evaluator(context2, mergedOptions);
          const result = evaluator.evaluate(ast);
          if (useCache) {
            this.storeCachedValue(expression, context2, result, mergedOptions);
          }
          return result;
        }
        compile(expression, overrideOptions = {}) {
          const baseOptions = this.mergeOptions(overrideOptions);
          const ast = this.parse(expression, baseOptions);
          return (context2 = {}, runtimeOptions = {}) => {
            const invocationOptions = this.mergeOptions(runtimeOptions, baseOptions);
            const evaluator = new Evaluator(context2, invocationOptions);
            return evaluator.evaluate(ast);
          };
        }
        shouldUseCache(options) {
          return options.cache !== false && options.cacheSize > 0;
        }
        ensureNormalizedOptions(options) {
          if (options && options[NORMALIZED_OPTIONS_FLAG]) {
            return options;
          }
          if (!options) {
            return this.options;
          }
          return this.mergeOptions(options);
        }
        ensureExpressionLength(expression, options) {
          if (expression.length > options.maxExpressionLength) {
            throw new ExpressionParserError(
              "EXPRESSION_TOO_LONG",
              `Expression exceeds maximum length of ${options.maxExpressionLength} characters`
            );
          }
        }
        mergeOptions(override = {}, baseOptions) {
          const base = baseOptions && baseOptions[NORMALIZED_OPTIONS_FLAG] ? baseOptions : baseOptions || this.options;
          return normalizeOptions(base, override);
        }
        getCachedValue(expression, context2, options) {
          const bucket = this.valueCache.get(expression);
          if (!bucket) {
            return { hit: false };
          }
          if (this.isObjectLike(context2)) {
            if (bucket.objectCache && bucket.objectCache.has(context2)) {
              return { hit: true, value: bucket.objectCache.get(context2) };
            }
            return { hit: false };
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return { hit: false };
          }
          if (bucket.primitiveCache && bucket.primitiveCache.has(key2)) {
            return { hit: true, value: bucket.primitiveCache.get(key2) };
          }
          return { hit: false };
        }
        storeCachedValue(expression, context2, value2, options) {
          if (!this.shouldUseCache(options)) {
            return;
          }
          let bucket = this.valueCache.get(expression);
          if (!bucket) {
            bucket = { objectCache: /* @__PURE__ */ new WeakMap(), primitiveCache: /* @__PURE__ */ new Map() };
            this.valueCache.set(expression, bucket);
          }
          if (this.isObjectLike(context2)) {
            bucket.objectCache.set(context2, value2);
            return;
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return;
          }
          bucket.primitiveCache.set(key2, value2);
        }
        resolvePrimitiveKey(context2, options) {
          if (options.cacheKeyResolver) {
            return options.cacheKeyResolver(context2);
          }
          return context2;
        }
        isObjectLike(value2) {
          return value2 !== null && (typeof value2 === "object" || typeof value2 === "function");
        }
        getCacheStats() {
          return {
            astEntries: this.astCache.size,
            valueEntries: this.valueCache.size
          };
        }
      };
      function normalizeOptions(baseOptions, overrideOptions = {}) {
        const base = baseOptions && baseOptions[NORMALIZED_OPTIONS_FLAG] ? baseOptions : { ...EXPRESSION_PARSER_DEFAULTS, ...baseOptions || {} };
        const helpers = { ...base.helpers || {}, ...overrideOptions.helpers || {} };
        const allowedFunctions = /* @__PURE__ */ new Set([
          ...base.allowedFunctions || [],
          ...overrideOptions.allowedFunctions || []
        ]);
        const allowedGlobals = /* @__PURE__ */ new Set([
          ...base.allowedGlobals || DEFAULT_ALLOWED_GLOBALS,
          ...overrideOptions.allowedGlobals || []
        ]);
        const normalized = {
          ...EXPRESSION_PARSER_DEFAULTS,
          ...base,
          ...overrideOptions,
          helpers,
          allowedFunctions: Array.from(allowedFunctions),
          allowedGlobals: Array.from(allowedGlobals)
        };
        Object.defineProperty(normalized, NORMALIZED_OPTIONS_FLAG, {
          value: true,
          enumerable: false
        });
        return normalized;
      }
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type,
        ExpressionParser,
        ExpressionParserError
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // ../jsgui3-html/node_modules/obext/node_modules/lang-mini/lib-lang-mini.js
  var require_lib_lang_mini3 = __commonJS({
    "../jsgui3-html/node_modules/obext/node_modules/lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini3();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // ../jsgui3-html/node_modules/obext/oext.js
  var require_oext = __commonJS({
    "../jsgui3-html/node_modules/obext/oext.js"(exports, module) {
      var {
        each,
        get_a_sig,
        def,
        is_array,
        tof,
        tf: tf2
      } = require_lib_lang_mini3();
      var ifn = (item2) => typeof item2 === "function";
      var ia2 = is_array;
      var get_instance = function() {
        const opts = {
          raise_change_events: true
        };
        const states = (obj2, states2) => {
        };
        const get_set = (obj2, prop_name2, fn_get, fn_set) => {
          const def2 = {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get: fn_get,
            set: fn_set,
            enumerable: true,
            configurable: false
          };
          const t_prop_name = tf2(prop_name2);
          if (t_prop_name === "a") {
            each(prop_name2, (name) => Object.defineProperty(obj2, name, def2));
          } else if (t_prop_name === "s") {
            Object.defineProperty(obj2, prop_name2, def2);
          } else {
            console.trace();
            throw "Unexpected prop_name, must be array or string";
          }
        };
        const read_only = (obj2, prop_name2, fn_get) => {
          Object.defineProperty(obj2, prop_name2, {
            enumerable: true,
            get: fn_get
          });
        };
        const prop = (...a) => {
          let s = get_a_sig(a);
          if (s === "[a]") {
            each(a[0], (item_params2) => {
              prop.apply(this, item_params2);
            });
          } else {
            if (a.length === 2) {
              if (ia2(a[1])) {
                const target = a[0];
                each(a[1], (item2) => {
                  if (ia2(item2)) {
                    throw "NYI 468732";
                  } else {
                    prop(target, item2);
                  }
                });
              } else {
                const ta1 = tof(a[1]);
                if (ta1 === "string") {
                  [obj, prop_name] = a;
                } else {
                  throw "NYI 468732b";
                }
              }
            } else if (a.length > 2) {
              if (ia2(a[0])) {
                throw "stop";
                let objs = a.shift();
                each(objs, (obj2) => {
                  prop.apply(this, [obj2].concat(item_params));
                });
              } else {
                let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
                const load_options = (options2) => {
                  prop_name2 = prop_name2 || options2.name || options2.prop_name;
                  fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                  fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                  fn_on_ready = options2.ready || options2.on_ready;
                  default_value = default_value || options2.default_value || options2.default;
                };
                if (a.length === 2) {
                  [obj2, options] = a;
                  load_options(options);
                } else if (a.length === 3) {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_onchange] = a;
                  } else {
                    if (a[2] !== void 0 && (a[2].change || a[2].ready)) {
                      load_options(a[2]);
                      [obj2, prop_name2] = a;
                    } else {
                      [obj2, prop_name2, default_value] = a;
                    }
                  }
                } else if (a.length === 4) {
                  if (ifn(a[2]) && ifn(a[3])) {
                    [obj2, prop_name2, fn_transform, fn_onchange] = a;
                  } else if (ifn(a[3])) {
                    [obj2, prop_name2, default_value, fn_onchange] = a;
                  } else {
                    [obj2, prop_name2, default_value, options] = a;
                    load_options(options);
                  }
                } else if (a.length === 5) {
                  [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
                }
                let _prop_value;
                if (typeof default_value !== "undefined") _prop_value = default_value;
                const _silent_set = (value2) => {
                  let _value;
                  if (fn_transform) {
                    _value = fn_transform(value2);
                  } else {
                    _value = value2;
                  }
                  _prop_value = _value;
                };
                const _set = (value2) => {
                  let _value;
                  if (fn_transform) {
                    _value = fn_transform(value2);
                  } else {
                    _value = value2;
                  }
                  let old = _prop_value;
                  _prop_value = _value;
                  if (fn_onchange) {
                    fn_onchange({
                      old,
                      value: _prop_value
                    });
                  }
                  if (obj2.raise && opts.raise_change_events) {
                    obj2.raise("change", {
                      name: prop_name2,
                      old,
                      value: _prop_value
                    });
                  }
                };
                if (def(default_value)) {
                  _prop_value = default_value;
                }
                const t_prop_name = tf2(prop_name2);
                if (t_prop_name === "s") {
                  Object.defineProperty(obj2, prop_name2, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                } else if (t_prop_name === "a") {
                  const l2 = prop_name2.length;
                  let item_prop_name;
                  for (let c2 = 0; c2 < l2; c2++) {
                    item_prop_name = prop_name2[c2];
                    Object.defineProperty(obj2, item_prop_name, {
                      get() {
                        return _prop_value;
                      },
                      set(value2) {
                        _set(value2);
                      }
                    });
                  }
                } else {
                  throw "Unexpected name type: " + t_prop_name;
                }
                if (fn_on_ready) {
                  fn_on_ready({
                    silent_set: _silent_set
                  });
                }
              }
            }
          }
        };
        const field = (...a) => {
          let s = get_a_sig(a);
          if (s === "[a]") {
            each(a[0], (item_params2) => {
              prop.apply(this, item_params2);
            });
          } else {
            if (a.length > 1) {
              if (ia2(a[0])) {
                let objs = a.shift();
                each(objs, (obj2) => {
                  prop.apply(this, [obj2].concat(item_params));
                });
              } else {
                let obj2, prop_name2, default_value, fn_transform;
                let raise_change_events = opts.raise_change_events;
                if (a.length === 2) {
                  [obj2, prop_name2] = a;
                } else if (a.length === 3) {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                } else if (a.length === 4) {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
                if (obj2 !== void 0) {
                  Object.defineProperty(obj2, prop_name2, {
                    get() {
                      if (def(obj2._)) {
                        return obj2._[prop_name2];
                      } else {
                        return void 0;
                      }
                    },
                    set(value2) {
                      let old = (obj2._ = obj2._ || {})[prop_name2];
                      let _value;
                      if (fn_transform) {
                        _value = fn_transform(value2);
                      } else {
                        _value = value2;
                      }
                      obj2._[prop_name2] = _value;
                      if (raise_change_events) {
                        obj2.raise("change", {
                          name: prop_name2,
                          old,
                          value: _value
                        });
                      }
                    }
                  });
                  if (def(default_value)) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                } else {
                  throw "stop";
                }
              }
            }
          }
        };
        return {
          opts,
          // module level options
          prop,
          field,
          read_only,
          ro: read_only,
          get_set,
          gs: get_set
        };
      };
      module.exports = get_instance();
    }
  });

  // ../jsgui3-html/html-core/control-core.js
  var require_control_core = __commonJS({
    "../jsgui3-html/html-core/control-core.js"(exports, module) {
      var jsgui = require_lang();
      var oext = require_oext();
      var { Base_Data_Object } = require_lang_tools_compat();
      var { Data_Model, Collection, tof, stringify, get_a_sig, each, Evented_Class } = jsgui;
      var Text_Node = require_text_node();
      var {
        prop,
        field
      } = require_oext();
      var px_handler = (target, property, value2, receiver) => {
        let res2;
        var t_val = tof(value2);
        if (t_val === "number") {
          res2 = value2 + "px";
        } else if (t_val === "string") {
          var match = value2.match(/(\d*\.?\d*)(.*)/);
          if (match.length === 2) {
            res2 = value2 + "px";
          } else {
            res2 = value2;
          }
        }
        return res2;
      };
      var style_input_handlers = {
        "width": px_handler,
        "height": px_handler,
        "left": px_handler,
        "top": px_handler
      };
      var new_obj_style = () => {
        let style = new Evented_Class({});
        style.__empty = true;
        style.toString = () => {
          var res3 = [];
          var first = true;
          each(style, (value2, key2) => {
            const tval = typeof value2;
            if (tval !== "function" && key2 !== "toString" && key2 !== "__empty" && key2 !== "_bound_events" && key2 !== "on" && key2 !== "subscribe" && key2 !== "raise" && key2 !== "trigger") {
              if (first) {
                first = false;
              } else {
                res3.push(" ");
              }
              res3.push(key2 + ": " + value2 + ";");
            }
          });
          return res3.join("");
        };
        const res2 = new Proxy(style, {
          set: (target, property, value2, receiver) => {
            let res3;
            target["__empty"] = false;
            var old_value = target[property];
            if (style_input_handlers[property]) {
              res3 = target[property] = style_input_handlers[property](target, property, value2, receiver);
            } else {
              res3 = target[property] = value2;
            }
            style.raise("change", {
              "key": property,
              "name": property,
              "old": old_value,
              "new": value2,
              "value": value2
            });
            return res3;
          },
          get: (target, property, receiver) => {
            if (property === "toString") {
              return () => target + "";
            } else {
              return target[property];
            }
          }
        });
        return res2;
      };
      var DOM_Attributes = class extends Evented_Class {
        constructor(spec) {
          super(spec);
          this.style = new_obj_style();
          this.style.on("change", (e_change) => {
            this.raise("change", {
              "property": "style",
              "key": "style",
              "name": "style",
              "value": this.style.toString()
            });
          });
        }
      };
      var Control_DOM = class extends Evented_Class {
        constructor() {
          super();
          var dom_attributes = new DOM_Attributes();
          var attrs = this.attrs = this.attributes = new Proxy(dom_attributes, {
            "set": (target, property, value2, receiver) => {
              if (property === "style") {
                var t_value = tof(value2);
                if (t_value === "string") {
                  var s_values = value2.trim().split(";");
                  var kv;
                  each(s_values, (s_value) => {
                    kv = s_value.split(":");
                    if (kv.length === 2) {
                      kv[0] = kv[0].trim();
                      kv[1] = kv[1].trim();
                      target.style[kv[0]] = kv[1];
                    }
                  });
                  dom_attributes.raise("change", {
                    "property": property
                  });
                }
              } else {
                var old_value = target[property];
                target[property] = value2;
                dom_attributes.raise("change", {
                  "key": property,
                  "name": property,
                  "old": old_value,
                  "new": value2,
                  "value": value2
                });
              }
              return true;
            },
            get: (target, property, receiver) => {
              return target[property];
            }
          });
        }
      };
      var Control_Background = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          let _color, _opacity;
          Object.defineProperty(this, "color", {
            get() {
              return _color;
            },
            set(value2) {
              const old = _color;
              _color = value2;
              this.raise("change", {
                "name": "color",
                "old": old,
                "new": _color,
                "value": _color
              });
            },
            enumerable: true,
            configurable: true
          });
        }
        set(val) {
        }
      };
      var Control_Core = class _Control_Core extends Base_Data_Object {
        constructor(spec = {}, fields) {
          spec.__type_name = spec.__type_name || "control";
          super(spec, fields);
          if (spec.id) {
            this.__id = spec.id;
          }
          if (spec.__id) {
            this.__id = spec.__id;
          }
          this.mapListeners = {};
          this.__type = "control";
          var spec_content;
          let d = this.dom = new Control_DOM();
          prop(this, "background", new Control_Background(), (e_change) => {
            let {
              value: value2
            } = e_change;
          });
          this.background.on("change", (evt) => {
            if (evt.name === "color") {
              d.attributes.style["background-color"] = evt.value;
            }
          });
          prop(this, "disabled", false);
          prop(this, "size", spec.size, (e_change) => {
            let {
              value: value2,
              old
            } = e_change;
            let [width, height2] = value2;
            const s = this.dom.attrs.style;
            s.width = width;
            s.height = height2;
            this.raise("resize", {
              "value": value2
            });
          });
          prop(this, "pos", void 0, (e_change) => {
            let {
              value: value2,
              old
            } = e_change;
            if (value2.length === 2) {
            }
            let [left, top] = value2;
            let o_style = {
              "left": left,
              "top": top
            };
            this.style(o_style);
            this.raise("move", {
              "value": value2
            });
          });
          if (spec.pos) this.pos = spec.pos;
          this.on("change", (e) => {
            if (e.name === "disabled") {
              if (e.value === true) {
                this.add_class("disabled");
              } else {
                this.remove_class("disabled");
              }
            }
          });
          let tagName = spec.tagName || spec.tag_name || "div";
          d.tagName = tagName;
          var content = this.content = new Collection({});
          spec_content = spec.content;
          if (spec_content) {
            var tsc = tof(spec_content);
            if (tsc === "array") {
              each(spec.content, (item2) => {
                content.add(item2);
              });
            } else if (tsc === "string" || tsc === "control") {
              content.add(spec_content);
            }
          }
          if (spec.el) {
            d.el = spec.el;
            if (spec.el.tagName) d.tagName = spec.el.tagName.toLowerCase();
          }
          var context2 = this.context || spec.context;
          if (context2) {
            if (context2.register_control) context2.register_control(this);
          } else {
          }
          if (spec["class"]) {
            this.add_class(spec["class"]);
          }
          if (spec["css_class"]) {
            this.add_class(spec["css_class"]);
          }
          if (spec["cssClass"]) {
            this.add_class(spec["cssClass"]);
          }
          if (spec.hide) {
            this.hide();
          }
          if (spec.add) {
            this.add(spec.add);
          }
          if (spec.attrs) {
            this.dom.attributes = spec.attrs;
          }
        }
        get left() {
          const sl = this.dom.attributes.style.left;
          if (sl) {
            return parseInt(sl) + this.ta[6];
          }
        }
        get top() {
          const st = this.dom.attributes.style.top;
          if (st) {
            return parseInt(st) + this.ta[7];
          }
        }
        set top(value2) {
          if (typeof value2 === "number") {
            const measured_current_top = this.top;
            const diff = Math.round(value2 - measured_current_top);
            this.ta[7] += diff;
          }
        }
        "hide"() {
          let e = {
            cancelDefault: false
          };
          this.raise("hide", e);
          if (!e.cancelDefault) {
            this.add_class("hidden");
          }
        }
        "show"() {
          let e = {
            cancelDefault: false
          };
          this.raise("show", e);
          if (!e.cancelDefault) {
            this.remove_class("hidden");
          }
        }
        get html() {
          return this.all_html_render();
        }
        get internal_relative_div() {
          return this._internal_relative_div || false;
        }
        set internal_relative_div(value2) {
          var old_value = this._internal_relative_div;
          this._internal_relative_div = value2;
          if (value2 === true) {
          }
        }
        get color() {
          return this.background.color;
        }
        set color(value2) {
          this.background.color = value2;
        }
        "post_init"(spec) {
          if (spec && spec.id === true) {
            this.dom.attrs.id = this._id();
          }
        }
        "has"(item_name) {
          var arr = item_name.split(".");
          var c2 = 0, l2 = arr.length;
          var i = this;
          var s;
          while (c2 < l2) {
            s = arr[c2];
            if (typeof i[s] == "undefined") {
              return false;
            }
            i = i[s];
            c2++;
          }
          ;
          return i;
        }
        "renderDomAttributes"() {
          var _a, _b, _c, _d;
          if (this.beforeRenderDomAttributes) {
            this.beforeRenderDomAttributes();
          }
          var dom_attrs = this.dom.attributes;
          if (!dom_attrs) {
            throw "expecting dom_attrs";
          } else {
            if (this._) {
              var keys = Object.keys(this._);
              var key2;
              for (var c2 = 0, l2 = keys.length; c2 < l2; c2++) {
                key2 = keys[c2];
                if (key2 !== "_bound_events") {
                  if (key2 instanceof _Control_Core) {
                    (this._ctrl_fields = this._ctrl_fields || {})[key2] = this._[key2];
                  } else {
                    this._fields = this._fields || {};
                    this._fields[key2] = this._[key2];
                  }
                }
              }
            }
            if (this._ctrl_fields) {
              var obj_ctrl_fields = {};
              var keys = Object.keys(this._ctrl_fields);
              var key2;
              for (var c2 = 0, l2 = keys.length; c2 < l2; c2++) {
                key2 = keys[c2];
                if (key2 !== "_bound_events") {
                  obj_ctrl_fields[key2] = this._ctrl_fields[key2]._id();
                }
              }
              let scf = stringify(obj_ctrl_fields).replace(/"/g, "'");
              if (scf.length > 2) {
                dom_attrs["data-jsgui-ctrl-fields"] = scf;
              }
            }
            if (this._fields) {
              let sf = stringify(this._fields).replace(/"/g, "'");
              if (sf.length > 2) {
                dom_attrs["data-jsgui-fields"] = sf;
              }
            }
            if (this.view.data.model.mixins) {
              let smxs = "[";
              let first = true;
              (_d = (_c = (_b = (_a = this.view) == null ? void 0 : _a.data) == null ? void 0 : _b.model) == null ? void 0 : _c.mixins) == null ? void 0 : _d.each((mx) => {
                if (!first) {
                  smxs += ",";
                } else {
                  first = false;
                }
                const smx = JSON.stringify(mx);
                smxs += smx;
              });
              smxs += "]";
              smxs = smxs.replace(/"/g, "'");
              if (smxs.length > 2) {
                dom_attrs["data-jsgui-mixins"] = smxs;
              }
            }
            const arr = [];
            const id = this._id();
            if (id !== void 0) {
              arr.push(' data-jsgui-id="' + this._id() + '"');
            }
            if (this.data && this.data._model instanceof Data_Model) {
              const dmid = this.data._model.__id;
              if (dmid) {
                arr.push(' data-jsgui-data-model-id="' + dmid + '"');
              }
            }
            const exempt_types = {
              html: true,
              head: true,
              body: true
            };
            if (this.context && this.__type_name) {
              if (!exempt_types[this.__type_name] && this.__type_name !== void 0) {
                arr.push(' data-jsgui-type="' + this.__type_name + '"');
              }
            }
            var dom_attrs_keys = Object.keys(dom_attrs);
            var key2, item2;
            for (var c2 = 0, l2 = dom_attrs_keys.length; c2 < l2; c2++) {
              key2 = dom_attrs_keys[c2];
              if (key2 == "_bound_events") {
              } else if (key2 === "style") {
                item2 = dom_attrs[key2];
                if (typeof item2 !== "function") {
                  if (typeof item2 === "object") {
                    if (key2 === "style") {
                      const sprops = [];
                      each(item2, (v, k) => {
                        const tval = typeof v;
                        if (tval !== "function") {
                          if (k !== "__empty") {
                            const sprop = k + ":" + v;
                            sprops.push(sprop);
                          }
                        }
                      });
                      if (sprops.length > 0) arr.push(" ", key2, '="', sprops.join(";"), '"');
                    } else {
                      let s_obj;
                      try {
                        s_obj = stringify(item2);
                      } catch (e) {
                        if (item2 && item2.toString) {
                          s_obj = item2.toString();
                        } else {
                          s_obj = "";
                        }
                      }
                      if (s_obj && s_obj.length > 0) {
                        s_obj = s_obj.replace(/\"/g, "'");
                        arr.push(" ", key2, '="', s_obj, '"');
                      }
                    }
                  } else {
                    let is = item2.toString();
                    if (!item2.__empty && is.length > 0) {
                      arr.push(" ", key2, '="', is, '"');
                    }
                  }
                }
              } else {
                item2 = dom_attrs[key2];
                if (item2 && item2.toString) {
                  if (typeof item2 === "object" && item2 !== null) {
                    let s_obj;
                    try {
                      s_obj = stringify(item2);
                    } catch (e) {
                      s_obj = item2.toString();
                    }
                    if (s_obj && s_obj.length > 0) {
                      s_obj = s_obj.replace(/\"/g, "'");
                      arr.push(" ", key2, '="', s_obj, '"');
                    }
                  } else {
                    arr.push(" ", key2, '="', item2.toString(), '"');
                  }
                }
              }
            }
            return arr.join("");
          }
        }
        "renderBeginTagToHtml"() {
          const tagName = this.dom.tagName;
          var res2;
          if (tagName === false) {
            res2 = "";
          } else {
            res2 = ["<", tagName, this.renderDomAttributes(), ">"].join("");
          }
          return res2;
        }
        "renderEndTagToHtml"() {
          var res2;
          const tagName = this.dom.tagName;
          const noClosingTag = this.dom.noClosingTag;
          if (tagName === false || noClosingTag) {
            res2 = "";
          } else {
            res2 = ["</", tagName, ">"].join("");
          }
          return res2;
        }
        "renderHtmlAppendment"() {
          return this.htmlAppendment || "";
        }
        "renderEmptyNodeJqo"() {
          return [this.renderBeginTagToHtml(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join("");
        }
        "register_this_and_subcontrols"() {
          const context2 = this.context;
          this.iterate_this_and_subcontrols((ctrl) => {
            context2.register_control(ctrl);
          });
        }
        "iterate_subcontrols"(ctrl_callback) {
          const content = this.content;
          content.each((v) => {
            ctrl_callback(v);
            if (v && v.iterate_subcontrols) {
              v.iterate_subcontrols(ctrl_callback);
            }
          });
        }
        "iterate_this_and_subcontrols"(ctrl_callback) {
          ctrl_callback(this);
          const content = this.content;
          let tv;
          if (typeof content !== "string") {
            content.each((v) => {
              tv = tof(v);
              if (tv == "string") {
              } else if (tv == "data_value") {
              } else {
                if (v && v.iterate_this_and_subcontrols) {
                  v.iterate_this_and_subcontrols(ctrl_callback);
                }
              }
            });
          }
        }
        "all_html_render"(callback2) {
          if (callback2) {
            var arr_waiting_controls = [];
            this.iterate_this_and_subcontrols((control) => {
              if (control.__status == "waiting") arr_waiting_controls.push(control);
            });
            if (arr_waiting_controls.length == 0) {
              callback2(null, this.all_html_render());
            } else {
              var c2 = arr_waiting_controls.length;
              var complete = () => {
                this.pre_all_html_render();
                var dom2 = this.dom;
                if (dom2) {
                  callback2(null, [this.renderBeginTagToHtml(), this.all_html_render_internal_controls(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join(""));
                }
              };
              each(arr_waiting_controls, (control, i) => {
                control.on("ready", (e_ready) => {
                  c2--;
                  if (c2 == 0) {
                    complete();
                  }
                });
              });
            }
          } else {
            this.pre_all_html_render();
            var dom = this.dom;
            if (dom) {
              return [this.renderBeginTagToHtml(), this.all_html_render_internal_controls(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join("");
            }
          }
        }
        "render_content"() {
          var content = this.content;
          if (tof(content) === "string") {
            return content;
          } else {
            var contentLength = content.length();
            var res2 = new Array(contentLength);
            var tn, output;
            var arr = content._arr;
            var c2, l2 = arr.length, n;
            for (c2 = 0; c2 < l2; c2++) {
              n = arr[c2];
              if (n === null || typeof n === "undefined") {
                res2.push("");
                continue;
              }
              tn = tof(n);
              if (tn === "string") {
                const string_processor = jsgui.output_processors && jsgui.output_processors["string"];
                if (string_processor) {
                  res2.push(string_processor(n));
                } else {
                  res2.push(new Text_Node(n).all_html_render());
                }
              } else if (tn === "data_value") {
                let dv_val;
                if (typeof n.value !== "undefined") {
                  dv_val = n.value;
                } else if (typeof n._ !== "undefined") {
                  dv_val = n._;
                } else {
                  dv_val = n.toString();
                }
                if (dv_val === null || typeof dv_val === "undefined") dv_val = "";
                res2.push("" + dv_val);
              } else if (tn === "data_model" || tn === "data_object") {
                let s_val;
                try {
                  s_val = stringify(n);
                } catch (e) {
                  s_val = "" + n;
                }
                if (typeof s_val === "string" && s_val.length >= 2 && s_val[0] === '"' && s_val[s_val.length - 1] === '"') {
                  s_val = s_val.slice(1, -1);
                }
                const string_processor = jsgui.output_processors && jsgui.output_processors["string"];
                if (string_processor) {
                  res2.push(string_processor(s_val));
                } else {
                  res2.push(new Text_Node(s_val).all_html_render());
                }
              } else if (tn === "number" || tn === "boolean") {
                res2.push("" + n);
              } else if (n && typeof n.all_html_render === "function") {
                res2.push(n.all_html_render());
              } else {
                const string_processor = jsgui.output_processors && jsgui.output_processors["string"];
                const fallback = "" + n;
                if (string_processor) {
                  res2.push(string_processor(fallback));
                } else {
                  res2.push(new Text_Node(fallback).all_html_render());
                }
              }
            }
            return res2.join("");
          }
        }
        "all_html_render_internal_controls"() {
          return this.render_content();
        }
        "render"() {
          return this.all_html_render();
        }
        "pre_all_html_render"() {
          if (typeof document === "undefined") {
            this.raise("server-pre-render");
          }
        }
        "compose"() {
        }
        "visible"(callback2) {
          this.style("display", "block", callback2);
        }
        "transparent"(callback2) {
          this.style("opacity", 0, callback2);
        }
        "opaque"(callback2) {
          return this.style({
            "opacity": 1
          }, callback2);
        }
        "remove"() {
          return this.parent.content.remove(this);
        }
        "add"(new_content) {
          const tnc = tof(new_content);
          let res2;
          if (tnc === "array") {
            let res3 = [];
            each(new_content, (v) => {
              res3.push(this.add(v));
            });
          } else {
            if (new_content) {
              if (tnc === "string" || tnc === "number" || tnc === "boolean") {
                new_content = new Text_Node({
                  "text": new_content + "",
                  "context": this.context
                });
              } else {
                if (!new_content.context) {
                  if (this.context) {
                    new_content.context = this.context;
                  }
                }
              }
              var inner_control = this.inner_control;
              if (inner_control) {
                res2 = inner_control.content.add(new_content);
              } else {
                res2 = this.content.add(new_content);
              }
              new_content.parent = this;
            }
          }
          return res2;
        }
        "insert_before"(target) {
          const target_parent = target.parent;
          const target_index = target._index;
          const content = target_parent.content;
          content.insert(this, target_index);
        }
        "style"() {
          const a = arguments, sig = get_a_sig(a, 1), d = this.dom, da = d.attrs;
          a.l = a.length;
          let style_name, style_value, modify_dom = true;
          if (sig == "[s]") {
            style_name = a[0];
            const res2 = getComputedStyle(d.el)[style_name];
            return res2;
          } else if (sig == "[s,s,b]") {
            [style_name, style_value, modify_dom] = a;
          } else if (sig == "[s,s]" || sig == "[s,n]") {
            [style_name, style_value] = a;
          }
          ;
          if (style_name && typeof style_value !== "undefined") {
            if (da.style) {
              da.style[style_name] = style_value;
              da.raise("change", {
                "property": "style",
                "name": "style",
                "value": da.style + ""
              });
            } else {
            }
          }
          if (sig == "[o]") {
            each(a[0], (v, i) => {
              this.style(i, v);
            });
          }
        }
        "active"() {
        }
        "find_selection_scope"() {
          var res2 = this.selection_scope;
          if (res2) return res2;
          if (this.parent && this.parent.find_selection_scope) return this.parent.find_selection_scope();
        }
        "click"(handler) {
          this.on("click", handler);
        }
        "add_class"(class_name) {
          let da = this.dom.attrs, cls = da["class"];
          if (!cls) {
            da["class"] = class_name;
          } else {
            const tCls = tof(cls);
            if (tCls == "object") {
              throw "removed";
            } else if (tCls == "string") {
              let arr_classes = cls.split(" "), already_has_class = false, l2 = arr_classes.length, c2 = 0;
              while (c2 < l2 && !already_has_class) {
                if (arr_classes[c2] === class_name) {
                  already_has_class = true;
                }
                c2++;
              }
              if (!already_has_class) {
                arr_classes.push(class_name);
              }
              da["class"] = arr_classes.join(" ");
            }
          }
        }
        "has_class"(class_name) {
          let da = this.dom.attrs, cls = da["class"];
          if (cls) {
            var tCls = tof(cls);
            if (tCls == "object") {
              throw "removed";
            }
            if (tCls == "string") {
              var arr_classes = cls.split(" ");
              var arr_res = [];
              var l2 = arr_classes.length, c2 = 0;
              while (c2 < l2) {
                if (arr_classes[c2] === class_name) {
                  return true;
                }
                c2++;
              }
            }
          }
        }
        "remove_class"(class_name) {
          let da = this.dom.attrs, cls = da["class"];
          if (cls) {
            var tCls = tof(cls);
            if (tCls == "object") {
              throw "removed";
            }
            if (tCls == "string") {
              var arr_classes = cls.split(" ");
              var arr_res = [];
              var l2 = arr_classes.length, c2 = 0;
              while (c2 < l2) {
                if (arr_classes[c2] != class_name) {
                  arr_res.push(arr_classes[c2]);
                }
                c2++;
              }
              da["class"] = arr_res.join(" ");
            }
          }
        }
        "toggle_class"(class_name, value2) {
          const has_value = typeof value2 !== "undefined";
          if (has_value) {
            if (value2) {
              this.add_class(class_name);
            } else {
              this.remove_class(class_name);
            }
          } else {
            if (this.has_class(class_name)) {
              this.remove_class(class_name);
            } else {
              this.add_class(class_name);
            }
          }
        }
        "is_ancestor_of"(target) {
          var t_target = tof(target);
          var el = this.dom.el;
          var inner = (target2) => {
            if (target2 == el) {
              return true;
            }
            var parent2 = target2.parentNode;
            if (!parent2) {
              return false;
            } else {
              return inner(parent2);
            }
          };
          if (t_target === "object") {
            if (el !== target) {
              var parent = target.parentNode;
              if (parent) {
                return inner(parent);
              }
            }
          } else {
            if (t_target === "control") {
            }
          }
        }
        "find_selected_ancestor_in_scope"() {
          var s = this.selection_scope;
          var ps = this.parent.selection_scope;
          if (s === ps) {
            var psel = this.parent.selected;
            if (psel && psel.value && psel.value() == true) {
              return this.parent;
            } else {
              return this.parent.find_selected_ancestor_in_scope();
            }
          }
        }
        "closest"(match) {
          let tmatch = tof(match);
          if (tmatch === "string") {
          }
          if (tmatch === "function") {
            let search = (ctrl) => {
              if (match(ctrl)) {
                return ctrl;
              } else {
                if (ctrl.parent) {
                  return search(ctrl.parent);
                } else {
                  return void 0;
                }
              }
            };
            return search(this);
          }
        }
        "shallow_copy"() {
          var res2 = new Control({
            "context": this.context
          });
          var da = this.dom.attributes;
          var cl = da.class;
          var map_class_exclude = {
            "selected": true
          };
          each(cl.split(" "), (v, i) => {
            if (i && !map_class_exclude[i]) res2.add_class(i);
          });
          var res_content = res2.content;
          this.content.each((v, i) => {
            if (tof(v) == "data_value") {
              res_content.add(v.value());
            } else {
              res_content.add(v.shallow_copy());
            }
          });
          return res2;
        }
        "matches_selector"(selector) {
          return this.$match(selector);
        }
        "find"(selector) {
          const res2 = [];
          const desc = (node, callback2) => {
            if (node.$match(selector)) {
              callback2(node);
            }
            node.content.each((child) => {
              desc(child, callback2);
            });
          };
          desc(this, ((node) => res2.push(node)));
          return res2;
        }
        "$match"(selector) {
          if (typeof selector === "function") {
            return selector(this);
          } else {
            const str_selector = String(selector || "").trim();
            if (str_selector === "") return false;
            const parse_part = (part) => {
              const str_part = String(part || "").trim();
              if (str_part === "" || str_part === "*") return () => true;
              if (str_part[0] === ".") {
                const cls = str_part.substr(1);
                return (node2) => node2 && typeof node2.has_class === "function" && node2.has_class(cls);
              }
              if (str_part[0] === ":") {
                const type_name = str_part.substr(1);
                return (node2) => node2 && node2.__type_name === type_name;
              }
              if (str_part[0] === "#") {
                const id = str_part.substr(1);
                return (node2) => {
                  var _a, _b, _c;
                  return node2 && (((_b = (_a = node2.dom) == null ? void 0 : _a.attributes) == null ? void 0 : _b.id) === id || ((_c = node2._id) == null ? void 0 : _c.call(node2)) === id);
                };
              }
              if (str_part[0] === "[" && str_part[str_part.length - 1] === "]") {
                const inner = str_part.substring(1, str_part.length - 1).trim();
                const eq_pos = inner.indexOf("=");
                if (eq_pos === -1) {
                  const prop_name3 = inner;
                  return (node2) => {
                    if (!node2) return false;
                    const v = node2[prop_name3];
                    return typeof v !== "undefined" && v !== null && v !== false;
                  };
                }
                const prop_name2 = inner.substring(0, eq_pos).trim();
                let expected = inner.substring(eq_pos + 1).trim();
                if (expected[0] === '"' && expected[expected.length - 1] === '"' || expected[0] === "'" && expected[expected.length - 1] === "'") {
                  expected = expected.substring(1, expected.length - 1);
                }
                return (node2) => {
                  if (!node2) return false;
                  const actual = node2[prop_name2];
                  return String(actual) === expected;
                };
              }
              return (node2) => node2 && node2.__type_name === str_part;
            };
            const parts = str_selector.split(/\s+/).filter((part) => part.length > 0);
            if (parts.length === 0) return false;
            const match_fns = parts.map(parse_part);
            if (match_fns.length === 1) {
              return match_fns[0](this);
            }
            let node = this;
            let idx = match_fns.length - 1;
            if (!match_fns[idx](node)) return false;
            for (idx = idx - 1; idx >= 0; idx--) {
              node = node.parent;
              while (node && !match_fns[idx](node)) {
                node = node.parent;
              }
              if (!node) return false;
            }
            return true;
          }
        }
        "$"(selector, handler) {
          let match = this.$match(selector);
          let res2 = [];
          if (match) {
            if (handler) handler(this);
            res2.push(this);
          }
          this.content.each((item2) => {
            if (item2.$) {
              let nested_res = item2.$(selector, handler);
              Array.prototype.push.apply(res2, nested_res);
            }
          });
          return res2;
        }
        "clear"() {
          this.content.clear();
        }
        "activate"() {
        }
        get this_and_descendents() {
          const res2 = [];
          this.iterate_this_and_subcontrols((ctrl) => res2.push(ctrl));
          return res2;
        }
        get descendents() {
          const res2 = [];
          this.iterate_subcontrols((ctrl) => res2.push(ctrl));
          return res2;
        }
        get siblings() {
          const res2 = [];
          if (this.parent) {
            const _ = this.parent.content._arr;
            _.forEach((x) => {
              if (x !== this) res2.push(x);
            });
          }
          return res2;
        }
      };
      var p = Control_Core.prototype;
      p.connect_fields = true;
      var customInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
      if (jsgui.custom_rendering === "very-simple") {
        p[customInspectSymbol] = function(depth, inspectOptions, inspect) {
          return "< " + this.dom.tagName + " " + this.__type_name + " >";
        };
      }
      module.exports = Control_Core;
      if (__require.main === module) {
        let test_svg2 = function() {
          const passed = [];
          const failed = [];
          let svg;
          try {
            svg = new Control2({
              tagName: "svg"
            });
            passed.push("Create SVG control");
          } catch (error2) {
            failed.push("Create SVG control");
          }
          try {
            const circle = new Control2({
              tagName: "circle",
              attrs: {
                cx: 100,
                cy: 100,
                r: 50
              }
            });
            svg.add(circle);
            passed.push("Add circle to SVG control");
          } catch (error2) {
            console.log("error", error2);
            failed.push("Add circle to SVG control");
          }
          try {
            const rect = new Control2({
              tagName: "rect",
              attrs: {
                x: 150,
                y: 150,
                width: 100,
                height: 100
              }
            });
            svg.add(rect);
            passed.push("Add rectangle to SVG control");
          } catch (error2) {
            console.log("error", error2);
            failed.push("Add rectangle to SVG control");
          }
          try {
            const expected = '<svg><circle cx="100" cy="100" r="50"></circle><rect x="150" y="150" width="100" height="100"></rect></svg>';
            const actual = svg.all_html_render();
            console.log("actual", actual);
            if (expected === actual) {
              passed.push("Check rendering of SVG control");
            } else {
              failed.push("Check rendering of SVG control");
            }
          } catch (error2) {
            console.log("error", error2);
            failed.push("Check rendering of SVG control");
          }
          return {
            passed,
            failed
          };
        };
        test_svg = test_svg2;
        const Control2 = Control_Core;
        console.log(test_svg2());
        const test_background_color = () => {
          const expectedColor = "#ff0000";
          const passed = [];
          const failed = [];
          let div;
          try {
            div = new Control2({
              tagName: "div"
            });
            passed.push("Create div control");
          } catch (error2) {
            failed.push(["Create div control", error2]);
          }
          try {
            div.background.color = expectedColor;
            passed.push("Set background color of div control");
          } catch (error2) {
            failed.push(["Set background color of div control", error2]);
          }
          try {
            const validationColor = div.background.color;
            if (validationColor === expectedColor) {
              passed.push("Validate background color of div control");
            } else {
              failed.push(["Validate background color of div control", "Background color is not as expected"]);
            }
          } catch (error2) {
            failed.push(["Validate background color of div control", error2]);
          }
          try {
            const expected = `<div style="background-color:${expectedColor}"></div>`;
            const actual = div.all_html_render();
            if (expected === actual) {
              passed.push("Check rendering of div control");
            } else {
              failed.push(["Check rendering of div control", "Rendering does not match expected output", {
                expected,
                actual
              }]);
            }
          } catch (error2) {
            failed.push(["Check rendering of div control", error2]);
          }
          return {
            passed,
            failed
          };
        };
        const rtest = test_background_color();
        console.log(rtest);
        console.log(rtest.failed);
      }
      var test_svg;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Shape.js
  var require_Shape = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Shape.js"(exports, module) {
      var Shape = class {
      };
      module.exports = Shape;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/node_modules/lang-mini/lang-mini.js
  var require_lang_mini4 = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/node_modules/lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              if (ctu == false) break;
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
              if (ctu === false) break;
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "null": "N",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          }
          first = false;
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        if (arr.some((subArray) => subArray.length === 0)) {
          return [];
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          const mfp_fn_call_shallow_sig = (() => {
            if (!a2 || a2.length === 0) return "";
            let res3 = "";
            for (let i = 0; i < a2.length; i++) {
              if (i > 0) res3 = res3 + ",";
              res3 = res3 + ltf(a2[i]);
            }
            return res3;
          })();
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else if (mfp_fn_call_shallow_sig && inner_map_sig_fns[mfp_fn_call_shallow_sig]) {
              return inner_map_sig_fns[mfp_fn_call_shallow_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else if (t === "date") {
              return new Date(obj2.getTime());
            } else if (t === "regex") {
              return new RegExp(obj2.source, obj2.flags);
            } else if (t === "buffer") {
              if (typeof Buffer !== "undefined" && Buffer.from) {
                return Buffer.from(obj2);
              } else if (obj2 && typeof obj2.slice === "function") {
                return obj2.slice(0);
              } else {
                return obj2;
              }
            } else if (t === "error") {
              const cloned_error = new obj2.constructor(obj2.message);
              cloned_error.name = obj2.name;
              cloned_error.stack = obj2.stack;
              each(obj2, (value2, key2) => {
                if (key2 !== "message" && key2 !== "name" && key2 !== "stack") {
                  cloned_error[key2] = clone(value2);
                }
              });
              return cloned_error;
            } else if (t === "object") {
              const res2 = {};
              each(obj2, (value2, key2) => {
                res2[key2] = clone(value2);
              });
              return res2;
            } else {
              return obj2;
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                } else if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return new ctr(input_array);
          } else if (length) {
            return new ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str, 10);
          if (!isNaN(p2) && p2.toString() === str) {
            return p2;
          }
          return void 0;
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        const t_value = typeof value2;
                        is_valid = data_type.validate(value2);
                        if (t_value === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                        console.log("t_value", t_value);
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    } else {
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var KEYWORD_LITERALS = /* @__PURE__ */ new Set(["true", "false", "null", "undefined"]);
      var KEYWORD_OPERATORS = /* @__PURE__ */ new Set(["typeof", "void", "delete", "in", "instanceof"]);
      var MULTI_CHAR_OPERATORS = [
        "===",
        "!==",
        "==",
        "!=",
        "<=",
        ">=",
        "&&",
        "||",
        "??",
        "++",
        "--",
        "+=",
        "-=",
        "*=",
        "/=",
        "%=",
        "&=",
        "|=",
        "^=",
        "<<",
        ">>",
        ">>>",
        "**"
      ];
      var SINGLE_CHAR_OPERATORS = /* @__PURE__ */ new Set(["+", "-", "*", "/", "%", "=", "!", "<", ">", "&", "|", "^", "~"]);
      var PUNCTUATION_CHARS = /* @__PURE__ */ new Set(["(", ")", "{", "}", "[", "]", ",", ":", "?", "."]);
      var GLOBAL_SCOPE = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var DEFAULT_ALLOWED_GLOBALS = ["Math"];
      var EXPRESSION_PARSER_DEFAULTS = {
        cache: true,
        cacheSize: 64,
        cacheKeyResolver: null,
        maxExpressionLength: 1e4,
        maxMemberDepth: 2,
        helpers: {},
        allowedFunctions: [],
        allowedGlobals: DEFAULT_ALLOWED_GLOBALS,
        allowCall: null,
        strict: false
      };
      var NORMALIZED_OPTIONS_FLAG = /* @__PURE__ */ Symbol("ExpressionParserOptions");
      var DISALLOWED_IDENTIFIERS = /* @__PURE__ */ new Set(["this", "new"]);
      var ExpressionParserError = class extends Error {
        constructor(code, message, details = {}) {
          super(message);
          this.name = "ExpressionParserError";
          this.code = code;
          this.details = details;
        }
      };
      var ExpressionCache = class {
        constructor(limit = 0) {
          this.limit = Math.max(0, limit || 0);
          this.map = /* @__PURE__ */ new Map();
        }
        get(key2) {
          if (!this.limit || !this.map.has(key2)) {
            return void 0;
          }
          const value2 = this.map.get(key2);
          this.map.delete(key2);
          this.map.set(key2, value2);
          return value2;
        }
        set(key2, value2) {
          if (!this.limit) {
            return;
          }
          if (this.map.has(key2)) {
            this.map.delete(key2);
          }
          this.map.set(key2, value2);
          while (this.map.size > this.limit) {
            const oldestKey = this.map.keys().next().value;
            this.map.delete(oldestKey);
          }
        }
        clear() {
          this.map.clear();
        }
        get size() {
          return this.map.size;
        }
      };
      var Tokenizer = class {
        constructor(expression) {
          this.expression = typeof expression === "string" ? expression : String(expression || "");
          this.length = this.expression.length;
          this.position = 0;
          this.line = 1;
          this.column = 1;
        }
        tokenize() {
          const tokens = [];
          if (!this.expression.trim()) {
            return tokens;
          }
          while (!this.isAtEnd()) {
            this.skipWhitespace();
            if (this.isAtEnd()) break;
            const ch = this.peek();
            if (this.isIdentifierStart(ch)) {
              tokens.push(this.tokenizeIdentifier());
            } else if (this.isDigit(ch) || ch === "." && this.isDigit(this.peek(1))) {
              tokens.push(this.tokenizeNumber());
            } else if (ch === '"' || ch === "'") {
              tokens.push(this.tokenizeString());
            } else if (this.isOperatorStart(ch)) {
              tokens.push(this.tokenizeOperator());
            } else if (PUNCTUATION_CHARS.has(ch)) {
              tokens.push(this.tokenizePunctuation());
            } else {
              this.throwError("TOKEN_INVALID_CHAR", `Unexpected character: ${ch}`);
            }
          }
          return tokens;
        }
        isAtEnd() {
          return this.position >= this.length;
        }
        skipWhitespace() {
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (/\s/.test(ch)) {
              this.advance();
              continue;
            }
            if (ch === "/" && this.peek(1) === "/") {
              while (!this.isAtEnd() && this.peek() !== "\n") {
                this.advance();
              }
              continue;
            }
            if (ch === "/" && this.peek(1) === "*") {
              this.advance();
              this.advance();
              while (!this.isAtEnd()) {
                if (this.peek() === "*" && this.peek(1) === "/") {
                  this.advance();
                  this.advance();
                  break;
                }
                this.advance();
              }
              continue;
            }
            break;
          }
        }
        peek(offset2 = 0) {
          if (this.position + offset2 >= this.length) return "\0";
          return this.expression[this.position + offset2];
        }
        advance() {
          if (this.isAtEnd()) {
            return "\0";
          }
          const char = this.expression[this.position++];
          if (char === "\n") {
            this.line += 1;
            this.column = 1;
          } else {
            this.column += 1;
          }
          return char;
        }
        getLocationSnapshot() {
          return { index: this.position, line: this.line, column: this.column };
        }
        createToken(type, value2, start, end) {
          return { type, value: value2, start, end };
        }
        throwError(code, message) {
          throw new ExpressionParserError(code, message, { location: this.getLocationSnapshot() });
        }
        isIdentifierStart(ch) {
          return /[A-Za-z_$]/.test(ch);
        }
        isIdentifierPart(ch) {
          return /[A-Za-z0-9_$]/.test(ch);
        }
        isDigit(ch) {
          return /[0-9]/.test(ch);
        }
        isOperatorStart(ch) {
          if (ch === "." && this.peek(1) === "." && this.peek(2) === ".") {
            this.throwError("SYNTAX_UNSUPPORTED", "Spread syntax is not supported");
          }
          if (ch === "?" && this.peek(1) === "?") {
            return true;
          }
          return SINGLE_CHAR_OPERATORS.has(ch);
        }
        tokenizeIdentifier() {
          const start = this.getLocationSnapshot();
          let value2 = "";
          while (!this.isAtEnd() && this.isIdentifierPart(this.peek())) {
            value2 += this.advance();
          }
          const end = this.getLocationSnapshot();
          if (KEYWORD_LITERALS.has(value2)) {
            return this.createToken("KEYWORD", value2, start, end);
          }
          if (KEYWORD_OPERATORS.has(value2)) {
            return this.createToken("OPERATOR", value2, start, end);
          }
          return this.createToken("IDENTIFIER", value2, start, end);
        }
        tokenizeNumber() {
          const start = this.getLocationSnapshot();
          let value2 = "";
          let hasDot = false;
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (this.isDigit(ch)) {
              value2 += this.advance();
            } else if (ch === "." && !hasDot) {
              hasDot = true;
              value2 += this.advance();
            } else {
              break;
            }
          }
          const end = this.getLocationSnapshot();
          return this.createToken("NUMBER", Number(value2), start, end);
        }
        tokenizeString() {
          const quote = this.advance();
          const start = this.getLocationSnapshot();
          let value2 = "";
          while (!this.isAtEnd()) {
            const ch = this.advance();
            if (ch === quote) {
              return this.createToken("STRING", value2, start, this.getLocationSnapshot());
            }
            if (ch === "\\") {
              const next = this.advance();
              switch (next) {
                case "n":
                  value2 += "\n";
                  break;
                case "r":
                  value2 += "\r";
                  break;
                case "t":
                  value2 += "	";
                  break;
                case "\\":
                  value2 += "\\";
                  break;
                case '"':
                  value2 += '"';
                  break;
                case "'":
                  value2 += "'";
                  break;
                default:
                  value2 += next;
              }
            } else {
              value2 += ch;
            }
          }
          this.throwError("TOKEN_UNTERMINATED_STRING", "Unterminated string literal");
        }
        tokenizeOperator() {
          const remaining = this.expression.slice(this.position);
          const start = this.getLocationSnapshot();
          for (const op of MULTI_CHAR_OPERATORS) {
            if (remaining.startsWith(op)) {
              if (op === "=>") {
                this.throwError("SYNTAX_UNSUPPORTED", "Arrow functions are not supported");
              }
              this.position += op.length;
              this.column += op.length;
              return this.createToken("OPERATOR", op, start, this.getLocationSnapshot());
            }
          }
          const ch = this.advance();
          if (ch === "=" && this.peek() === ">") {
            this.throwError("SYNTAX_UNSUPPORTED", "Arrow functions are not supported");
          }
          if (!SINGLE_CHAR_OPERATORS.has(ch) && ch !== "?") {
            this.throwError("TOKEN_UNEXPECTED_OPERATOR", "Unexpected operator");
          }
          return this.createToken("OPERATOR", ch, start, this.getLocationSnapshot());
        }
        tokenizePunctuation() {
          const start = this.getLocationSnapshot();
          const ch = this.advance();
          if (ch === "." && this.peek() === "." && this.peek(1) === ".") {
            this.throwError("SYNTAX_UNSUPPORTED", "Spread syntax is not supported");
          }
          return this.createToken("PUNCTUATION", ch, start, this.getLocationSnapshot());
        }
      };
      var Parser = class {
        constructor(tokens, options = {}) {
          this.tokens = tokens;
          this.pos = 0;
          this.maxMemberDepth = options.maxMemberDepth || EXPRESSION_PARSER_DEFAULTS.maxMemberDepth;
          const disallowed = new Set(DISALLOWED_IDENTIFIERS);
          if (options.disallowedIdentifiers) {
            options.disallowedIdentifiers.forEach((identifier) => disallowed.add(identifier));
          }
          this.disallowedIdentifiers = disallowed;
        }
        parse() {
          if (!this.tokens.length) {
            throw new ExpressionParserError("EMPTY_EXPRESSION", "Empty expression");
          }
          const ast = this.parseExpression();
          if (!this.isAtEnd()) {
            this.error("UNEXPECTED_TOKEN", `Unexpected token: ${this.peek().value}`, this.peek());
          }
          return ast;
        }
        parseExpression() {
          return this.parseConditionalExpression();
        }
        parseConditionalExpression() {
          let expr = this.parseLogicalOrExpression();
          if (this.matchPunctuation("?")) {
            const consequent = this.parseExpression();
            this.consume("PUNCTUATION", ":");
            const alternate = this.parseExpression();
            expr = {
              type: "ConditionalExpression",
              test: expr,
              consequent,
              alternate
            };
          }
          return expr;
        }
        parseLogicalOrExpression() {
          let expr = this.parseLogicalAndExpression();
          while (this.matchOperator("||")) {
            const operator = this.previous().value;
            const right = this.parseLogicalAndExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseLogicalAndExpression() {
          let expr = this.parseNullishExpression();
          while (this.matchOperator("&&")) {
            const operator = this.previous().value;
            const right = this.parseNullishExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseNullishExpression() {
          let expr = this.parseEqualityExpression();
          while (this.matchOperator("??")) {
            const operator = this.previous().value;
            const right = this.parseEqualityExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseEqualityExpression() {
          let expr = this.parseRelationalExpression();
          while (this.matchOperator("===", "!==", "==", "!=")) {
            const operator = this.previous().value;
            const right = this.parseRelationalExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseRelationalExpression() {
          let expr = this.parseShiftExpression();
          while (this.matchOperator("<", ">", "<=", ">=", "instanceof", "in")) {
            const operator = this.previous().value;
            const right = this.parseShiftExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseShiftExpression() {
          let expr = this.parseAdditiveExpression();
          while (this.matchOperator("<<", ">>", ">>>")) {
            const operator = this.previous().value;
            const right = this.parseAdditiveExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseAdditiveExpression() {
          let expr = this.parseMultiplicativeExpression();
          while (this.matchOperator("+", "-")) {
            const operator = this.previous().value;
            const right = this.parseMultiplicativeExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseMultiplicativeExpression() {
          let expr = this.parseUnaryExpression();
          while (this.matchOperator("*", "/", "%")) {
            const operator = this.previous().value;
            const right = this.parseUnaryExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseUnaryExpression() {
          if (this.matchOperator("+", "-", "!", "~", "typeof", "void", "delete")) {
            const operator = this.previous().value;
            const argument = this.parseUnaryExpression();
            return { type: "UnaryExpression", operator, argument };
          }
          return this.parseLeftHandSideExpression();
        }
        parseLeftHandSideExpression() {
          let expr = this.parsePrimaryExpression();
          while (true) {
            if (this.matchPunctuation(".")) {
              const operatorToken = this.previous();
              const property = this.consumePropertyIdentifier();
              const depth = this.getChainDepth(expr) + 1;
              this.assertMemberDepth(depth, operatorToken);
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: false
              };
              this.setChainDepth(expr, depth);
            } else if (this.matchPunctuation("[")) {
              const operatorToken = this.previous();
              const property = this.parseExpression();
              this.consume("PUNCTUATION", "]");
              const depth = this.getChainDepth(expr) + 1;
              this.assertMemberDepth(depth, operatorToken);
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: true
              };
              this.setChainDepth(expr, depth);
            } else if (this.matchPunctuation("(")) {
              const args = this.parseArguments();
              expr = {
                type: "CallExpression",
                callee: expr,
                arguments: args
              };
              this.setChainDepth(expr, this.getChainDepth(expr.callee));
            } else {
              break;
            }
          }
          return expr;
        }
        parsePrimaryExpression() {
          const token = this.peek();
          if (!token) {
            this.error("UNEXPECTED_END", "Unexpected end of expression", token);
          }
          if (token.type === "NUMBER" || token.type === "STRING") {
            this.advance();
            return { type: "Literal", value: token.value };
          }
          if (token.type === "KEYWORD") {
            this.advance();
            return { type: "Literal", value: this.literalFromKeyword(token.value) };
          }
          if (token.type === "IDENTIFIER") {
            this.advance();
            this.assertIdentifierAllowed(token);
            return { type: "Identifier", value: token.value };
          }
          if (this.matchPunctuation("(")) {
            const expr = this.parseExpression();
            this.consume("PUNCTUATION", ")");
            return expr;
          }
          if (this.matchPunctuation("[")) {
            const elements = [];
            if (!this.check("PUNCTUATION", "]")) {
              do {
                elements.push(this.parseExpression());
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "]");
            return { type: "ArrayExpression", elements };
          }
          if (this.matchPunctuation("{")) {
            const properties = [];
            if (!this.check("PUNCTUATION", "}")) {
              do {
                const key2 = this.parsePropertyKey();
                this.consume("PUNCTUATION", ":");
                const value2 = this.parseExpression();
                properties.push({ key: key2, value: value2 });
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "}");
            return { type: "ObjectExpression", properties };
          }
          this.error("UNEXPECTED_TOKEN", `Unexpected token: ${token.value}`, token);
        }
        parsePropertyKey() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          this.error("INVALID_OBJECT_KEY", "Invalid object property key", token);
        }
        parseArguments() {
          const args = [];
          if (!this.check("PUNCTUATION", ")")) {
            do {
              args.push(this.parseExpression());
            } while (this.matchPunctuation(","));
          }
          this.consume("PUNCTUATION", ")");
          return args;
        }
        literalFromKeyword(value2) {
          switch (value2) {
            case "true":
              return true;
            case "false":
              return false;
            case "null":
              return null;
            case "undefined":
              return void 0;
            default:
              return value2;
          }
        }
        consume(type, value2) {
          if (this.check(type, value2)) {
            return this.advance();
          }
          const expected = value2 ? `${type} '${value2}'` : type;
          this.error("MISSING_TOKEN", `Expected ${expected}`, this.peek());
        }
        check(type, value2) {
          if (this.isAtEnd()) return false;
          const token = this.peek();
          if (token.type !== type) return false;
          if (typeof value2 === "undefined") return true;
          return token.value === value2;
        }
        matchOperator(...operators) {
          if (this.check("OPERATOR") && operators.includes(this.peek().value)) {
            this.advance();
            return true;
          }
          return false;
        }
        matchPunctuation(value2) {
          if (this.check("PUNCTUATION", value2)) {
            this.advance();
            return true;
          }
          return false;
        }
        consumePropertyIdentifier() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          this.error("INVALID_PROPERTY", "Expected property name", token);
        }
        buildBinaryExpression(operator, left, right) {
          return { type: "BinaryExpression", operator, left, right };
        }
        buildLogicalExpression(operator, left, right) {
          return { type: "LogicalExpression", operator, left, right };
        }
        getChainDepth(node) {
          if (!node || typeof node !== "object") {
            return 0;
          }
          return node.__chainDepth || 0;
        }
        setChainDepth(node, depth) {
          if (!node || typeof node !== "object") {
            return;
          }
          Object.defineProperty(node, "__chainDepth", {
            value: depth,
            enumerable: false,
            configurable: true
          });
        }
        assertMemberDepth(depth, token) {
          if (depth > this.maxMemberDepth) {
            this.error("MEMBER_DEPTH_EXCEEDED", `Member access depth ${depth} exceeds maximum of ${this.maxMemberDepth}`, token);
          }
        }
        assertIdentifierAllowed(token) {
          if (this.disallowedIdentifiers.has(token.value)) {
            this.error("DISALLOWED_IDENTIFIER", `Identifier '${token.value}' is not allowed in expressions`, token);
          }
        }
        error(code, message, token) {
          throw new ExpressionParserError(code, message, token ? { location: token.start } : void 0);
        }
        advance() {
          if (!this.isAtEnd()) {
            this.pos += 1;
          }
          return this.tokens[this.pos - 1];
        }
        peek() {
          if (this.isAtEnd()) return null;
          return this.tokens[this.pos];
        }
        previous() {
          return this.tokens[this.pos - 1];
        }
        isAtEnd() {
          return this.pos >= this.tokens.length;
        }
      };
      var Evaluator = class {
        constructor(context2 = {}, options = {}) {
          this.context = context2 || {};
          this.helpers = options.helpers || {};
          this.strict = options.strict || false;
          this.allowCall = options.allowCall || null;
          this.allowedFunctions = new Set(options.allowedFunctions || []);
          this.allowedGlobals = new Set(options.allowedGlobals || []);
          Object.values(this.helpers).forEach((value2) => {
            if (typeof value2 === "function") {
              this.allowedFunctions.add(value2);
            }
          });
        }
        evaluate(node) {
          switch (node.type) {
            case "Literal":
              return node.value;
            case "Identifier":
              return this.evaluateIdentifier(node);
            case "MemberExpression":
              return this.evaluateMemberExpression(node);
            case "CallExpression":
              return this.evaluateCallExpression(node);
            case "UnaryExpression":
              return this.evaluateUnaryExpression(node);
            case "BinaryExpression":
              return this.evaluateBinaryExpression(node);
            case "LogicalExpression":
              return this.evaluateLogicalExpression(node);
            case "ArrayExpression":
              return node.elements.map((element) => this.evaluate(element));
            case "ObjectExpression":
              return this.evaluateObjectExpression(node);
            case "ConditionalExpression":
              return this.evaluateConditionalExpression(node);
            default:
              throw new ExpressionParserError("UNSUPPORTED_NODE", `Unsupported AST node type: ${node.type}`);
          }
        }
        evaluateIdentifier(node) {
          const name = node.value;
          if (Object.prototype.hasOwnProperty.call(this.helpers, name)) {
            return this.helpers[name];
          }
          if (this.context && Object.prototype.hasOwnProperty.call(this.context, name)) {
            return this.context[name];
          }
          if (this.allowedGlobals.has(name) && name in GLOBAL_SCOPE) {
            return GLOBAL_SCOPE[name];
          }
          if (this.strict) {
            throw new ExpressionParserError("UNDEFINED_IDENTIFIER", `Undefined identifier: ${name}`);
          }
          console.error(`Undefined identifier: ${name}`);
          return void 0;
        }
        evaluateMemberExpression(node) {
          const object = this.evaluate(node.object);
          if (object === null || object === void 0) {
            throw new ExpressionParserError("NULL_MEMBER_ACCESS", "Cannot read property of null or undefined");
          }
          const property = node.computed ? this.evaluate(node.property) : node.property.type === "Identifier" ? node.property.value : node.property.value;
          return object[property];
        }
        evaluateCallExpression(node) {
          let callee;
          let thisArg;
          if (node.callee.type === "MemberExpression") {
            const object = this.evaluate(node.callee.object);
            if (object === null || object === void 0) {
              throw new ExpressionParserError("NULL_MEMBER_CALL", "Cannot call property of null or undefined");
            }
            const property = node.callee.computed ? this.evaluate(node.callee.property) : node.callee.property.type === "Identifier" ? node.callee.property.value : node.callee.property.value;
            callee = object[property];
            thisArg = object;
          } else {
            callee = this.evaluate(node.callee);
            thisArg = void 0;
          }
          if (typeof callee !== "function") {
            throw new ExpressionParserError("CALL_NON_FUNCTION", "Attempted to call a non-function");
          }
          if (!this.isCallAllowed(callee, thisArg)) {
            throw new ExpressionParserError("CALL_NOT_ALLOWED", "Function call not allowed by policy");
          }
          const args = node.arguments.map((arg) => this.evaluate(arg));
          return callee.apply(thisArg, args);
        }
        isCallAllowed(fn, thisArg) {
          if (this.allowCall) {
            const decision = this.allowCall(fn, thisArg);
            if (decision === true) return true;
            if (decision === false) return false;
          }
          return this.allowedFunctions.has(fn);
        }
        evaluateUnaryExpression(node) {
          let argumentValue;
          if (node.operator === "delete") {
            argumentValue = node.argument;
          } else if (node.operator === "typeof" && node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
            argumentValue = void 0;
          } else {
            argumentValue = this.evaluate(node.argument);
          }
          switch (node.operator) {
            case "+":
              return +argumentValue;
            case "-":
              return -argumentValue;
            case "!":
              return !argumentValue;
            case "~":
              return ~argumentValue;
            case "typeof":
              if (node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
                return "undefined";
              }
              return typeof argumentValue;
            case "void":
              return void argumentValue;
            case "delete":
              return this.performDelete(node.argument);
            default:
              throw new ExpressionParserError("UNSUPPORTED_UNARY", `Unsupported unary operator: ${node.operator}`);
          }
        }
        isIdentifierDefined(name) {
          return Object.prototype.hasOwnProperty.call(this.helpers, name) || this.context && Object.prototype.hasOwnProperty.call(this.context, name) || this.allowedGlobals.has(name) && name in GLOBAL_SCOPE;
        }
        performDelete(argument) {
          if (argument.type === "Identifier" && this.context && typeof this.context === "object") {
            return delete this.context[argument.value];
          }
          if (argument.type === "MemberExpression") {
            const target = this.evaluate(argument.object);
            if (target === null || target === void 0) {
              return true;
            }
            const property = argument.computed ? this.evaluate(argument.property) : argument.property.type === "Identifier" ? argument.property.value : argument.property.value;
            return delete target[property];
          }
          this.evaluate(argument);
          return true;
        }
        evaluateBinaryExpression(node) {
          const left = this.evaluate(node.left);
          const right = this.evaluate(node.right);
          switch (node.operator) {
            case "+":
              return left + right;
            case "-":
              return left - right;
            case "*":
              return left * right;
            case "/":
              return left / right;
            case "%":
              return left % right;
            case "==":
              return left == right;
            case "!=":
              return left != right;
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "in":
              return left in right;
            case "instanceof":
              return left instanceof right;
            default:
              throw new ExpressionParserError("UNSUPPORTED_BINARY", `Unsupported binary operator: ${node.operator}`);
          }
        }
        evaluateLogicalExpression(node) {
          switch (node.operator) {
            case "&&": {
              const left = this.evaluate(node.left);
              return left ? this.evaluate(node.right) : left;
            }
            case "||": {
              const left = this.evaluate(node.left);
              return left ? left : this.evaluate(node.right);
            }
            case "??": {
              const left = this.evaluate(node.left);
              return left !== null && left !== void 0 ? left : this.evaluate(node.right);
            }
            default:
              throw new ExpressionParserError("UNSUPPORTED_LOGICAL", `Unsupported logical operator: ${node.operator}`);
          }
        }
        evaluateObjectExpression(node) {
          const obj2 = {};
          node.properties.forEach((property) => {
            const key2 = this.evaluatePropertyKey(property.key);
            obj2[key2] = this.evaluate(property.value);
          });
          return obj2;
        }
        evaluatePropertyKey(node) {
          if (node.type === "Identifier") {
            return node.value;
          }
          return node.value;
        }
        evaluateConditionalExpression(node) {
          const test = this.evaluate(node.test);
          return test ? this.evaluate(node.consequent) : this.evaluate(node.alternate);
        }
      };
      var ExpressionParser = class {
        constructor(options = {}) {
          this.options = normalizeOptions(null, options);
          const cacheLimit = this.options.cache !== false ? this.options.cacheSize : 0;
          this.astCache = new ExpressionCache(cacheLimit);
          this.valueCache = new ExpressionCache(cacheLimit);
        }
        tokenize(expression) {
          return new Tokenizer(expression).tokenize();
        }
        parse(expression, overrideOptions) {
          const options = this.ensureNormalizedOptions(overrideOptions);
          this.ensureExpressionLength(expression, options);
          const useCache = this.shouldUseCache(options);
          if (useCache) {
            const cachedAst = this.astCache.get(expression);
            if (cachedAst) {
              return cachedAst;
            }
          }
          const tokens = this.tokenize(expression);
          if (!tokens.length) {
            throw new ExpressionParserError("EMPTY_EXPRESSION", "Empty expression");
          }
          const parser = new Parser(tokens, options);
          const ast = parser.parse();
          Object.defineProperty(ast, "tokens", {
            value: tokens,
            enumerable: false,
            configurable: true
          });
          if (useCache) {
            this.astCache.set(expression, ast);
          }
          return ast;
        }
        evaluate(expression, context2 = {}, overrideOptions = {}) {
          const mergedOptions = this.mergeOptions(overrideOptions);
          const useCache = this.shouldUseCache(mergedOptions);
          if (useCache) {
            const cached = this.getCachedValue(expression, context2, mergedOptions);
            if (cached.hit) {
              return cached.value;
            }
          }
          const ast = this.parse(expression, mergedOptions);
          const evaluator = new Evaluator(context2, mergedOptions);
          const result = evaluator.evaluate(ast);
          if (useCache) {
            this.storeCachedValue(expression, context2, result, mergedOptions);
          }
          return result;
        }
        compile(expression, overrideOptions = {}) {
          const baseOptions = this.mergeOptions(overrideOptions);
          const ast = this.parse(expression, baseOptions);
          return (context2 = {}, runtimeOptions = {}) => {
            const invocationOptions = this.mergeOptions(runtimeOptions, baseOptions);
            const evaluator = new Evaluator(context2, invocationOptions);
            return evaluator.evaluate(ast);
          };
        }
        shouldUseCache(options) {
          return options.cache !== false && options.cacheSize > 0;
        }
        ensureNormalizedOptions(options) {
          if (options && options[NORMALIZED_OPTIONS_FLAG]) {
            return options;
          }
          if (!options) {
            return this.options;
          }
          return this.mergeOptions(options);
        }
        ensureExpressionLength(expression, options) {
          if (expression.length > options.maxExpressionLength) {
            throw new ExpressionParserError(
              "EXPRESSION_TOO_LONG",
              `Expression exceeds maximum length of ${options.maxExpressionLength} characters`
            );
          }
        }
        mergeOptions(override = {}, baseOptions) {
          const base = baseOptions && baseOptions[NORMALIZED_OPTIONS_FLAG] ? baseOptions : baseOptions || this.options;
          return normalizeOptions(base, override);
        }
        getCachedValue(expression, context2, options) {
          const bucket = this.valueCache.get(expression);
          if (!bucket) {
            return { hit: false };
          }
          if (this.isObjectLike(context2)) {
            if (bucket.objectCache && bucket.objectCache.has(context2)) {
              return { hit: true, value: bucket.objectCache.get(context2) };
            }
            return { hit: false };
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return { hit: false };
          }
          if (bucket.primitiveCache && bucket.primitiveCache.has(key2)) {
            return { hit: true, value: bucket.primitiveCache.get(key2) };
          }
          return { hit: false };
        }
        storeCachedValue(expression, context2, value2, options) {
          if (!this.shouldUseCache(options)) {
            return;
          }
          let bucket = this.valueCache.get(expression);
          if (!bucket) {
            bucket = { objectCache: /* @__PURE__ */ new WeakMap(), primitiveCache: /* @__PURE__ */ new Map() };
            this.valueCache.set(expression, bucket);
          }
          if (this.isObjectLike(context2)) {
            bucket.objectCache.set(context2, value2);
            return;
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return;
          }
          bucket.primitiveCache.set(key2, value2);
        }
        resolvePrimitiveKey(context2, options) {
          if (options.cacheKeyResolver) {
            return options.cacheKeyResolver(context2);
          }
          return context2;
        }
        isObjectLike(value2) {
          return value2 !== null && (typeof value2 === "object" || typeof value2 === "function");
        }
        getCacheStats() {
          return {
            astEntries: this.astCache.size,
            valueEntries: this.valueCache.size
          };
        }
      };
      function normalizeOptions(baseOptions, overrideOptions = {}) {
        const base = baseOptions && baseOptions[NORMALIZED_OPTIONS_FLAG] ? baseOptions : { ...EXPRESSION_PARSER_DEFAULTS, ...baseOptions || {} };
        const helpers = { ...base.helpers || {}, ...overrideOptions.helpers || {} };
        const allowedFunctions = /* @__PURE__ */ new Set([
          ...base.allowedFunctions || [],
          ...overrideOptions.allowedFunctions || []
        ]);
        const allowedGlobals = /* @__PURE__ */ new Set([
          ...base.allowedGlobals || DEFAULT_ALLOWED_GLOBALS,
          ...overrideOptions.allowedGlobals || []
        ]);
        const normalized = {
          ...EXPRESSION_PARSER_DEFAULTS,
          ...base,
          ...overrideOptions,
          helpers,
          allowedFunctions: Array.from(allowedFunctions),
          allowedGlobals: Array.from(allowedGlobals)
        };
        Object.defineProperty(normalized, NORMALIZED_OPTIONS_FLAG, {
          value: true,
          enumerable: false
        });
        return normalized;
      }
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type,
        ExpressionParser,
        ExpressionParserError
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/node_modules/lang-mini/lib-lang-mini.js
  var require_lib_lang_mini4 = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/node_modules/lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini4();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Rectangle.js
  var require_Rectangle = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Rectangle.js"(exports, module) {
      var Shape = require_Shape();
      var { tof, get_item_sig, is_arr_of_t } = require_lib_lang_mini4();
      var { prop, get_set } = require_oext();
      var Rectangle = class _Rectangle extends Shape {
        // y_axis_up_direction = -1 for example?
        // up property being -1 or 1?
        //. y_axis_scaling_factor = -1 would make sense here.
        // though up_is_negitive would be simpler and quicker logically, could subtract vectors rater than multiply them by -1 and
        // then add them.
        // Should hold a typed array to keep a few values.
        //.  Or even be able to be part of a larger typed array holding many rects.
        // up_direction...?
        // up = +1?
        // This constructor system is maybe too slow for when many such rectangles get made.
        constructor(...a) {
          super(...a);
          this.up_is_negitive = true;
          const al = a.length;
          let x, y, w, h;
          const sig = get_item_sig(a, 2);
          if (sig === "[[n,n],[n,n]]") {
            [[w, h], [x, y]] = a;
          }
          get_set(this, "x", () => x, (value2) => x = value2);
          get_set(this, "y", () => y, (value2) => y = value2);
          get_set(this, ["w", "width"], () => w, (value2) => w = value2);
          get_set(this, ["h", "height"], () => h, (value2) => h = value2);
          get_set(this, "size", () => [w, h], (value2) => [w, h] = value2);
          get_set(this, "pos", () => [x, y], (value2) => [x, y] = value2);
          get_set(this, "left", () => x);
          get_set(this, "top", () => this.up_is_negitive ? y : y + h, (value2) => this.up_is_negitive ? y = value2 : y = value2 - height);
          get_set(this, "right", () => x + w);
          get_set(this, "bottom", () => this.up_is_negitive ? y + h : y);
          const using_bcr_interface = true;
          if (using_bcr_interface) {
            get_set(this, "0", () => [x, y]);
            get_set(this, "1", () => [this.right, this.bottom]);
            get_set(this, "2", () => [w, h]);
          }
        }
        extend(direction, px) {
          if (direction === "left" || direction === "l") {
            const cx = this.x, cw = this.width;
            this.x = cx - px;
            this.width = cw + px;
          } else if (direction === "right" || direction === "r") {
            const cx = this.x, cw = this.width;
            this.width = cw + px;
          } else if (direction === "up" || direction === "u") {
            if (this.up_is_negitive) {
              this.y = this.y - px;
              this.h = this.h + px;
            } else {
              this.h = this.h + px;
            }
          } else if (direction === "down" || direction === "d") {
            if (!this.up_is_negitive) {
              this.y = this.y - px;
              this.h = this.h + px;
            } else {
              this.h = this.h + px;
            }
          } else {
            throw "Supported directions: left l right r up u down d";
          }
          return this;
        }
        // Maybe we don't want Control specific things in here???
        //.  Seems OK for now, though maybe should refactor it out later on.
        //.  And this gfx-core is specific to jsgui3 so let's do it.
        overlaps(overlap_target) {
          const a = arguments;
          const al = a.length;
          if (al === 1) {
            const t_overlap_target = tof(overlap_target);
            if (t_overlap_target === "array") {
              if (is_arr_of_t(overlap_target, "control")) {
                const res2 = [];
                for (const target_ctrl of overlap_target) {
                  const target_overlap = this.overlaps(target_ctrl);
                  if (target_overlap) {
                    res2.push(target_overlap);
                  }
                }
                return res2;
              }
            } else if (t_overlap_target === "control") {
              const target_bcr = overlap_target.bcr();
              return this.overlaps(target_bcr);
            } else if (overlap_target instanceof _Rectangle) {
              const calculate_overlap = (box1, box2) => {
                const x = Math.max(box1.x, box2.x);
                const y = Math.max(box1.y, box2.y);
                const w = Math.min(box1.x + box1.w, box2.x + box2.w) - x;
                const h = Math.min(box1.y + box1.h, box2.y + box2.h) - y;
                if (w <= 0 || h <= 0) {
                  return false;
                } else {
                  return new _Rectangle([w, h], [x, y]);
                }
              };
              return calculate_overlap(this, overlap_target);
            }
          } else {
            console.trace();
            throw "NYI";
          }
        }
        // Properties
      };
      if (__require.main === module) {
        const rect = new Rectangle([30, 40], [100, 100]);
        console.log("rect", rect);
        console.log("rect.right", rect.right);
        rect.extend("l", 40);
        rect.extend("u", 40);
        console.log("rect.left", rect.left);
        console.log("rect.top", rect.top);
        console.log("rect.right", rect.right);
      }
      module.exports = Rectangle;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-pos-list.js
  var require_pixel_pos_list = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-pos-list.js"(exports, module) {
      var inspect = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
      var Ui16toUi32 = (ui16) => {
        let res2 = new Uint32Array(ui16.length / 2);
        let dv = new DataView(ui16.buffer);
        let l2 = ui16.length;
        let hl = l2 / 2;
        let resw = 0;
        for (let c2 = 0; c2 < hl; c2++) {
          res2[resw++] = dv.getUint32(c2 * 4);
        }
        return res2;
      };
      var Ui32toUi16 = (ui32) => {
        let res2 = new Uint16Array(ui32.length * 2);
        let dv = new DataView(ui32.buffer);
        let l2 = ui32.length;
        let resw = 0;
        for (let c2 = 0; c2 < l2; c2++) {
          res2[resw++] = dv.getUint16(c2 * 4 + 2);
          res2[resw++] = dv.getUint16(c2 * 4);
        }
        return res2;
      };
      var Pixel_Pos_List = class _Pixel_Pos_List {
        [Symbol.iterator]() {
          let index = 0;
          const pixels = [];
          this.each_pixel((pos) => {
            pixels.push([pos[0], pos[1]]);
          });
          return {
            next: () => {
              if (index < pixels.length) {
                return { value: pixels[index++], done: false };
              } else {
                return { done: true };
              }
            }
          };
        }
        [inspect]() {
          return this.toString();
        }
        toString() {
          const res2 = "PPL " + JSON.stringify({
            length: this.length,
            pixels: this.str_pixels
          });
          return res2;
        }
        /**
         * Creates a new Pixel_Pos_List instance.
         * @param {Object} [spec] - Optional specification object.
         */
        constructor(spec) {
          const capacities = new Uint32Array([16, 1024, 1024 * 1024 / 8, 1024 * 1024 / 2, 1024 * 1024 * 2, 1024 * 1024 * 8]);
          let i_capacity = 0;
          let capacity = capacities[i_capacity];
          let max_index = capacity * 2 - 1;
          let i = 0;
          let ta_pixels = new Uint16Array(capacity * 2);
          let read_pos = 0;
          this.sort = () => {
            if (read_pos > 0) {
              const length = i - read_pos;
              for (let idx = 0; idx < length; idx++) {
                ta_pixels[idx] = ta_pixels[idx + read_pos];
              }
              i = length;
              read_pos = 0;
            }
            const activeSlice = ta_pixels.slice(0, i);
            let ui32 = Ui16toUi32(activeSlice);
            ui32.sort();
            const sortedUi16 = Ui32toUi16(ui32);
            for (let idx = 0; idx < i; idx++) {
              ta_pixels[idx] = sortedUi16[idx];
            }
            return this;
          };
          this.shift = () => {
            if (read_pos < i) {
              const res2 = new Uint16Array(2);
              res2[0] = ta_pixels[read_pos];
              res2[1] = ta_pixels[read_pos + 1];
              read_pos += 2;
              if (read_pos >= 1024 && read_pos > i / 2) {
                const newArray = new Uint16Array(i - read_pos);
                for (let idx = 0; idx < i - read_pos; idx++) {
                  newArray[idx] = ta_pixels[idx + read_pos];
                }
                ta_pixels = this.ta = newArray;
                i = i - read_pos;
                read_pos = 0;
                max_index = ta_pixels.length - 1;
              }
              return res2;
            }
            return void 0;
          };
          this.pop = () => {
            if (i > read_pos) {
              const res2 = new Uint16Array(2);
              i -= 2;
              res2[0] = ta_pixels[i];
              res2[1] = ta_pixels[i + 1];
              return res2;
            }
            return void 0;
          };
          this.ta = ta_pixels;
          this.add = (pos) => {
            if (!pos || pos.length < 2) {
              throw new Error("Invalid pixel position. Expected [x, y] array with at least 2 elements.");
            }
            const x = Math.floor(pos[0]);
            const y = Math.floor(pos[1]);
            if (i > max_index) {
              if (read_pos >= 1024) {
                const new_ta = new Uint16Array(capacity * 2);
                const l2 = ta_pixels.length - read_pos;
                for (let c2 = 0; c2 < l2; c2++) {
                  new_ta[c2] = ta_pixels[c2 + read_pos];
                }
                ta_pixels = new_ta;
                i -= read_pos;
                read_pos = 0;
              } else {
                if (i_capacity < capacities.length - 1) {
                  capacity = capacities[++i_capacity];
                } else {
                  capacity *= 2;
                }
                max_index = capacity * 2 - 1;
                const new_ta = new Uint16Array(capacity * 2);
                const l2 = ta_pixels.length;
                for (let c2 = 0; c2 < l2; c2++) {
                  new_ta[c2] = ta_pixels[c2];
                }
                ta_pixels = this.ta = new_ta;
              }
            }
            ta_pixels[i++] = x;
            ta_pixels[i++] = y;
            return this;
          };
          this.each_pixel = (cb) => {
            let count = 0;
            for (let i2 = read_pos; i2 < i; i2 += 2) {
              const pixelPos = new Uint16Array(2);
              pixelPos[0] = ta_pixels[i2];
              pixelPos[1] = ta_pixels[i2 + 1];
              cb(pixelPos, count++);
            }
          };
          this.fix = () => {
            const adjusted = ta_pixels.slice(0, i);
            this.ta = ta_pixels = adjusted;
            max_index = this.ta.length - 1;
            return this;
          };
          this.equals = (pixel_pos_list) => {
            if (this.length !== pixel_pos_list.length) {
              return false;
            }
            const thisList = [];
            const otherList = [];
            this.each_pixel((pos) => {
              thisList.push([pos[0], pos[1]]);
            });
            pixel_pos_list.each_pixel((pos) => {
              otherList.push([pos[0], pos[1]]);
            });
            thisList.sort((a, b) => {
              if (a[0] === b[0]) return a[1] - b[1];
              return a[0] - b[0];
            });
            otherList.sort((a, b) => {
              if (a[0] === b[0]) return a[1] - b[1];
              return a[0] - b[0];
            });
            for (let i2 = 0; i2 < thisList.length; i2++) {
              if (thisList[i2][0] !== otherList[i2][0] || thisList[i2][1] !== otherList[i2][1]) {
                return false;
              }
            }
            return true;
          };
          this.map = (mapFn) => {
            const result = [];
            this.each_pixel((pos, idx) => {
              result.push(mapFn(pos, idx));
            });
            return result;
          };
          this.filter = (predicate) => {
            const result = new _Pixel_Pos_List();
            this.each_pixel((pos, idx) => {
              if (predicate(pos, idx)) {
                result.add([pos[0], pos[1]]);
              }
            });
            return result;
          };
          this.forEach = (callback2) => {
            this.each_pixel(callback2);
          };
          const str_pixels = () => {
            let res2 = "";
            let first = true;
            this.each_pixel((pos) => {
              if (first) {
                first = false;
              } else {
                res2 = res2 + ", ";
              }
              res2 = res2 + "[" + pos[0] + ", " + pos[1] + "]";
            });
            return res2;
          };
          Object.defineProperty(this, "str_pixels", {
            get: () => str_pixels(),
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(this, "length", {
            get: () => (i - read_pos) / 2,
            enumerable: true,
            configurable: false
          });
          let _bounds;
          Object.defineProperty(this, "bounds", {
            get: () => {
              _bounds = new Uint16Array(4);
              if (this.length > 0) {
                _bounds[0] = Number.MAX_SAFE_INTEGER;
                _bounds[1] = Number.MAX_SAFE_INTEGER;
                _bounds[2] = 0;
                _bounds[3] = 0;
                this.each_pixel((pos) => {
                  if (pos[0] < _bounds[0]) _bounds[0] = pos[0];
                  if (pos[0] > _bounds[2]) _bounds[2] = pos[0];
                  if (pos[1] < _bounds[1]) _bounds[1] = pos[1];
                  if (pos[1] > _bounds[3]) _bounds[3] = pos[1];
                });
              } else {
                _bounds[0] = 0;
                _bounds[1] = 0;
                _bounds[2] = 0;
                _bounds[3] = 0;
              }
              return _bounds;
            },
            enumerable: true,
            configurable: false
          });
          let _pos;
          Object.defineProperty(this, "pos", {
            get: () => {
              _pos = new Uint16Array(2);
              if (this.length > 0) {
                _pos[0] = Number.MAX_SAFE_INTEGER;
                _pos[1] = Number.MAX_SAFE_INTEGER;
                this.each_pixel((pos) => {
                  if (pos[0] < _pos[0]) _pos[0] = pos[0];
                  if (pos[1] < _pos[1]) _pos[1] = pos[1];
                });
              } else {
                _pos[0] = 0;
                _pos[1] = 0;
              }
              return _pos;
            },
            enumerable: true,
            configurable: false
          });
          this.clear = () => {
            i = 0;
            read_pos = 0;
            return this;
          };
          this.contains = (pos) => {
            if (!pos || pos.length < 2) return false;
            const isXInteger = Number.isInteger(pos[0]);
            const isYInteger = Number.isInteger(pos[1]);
            if (!isXInteger && !isYInteger) {
              return false;
            }
            const x = Math.floor(pos[0]);
            const y = Math.floor(pos[1]);
            let found = false;
            this.each_pixel((pixel) => {
              if (pixel[0] === x && pixel[1] === y) {
                if (!isXInteger && Math.floor(pos[0]) !== pos[0] || !isYInteger && Math.floor(pos[1]) !== pos[1]) {
                  return;
                }
                found = true;
              }
            });
            return found;
          };
          this.toArray = () => {
            const result = [];
            this.each_pixel((pos) => {
              result.push([pos[0], pos[1]]);
            });
            return result;
          };
        }
        /**
         * Creates a Pixel_Pos_List from an array of positions.
         * @param {Array} positions - Array of [x,y] positions
         * @returns {Pixel_Pos_List} A new Pixel_Pos_List
         * @static
         */
        static fromArray(positions) {
          const ppl = new _Pixel_Pos_List();
          if (Array.isArray(positions)) {
            positions.forEach((pos) => {
              if (Array.isArray(pos) && pos.length >= 2) {
                ppl.add(pos);
              }
            });
          }
          return ppl;
        }
      };
      if (__require.main === module) {
        const test1 = () => {
          let ppl = new Pixel_Pos_List();
          ppl.add([2, 2]);
          ppl.add([2, 3]);
          ppl.add([8, 4]);
          ppl.add([8, 3]);
          ppl.add([3, 3]);
          ppl.add([1, 2]);
          ppl.add([1, 3]);
          ppl.add([3, 2]);
          ppl.fix();
          console.log("Pixels using for...of:");
          for (const pos of ppl) {
            console.log(`  [${pos[0]}, ${pos[1]}]`);
          }
          console.log("\nFiltered pixels (x > 2):");
          const filtered = ppl.filter((pos) => pos[0] > 2);
          filtered.forEach((pos) => {
            console.log(`  [${pos[0]}, ${pos[1]}]`);
          });
          console.log("\nMapped pixels (x+y):");
          const sums = ppl.map((pos) => pos[0] + pos[1]);
          console.log(sums);
          console.log("\nSorted pixels:");
          ppl = ppl.sort();
          let item2;
          while (item2 = ppl.shift()) {
            console.log(`  [${item2[0]}, ${item2[1]}]`);
          }
        };
        test1();
      } else {
      }
      module.exports = Pixel_Pos_List;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/Typed_Array_Binary_Read_Write.js
  var require_Typed_Array_Binary_Read_Write = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/Typed_Array_Binary_Read_Write.js"(exports, module) {
      var Typed_Array_Binary_Read_Write = class {
        constructor(ta2) {
          this.ta = ta2;
          this.dv = new DataView(ta2.buffer, ta2.byteOffset, ta2.byteLength);
          this.byl = ta2.byteLength;
          this.bil = this.byl << 3;
        }
        get_bit(idx_bit) {
          const idx_byte_bit = idx_bit & 7;
          return (this.dv.getUint8(idx_bit >>> 3) & 1 << idx_byte_bit) >> idx_byte_bit;
        }
        set_bit(idx_bit, value2) {
          value2 = value2 ? 1 : 0;
          const { dv } = this;
          const idx_byte = idx_bit >>> 3;
          const idx_byte_bit = idx_bit & 7;
          const byte_mask = 1 << idx_byte_bit;
          const read_byte = dv.getUint8(idx_byte);
          const updated_byte = read_byte & ~byte_mask | value2 << idx_byte_bit;
          dv.setUint8(idx_byte, updated_byte);
        }
      };
      module.exports = Typed_Array_Binary_Read_Write;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/copy.js
  var require_copy = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/copy.js"(exports, module) {
      var get_instance = () => {
        const copy_ta_byte_range = (ta_source2, ta_dest, byte_idx_source_start, byte_idx_dest_start, length) => {
          ta_dest.set(ta_source2.subarray(byte_idx_source_start, byte_idx_source_start + length), byte_idx_dest_start);
        };
        const copy_rect_to_same_size_8bipp = (xy, bounds2, ta2, ta_res, ta_byte_indexes, bytes_read_row_end_jump) => {
          for (xy[1] = bounds2[1]; xy[1] < bounds2[3]; xy[1]++) {
            for (xy[0] = bounds2[0]; xy[0] < bounds2[2]; xy[0]++) {
              ta_res[ta_byte_indexes[1]++] = ta2[ta_byte_indexes[0]++];
            }
            ta_byte_indexes[0] += bytes_read_row_end_jump;
          }
        };
        const copy_rect_to_same_size_24bipp = (xy, bounds2, ta2, ta_res, ta_byte_indexes, bytes_read_row_end_jump) => {
          for (xy[1] = bounds2[1]; xy[1] < bounds2[3]; xy[1]++) {
            for (xy[0] = bounds2[0]; xy[0] < bounds2[2]; xy[0]++) {
              ta_res[ta_byte_indexes[1]++] = ta2[ta_byte_indexes[0]++];
              ta_res[ta_byte_indexes[1]++] = ta2[ta_byte_indexes[0]++];
              ta_res[ta_byte_indexes[1]++] = ta2[ta_byte_indexes[0]++];
            }
            ta_byte_indexes[0] += bytes_read_row_end_jump;
          }
        };
        const dest_aligned_copy_rect_1to4bypp = (ta_source2, ta_dest, bypr_source, bytes_per_pixel, ta_source_bounds) => {
          let y;
          const bounds_row_width = ta_source_bounds[2] - ta_source_bounds[0];
          const bypr_dest = bounds_row_width * bytes_per_pixel;
          const bytes_per_bounds_row = bytes_per_pixel * bounds_row_width;
          const byi_read_start = ta_source_bounds[0] * bytes_per_pixel + ta_source_bounds[1] * bypr_source;
          const byi_dest_start = 0;
          let byi_read = byi_read_start, byi_write = byi_dest_start;
          for (y = ta_source_bounds[1]; y < ta_source_bounds[3]; y++) {
            copy_ta_byte_range(ta_source2, ta_dest, byi_read, byi_write, bytes_per_bounds_row);
            byi_read += bypr_source;
            byi_write += bypr_dest;
          }
        };
        const unaligned_copy_rect_1to4bypp = (ta_source2, ta_dest, bypr_source, bypr_dest, bytes_per_pixel, ta_source_bounds, ta_dest_pos) => {
          let y;
          const bounds_row_width = ta_source_bounds[2] - ta_source_bounds[0];
          const bytes_per_bounds_row = bytes_per_pixel * bounds_row_width;
          const byi_read_start = ta_source_bounds[0] * bytes_per_pixel + ta_source_bounds[1] * bypr_source;
          const byi_dest_start = ta_dest_pos[0] * bytes_per_pixel + ta_dest_pos[1] * bypr_dest;
          let byi_read = byi_read_start, byi_write = byi_dest_start;
          for (y = ta_source_bounds[1]; y < ta_source_bounds[3]; y++) {
            copy_ta_byte_range(ta_source2, ta_dest, byi_read, byi_write, bytes_per_bounds_row);
            byi_read += bypr_source;
            byi_write += bypr_dest;
          }
        };
        const copy_px_to_ta_dest_byi = (ta_source2, source_colorspace, source_xy, ta_dest, byi_dest) => {
          const [width, height2, bypp2, bypr2, bipp, bipr] = source_colorspace;
          if (bipp === 24) {
            let byi_read = source_xy[0] * bypp2 + source_xy[1] * bypr2;
            ta_dest[byi_dest] = ta_source2[byi_read++];
            ta_dest[byi_dest + 1] = ta_source2[byi_read++];
            ta_dest[byi_dest + 2] = ta_source2[byi_read++];
          } else {
            console.trace();
            throw "NYI";
          }
        };
        const copy_px_24bipp = (ta_source2, byi_read, ta_dest, byi_write) => {
          ta_dest[byi_write] = ta_source2[byi_read++];
          ta_dest[byi_write + 1] = ta_source2[byi_read++];
          ta_dest[byi_write + 2] = ta_source2[byi_read++];
        };
        return {
          unaligned_copy_rect_1to4bypp,
          dest_aligned_copy_rect_1to4bypp,
          copy_rect_to_same_size_24bipp,
          copy_rect_to_same_size_8bipp,
          copy_ta_byte_range,
          get_instance,
          copy_px_to_ta_dest_byi,
          copy_px_24bipp
        };
      };
      module.exports = get_instance();
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/info.js
  var require_info = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/info.js"(exports, module) {
      var get_instance = () => {
        const byi_from_cs_pos2 = (colorspace, pos) => {
          const [width, height2, bypp2, bypr2, bipp, bipr] = colorspace;
          return pos[0] * bypp2 + pos[1] * bypr2;
        };
        const overlapping_bounds = (bounds_1, bounds_2, res_bounds = new Int16Array(4)) => {
          res_bounds[0] = bounds_1[0] < bounds_2[0] ? bounds_2[0] : bounds_1[0];
          res_bounds[1] = bounds_1[1] < bounds_2[1] ? bounds_2[1] : bounds_1[1];
          res_bounds[2] = bounds_1[2] > bounds_2[2] ? bounds_2[2] : bounds_1[2];
          res_bounds[3] = bounds_1[3] > bounds_2[3] ? bounds_2[3] : bounds_1[3];
          return res_bounds;
        };
        return {
          overlapping_bounds,
          byi_from_cs_pos: byi_from_cs_pos2,
          get_instance
        };
      };
      module.exports = get_instance();
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/read.js
  var require_read = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/read.js"(exports, module) {
      var get_instance = () => {
        const read_px = (ta_source2, ta_colorspace, ta_pos) => {
          const bipp = ta_colorspace[4];
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);
            return ta_source2[byi];
          } else if (bipp === 24) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);
            return ta_source2.subarray(byi, byi + 3);
          } else if (bipp === 32) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);
            return ta_source2.subarray(byi, byi + 4);
          }
        };
        const read_2x1_rect = (ta_source2, ta_colorspace, ta_pos) => {
          const [x, y] = ta_pos;
          const [width, height2, bypp2, bypr2, bipp, bipr] = ta_colorspace;
          if (x < 0) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (x > width - 1) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (y < 0) {
            throw "y position must be between 0 and height";
          }
          if (y > height2) {
            throw "y position must be between 0 and height";
          }
          let byi_read = x * bypp2 + y * bypr2;
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            const res2 = new Uint8ClampedArray(2);
            res2[0] = ta_source2[byi_read];
            res2[1] = ta_source2[byi_read + 1];
            return res2;
          } else if (bipp === 24) {
            const res2 = new Uint8ClampedArray(6);
            res2.set(ta_source2.subarray(byi_read, byi_read + 6), 0);
            return res2;
          } else if (bipp === 32) {
            const res2 = new Uint8ClampedArray(8);
            res2.set(ta_source2.subarray(byi_read, byi_read + 8), 0);
            return res2;
          }
        };
        const read_1x2_rect = (ta_source2, ta_colorspace, ta_pos) => {
          const [x, y] = ta_pos;
          const [width, height2, bypp2, bypr2, bipp, bipr] = ta_colorspace;
          if (x < 0) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (x > width - 1) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (y < 0) {
            throw "y position must be between 0 and height";
          }
          if (y > height2) {
            throw "y position must be between 0 and height";
          }
          let byi_read = x * bypp2 + y * bypr2;
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            const res2 = new Uint8ClampedArray(2);
            res2[0] = ta_source2[byi_read];
            res2[1] = ta_source2[byi_read + bypr2];
            return res2;
          } else if (bipp === 24) {
            const res2 = new Uint8ClampedArray(6);
            res2.set(ta_source2.subarray(byi_read, byi_read + 3), 0);
            byi_read += bypr2;
            res2.set(ta_source2.subarray(byi_read, byi_read + 3), 3);
            return res2;
          } else if (bipp === 32) {
            const res2 = new Uint8ClampedArray(8);
            res2.set(ta_source2.subarray(byi_read, byi_read + 4), 0);
            byi_read += bypr2;
            res2.set(ta_source2.subarray(byi_read, byi_read + 4), 4);
            return res2;
          }
        };
        const read_2x2_rect = (ta_source2, ta_colorspace, ta_pos) => {
          const [x, y] = ta_pos;
          const [width, height2, bypp2, bypr2, bipp, bipr] = ta_colorspace;
          if (x < 0) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (x > width - 1) {
            throw "x position must be between 0 and (width - 1)";
          }
          if (y < 0) {
            throw "y position must be between 0 and (height - 1)";
          }
          if (y > height2 - 1) {
            throw "y position must be between 0 and (height - 1)";
          }
          let byi_read = x * bypp2 + y * bypr2;
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            const res2 = new Uint8ClampedArray(4);
            res2[0] = ta_source2[byi_read];
            res2[1] = ta_source2[byi_read + 1];
            res2[2] = ta_source2[byi_read + bypr2];
            res2[3] = ta_source2[byi_read + bypr2 + 1];
            return res2;
          } else if (bipp === 24) {
            const res2 = new Uint8ClampedArray(12);
            res2.set(ta_source2.subarray(byi_read, byi_read + 6), 0);
            byi_read += bypr2;
            res2.set(ta_source2.subarray(byi_read, byi_read + 6), 6);
            return res2;
          } else if (bipp === 32) {
            const res2 = new Uint8ClampedArray(16);
            res2.set(ta_source2.subarray(byi_read, byi_read + 8), 0);
            byi_read += bypr2;
            res2.set(ta_source2.subarray(byi_read, byi_read + 8), 8);
            return res2;
          }
        };
        const read_merged_vfpx_24bipp = (ta_source2, colorspace, vfpx) => {
          const [width, height2, bypp2, bypr2, bipp, bipr] = colorspace;
          const { weights, i_any_coverage_bounds } = vfpx;
          const xy = new Int16Array(2);
          let byi_read = 3 * i_any_coverage_bounds[0] + bypr2 * i_any_coverage_bounds[1];
          let byi_weight = 0;
          const iw = i_any_coverage_bounds[2] - i_any_coverage_bounds[0];
          const bytes_read_row_end_jump = bypr2 - iw * 3;
          const acc_rgb = new Float32Array(3);
          for (xy[1] = i_any_coverage_bounds[1]; xy[1] < i_any_coverage_bounds[3]; xy[1]++) {
            for (xy[0] = i_any_coverage_bounds[0]; xy[0] < i_any_coverage_bounds[2]; xy[0]++) {
              acc_rgb[0] += ta_source2[byi_read++] * weights[byi_weight];
              acc_rgb[1] += ta_source2[byi_read++] * weights[byi_weight];
              acc_rgb[2] += ta_source2[byi_read++] * weights[byi_weight++];
            }
            byi_read += bytes_read_row_end_jump;
          }
          const res2 = new Uint8ClampedArray(acc_rgb);
          return res2;
        };
        const read_merged_vfpx = (ta_source2, colorspace, vfpx) => {
          const bipp = colorspace[4];
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            console.trace();
            throw "NYI";
          } else if (bipp === 24) {
            return read_merged_vfpx_24bipp(ta_source2, colorspace, vfpx);
          } else if (bipp === 32) {
            console.trace();
            throw "NYI";
          }
        };
        const each_pixel_in_colorspace = (colorspace, callback2) => {
          const [width, height2, bypp2, bypr2, bipp, bipr] = colorspace;
          let byi = 0;
          const xy = new Int16Array(2);
          for (xy[1] = 0; xy[1] < height2; xy[1]++) {
            for (xy[0] = 0; xy[0] < width; xy[0]++) {
              callback2(xy, byi);
              byi += bypp2;
            }
          }
        };
        return {
          read_2x2_rect,
          read_1x2_rect,
          read_2x1_rect,
          read_merged_vfpx_24bipp,
          read_merged_vfpx,
          get_instance,
          each_pixel_in_colorspace
        };
      };
      module.exports = get_instance();
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/transform.js
  var require_transform = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/transform.js"(exports, module) {
      var each_source_dest_pixels_resized_limited_further_info$inline = (source_colorspace, dest_size, callback2) => {
        const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
        const source_edge_distances = new Float32Array(4);
        const edge_distances_proportions_of_total = new Float32Array(4);
        const corner_areas_proportions_of_total = new Float32Array(4);
        const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
        let [width, height2, bypp2, bypr2, bipp, bipr] = source_colorspace;
        const source_bypr = bypr2;
        const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], bypp2, bypp2 * dest_size[0], bipp, bipp * dest_size[0]]);
        const source_fbounds = new Float32Array(4);
        const source_ibounds = new Int16Array(4);
        const source_i_any_coverage_size = new Int16Array(2);
        const source_total_coverage_ibounds = new Int16Array(4);
        let byi_read;
        let dest_byi = 0;
        [width, height2, bypp2, bypr2, bipp, bipr] = dest_colorspace;
        let x, y;
        for (y = 0; y < height2; y++) {
          source_fbounds[1] = y * dest_to_source_ratio[1];
          source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
          source_ibounds[1] = source_fbounds[1];
          source_ibounds[3] = Math.ceil(source_fbounds[3]);
          source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
          source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
          source_total_coverage_ibounds[3] = source_fbounds[3];
          source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
          source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
          if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
          if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
          edge_distances_proportions_of_total[1] = source_edge_distances[1] / fpx_area;
          edge_distances_proportions_of_total[3] = source_edge_distances[3] / fpx_area;
          for (x = 0; x < width; x++) {
            source_fbounds[0] = x * dest_to_source_ratio[0];
            source_fbounds[2] = source_fbounds[0] + dest_to_source_ratio[0];
            source_ibounds[0] = source_fbounds[0];
            source_ibounds[2] = Math.ceil(source_fbounds[2]);
            source_i_any_coverage_size[0] = source_ibounds[2] - source_ibounds[0];
            byi_read = source_ibounds[0] * bypp2 + source_ibounds[1] * source_bypr;
            if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 1) {
              callback2(dest_byi, source_i_any_coverage_size, void 0, void 0, byi_read);
            } else {
              source_total_coverage_ibounds[0] = Math.ceil(source_fbounds[0]);
              source_total_coverage_ibounds[2] = source_fbounds[2];
              if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 2) {
                callback2(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, void 0, byi_read);
              } else {
                source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
                source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
                if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
                if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
                if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 1) {
                  edge_distances_proportions_of_total[0] = source_edge_distances[0] / dest_to_source_ratio[0];
                  edge_distances_proportions_of_total[2] = source_edge_distances[2] / dest_to_source_ratio[0];
                  callback2(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, void 0, byi_read);
                } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
                  corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
                  corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
                  corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
                  corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
                  callback2(dest_byi, source_i_any_coverage_size, void 0, corner_areas_proportions_of_total, byi_read);
                } else {
                  edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
                  edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
                  corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
                  corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
                  corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
                  corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
                  callback2(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read);
                }
              }
            }
            dest_byi += bypp2;
          }
        }
      };
      var each_source_dest_pixels_resized_limited_further_info = each_source_dest_pixels_resized_limited_further_info$inline;
      var copy_px_24bipp = (ta_source2, byi_read, ta_dest, byi_write) => {
        ta_dest[byi_write] = ta_source2[byi_read++];
        ta_dest[byi_write + 1] = ta_source2[byi_read++];
        ta_dest[byi_write + 2] = ta_source2[byi_read++];
      };
      var read_1x2_weight_write_24bipp = (ta_source2, bypr2, byi_read, ta_dest, byi_write, weight_t, weight_b) => {
        let byi_read_below2 = byi_read + bypr2;
        ta_dest[byi_write] = weight_t * ta_source2[byi_read++] + weight_b * ta_source2[byi_read_below2++];
        ta_dest[byi_write + 1] = weight_t * ta_source2[byi_read++] + weight_b * ta_source2[byi_read_below2++];
        ta_dest[byi_write + 2] = weight_t * ta_source2[byi_read++] + weight_b * ta_source2[byi_read_below2++];
      };
      var read_2x1_weight_write_24bipp = (ta_source2, byi_read, ta_dest, byi_write, weight_l, weight_r) => {
        let byi_read_right2 = byi_read + 3;
        ta_dest[byi_write] = weight_l * ta_source2[byi_read++] + weight_r * ta_source2[byi_read_right2++];
        ta_dest[byi_write + 1] = weight_l * ta_source2[byi_read++] + weight_r * ta_source2[byi_read_right2++];
        ta_dest[byi_write + 2] = weight_l * ta_source2[byi_read++] + weight_r * ta_source2[byi_read_right2++];
      };
      var read_2x2_weight_write_24bipp = (ta_source2, bypr2, byi_read, ta_dest, byi_write, corner_weights_ltrb) => {
        let byi_read_right2 = byi_read + 3;
        let byi_read_below2 = byi_read + bypr2;
        let byi_read_below_right2 = byi_read_below2 + 3;
        ta_dest[byi_write] = corner_weights_ltrb[0] * ta_source2[byi_read++] + corner_weights_ltrb[1] * ta_source2[byi_read_right2++] + corner_weights_ltrb[2] * ta_source2[byi_read_below2++] + corner_weights_ltrb[3] * ta_source2[byi_read_below_right2++];
        ta_dest[byi_write + 1] = corner_weights_ltrb[0] * ta_source2[byi_read++] + corner_weights_ltrb[1] * ta_source2[byi_read_right2++] + corner_weights_ltrb[2] * ta_source2[byi_read_below2++] + corner_weights_ltrb[3] * ta_source2[byi_read_below_right2++];
        ta_dest[byi_write + 2] = corner_weights_ltrb[0] * ta_source2[byi_read++] + corner_weights_ltrb[1] * ta_source2[byi_read_right2++] + corner_weights_ltrb[2] * ta_source2[byi_read_below2++] + corner_weights_ltrb[3] * ta_source2[byi_read_below_right2++];
      };
      var read_3x2_weight_write_24bipp = (ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_weights_ltrb, ta_dest, dest_byi) => {
        const bypp2 = 3;
        let byi_tl = byi_read;
        let byi_tm = byi_tl + bypp2, byi_tr = byi_tm + bypp2;
        let byi_bl = byi_tm + bypr2, byi_bm = byi_bl + bypp2, byi_br = byi_bm + bypp2;
        ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
      };
      var read_2x3_weight_write_24bipp = (ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_weights_ltrb, ta_dest, dest_byi) => {
        const bypp2 = 3;
        let byi_tl = byi_read, byi_tr = byi_tl + bypp2;
        let byi_ml = byi_tl + bypr2, byi_mr = byi_ml + bypp2;
        let byi_bl = byi_ml + bypr2, byi_br = byi_bl + bypp2;
        ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source2[byi_mr++] * edge_distances_proportions_of_total[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source2[byi_mr++] * edge_distances_proportions_of_total[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source2[byi_mr++] * edge_distances_proportions_of_total[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_br++] * corner_weights_ltrb[3];
      };
      var read_3x3_weight_write_24bipp = (ta_source2, bypr2, byi_read, edge_weights, corner_weights_ltrb, fpx_area_recip2, ta_dest, dest_byi) => {
        const bypp2 = 3;
        let byi_tl = byi_read, byi_tm = byi_tl + bypp2, byi_tr = byi_tm + bypp2;
        let byi_ml = byi_tl + bypr2, byi_mm = byi_ml + bypp2, byi_mr = byi_mm + bypp2;
        let byi_bl = byi_ml + bypr2, byi_bm = byi_bl + bypp2, byi_br = byi_bm + bypp2;
        ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_weights[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_weights[0] + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_weights[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_weights[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_weights[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_weights[0] + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_weights[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_weights[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
        ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_weights_ltrb[0] + ta_source2[byi_tm++] * edge_weights[1] + ta_source2[byi_tr++] * corner_weights_ltrb[1] + ta_source2[byi_ml++] * edge_weights[0] + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_weights[2] + ta_source2[byi_bl++] * corner_weights_ltrb[2] + ta_source2[byi_bm++] * edge_weights[3] + ta_source2[byi_br++] * corner_weights_ltrb[3];
      };
      var read_gt3x3_weight_write_24bipp = (ta_source2, bypr2, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_weights_ltrb, fpx_area_recip2, ta_dest, dest_byi) => {
        const byi_tl = byi_read;
        let r = 0, g = 0, b = 0;
        let x, y;
        const end_hmiddle = source_i_any_coverage_size[0] - 1, end_vmiddle = source_i_any_coverage_size[1] - 1;
        r += ta_source2[byi_read++] * corner_weights_ltrb[0];
        g += ta_source2[byi_read++] * corner_weights_ltrb[0];
        b += ta_source2[byi_read++] * corner_weights_ltrb[0];
        for (x = 1; x < end_hmiddle; x++) {
          r += ta_source2[byi_read++] * edge_distances_proportions_of_total[1];
          g += ta_source2[byi_read++] * edge_distances_proportions_of_total[1];
          b += ta_source2[byi_read++] * edge_distances_proportions_of_total[1];
        }
        r += ta_source2[byi_read++] * corner_weights_ltrb[1];
        g += ta_source2[byi_read++] * corner_weights_ltrb[1];
        b += ta_source2[byi_read++] * corner_weights_ltrb[1];
        for (y = 1; y < end_vmiddle; y++) {
          byi_read = byi_tl + y * bypr2;
          r += ta_source2[byi_read++] * edge_distances_proportions_of_total[0];
          g += ta_source2[byi_read++] * edge_distances_proportions_of_total[0];
          b += ta_source2[byi_read++] * edge_distances_proportions_of_total[0];
          for (x = 1; x < end_hmiddle; x++) {
            r += ta_source2[byi_read++] * fpx_area_recip2;
            g += ta_source2[byi_read++] * fpx_area_recip2;
            b += ta_source2[byi_read++] * fpx_area_recip2;
          }
          r += ta_source2[byi_read++] * edge_distances_proportions_of_total[2];
          g += ta_source2[byi_read++] * edge_distances_proportions_of_total[2];
          b += ta_source2[byi_read++] * edge_distances_proportions_of_total[2];
        }
        byi_read = byi_tl + end_vmiddle * bypr2;
        r += ta_source2[byi_read++] * corner_weights_ltrb[2];
        g += ta_source2[byi_read++] * corner_weights_ltrb[2];
        b += ta_source2[byi_read++] * corner_weights_ltrb[2];
        for (x = 1; x < end_hmiddle; x++) {
          r += ta_source2[byi_read++] * edge_distances_proportions_of_total[3];
          g += ta_source2[byi_read++] * edge_distances_proportions_of_total[3];
          b += ta_source2[byi_read++] * edge_distances_proportions_of_total[3];
        }
        r += ta_source2[byi_read++] * corner_weights_ltrb[3];
        g += ta_source2[byi_read++] * corner_weights_ltrb[3];
        b += ta_source2[byi_read++] * corner_weights_ltrb[3];
        ta_dest[dest_byi] = Math.round(r);
        ta_dest[dest_byi + 1] = Math.round(g);
        ta_dest[dest_byi + 2] = Math.round(b);
      };
      var resize_ta_colorspace_24bipp$subpixel$inline = (ta_source2, source_colorspace, dest_size, ta_dest) => {
        const source_bypp = source_colorspace[2];
        const source_bypr = source_colorspace[3];
        const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
        let f_source_x, f_source_r;
        let i_source_l, i_source_lr_crossover;
        let f_source_y, f_source_b;
        let i_source_t, i_source_tb_crossover;
        let i_dest_x, i_dest_y;
        const ta_left_proportions = new Float32Array(dest_size[0]);
        const ta_top_proportions = new Float32Array(dest_size[1]);
        const ta_source_x_byi_component = new Int32Array(dest_size[0]);
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
          f_source_x = i_dest_x * f_px_w;
          f_source_r = f_source_x + f_px_w;
          i_source_l = Math.floor(f_source_x);
          i_source_lr_crossover = i_source_l + 1;
          ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
          if (f_source_r < i_source_lr_crossover || i_source_l === f_source_x) {
            ta_left_proportions[i_dest_x] = 1;
          } else {
            ta_left_proportions[i_dest_x] = (i_source_lr_crossover - f_source_x) / f_px_w;
          }
        }
        let byi_source;
        let byi_write = 0;
        let byi_read_below2, byi_read_right2, byi_read_below_right2;
        let edge_l, edge_t, edge_r;
        let corner_tl, corner_tr, corner_bl, corner_br;
        let y_byi;
        for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
          f_source_y = i_dest_y * f_px_h;
          f_source_b = f_source_y + f_px_h;
          i_source_t = Math.floor(f_source_y);
          i_source_tb_crossover = i_source_t + 1;
          y_byi = i_source_t * source_bypr;
          if (f_source_b < i_source_tb_crossover || i_source_t === f_source_y) {
            ta_top_proportions[i_dest_y] = 1;
          } else {
            ta_top_proportions[i_dest_y] = (i_source_tb_crossover - f_source_y) / f_px_h;
          }
          edge_t = ta_top_proportions[i_dest_y];
          if (edge_t === 1) {
            for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
              edge_l = ta_left_proportions[i_dest_x];
              edge_r = 1 - ta_left_proportions[i_dest_x];
              byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
              if (edge_l === 1) {
                ta_dest[byi_write++] = ta_source2[byi_source++];
                ta_dest[byi_write++] = ta_source2[byi_source++];
                ta_dest[byi_write++] = ta_source2[byi_source++];
              } else {
                byi_read_right2 = byi_source + 3;
                ta_dest[byi_write++] = edge_l * ta_source2[byi_source++] + edge_r * ta_source2[byi_read_right2++];
                ta_dest[byi_write++] = edge_l * ta_source2[byi_source++] + edge_r * ta_source2[byi_read_right2++];
                ta_dest[byi_write++] = edge_l * ta_source2[byi_source++] + edge_r * ta_source2[byi_read_right2++];
              }
            }
          } else {
            const edge_b = 1 - ta_top_proportions[i_dest_y];
            for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
              edge_l = ta_left_proportions[i_dest_x];
              edge_r = 1 - ta_left_proportions[i_dest_x];
              byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
              if (edge_l === 1) {
                byi_read_below2 = byi_source + source_bypr;
                ta_dest[byi_write++] = edge_t * ta_source2[byi_source++] + edge_b * ta_source2[byi_read_below2++];
                ta_dest[byi_write++] = edge_t * ta_source2[byi_source++] + edge_b * ta_source2[byi_read_below2++];
                ta_dest[byi_write++] = edge_t * ta_source2[byi_source++] + edge_b * ta_source2[byi_read_below2++];
              } else {
                corner_tl = edge_l * edge_t;
                corner_tr = edge_r * edge_t;
                corner_bl = edge_l * edge_b;
                corner_br = edge_r * edge_b;
                byi_read_right2 = byi_source + 3;
                byi_read_below2 = byi_source + source_bypr;
                byi_read_below_right2 = byi_read_below2 + 3;
                ta_dest[byi_write++] = corner_tl * ta_source2[byi_source++] + corner_tr * ta_source2[byi_read_right2++] + corner_bl * ta_source2[byi_read_below2++] + corner_br * ta_source2[byi_read_below_right2++];
                ta_dest[byi_write++] = corner_tl * ta_source2[byi_source++] + corner_tr * ta_source2[byi_read_right2++] + corner_bl * ta_source2[byi_read_below2++] + corner_br * ta_source2[byi_read_below_right2++];
                ta_dest[byi_write++] = corner_tl * ta_source2[byi_source++] + corner_tr * ta_source2[byi_read_right2++] + corner_bl * ta_source2[byi_read_below2++] + corner_br * ta_source2[byi_read_below_right2++];
              }
            }
          }
        }
      };
      var resize_ta_colorspace_24bipp$subpixel = resize_ta_colorspace_24bipp$subpixel$inline;
      var resize_ta_colorspace_24bipp$superpixel$inline$locals$inline = (ta_source2, source_colorspace, dest_size, opt_ta_dest2) => {
        const ta_dest = opt_ta_dest2;
        const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
        const fpx_area_recip2 = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
        const [fpxw, fpxh] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
        let edge_l, edge_t, edge_r, edge_b;
        let edge_p_l, edge_p_t, edge_p_r, edge_p_b;
        let corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br;
        const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
        const source_bypp = source_colorspace[2];
        const source_bypr = source_colorspace[3];
        const source_bipp = source_colorspace[4];
        const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], source_bypp, source_bypp * dest_size[0], source_bipp, source_bipp * dest_size[0]]);
        let fbounds_l, fbounds_t, fbounds_r, fbounds_b;
        let ibounds_l, ibounds_t, ibounds_r, ibounds_b;
        let any_coverage_w, any_coverage_h;
        let total_coverage_l, total_coverage_t, total_coverage_r, total_coverage_b;
        let byi_read;
        let dest_byi = 0;
        const width = dest_colorspace[0], height2 = dest_colorspace[1];
        let x, y;
        let r = 0, g = 0, b = 0;
        let x_inner, y_inner;
        let byi_read_right2, byi_read_below2, byi_read_below_right2;
        let byi_tl, byi_tm, byi_tr;
        let byi_ml, byi_mm, byi_mr;
        let byi_bl, byi_bm, byi_br;
        let end_hmiddle, end_vmiddle;
        for (y = 0; y < height2; y++) {
          fbounds_t = y * fpxh;
          fbounds_b = fbounds_t + fpxh;
          ibounds_t = Math.floor(fbounds_t);
          ibounds_b = Math.ceil(fbounds_b);
          any_coverage_h = ibounds_b - ibounds_t;
          total_coverage_t = Math.ceil(fbounds_t);
          total_coverage_b = Math.floor(fbounds_b);
          edge_t = total_coverage_t - fbounds_t;
          edge_b = fbounds_b - total_coverage_b;
          if (edge_t === 0) edge_t = 1;
          if (edge_b === 0) edge_b = 1;
          edge_p_t = edge_t / fpx_area;
          edge_p_b = edge_b / fpx_area;
          fbounds_l = 0;
          fbounds_r = fpxw;
          for (x = 0; x < width; x++) {
            fbounds_l = x * fpxw;
            fbounds_r = (x + 1) * fpxw;
            ibounds_l = Math.floor(fbounds_l);
            ibounds_r = Math.ceil(fbounds_r);
            any_coverage_w = ibounds_r - ibounds_l;
            byi_read = ibounds_l * source_bypp + ibounds_t * source_bypr;
            total_coverage_l = Math.ceil(fbounds_l);
            total_coverage_r = Math.floor(fbounds_r);
            edge_l = total_coverage_l - fbounds_l;
            edge_r = fbounds_r - total_coverage_r;
            if (edge_l === 0) edge_l = 1;
            if (edge_r === 0) edge_r = 1;
            corner_p_tl = edge_l * edge_p_t;
            corner_p_tr = edge_r * edge_p_t;
            corner_p_bl = edge_l * edge_p_b;
            corner_p_br = edge_r * edge_p_b;
            if (any_coverage_w > 3 || any_coverage_h > 3) {
              edge_p_l = edge_l / fpx_area;
              edge_p_r = edge_r / fpx_area;
              byi_tl = byi_read;
              end_hmiddle = any_coverage_w - 1;
              end_vmiddle = any_coverage_h - 1;
              r = g = b = 0;
              r += ta_source2[byi_read++] * corner_p_tl;
              g += ta_source2[byi_read++] * corner_p_tl;
              b += ta_source2[byi_read++] * corner_p_tl;
              for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                r += ta_source2[byi_read++] * edge_p_t;
                g += ta_source2[byi_read++] * edge_p_t;
                b += ta_source2[byi_read++] * edge_p_t;
              }
              r += ta_source2[byi_read++] * corner_p_tr;
              g += ta_source2[byi_read++] * corner_p_tr;
              b += ta_source2[byi_read++] * corner_p_tr;
              for (y_inner = 1; y_inner < end_vmiddle; y_inner++) {
                byi_read = byi_tl + y_inner * source_bypr;
                r += ta_source2[byi_read++] * edge_p_l;
                g += ta_source2[byi_read++] * edge_p_l;
                b += ta_source2[byi_read++] * edge_p_l;
                for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                  r += ta_source2[byi_read++] * fpx_area_recip2;
                  g += ta_source2[byi_read++] * fpx_area_recip2;
                  b += ta_source2[byi_read++] * fpx_area_recip2;
                }
                r += ta_source2[byi_read++] * edge_p_r;
                g += ta_source2[byi_read++] * edge_p_r;
                b += ta_source2[byi_read++] * edge_p_r;
              }
              byi_read = byi_tl + end_vmiddle * source_bypr;
              r += ta_source2[byi_read++] * corner_p_bl;
              g += ta_source2[byi_read++] * corner_p_bl;
              b += ta_source2[byi_read++] * corner_p_bl;
              for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                r += ta_source2[byi_read++] * edge_p_b;
                g += ta_source2[byi_read++] * edge_p_b;
                b += ta_source2[byi_read++] * edge_p_b;
              }
              r += ta_source2[byi_read++] * corner_p_br;
              g += ta_source2[byi_read++] * corner_p_br;
              b += ta_source2[byi_read++] * corner_p_br;
              ta_dest[dest_byi] = Math.round(r);
              ta_dest[dest_byi + 1] = Math.round(g);
              ta_dest[dest_byi + 2] = Math.round(b);
            } else {
              if (any_coverage_w === 2 && any_coverage_h === 2) {
                byi_read_right2 = byi_read + 3;
                byi_read_below2 = byi_read + source_bypr;
                byi_read_below_right2 = byi_read_below2 + 3;
                ta_dest[dest_byi] = corner_p_tl * ta_source2[byi_read++] + corner_p_tr * ta_source2[byi_read_right2++] + corner_p_bl * ta_source2[byi_read_below2++] + corner_p_br * ta_source2[byi_read_below_right2++];
                ta_dest[dest_byi + 1] = corner_p_tl * ta_source2[byi_read++] + corner_p_tr * ta_source2[byi_read_right2++] + corner_p_bl * ta_source2[byi_read_below2++] + corner_p_br * ta_source2[byi_read_below_right2++];
                ta_dest[dest_byi + 2] = corner_p_tl * ta_source2[byi_read++] + corner_p_tr * ta_source2[byi_read_right2++] + corner_p_bl * ta_source2[byi_read_below2++] + corner_p_br * ta_source2[byi_read_below_right2++];
              } else {
                edge_p_l = edge_l / fpx_area;
                edge_p_r = edge_r / fpx_area;
                if (any_coverage_w === 2 && any_coverage_h === 3) {
                  byi_tl = byi_read;
                  byi_tr = byi_tl + 3;
                  byi_ml = byi_tl + source_bypr;
                  byi_mr = byi_ml + 3;
                  byi_bl = byi_ml + source_bypr;
                  byi_br = byi_bl + 3;
                  ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_br++] * corner_p_br;
                } else if (any_coverage_w === 3 && any_coverage_h === 2) {
                  byi_tl = byi_read;
                  byi_tm = byi_tl + 3;
                  byi_tr = byi_tm + 3;
                  byi_bl = byi_tm + source_bypr;
                  byi_bm = byi_bl + 3;
                  byi_br = byi_bm + 3;
                  ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                } else if (any_coverage_w === 3 && any_coverage_h === 3) {
                  byi_tl = byi_read;
                  byi_tm = byi_tl + source_bypp;
                  byi_tr = byi_tm + source_bypp;
                  byi_ml = byi_tl + source_bypr;
                  byi_mm = byi_ml + source_bypp;
                  byi_mr = byi_mm + source_bypp;
                  byi_bl = byi_ml + source_bypr;
                  byi_bm = byi_bl + source_bypp;
                  byi_br = byi_bm + source_bypp;
                  ta_dest[dest_byi] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 1] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                  ta_dest[dest_byi + 2] = ta_source2[byi_tl++] * corner_p_tl + ta_source2[byi_tm++] * edge_p_t + ta_source2[byi_tr++] * corner_p_tr + ta_source2[byi_ml++] * edge_p_l + ta_source2[byi_mm++] * fpx_area_recip2 + ta_source2[byi_mr++] * edge_p_r + ta_source2[byi_bl++] * corner_p_bl + ta_source2[byi_bm++] * edge_p_b + ta_source2[byi_br++] * corner_p_br;
                } else {
                  console.trace();
                  throw "stop";
                }
              }
            }
            dest_byi += source_bypp;
          }
        }
      };
      var resize_ta_colorspace_24bipp$superpixel = resize_ta_colorspace_24bipp$superpixel$inline$locals$inline;
      var resize_ta_colorspace_24bipp$general = (ta_source2, source_colorspace, dest_size, opt_ta_dest2) => {
        const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
        const [width, height2, bypp2, bypr2, bipp, bipr] = source_colorspace;
        const fpx_area_recip2 = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
        each_source_dest_pixels_resized_limited_further_info(source_colorspace, dest_size, (dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read) => {
          if (source_i_any_coverage_size[0] === 1) {
            if (source_i_any_coverage_size[1] === 1) {
              copy_px_24bipp(ta_source2, byi_read, opt_ta_dest2, dest_byi);
            } else if (source_i_any_coverage_size[1] === 2) {
              read_1x2_weight_write_24bipp(ta_source2, bypr2, byi_read, opt_ta_dest2, dest_byi, edge_distances_proportions_of_total[1], edge_distances_proportions_of_total[3]);
            } else {
              console.log("source_i_any_coverage_size", source_i_any_coverage_size);
              console.trace();
              throw "NYI";
            }
          } else if (source_i_any_coverage_size[0] === 2) {
            if (source_i_any_coverage_size[1] === 1) {
              read_2x1_weight_write_24bipp(ta_source2, byi_read, opt_ta_dest2, dest_byi, edge_distances_proportions_of_total[0], edge_distances_proportions_of_total[2]);
            } else if (source_i_any_coverage_size[1] === 2) {
              read_2x2_weight_write_24bipp(ta_source2, bypr2, byi_read, opt_ta_dest2, dest_byi, corner_areas_proportions_of_total);
            } else {
              read_2x3_weight_write_24bipp(ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest2, dest_byi);
            }
          } else if (source_i_any_coverage_size[0] === 3) {
            if (source_i_any_coverage_size[1] === 1) {
              console.log("source_i_any_coverage_size", source_i_any_coverage_size);
              console.trace();
              throw "NYI";
            } else if (source_i_any_coverage_size[1] === 2) {
              read_3x2_weight_write_24bipp(ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest2, dest_byi);
            } else if (source_i_any_coverage_size[1] === 3) {
              read_3x3_weight_write_24bipp(ta_source2, bypr2, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip2, opt_ta_dest2, dest_byi);
            } else {
              read_gt3x3_weight_write_24bipp(ta_source2, bypr2, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip2, opt_ta_dest2, dest_byi);
            }
          } else {
            read_gt3x3_weight_write_24bipp(ta_source2, bypr2, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip2, opt_ta_dest2, dest_byi);
          }
        });
      };
      var resize_ta_colorspace_24bipp = (ta_source2, source_colorspace, dest_size, opt_ta_dest2) => {
        const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
        if (dest_to_source_ratio[0] < 1 && dest_to_source_ratio[1] < 1) {
          return resize_ta_colorspace_24bipp$subpixel(ta_source2, source_colorspace, dest_size, opt_ta_dest2);
        } else if (dest_to_source_ratio[0] > 1 && dest_to_source_ratio[1] > 1) {
          return resize_ta_colorspace_24bipp$superpixel(ta_source2, source_colorspace, dest_size, opt_ta_dest2);
        } else {
          return resize_ta_colorspace_24bipp$general(ta_source2, source_colorspace, dest_size, opt_ta_dest2);
        }
      };
      var resize_ta_colorspace = (ta_source2, source_colorspace, dest_size, opt_ta_dest2) => {
        const bipp = source_colorspace[4];
        if (bipp === 1) {
          console.trace();
          throw "NYI";
        } else if (bipp === 8) {
          console.trace();
          throw "NYI";
        } else if (bipp === 24) {
          return resize_ta_colorspace_24bipp(ta_source2, source_colorspace, dest_size, opt_ta_dest2);
        } else if (bipp === 32) {
          console.trace();
          throw "NYI";
        } else {
          console.trace();
          throw "unsupported bipp: " + bipp;
        }
      };
      module.exports = {
        resize_ta_colorspace,
        resize_ta_colorspace_24bipp,
        resize_ta_colorspace_24bipp$subpixel
      };
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/write.js
  var require_write = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/write.js"(exports, module) {
      var get_instance = () => {
        const fill_solid_rect_by_bounds_8bipp = (ta_dest, bypr_dest, ta_bounds, ui8_color) => {
          const row_width = ta_bounds[2] - ta_bounds[0];
          const bytes_per_row = row_width;
          const ta_write_row = new Uint8ClampedArray(bytes_per_row).fill(ui8_color);
          const byi_dest_start = ta_bounds[0] + ta_bounds[1] * bypr_dest;
          let byi_write = byi_dest_start;
          for (let y = ta_bounds[1]; y < ta_bounds[3]; y++) {
            ta_dest.set(ta_write_row, byi_write);
            byi_write += bypr_dest;
          }
        };
        const fill_solid_rect_by_bounds_24bipp = (ta_dest, bypr_dest, ta_bounds, ta_rgb) => {
          const row_width = ta_bounds[2] - ta_bounds[0];
          const bytes_per_row = row_width * 3;
          const ta_write_row = new Uint8ClampedArray(bytes_per_row);
          let cc = 0, c2 = 0;
          while (c2 < bytes_per_row) {
            ta_write_row[c2++] = ta_rgb[cc++];
            if (cc === 3) cc = 0;
          }
          const byi_dest_start = ta_bounds[0] * 3 + ta_bounds[1] * bypr_dest;
          let byi_write = byi_dest_start;
          for (let y = ta_bounds[1]; y < ta_bounds[3]; y++) {
            ta_dest.set(ta_write_row, byi_write);
            byi_write += bypr_dest;
          }
        };
        const fill_solid_rect_by_bounds = (ta_dest, bypr_dest, ta_bounds, bipp, color) => {
          if (bipp === 8) {
            return fill_solid_rect_by_bounds_8bipp(ta_dest, bypr_dest, ta_bounds, color);
          } else if (bipp === 24) {
            return fill_solid_rect_by_bounds_24bipp(ta_dest, bypr_dest, ta_bounds, color);
          } else if (bipp === 32) {
            console.trace();
            throw "NYI";
          } else {
            console.trace();
            throw "Unsupported bipp: " + bipp;
          }
        };
        return {
          fill_solid_rect_by_bounds,
          fill_solid_rect_by_bounds_24bipp,
          fill_solid_rect_by_bounds_8bipp,
          get_instance
        };
      };
      module.exports = get_instance();
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/bitwise.js
  var require_bitwise = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/bitwise.js"(exports, module) {
      var to_binary_string = (uint8Array) => {
        return Array.from(uint8Array).map((byte) => byte.toString(2).padStart(8, "0")).join("");
      };
      var right_shift_32bit_with_carry2 = (image) => {
        const length = image.length;
        const shifted_result = new Uint8Array(length);
        const dataView = new DataView(image.buffer);
        const resultView = new DataView(shifted_result.buffer);
        const chunks = length >> 2;
        const remainder = length & 3;
        let carry = 0;
        for (let i = 0; i < chunks; i++) {
          const original = dataView.getUint32(i * 4);
          const shifted = carry << 31 | original >>> 1;
          resultView.setUint32(i * 4, shifted);
          carry = original & 1;
        }
        if (remainder > 0) {
          const lastIndex = chunks * 4;
          const lastChunk = new Uint8Array(4);
          lastChunk.set(image.slice(lastIndex));
          const lastOriginal = new DataView(lastChunk.buffer).getUint32(0);
          const lastShifted = carry << 31 | lastOriginal >>> 1;
          for (let j = 0; j < remainder; j++) {
            resultView.setUint8(lastIndex + j, lastShifted >>> 8 * (3 - j) & 255);
          }
        }
        return shifted_result;
      };
      var xor_typed_arrays2 = (original_image, shifted_image, res2) => {
        const length = original_image.length;
        if (length !== shifted_image.length) {
          throw new Error("Typed arrays must be of the same length.");
        }
        const xor_result = res2 || new Uint8Array(length);
        const originalView = new DataView(original_image.buffer);
        const shiftedView = new DataView(shifted_image.buffer);
        const resultView = new DataView(xor_result.buffer);
        const chunks = length >>> 2;
        const remaining_start_index = chunks << 2;
        for (let i = 0; i < chunks; i++) {
          const byteOffset = i << 2;
          const original = originalView.getUint32(byteOffset, false);
          const shifted = shiftedView.getUint32(byteOffset, false);
          const xor_result_chunk = original ^ shifted;
          resultView.setUint32(byteOffset, xor_result_chunk, false);
        }
        for (let i = remaining_start_index; i < length; i++) {
          const originalByte = originalView.getUint8(i);
          const shiftedByte = shiftedView.getUint8(i);
          resultView.setUint8(i, originalByte ^ shiftedByte);
        }
        return xor_result;
      };
      var copy_row_beginning_bits = (ta_source2, row_width, ta_dest) => {
        if (ta_source2.length !== ta_dest.length) {
          throw new Error("Source and destination arrays must be the same length.");
        }
        const total_bits = ta_source2.length * 8;
        const dataViewSource = new DataView(ta_source2.buffer, ta_source2.byteOffset);
        const dataViewDest = new DataView(ta_dest.buffer, ta_dest.byteOffset);
        const height2 = Math.floor(total_bits / row_width);
        let bit_index = 0;
        for (let y = 0; y < height2; y++) {
          const byte_index = Math.floor(bit_index / 8);
          const bit_in_byte = bit_index % 8;
          const source_byte = dataViewSource.getUint8(byte_index);
          const first_bit = source_byte >> 7 - bit_in_byte & 1;
          const dest_byte = dataViewDest.getUint8(byte_index);
          const updated_dest_byte = dest_byte & ~(1 << 7 - bit_in_byte) | first_bit << 7 - bit_in_byte;
          dataViewDest.setUint8(byte_index, updated_dest_byte);
          bit_index += row_width;
        }
      };
      var set_row_beginning_bits_to_0 = (ta2, row_width) => {
        const total_bits = ta2.length * 8;
        const dataView = new DataView(ta2.buffer, ta2.byteOffset);
        const height2 = Math.floor(total_bits / row_width);
        let bit_index = 0;
        for (let y = 0; y < height2; y++) {
          const byte_index = Math.floor(bit_index / 8);
          const bit_in_byte = bit_index % 8;
          const byte = dataView.getUint8(byte_index);
          const updated_byte = byte & ~(1 << 7 - bit_in_byte);
          dataView.setUint8(byte_index, updated_byte);
          bit_index += row_width;
        }
      };
      var fast_find_next_set_bit = (num, start_index) => {
        if (start_index < -1 || start_index > 31) return false;
        if (start_index === 31) return false;
        if (start_index >= 0) {
          num = num & (1 << 31 - start_index) - 1;
        }
        if (num === 0) return false;
        const next_set_bit = Math.clz32(num);
        return next_set_bit < 32 ? next_set_bit : false;
      };
      var fast_find_next_set_ta_bit = (ta2, start_index = 0, limit = ta2.length * 8) => {
        const total_bits = ta2.length * 8;
        const end_index = Math.min(start_index + limit, total_bits);
        for (let bit_index = start_index + 1; bit_index < end_index; bit_index++) {
          const byte_index = bit_index >>> 3;
          const bit_in_byte = bit_index & 7;
          if ((ta2[byte_index] & 1 << 7 - bit_in_byte) !== 0) {
            return bit_index;
          }
        }
        return false;
      };
      var each_1_index2 = (ta2, cb) => {
        const length = ta2.length;
        if (length === 0) return;
        const view = new DataView(ta2.buffer, ta2.byteOffset);
        const chunks = length >>> 2;
        const remaining_start_index = chunks << 2;
        const remaining_length = length % 4;
        for (let i = 0; i < chunks; i++) {
          const value2 = view.getUint32(i << 2, false);
          let bit_index = fast_find_next_set_bit(value2, -1);
          while (bit_index !== false) {
            cb((i << 5) + bit_index);
            bit_index = fast_find_next_set_bit(value2, bit_index);
          }
        }
        for (let i = 0; i < remaining_length; i++) {
          const byte = view.getUint8(remaining_start_index + i);
          for (let bit = 0; bit < 8; bit++) {
            if (byte & 1 << 7 - bit) {
              const absolute_index = remaining_start_index * 8 + i * 8 + bit;
              cb(absolute_index);
            }
          }
        }
      };
      var pop_cnt = (n) => {
        n = n - (n >> 1 & 1431655765);
        n = (n & 858993459) + (n >> 2 & 858993459);
        n = n + (n >> 4) & 252645135;
        n = n + (n >> 8);
        n = n + (n >> 16);
        return n & 63;
      };
      var pop_cnt_typed_array = (typedArray, is_little_endian = true) => {
        let total_count = 0;
        const length = typedArray.length;
        if (length === 0) return total_count;
        const view = new DataView(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
        const chunks = length >>> 2;
        for (let i = 0; i < chunks; i++) {
          const value2 = view.getUint32(i << 2, is_little_endian);
          total_count += pop_cnt(value2);
        }
        const remaining_start_index = chunks << 2;
        const remaining_length = length - remaining_start_index;
        for (let i = 0; i < remaining_length; i++) {
          const byte = view.getUint8(remaining_start_index + i);
          total_count += (byte & 1) + (byte >> 1 & 1) + (byte >> 2 & 1) + (byte >> 3 & 1) + (byte >> 4 & 1) + (byte >> 5 & 1) + (byte >> 6 & 1) + (byte >> 7 & 1);
        }
        return total_count;
      };
      var count_1s2 = pop_cnt_typed_array;
      var BitwiseTester = class {
        constructor(ta2 = null) {
          if (ta2) {
            this.ta = ta2;
          } else {
            this.ta = new Uint8Array([0, 1, 1, 2, 3, 5, 8, 13]);
          }
        }
        // Testing shift_typed_array_right using string representation
        test_shift_typed_array_right() {
          const result = right_shift_32bit_with_carry2(this.ta);
          const binary_ta1 = to_binary_string(this.ta);
          const binary_ta2 = to_binary_string(result);
          const expected_shift = "0" + binary_ta1.slice(0, -1);
          if (expected_shift === binary_ta2) {
            return {
              passed: true,
              messages: ["Test Passed: The shift operation works correctly."]
            };
          } else {
            return {
              passed: false,
              messages: [`Test Failed: The shifted result does not match the expected output. Expected: ${expected_shift}, Got: ${binary_ta2}`]
            };
          }
        }
        // Testing xor_typed_arrays (unchanged for context)
        test_xor_typed_arrays() {
          const ta2 = new Uint8Array(this.ta.length).fill(1);
          const result = xor_typed_arrays2(this.ta, ta2);
          let resultBinary = "";
          for (const byte of result) {
            resultBinary += byte.toString(2).padStart(8, "0");
          }
          let expectedBinary = "";
          for (let i = 0; i < this.ta.length; i++) {
            expectedBinary += (this.ta[i] ^ ta2[i]).toString(2).padStart(8, "0");
          }
          const passed = resultBinary === expectedBinary;
          const messages = [];
          if (!passed) {
            messages.push("XOR test failed. Expected: " + expectedBinary + ", Got: " + resultBinary);
          } else {
          }
          return {
            passed,
            messages
          };
        }
        // Method to run all tests (unchanged for context)
        test() {
          const results = [];
          let count_passed = 0;
          let count_failed = 0;
          const shift_test_result = this.test_shift_typed_array_right();
          results.push(shift_test_result);
          if (shift_test_result.passed) count_passed++;
          else count_failed++;
          const xor_test_result = this.test_xor_typed_arrays();
          results.push(xor_test_result);
          if (xor_test_result.passed) count_passed++;
          else count_failed++;
          return {
            passed: count_failed === 0,
            count_passed,
            count_failed,
            results
          };
        }
      };
      if (__require.main === module) {
        const tester = new BitwiseTester();
        const test_res = tester.test();
        console.log("test_res", JSON.stringify(test_res, null, 2));
      }
      var get_ta_bits_that_differ_from_previous_as_1s2 = (ta_source2, bits_per_row, ta_dest = new ta_source2.constructor(ta_source2.length), copy_original_x0_values = false) => {
        const rshifted = right_shift_32bit_with_carry2(ta_source2);
        xor_typed_arrays2(ta_source2, rshifted, ta_dest);
        if (copy_original_x0_values) {
          copy_row_beginning_bits(ta_source2, bits_per_row, ta_dest);
        } else {
          set_row_beginning_bits_to_0(ta_dest);
        }
        return ta_dest;
      };
      var get_bit = (ta2, i) => ta2[i >> 3] >> 7 - (i & 7) & 1;
      module.exports = {
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        pop_cnt,
        pop_cnt_typed_array,
        copy_row_beginning_bits,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        get_bit,
        fast_find_next_set_ta_bit
      };
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/draw.js
  var require_draw = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math/draw.js"(exports, module) {
      var is_integer_typed_array = (obj2) => {
        if (ArrayBuffer.isView(obj2)) {
          return obj2 instanceof Int8Array || obj2 instanceof Uint8Array || obj2 instanceof Int16Array || obj2 instanceof Uint16Array || obj2 instanceof Int32Array || obj2 instanceof Uint32Array || obj2 instanceof BigInt64Array || obj2 instanceof BigUint64Array;
        }
        return false;
      };
      var ensure_polygon_is_ta = (polygon) => {
        if (is_integer_typed_array(polygon)) {
          if (polygon.length % 2 === 0) {
            return polygon;
          } else {
            throw "ta must have even number length, being [x, y] pairs";
          }
        } else {
          return new Uint32Array(polygon.flat());
        }
      };
      var draw_polygon_outline_to_ta_1bipp = (ta2, img_width, polygon) => {
        polygon = ensure_polygon_is_ta(polygon);
        const num_points = polygon.length >>> 1;
        let r = 0, x = polygon[r++], y = polygon[r++], next_x, next_y;
        let dx, dy, sx, sy, err, e2;
        const set_pixel_on = (x2, y2) => {
          const idx_bit = y2 * img_width + x2;
          const byte = idx_bit >> 3;
          const bit = idx_bit & 7;
          ta2[byte] |= 128 >> bit;
        };
        for (let p = 1; p < num_points; p++) {
          next_x = polygon[r++];
          next_y = polygon[r++];
          dx = Math.abs(next_x - x);
          dy = Math.abs(next_y - y);
          sx = x < next_x ? 1 : -1;
          sy = y < next_y ? 1 : -1;
          err = dx - dy;
          while (true) {
            set_pixel_on(x, y);
            if (x === next_x && y === next_y) {
              break;
            }
            e2 = 2 * err;
            if (e2 > -dy) {
              err -= dy;
              x += sx;
            }
            if (e2 < dx) {
              err += dx;
              y += sy;
            }
          }
          x = next_x;
          y = next_y;
        }
        next_x = polygon[0];
        next_y = polygon[1];
        dx = Math.abs(next_x - x);
        dy = Math.abs(next_y - y);
        sx = x < next_x ? 1 : -1;
        sy = y < next_y ? 1 : -1;
        err = dx - dy;
        while (true) {
          set_pixel_on(x, y);
          if (x === next_x && y === next_y) {
            break;
          }
          e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x += sx;
          }
          if (e2 < dx) {
            err += dx;
            y += sy;
          }
        }
        return ta2;
      };
      var remove_duplicates = (ta2) => {
        quicksort_points(ta2);
        const numRecords = ta2.length >>> 1;
        let uniqueCount = 0;
        let prev_x, prev_y;
        for (let i = 0; i < numRecords; i++) {
          const x = ta2[i * 2];
          const y = ta2[i * 2 + 1];
          if (i === 0 || x !== prev_x || y !== prev_y) {
            uniqueCount++;
            prev_x = x;
            prev_y = y;
          }
        }
        const result = new ta2.constructor(uniqueCount * 2);
        let index = 0;
        prev_x = prev_y = void 0;
        for (let i = 0; i < numRecords; i++) {
          const x = ta2[i * 2];
          const y = ta2[i * 2 + 1];
          if (i === 0 || x !== prev_x || y !== prev_y) {
            result[index * 2] = x;
            result[index * 2 + 1] = y;
            index++;
            prev_x = x;
            prev_y = y;
          }
        }
        return result;
      };
      var quicksort_points = (ta2) => {
        const partition = (left, right, pivotIndex) => {
          const pivotY = ta2[pivotIndex * 2 + 1];
          const pivotX = ta2[pivotIndex * 2];
          swap(pivotIndex, right);
          let storeIndex = left;
          for (let i = left; i < right; i++) {
            const currentY = ta2[i * 2 + 1];
            const currentX = ta2[i * 2];
            if (currentY < pivotY || currentY === pivotY && currentX < pivotX) {
              swap(i, storeIndex);
              storeIndex++;
            }
          }
          swap(storeIndex, right);
          return storeIndex;
        };
        const quicksort_recursive = (left, right) => {
          if (left < right) {
            const pivotIndex = Math.floor((left + right) / 2);
            const newPivot = partition(left, right, pivotIndex);
            quicksort_recursive(left, newPivot - 1);
            quicksort_recursive(newPivot + 1, right);
          }
        };
        const swap = (i, j) => {
          if (i === j) return;
          const tempX = ta2[i * 2];
          ta2[i * 2] = ta2[j * 2];
          ta2[j * 2] = tempX;
          const tempY = ta2[i * 2 + 1];
          ta2[i * 2 + 1] = ta2[j * 2 + 1];
          ta2[j * 2 + 1] = tempY;
        };
        const numRecords = ta2.length >>> 1;
        quicksort_recursive(0, numRecords - 1);
        return ta2;
      };
      var calc_polygon_stroke_points_x_y = (polygon) => {
        polygon = ensure_polygon_is_ta(polygon);
        const arr_stroke_points = [];
        const num_points = polygon.length >>> 1;
        let r = 0, x = polygon[r++], y = polygon[r++], next_x, next_y;
        let dx, dy, sx, sy, err, e2;
        let prev_x, prev_y;
        const set_pixel_on = (x2, y2) => {
          if (!(prev_x === x2 && prev_y === y2)) {
            arr_stroke_points.push(x2, y2);
          }
          prev_x = x2;
          prev_y = y2;
        };
        for (let p = 1; p < num_points; p++) {
          next_x = polygon[r++];
          next_y = polygon[r++];
          dx = Math.abs(next_x - x);
          dy = Math.abs(next_y - y);
          sx = x < next_x ? 1 : -1;
          sy = y < next_y ? 1 : -1;
          err = dx - dy;
          while (true) {
            set_pixel_on(x, y);
            if (x === next_x && y === next_y) {
              break;
            }
            e2 = 2 * err;
            if (e2 > -dy) {
              err -= dy;
              x += sx;
            }
            if (e2 < dx) {
              err += dx;
              y += sy;
            }
          }
          x = next_x;
          y = next_y;
        }
        next_x = polygon[0];
        next_y = polygon[1];
        dx = Math.abs(next_x - x);
        dy = Math.abs(next_y - y);
        sx = x < next_x ? 1 : -1;
        sy = y < next_y ? 1 : -1;
        err = dx - dy;
        while (true) {
          set_pixel_on(x, y);
          if (x === next_x && y === next_y) {
            break;
          }
          e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x += sx;
          }
          if (e2 < dx) {
            err += dx;
            y += sy;
          }
        }
        const res2 = remove_duplicates(quicksort_points(new Uint16Array(arr_stroke_points)));
        return res2;
      };
      module.exports = {
        ensure_polygon_is_ta,
        draw_polygon_outline_to_ta_1bipp,
        calc_polygon_stroke_points_x_y
      };
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math.js
  var require_ta_math = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/ta-math.js"(exports, module) {
      var copy = require_copy();
      var info = require_info();
      var read = require_read();
      var transform = require_transform();
      var write = require_write();
      var bitwise = require_bitwise();
      var {
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        get_bit,
        fast_find_next_set_ta_bit
      } = bitwise;
      var draw = require_draw();
      var { draw_polygon_outline_to_ta_1bipp, ensure_polygon_is_ta, calc_polygon_stroke_points_x_y } = draw;
      var {
        copy_rect_to_same_size_8bipp,
        copy_rect_to_same_size_24bipp,
        copy_ta_byte_range,
        unaligned_copy_rect_1to4bypp,
        dest_aligned_copy_rect_1to4bypp
      } = copy;
      var { overlapping_bounds } = info;
      var { fill_solid_rect_by_bounds } = write;
      var { read_1x2_rect, read_2x1_rect, read_2x2_rect, read_px } = read;
      var { resize_ta_colorspace } = transform;
      module.exports = {
        draw_polygon_outline_to_ta_1bipp,
        ensure_polygon_is_ta,
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        calc_polygon_stroke_points_x_y,
        get_bit,
        fast_find_next_set_ta_bit,
        draw,
        copy,
        info,
        read,
        transform,
        write,
        bitwise,
        overlapping_bounds,
        copy_rect_to_same_size_8bipp,
        copy_rect_to_same_size_24bipp,
        copy_ta_byte_range,
        unaligned_copy_rect_1to4bypp,
        dest_aligned_copy_rect_1to4bypp,
        fill_solid_rect_by_bounds,
        read_1x2_rect,
        read_2x1_rect,
        read_2x2_rect,
        read_px,
        read_pixel: read_px,
        resize_ta_colorspace
        //,
        //override: override,
        //get_instance: get_instance
      };
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-painter.js
  var require_pixel_buffer_painter = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-painter.js"(exports, module) {
      var ta_math2 = require_ta_math();
      var { fill_solid_rect_by_bounds } = ta_math2;
      var Pixel_Buffer_Painter = class {
        constructor(spec) {
          const pb = this.pb = spec.pb || spec.pixel_buffer;
          this.rect = (pos, size, color) => {
            const ta_bounds = new Int16Array(4);
            ta_bounds[0] = pos[0];
            ta_bounds[1] = pos[1];
            ta_bounds[2] = pos[0] + size[0];
            ta_bounds[3] = pos[1] + size[1];
            fill_solid_rect_by_bounds(pb.ta, pb.bypr, ta_bounds, pb.bipp, color);
            return this;
          };
        }
        //rect()
      };
      module.exports = Pixel_Buffer_Painter;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-0-core-inner-structures.js
  var require_pixel_buffer_0_core_inner_structures = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-0-core-inner-structures.js"(exports, module) {
      var lang = require_lib_lang_mini4();
      var {
        each,
        fp,
        tof,
        get_a_sig,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~/* @__PURE__ */ BigInt("0");
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Inner_Structures = class _Pixel_Buffer_Core_Inner_Structures {
        constructor(spec) {
          if (spec instanceof _Pixel_Buffer_Core_Inner_Structures) {
            spec = {
              bits_per_pixel: spec.bits_per_pixel,
              size: spec.size,
              ta: spec.ta
            };
          }
          if (spec.window_to) {
            spec.bits_per_pixel = spec.window_to.bits_per_pixel;
          }
          const pos = new Int16Array(2);
          const size = new Int16Array(2);
          let ta2;
          ro(this, "ta", () => {
            return ta2;
          });
          ro(this, "buffer", () => {
            return ta2;
          });
          const ta_bpp = new Uint8Array(2);
          ta_bpp[1] = 8;
          const _24bipp_to_8bipp = () => {
            const old_ta = ta2;
            const new_ta = ta2 = new Uint8Array(this.num_px);
            const l_read = old_ta.length;
            let iby_read = 0, iby_write = 0;
            while (iby_read < l_read) {
              new_ta[iby_write++] = Math.round((old_ta[iby_read++] + old_ta[iby_read++] + old_ta[iby_read++]) / 3);
            }
          };
          const _change_bipp_inner_update = (old_bipp, new_bipp) => {
            if (old_bipp === 24) {
              if (new_bipp === 8) {
                _24bipp_to_8bipp();
              } else {
                console.trace();
                throw "NYI";
              }
            } else {
              console.trace();
              throw "NYI";
            }
          };
          const def_bipp = {
            get() {
              return ta_bpp[0];
            },
            set(value2) {
              console.log("value", value2);
              const old_bipp = ta_bpp[0];
              ta_bpp[0] = value2;
              _change_bipp_inner_update(old_bipp, ta_bpp[0]);
            },
            enumerable: true,
            configurable: false
          };
          Object.defineProperty(this, "bits_per_pixel", def_bipp);
          Object.defineProperty(this, "bipp", def_bipp);
          const def_bypp = {
            get() {
              return ta_bpp[0] / 8;
            },
            set(value2) {
              const old_bipp = ta_bpp[0];
              ta_bpp[0] = value2 * 8;
              _change_bipp_inner_update(old_bipp, ta_bpp[0]);
            },
            enumerable: true,
            configurable: false
          };
          Object.defineProperty(this, "bytes_per_pixel", def_bypp);
          Object.defineProperty(this, "bypp", def_bypp);
          const def_bypr = {
            get() {
              return size[0] * ta_bpp[0] / 8;
            }
          };
          Object.defineProperty(this, "bytes_per_row", def_bypr);
          Object.defineProperty(this, "bypr", def_bypr);
          Object.defineProperty(this, "pos", {
            get() {
              return pos;
            },
            set(value2) {
              if (value2 instanceof Int16Array) {
                if (value2.length === 2) {
                  pos[0] = value2[0];
                  pos[1] = value2[1];
                }
              }
            },
            enumerable: true,
            configurable: false
          });
          const pos_bounds2 = new Int16Array(4);
          const pos_center = new Int16Array(2);
          const edge_offsets_from_center = new Int16Array(4);
          ro(this, "pos_center", () => pos_center);
          ro(this, "edge_offsets_from_center", () => edge_offsets_from_center);
          Object.defineProperty(this, "pos_bounds", {
            get() {
              return pos_bounds2;
            },
            set(value2) {
              const tv = tf2(value2);
              if (tv === "a") {
                if (value2.length === 4) {
                  pos_bounds2.set(value2);
                } else {
                  throw "Expected Array with .length 4, value.length: " + value2.length;
                }
              } else {
                console.trace();
                console.log("pos_bounds set tv", tv);
                throw "Expected Array";
              }
            },
            enumerable: true,
            configurable: false
          });
          const minus_pos = new Int16Array(2);
          Object.defineProperty(this, "minus_pos", {
            get() {
              if (pos) {
                minus_pos[0] = pos[0] * -1;
                minus_pos[1] = pos[1] * -1;
                return minus_pos;
              }
            },
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(this, "size", {
            get() {
              return size;
            },
            set(value2) {
              if (value2 instanceof Int16Array) {
                if (value2.length === 2) {
                  size[0] = value2[0];
                  size[1] = value2[1];
                }
              } else {
                console.trace();
                throw "NYI";
              }
            },
            enumerable: true,
            configurable: false
          });
          if (spec instanceof Pixel_Pos_List) {
            throw "NYI - change to 1bipp";
            const ppl = spec;
            const bounds2 = ppl.bounds;
            const ppl_size = new Uint16Array(2);
            ppl_size[0] = bounds2[2] - bounds2[0];
            ppl_size[1] = bounds2[3] - bounds2[1];
            this.bits_per_pixel = 8;
            const bpp = this.bytes_per_pixel = 1;
            this.size = new Uint16Array([ppl_size[0] + 4, ppl_size[1] + 4]);
            this.pos = new Int16Array([bounds2[0], bounds2[1]]);
            const bpr = this.bytes_per_row = bpp * this.size[0];
            const buf = this.ta = this.buffer = new Uint8ClampedArray(this.size[0] * this.size[1]);
            const l2 = buf.length;
            for (var c2 = 0; c2 < l2; c2++) buf[c2] = 255;
            ppl.each_pixel((pixel_pos) => {
              buf[bpr * (pixel_pos[1] - bounds2[1]) + (pixel_pos[0] - bounds2[0])] = 0;
            });
          } else {
            if (spec.buffer) {
              if (spec.buffer instanceof Buffer) {
                ta2 = new Uint8ClampedArray(spec.buffer.buffer);
              } else {
                ta2 = spec.buffer;
              }
            }
            if (spec.ta) {
              ta2 = spec.ta;
            }
            if (spec.size) {
              size[0] = spec.size[0];
              size[1] = spec.size[1];
            } else {
              throw "Expected: size [x, y] property in the Pixel_Buffer_Core specification";
            }
            if (spec.bytes_per_pixel && !spec.bits_per_pixel) spec.bits_per_pixel = spec.bytes_per_pixel * 8;
            spec.bits_per_pixel = spec.bits_per_pixel || 32;
            if (spec.bits_per_pixel) {
              if (spec.bits_per_pixel != 1 && spec.bits_per_pixel != 8 && spec.bits_per_pixel != 24 && spec.bits_per_pixel != 32) {
                console.log("spec.bits_per_pixel", spec.bits_per_pixel);
                console.trace();
                throw "Invalid bits_per_pixel value of " + spec.bits_per_pixel + ", must be 8, 24 or 32, default is 32.";
              } else {
                ta_bpp[0] = spec.bits_per_pixel;
              }
            }
            let auto_adjust_ta_length_to_multiple_of_8 = true;
            if (size && !this.buffer) {
              this.bits_per_row = size[0] * this.bits_per_pixel;
              let proposed_ta_length = Math.ceil(ta_bpp[0] / 8 * (size[0] * size[1]));
              if (auto_adjust_ta_length_to_multiple_of_8) {
                const r8 = proposed_ta_length % 8;
                if (r8 > 0) {
                  proposed_ta_length += 8 - r8;
                }
              }
              ta2 = new Uint8Array(proposed_ta_length);
            }
            if (spec.color) {
              this.color_whole(spec.color);
            }
          }
          ro(this, "meta", () => {
            return {
              size: this.size,
              bits_per_pixel: this.bits_per_pixel,
              bytes_per_pixel: this.bytes_per_pixel,
              bytes_per_row: this.bytes_per_row
            };
          });
          if (spec.window_to || spec.source || spec.window_to_source) {
            pb_source = spec.window_to || spec.source || spec.window_to_source;
            const log_info = () => {
              console.log("Pixel_Buffer_Core (or subclass) needs to act as a window to another Pixel Buffer.");
              console.log("pb_source", pb_source);
              console.log("pb_source.size", pb_source.size);
              console.log("spec.pos", spec.pos);
              console.log("spec.pos_center", spec.pos_center);
              console.log("this.pos", this.pos);
              console.log("this.pos_my_center_within_source", this.pos_my_center_within_source);
              console.log("spec", spec);
            };
          }
          if (spec.pos_bounds) {
            this.pos_bounds = spec.pos_bounds;
          }
          this.move = (ta_2d_vector) => {
            pos[0] += ta_2d_vector[0];
            pos[1] += ta_2d_vector[1];
            if (this.source) {
              this.copy_from_source();
            }
          };
          this.each_pos_within_bounds = (callback2) => {
            const has_source = !!this.source;
            for (pos[1] = pos_bounds2[1]; pos[1] < pos_bounds2[3]; pos[1]++) {
              for (pos[0] = pos_bounds2[0]; pos[0] < pos_bounds2[2]; pos[0]++) {
                if (has_source) this.copy_from_source();
                callback2();
              }
            }
          };
          this.move_next_px = () => {
            const source_size = this.source.size;
            if (pos[0] + size[0] < source_size[0]) {
              pos[0]++;
            } else {
              if (pos[1] + size[1] < source_size[1]) {
                pos[0] = 0;
                pos[1]++;
              } else {
                return false;
              }
            }
            if (this.source) {
              this.copy_from_source();
            }
            return pos;
          };
          this.tabrw = new Typed_Array_Binary_Read_Write(ta2);
          this.dv = this.tabrw.dv;
        }
        toString() {
          return JSON.stringify({
            buffer: "Uint8ClampedArray length " + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
          });
        }
        /*
        [inspect]() {
            return 'Pixel_Buffer_Core ' + this.toString();
        }
        */
        each_pixel_byte_index(cb) {
          const { bipp } = this;
          let ctu = true;
          const stop = () => ctu = false;
          const [w, h] = this.size;
          const num_pixels = w * h;
          let bit_idx = 0, byte_idx = bit_idx >> 3;
          for (let c2 = 0; c2 < num_pixels; c2++) {
            byte_idx = bit_idx >> 3;
            bc(byte_idx);
          }
        }
        each_px(callback2) {
          const ta_pos = new Int32Array(2);
          const [w, h] = this.size;
          let index = 0;
          for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
              const color = this.get_pixel(ta_pos);
              callback2(ta_pos, color, index++);
            }
          }
        }
        paint_pixel_list(pixel_pos_list, color) {
          pixel_pos_list.each_pixel((pos) => {
            this.set_pixel_ta(pos, color);
          });
        }
        // Maybe a class level that has get and set pixel logic for the different bipps at this level.
        get num_px() {
          return this.size[0] * this.size[1];
        }
        get split_rgb_channels() {
          const [bipp, bypp2] = [this.bits_per_pixel, this.bytes_per_pixel];
          if (bipp === 24 || bipp === 32) {
            const res2 = [new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            })];
            const [r, g, b] = res2;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta2 = this.ta;
            while (i_px < num_px) {
              ta_r[i_px] = ta2[i_byte];
              ta_g[i_px] = ta2[i_byte + 1];
              ta_b[i_px] = ta2[i_byte + 2];
              i_px++;
              i_byte += bypp2;
            }
            return res2;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        process(fn) {
          let res2 = this.clone();
          return fn(this, res2);
        }
        /*
            function typedArraysAreEqual(a, b) {
        if (a.byteLength !== b.byteLength) return false;
        return a.every((val, i) => val === b[i]);
        }
            */
        equals(other_pixel_buffer) {
          let buf1 = this.ta;
          let buf2 = other_pixel_buffer.ta;
          const other_colorspace = other_pixel_buffer.ta_colorspace;
          const my_colorspace = other_pixel_buffer.ta_colorspace;
          if (my_colorspace.length === other_colorspace.length) {
            if (my_colorspace.every((val, i) => val === other_colorspace[i])) {
              if (buf1.length === buf2.length) {
                return buf1.every((val, i) => val === buf2[i]);
              } else {
              }
            } else {
            }
          }
          return false;
        }
        copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
          let bounds2 = pixel_pos_list.bounds;
          let size = new Uint16Array([bounds2[2] - bounds2[0] + 1, bounds2[3] - bounds2[1] + 1]);
          const res2 = new this.constructor({
            size,
            bytes_per_pixel: this.bytes_per_pixel
          });
          if (this.pos) res2.pos = this.pos;
          if (bg_color) {
            res2.color_whole(bg_color);
          }
          res2.pos = new Int16Array([bounds2[0], bounds2[1]]);
          pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([pos[0] - bounds2[0], pos[1] - bounds2[1]]);
            res2.set_pixel_ta(target_pos, color);
          });
          return res2;
        }
        "blank_copy"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel
          });
          res2.buffer.fill(0);
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "clone"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel,
            "buffer": new this.buffer.constructor(this.buffer)
          });
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "add_alpha_channel"() {
          console.log("add_alpha_channel this.bytes_per_pixel", this.bytes_per_pixel);
          if (this.bytes_per_pixel === 3) {
            var res2 = new this.constructor({
              "size": this.size,
              "bytes_per_pixel": 4
            });
            if (this.pos) res2.pos = this.pos;
            const buf = this.buffer, res_buf = res2.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0, ir = 0;
            for (let p = 0; p < px_count; p++) {
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = 255;
            }
            return res2;
          }
          if (this.bytes_per_pixel === 4) {
            return this;
          }
        }
      };
      module.exports = Pixel_Buffer_Core_Inner_Structures;
      if (__require.main === module) {
        const lg = console.log;
        (async () => {
          const run_examples = async () => {
            lg("Begin run examples");
            const examples = [
              async () => {
                lg("Begin example 0");
                const pb = new Pixel_Buffer_Core_Reference_Implementations({
                  bits_per_pixel: 1,
                  size: [8, 8]
                });
                const ta_pos = new Int16Array(2);
                ta_pos[0] = 3;
                ta_pos[1] = 3;
                pb.set_pixel(ta_pos, 1);
                lg("End example 0");
                return pb;
              }
            ];
            const l2 = examples.length;
            for (var c2 = 0; c2 < l2; c2++) {
              const res_eg = await examples[c2]();
              console.log("res_eg " + c2 + ":", res_eg);
            }
            ;
            lg("End run examples");
          };
          await run_examples();
        })();
      }
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-1-core-get-set-pixel.js
  var require_pixel_buffer_1_core_get_set_pixel = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-1-core-get-set-pixel.js"(exports, module) {
      var lang = require_lib_lang_mini4();
      var {
        each,
        fp,
        tof,
        get_a_sig,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~/* @__PURE__ */ BigInt("0");
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var Pixel_Buffer_Painter = require_pixel_buffer_painter();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Inner_Structures = require_pixel_buffer_0_core_inner_structures();
      var Pixel_Buffer_Core_Get_Set_Pixels = class _Pixel_Buffer_Core_Get_Set_Pixels extends Pixel_Buffer_Core_Inner_Structures {
        constructor(spec) {
          if (spec instanceof _Pixel_Buffer_Core_Get_Set_Pixels) {
            spec = {
              bits_per_pixel: spec.bits_per_pixel,
              size: spec.size,
              ta: spec.ta
            };
          }
          super(spec);
        }
        "get_pixel_byte_bit_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          const bit = idx & 7;
          return { byte, bit };
        }
        "get_pixel_byte_bit_BE_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          const bit = idx & 7;
          return { byte, bit };
        }
        set_pixel_on_1bipp_by_pixel_index(pixel_index) {
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        "set_pixel_on_1bipp_xy"(x, y) {
          const pixel_index = y * this.size[0] + x;
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        "set_pixel_on_1bipp"(pos) {
          const pixel_index = pos[1] * this.size[0] + pos[0];
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        set_pixel_off_1bipp_by_pixel_index(pixel_index) {
          this.ta[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
        }
        "set_pixel_off_1bipp"(pos) {
          const pixel_idx = pos[1] * this.size[0] + pos[0];
          this.ta[pixel_idx >> 3] &= ~(128 >> (pixel_idx & 7)) & 255;
        }
        "set_pixel_1bipp"(pos, color) {
          const idx_bit = pos[1] * this.size[0] + pos[0];
          const byte = idx_bit >> 3;
          const bit = idx_bit & 7;
          if (color === 1) {
            this.ta[byte] |= 128 >> bit;
          } else {
            this.ta[byte] &= ~(128 >> bit) & 255;
          }
        }
        "set_pixel_8bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          this.ta[idx] = color;
        }
        "set_pixel_24bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          let byte = idx * 3;
          this.ta[byte++] = color[0];
          this.ta[byte++] = color[1];
          this.ta[byte] = color[2];
        }
        "set_pixel_32bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          let byte = idx * 4;
          this.ta[byte++] = color[0];
          this.ta[byte++] = color[1];
          this.ta[byte++] = color[2];
          this.ta[byte] = color[3];
        }
        "set_pixel_by_idx_8bipp"(idx, color) {
          const byte = idx;
          this.ta[byte] = color;
        }
        "set_pixel_by_idx_24bipp"(idx, color) {
          const byte = idx * 3;
          this.ta[byte] = color[0];
          this.ta[byte + 1] = color[1];
          this.ta[byte + 2] = color[2];
        }
        "set_pixel_by_idx_32bipp"(idx, color) {
          const byte = idx * 4;
          this.ta[byte] = color[0];
          this.ta[byte + 1] = color[1];
          this.ta[byte + 2] = color[2];
          this.ta[byte + 3] = color[3];
        }
        "set_pixel_by_idx"(idx, color) {
          const a = arguments;
          const l2 = a.length;
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.set_pixel_by_idx_1bipp(a[0], a[1]);
          } else if (bipp === 8) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_8bipp(a[0], a[1]);
            }
          } else if (bipp === 24) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_24bipp(a[0], a[1]);
            }
          } else if (bipp === 32) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_32bipp(a[0], a[1]);
            }
          }
        }
        "set_pixel"(pos, color) {
          const a = arguments;
          const l2 = a.length;
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.set_pixel_1bipp(a[0], a[1]);
          } else if (bipp === 8) {
            if (l2 === 2) {
              return this.set_pixel_8bipp(a[0], a[1]);
            }
          } else if (bipp === 24) {
            if (l2 === 2) {
              return this.set_pixel_24bipp(a[0], a[1]);
            }
          } else if (bipp === 32) {
            if (l2 === 2) {
              return this.set_pixel_32bipp(a[0], a[1]);
            }
          } else {
            console.trace();
            throw "unsupported bipp: " + bipp;
          }
        }
        "get_pixel_by_idx_1bipp"(idx) {
          const byte = idx >> 3;
          const bit = idx & 7;
          const pow = 128 >> bit;
          return (this.ta[byte] & pow) === pow ? 1 : 0;
        }
        "get_pixel_by_idx_8bipp"(idx) {
          const byte = idx;
          return this.ta[byte];
        }
        "get_pixel_by_idx_24bipp"(idx) {
          const byte = idx * 3;
          return this.ta.slice(byte, byte + 3);
        }
        "get_pixel_by_idx_32bipp"(idx) {
          const byte = idx * 4;
          return this.ta.slice(byte, byte + 4);
        }
        "get_pixel_by_idx"(idx) {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            return this.get_pixel_by_idx_1bipp(idx);
          } else if (bipp === 8) {
            return this.get_pixel_by_idx_8bipp(idx);
          } else if (bipp === 24) {
            return this.get_pixel_by_idx_24bipp(idx);
          } else if (bipp === 32) {
            return this.get_pixel_by_idx_32bipp(idx);
          } else {
            throw "Unsupported bipp";
          }
        }
        "get_pixel_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          return (this.ta[byte] & 128 >> (idx & 7)) !== 0 ? 1 : 0;
        }
        "get_pixel_8bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx;
          return this.ta[byte];
        }
        "get_pixel_24bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx * 3;
          return this.ta.slice(byte, byte + 3);
        }
        "get_pixel_32bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx * 4;
          return this.ta.slice(byte, byte + 4);
        }
        "get_pixel"(pos) {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            return this.get_pixel_1bipp(pos);
          } else if (bipp === 8) {
            return this.get_pixel_8bipp(pos);
          } else if (bipp === 24) {
            return this.get_pixel_24bipp(pos);
          } else if (bipp === 32) {
            return this.get_pixel_32bipp(pos);
          } else {
            console.trace();
            throw "bits per pixels error";
          }
        }
        // Maybe a class level that has get and set pixel logic for the different bipps at this level.
      };
      module.exports = Pixel_Buffer_Core_Get_Set_Pixels;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-1.1-core-draw-line.js
  var require_pixel_buffer_1_1_core_draw_line = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-1.1-core-draw-line.js"(exports, module) {
      var lang = require_lib_lang_mini4();
      var {
        each,
        fp,
        tof,
        get_a_sig,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~/* @__PURE__ */ BigInt("0");
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var Pixel_Buffer_Painter = require_pixel_buffer_painter();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Get_Set_Pixels = require_pixel_buffer_1_core_get_set_pixel();
      var Pixel_Buffer_Core_Draw_Lines = class extends Pixel_Buffer_Core_Get_Set_Pixels {
        constructor(spec) {
          super(spec);
        }
        "draw_line"(pos1, pos2, color) {
          if (this.bits_per_pixel === 1) {
            let x0 = pos1[0];
            let y0 = pos1[1];
            let x1 = pos2[0];
            let y1 = pos2[1];
            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
            let sx = x0 < x1 ? 1 : -1;
            let sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            while (true) {
              this.set_pixel_1bipp([x0, y0], color);
              if (x0 === x1 && y0 === y1) {
                break;
              }
              let e2 = 2 * err;
              if (e2 > -dy) {
                err -= dy;
                x0 += sx;
              }
              if (e2 < dx) {
                err += dx;
                y0 += sy;
              }
            }
          } else {
            let x0 = pos1[0];
            let y0 = pos1[1];
            let x1 = pos2[0];
            let y1 = pos2[1];
            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
            let sx = x0 < x1 ? 1 : -1;
            let sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            while (true) {
              this.set_pixel([x0, y0], color);
              if (x0 === x1 && y0 === y1) {
                break;
              }
              let e2 = 2 * err;
              if (e2 > -dy) {
                err -= dy;
                x0 += sx;
              }
              if (e2 < dx) {
                err += dx;
                y0 += sy;
              }
            }
          }
        }
        draw_line_1bipp(ta_pixel_pair, color) {
          const { ta: ta2 } = this;
          let [x0, y0, x1, y1] = ta_pixel_pair, bytes_per_row = this.bytes_per_row, dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0), sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1, err = dx - dy, e2;
          while (true) {
            const byte_index = (x0 >> 3) + y0 * bytes_per_row, bit_position = x0 & 7;
            if (color) {
              ta2[byte_index] |= 1 << 7 - bit_position;
            } else {
              ta2[byte_index] &= ~(1 << 7 - bit_position);
            }
            if (x0 === x1 && y0 === y1) break;
            e2 = err << 1;
            if (e2 > -dy) err -= dy, x0 += sx;
            if (e2 < dx) err += dx, y0 += sy;
          }
        }
        "draw_horizontal_line_off_1bipp_inclusive"([x1, x2], y) {
          const { size, ta: ta2 } = this;
          const number_of_pixels_to_draw = x2 - x1 + 1;
          if (number_of_pixels_to_draw === 1) {
            const pixel_index = y * size[0] + x1;
            ta2[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
          } else if (number_of_pixels_to_draw === 2) {
            let pixel_index = y * size[0] + x1;
            ta2[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
            pixel_index++;
            ta2[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
            pixel_index++;
          } else {
            const [w] = size;
            const starting_pixel_index = y * w + x1 | 0;
            const ending_pixel_index = starting_pixel_index + (number_of_pixels_to_draw - 1);
            const starting_byte_index = starting_pixel_index >> 3;
            const starting_bit_within_byte_index = starting_pixel_index & 7;
            const ending_byte_index = ending_pixel_index >> 3;
            const ending_bit_within_byte_index = ending_pixel_index & 7;
            const bits_from_end_of_byte = 7 - ending_bit_within_byte_index;
            const number_of_bytes_with_any_coverage = ending_byte_index - starting_byte_index + 1;
            if (starting_byte_index === ending_byte_index) {
              ta2[starting_byte_index] &= ~((255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index >> bits_from_end_of_byte << bits_from_end_of_byte) & 255;
            } else if (number_of_bytes_with_any_coverage === 2) {
              ta2[starting_byte_index] &= ~((255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index) & 255;
              ta2[ending_byte_index] &= ~(255 >> bits_from_end_of_byte << bits_from_end_of_byte) & 255;
            } else {
              ta2[starting_byte_index] &= ~((255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index) & 255;
              for (let x = starting_byte_index + 1; x < ending_byte_index; x++) {
                ta2[x] = 0;
              }
              ta2[ending_byte_index] &= ~(255 >> bits_from_end_of_byte << bits_from_end_of_byte) & 255;
            }
          }
        }
        draw_x_span_on_1bipp(x, y, l2) {
          const x2 = x + l2;
          for (let ix = x; ix < x2; ix++) {
            this.set_pixel_on_1bipp_xy(ix, y);
          }
        }
        // May do more lower level / general purpose work on line drawing....
        "draw_horizontal_line_on_1bipp_inclusive"([x1, x2], y) {
          const { size, ta: ta2 } = this;
          const number_of_pixels_to_draw = x2 - x1 + 1;
          if (number_of_pixels_to_draw === 1) {
            const pixel_index = y * size[0] + x1;
            ta2[pixel_index >> 3] |= 128 >> (pixel_index & 7);
          } else if (number_of_pixels_to_draw === 2) {
            let pixel_index = y * size[0] + x1;
            ta2[pixel_index >> 3] |= 128 >> (pixel_index & 7);
            pixel_index++;
            ta2[pixel_index >> 3] |= 128 >> (pixel_index & 7);
            pixel_index++;
          } else {
            const [w, h] = size;
            const starting_pixel_index = y * w + x1 | 0;
            const ending_pixel_index = starting_pixel_index + (number_of_pixels_to_draw - 1);
            const starting_byte_index = starting_pixel_index >> 3;
            const starting_bit_within_byte_index = starting_pixel_index & 7;
            const ending_byte_index = ending_pixel_index >> 3;
            const ending_bit_within_byte_index = ending_pixel_index & 7;
            const bits_from_end_of_byte = 7 - ending_bit_within_byte_index;
            if (starting_byte_index === ending_byte_index) {
              ta2[starting_byte_index] |= (255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index >> bits_from_end_of_byte << bits_from_end_of_byte;
            } else {
              ta2[starting_byte_index] |= (255 << starting_bit_within_byte_index & 255) >> starting_bit_within_byte_index;
              for (let x = starting_byte_index + 1; x < ending_byte_index; x++) {
                ta2[x] = 255;
              }
              ta2[ending_byte_index] |= 255 >> bits_from_end_of_byte << bits_from_end_of_byte;
            }
          }
        }
        "draw_horizontal_line_8bipp"(xspan, y, color) {
          const [x1, x2] = xspan;
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          let w = start_pixel_idx;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = color;
          }
        }
        "draw_horizontal_line_24bipp"(xspan, y, color) {
          const [x1, x2] = xspan;
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          const [r, g, b] = color;
          let w = start_pixel_idx * 3;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
          }
        }
        "draw_horizontal_line_32bipp"(xspan, y, color) {
          const [x1, x2] = xspan;
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          const [r, g, b, a] = color;
          let w = start_pixel_idx * 4;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
            ta2[w++] = a;
          }
        }
        "draw_horizontal_line"(xspan, y, color) {
          const { bipp } = this;
          if (bipp === 1) {
            if (color === 1) {
              return this.draw_horizontal_line_on_1bipp_inclusive(xspan, y);
            } else {
              return this.draw_horizontal_line_off_1bipp_inclusive(xspan, y);
            }
          } else if (bipp === 8) {
            return this.draw_horizontal_line_8bipp(xspan, y, color);
          } else if (bipp === 24) {
            return this.draw_horizontal_line_24bipp(xspan, y, color);
          } else if (bipp === 32) {
            return this.draw_horizontal_line_32bipp(xspan, y, color);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        "draw_horizontal_line_y_x1_x2"(y, x1, x2, color, pre_populated_array, populate_array) {
          const { bipp } = this;
          if (bipp === 1) {
            if (color === 1) {
              return this.draw_horizontal_line_on_1bipp_inclusive_y_x1_x2(y, x1, x2);
            } else {
              return this.draw_horizontal_line_off_1bipp_inclusive_y_x1_x2(y, x1, x2);
            }
          } else if (bipp === 8) {
            return this.draw_horizontal_line_8bipp_y_x1_x2(y, x1, x2, color);
          } else if (bipp === 24) {
            return this.draw_horizontal_line_24bipp_y_x1_x2(y, x1, x2, color, pre_populated_array, populate_array);
          } else if (bipp === 32) {
            return this.draw_horizontal_line_32bipp_y_x1_x2(y, x1, x2, color);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        "draw_horizontal_line_8bipp_y_x1_x2"(y, x1, x2, color) {
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          let w = start_pixel_idx;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = color;
          }
        }
        "_draw_horizontal_line_24bipp_y_x1_x2"(y, x1, x2, color) {
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          const [r, g, b] = color;
          let w = start_pixel_idx * 3;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
          }
        }
        "draw_horizontal_line_24bipp_y_x1_x2"(y, x1, x2, color, pre_populated_array = null, populate_array = true) {
          const { ta: ta2 } = this;
          const [width, height2] = this.size;
          if (y < 0 || y >= height2 || x1 < 0 || x2 >= width || x1 > x2) {
            throw new Error("Coordinates out of bounds");
          }
          const start_pixel_idx = width * y + x1;
          const [r, g, b] = color;
          const pixel_count = x2 - x1 + 1;
          if (pixel_count < 8) {
            let w2 = start_pixel_idx * 3;
            for (let x = x1; x <= x2; x++) {
              ta2[w2++] = r;
              ta2[w2++] = g;
              ta2[w2++] = b;
            }
            return;
          }
          if (!pre_populated_array) {
            pre_populated_array = new Uint8Array(96 * 3);
          }
          if (populate_array) {
            for (let i = 0; i < pre_populated_array.length; i += 3) {
              pre_populated_array[i] = r;
              pre_populated_array[i + 1] = g;
              pre_populated_array[i + 2] = b;
            }
          }
          let w = start_pixel_idx * 3;
          const ppal = pre_populated_array.length;
          const chunk_size = ppal / 3;
          let remaining_pixels = pixel_count;
          while (remaining_pixels >= chunk_size) {
            ta2.set(pre_populated_array, w);
            w += ppal;
            remaining_pixels -= chunk_size;
          }
          for (let i = 0; i < remaining_pixels; i++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
          }
        }
        "draw_horizontal_line_32bipp_y_x1_x2"(y, x1, x2, color) {
          const { ta: ta2 } = this;
          const [width] = this.size;
          const start_pixel_idx = width * y + x1;
          const [r, g, b, a] = color;
          let w = start_pixel_idx * 4;
          for (let x = x1; x <= x2; x++) {
            ta2[w++] = r;
            ta2[w++] = g;
            ta2[w++] = b;
            ta2[w++] = a;
          }
        }
      };
      module.exports = Pixel_Buffer_Core_Draw_Lines;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/is_debug.js
  var require_is_debug = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/is_debug.js"(exports, module) {
      module.exports = false;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/TA_Table_8_Columns.js
  var require_TA_Table_8_Columns = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/TA_Table_8_Columns.js"(exports, module) {
      var TA_Table_8_Columns = class {
        constructor(row_count) {
          this.row_size = 8;
          this.row_count = row_count;
          this.ta = new Float32Array(this.row_size * this.row_count);
          const sorted_indices = this.sorted_indices = new Uint32Array(this.row_count);
          for (let i = 0; i < row_count; i++) {
            sorted_indices[i] = i;
          }
        }
        get(row, col) {
          return this.ta[(row << 3) + col];
        }
        set(row, col, value2) {
          this.ta[(row << 3) + col] = value2;
        }
        sort_indices(comparator) {
          this.sorted_indices.sort((a, b) => comparator(a, b, this));
        }
      };
      module.exports = TA_Table_8_Columns;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Polygon_Edges.js
  var require_Polygon_Edges = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Polygon_Edges.js"(exports, module) {
      var DEBUG = require_is_debug();
      var TA_Table_8_Columns = require_TA_Table_8_Columns();
      var Polygon_Edges = class extends TA_Table_8_Columns {
        constructor(polygon) {
          const ptap = polygon.ta_points;
          const num_points = ptap.length >> 1;
          let num_edges = 0;
          for (let i = 0; i < num_points; i++) {
            const y1 = ptap[(i << 1) + 1];
            const y2 = ptap[((i + 1) % num_points << 1) + 1];
            if (y1 !== y2 || y1 === y2) {
              num_edges++;
            }
          }
          super(num_edges);
          this.sorted_indices = new Uint32Array(num_edges);
          this.populate_edges(polygon);
          this.sort_by_y1_then_x1();
        }
        populate_edges(polygon) {
          const ptap = polygon.ta_points;
          const num_points = ptap.length >> 1;
          const { sorted_indices } = this;
          let row = 0;
          for (let i = 0; i < num_points; i++) {
            const ix2 = i << 1;
            const indx2 = (i + 1) % num_points << 1;
            const x1 = ptap[ix2];
            const y1 = ptap[ix2 + 1];
            const x2 = ptap[indx2];
            const y2 = ptap[indx2 + 1];
            if (y1 !== y2 || y1 === y2) {
              const is_horizontal = y1 === y2 ? 1 : 0;
              this.set(row, 0, y1 < y2 ? x1 : x2);
              this.set(row, 1, Math.min(y1, y2));
              this.set(row, 2, y1 < y2 ? x2 : x1);
              this.set(row, 3, Math.max(y1, y2));
              this.set(row, 4, y1 !== y2 ? (x2 - x1) / (y2 - y1) : 0);
              this.set(row, 5, is_horizontal);
              sorted_indices[row] = row;
              row++;
            }
          }
          if (DEBUG) {
            console.log("Edges populated:", Array.from({ length: this.row_count }, (_, i) => ({
              x1: this.get(i, 0),
              y1: this.get(i, 1),
              x2: this.get(i, 2),
              y2: this.get(i, 3),
              slope: this.get(i, 4),
              is_horizontal: this.get(i, 5)
            })));
          }
        }
        sort_by_y1_then_x1() {
          this.sorted_indices.sort((a, b) => {
            const y1A = this.get(a, 1);
            const y1B = this.get(b, 1);
            if (y1A !== y1B) return y1A - y1B;
            const x1A = this.get(a, 0);
            const x1B = this.get(b, 0);
            return x1A - x1B;
          });
          if (DEBUG) {
            console.log(
              "Sorted edges by y1, then x1:",
              this.sorted_indices.map((index) => ({
                x1: this.get(index, 0),
                y1: this.get(index, 1),
                x2: this.get(index, 2),
                y2: this.get(index, 3),
                slope: this.get(index, 4),
                is_horizontal: this.get(index, 5)
              }))
            );
          }
        }
      };
      module.exports = Polygon_Edges;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Polygon_Scanline_Edges.js
  var require_Polygon_Scanline_Edges = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Polygon_Scanline_Edges.js"(exports, module) {
      var DEBUG = require_is_debug();
      var Polygon_Edges = require_Polygon_Edges();
      var Scanline_Polygon_Edges = class extends Polygon_Edges {
        constructor(polygon, options = {}) {
          super(polygon);
          this.active_edges = new Uint32Array(this.row_count);
          this.num_active_edges = 0;
          this.allow_horizontal_edges = options.allow_horizontal_edges || false;
        }
        update_active_edges(scanline_y) {
          let write_index = 0;
          const { active_edges, sorted_indices } = this;
          for (let i = 0; i < this.num_active_edges; i++) {
            const edge_index = active_edges[i];
            const y2 = this.get(edge_index, 3);
            if (scanline_y < y2 || this.allow_horizontal_edges && scanline_y === y2) {
              active_edges[write_index++] = edge_index;
            } else if (DEBUG) {
              console.log(`Edge ${edge_index} removed (scanline_y=${scanline_y}, y2=${y2})`);
            }
          }
          this.num_active_edges = write_index;
          const sil = sorted_indices.length;
          for (let i = 0; i < sil; i++) {
            const edge_index = sorted_indices[i];
            const y1 = this.get(edge_index, 1);
            const y2 = this.get(edge_index, 3);
            if (y1 === scanline_y && (scanline_y < y2 || this.allow_horizontal_edges && scanline_y === y2)) {
              active_edges[this.num_active_edges++] = edge_index;
              if (DEBUG) {
                console.log(
                  `Edge ${edge_index} added (scanline_y=${scanline_y}, y1=${y1}, y2=${y2})`
                );
              }
            }
          }
          if (DEBUG) {
            console.log(
              `Updated active edges for scanline ${scanline_y}:`,
              active_edges.slice(0, this.num_active_edges)
            );
          }
        }
        sort_active_edges_by_x() {
          this.active_edges.set(
            this.active_edges.slice(0, this.num_active_edges).sort((edgeA, edgeB) => this.get(edgeA, 0) - this.get(edgeB, 0))
          );
          if (DEBUG) {
            console.log(
              `Sorted active edges by x:`,
              this.active_edges.slice(0, this.num_active_edges)
            );
          }
        }
        get_active_edges() {
          return this.active_edges.slice(0, this.num_active_edges);
        }
      };
      module.exports = Scanline_Polygon_Edges;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Polygon.js
  var require_Polygon = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/Polygon.js"(exports, module) {
      var Shape = require_Shape();
      var { tof, is_array, get_item_sig, is_arr_of_t } = require_lib_lang_mini4();
      var Rectangle = require_Rectangle();
      var {
        draw_polygon_outline_to_ta_1bipp,
        ensure_polygon_is_ta,
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        fast_find_next_set_ta_bit,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        get_bit,
        calc_polygon_stroke_points_x_y
      } = require_ta_math();
      var is_integer_typed_array = (obj2) => {
        if (ArrayBuffer.isView(obj2)) {
          return obj2 instanceof Int8Array || obj2 instanceof Uint8Array || obj2 instanceof Int16Array || obj2 instanceof Uint16Array || obj2 instanceof Int32Array || obj2 instanceof Uint32Array || obj2 instanceof BigInt64Array || obj2 instanceof BigUint64Array;
        }
        return false;
      };
      var Polygon_Scanline_Edges = require_Polygon_Scanline_Edges();
      var Polygon = class _Polygon extends Shape {
        // Set the points but with an offset too????
        constructor(spec) {
          super(spec);
          if (is_array(spec)) {
            const l2 = spec.length;
            const num_points = l2;
            const ta_points = new Uint32Array(num_points << 1);
            let i = 0;
            for (const [x, y] of spec) {
              ta_points[i++] = x;
              ta_points[i++] = y;
            }
            this.ta_points = ta_points;
          } else {
            if (is_integer_typed_array(spec)) {
              this.ta_points = spec;
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        // Or just as a normal array? Maybe that would be faster.
        get ta_bounding_box() {
          if (!this._ta_bounding_box) {
            const { ta_points } = this, l2 = ta_points.length;
            let min_x = Infinity, min_y = Infinity, max_x = -Infinity, max_y = -Infinity;
            let i = 0;
            let x, y;
            while (i < l2) {
              x = ta_points[i++];
              y = ta_points[i++];
              min_x = Math.min(min_x, x);
              min_y = Math.min(min_y, y);
              max_x = Math.max(max_x, x);
              max_y = Math.max(max_y, y);
            }
            return this._ta_bounding_box = new Uint32Array([min_x, min_y, max_x, max_y]);
          } else {
            return this._ta_bounding_box;
          }
        }
        get ta_xylc_x_spans() {
          const downshifted = this.downshifted();
          const tabb = downshifted.ta_bounding_box;
          const offset2 = this.ta_bounding_box;
          const draw_size = [tabb[2], tabb[3]];
          const [w, h] = draw_size;
          const draw_size_num_pixels = draw_size[0] * draw_size[1];
          const r_from_8 = draw_size_num_pixels % 8;
          const has_remainder_byte = r_from_8 !== 0;
          const ta_draw_num_bytes = (draw_size_num_pixels >>> 3) + (has_remainder_byte ? 1 : 0);
          const ta_draw = new Uint8Array(ta_draw_num_bytes);
          draw_polygon_outline_to_ta_1bipp(ta_draw, draw_size[0], downshifted.ta_points);
          const ta_x_span_toggles = get_ta_bits_that_differ_from_previous_as_1s2(ta_draw, draw_size[0]);
          const num_toggle_bits = count_1s2(ta_x_span_toggles);
          const iterate_to_count_x_spans = () => {
            let i_row_start = 0, i_row_end = w + 1;
            let cx = 0;
            const found_x_span = (x, y, l2, c2) => {
              cx++;
            };
            for (let y = 0; y < h; y++) {
              let i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_row_start, i_row_end - i_row_start - 1);
              if (i_next_set_bit === false) {
                found_x_span(0, y, i_row_end);
              } else {
                found_x_span(0, y, i_next_set_bit - i_row_start);
                let i_last_set_bit = i_next_set_bit;
                while (i_next_set_bit !== false && i_next_set_bit < i_row_end) {
                  i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_next_set_bit, i_row_end - i_next_set_bit - 1);
                  if (i_next_set_bit === false) {
                    found_x_span(i_last_set_bit - i_row_start, y, i_row_end - i_last_set_bit);
                  } else {
                    found_x_span(i_last_set_bit - i_row_start, y, i_next_set_bit - i_last_set_bit);
                    i_last_set_bit = i_next_set_bit;
                  }
                }
              }
              i_row_start += w;
              i_row_end += w;
            }
            return cx;
          };
          const num_x_spans = iterate_to_count_x_spans();
          const num_fields_per_result_item = 4;
          const l_res = num_x_spans * num_fields_per_result_item;
          const res2 = new Uint32Array(l_res);
          const iterate_to_write_result = () => {
            let i_w_res = 0;
            let i_row_start = 0, i_row_end = w + 1;
            let cx = 0;
            const found_x_span = (x, y, l2, c2) => {
              res2[i_w_res++] = x;
              res2[i_w_res++] = y;
              res2[i_w_res++] = l2;
              res2[i_w_res++] = c2;
              cx++;
            };
            for (let y = 0; y < h; y++) {
              const row_x0_value = get_bit(ta_x_span_toggles, i_row_start);
              let color = row_x0_value;
              let i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_row_start, i_row_end - i_row_start - 1);
              if (i_next_set_bit === false) {
                found_x_span(0, y, i_row_end, color);
              } else {
                found_x_span(0, y, i_next_set_bit - i_row_start, color);
                color = ~color & 1;
                let i_last_set_bit = i_next_set_bit;
                while (i_next_set_bit !== false && i_next_set_bit < i_row_end) {
                  i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_next_set_bit, i_row_end - i_next_set_bit - 1);
                  if (i_next_set_bit === false) {
                    found_x_span(i_last_set_bit - i_row_start, y, i_row_end - i_last_set_bit, color);
                  } else {
                    found_x_span(i_last_set_bit - i_row_start, y, i_next_set_bit - i_last_set_bit, color);
                    i_last_set_bit = i_next_set_bit;
                    color = ~color & 1;
                  }
                }
              }
              i_row_start += w;
              i_row_end += w;
            }
          };
          iterate_to_write_result();
          return res2;
        }
        // x, y, l makes the most sense
        get ta_x_spans_filled() {
          const calling_other_fns_attempt = () => {
            const bb = this.ta_bounding_box;
            const offset_width = bb[2] - bb[0];
            const offset_height = bb[3] - bb[1];
            const ohm1 = offset_height - 1;
            const ta_xylc_x_spans = this.ta_xylc_x_spans;
            const iterate_to_count_x_spans_touching_image_border = () => {
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              let i_r = 0;
              let c_touching_image_border2 = 0;
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l2 = ta_xylc_x_spans[i_r++], c2 = ta_xylc_x_spans[i_r++];
                if (x === 0) {
                  c_touching_image_border2++;
                } else if (x + l2 === offset_width) {
                  c_touching_image_border2++;
                } else if (y === 0) {
                  c_touching_image_border2++;
                } else if (y === ohm1) {
                  c_touching_image_border2++;
                }
              }
              return c_touching_image_border2;
            };
            const c_touching_image_border = iterate_to_count_x_spans_touching_image_border();
            const indexes_of_x_spans_touching_image_border = new Uint32Array(c_touching_image_border);
            const iterate_to_populate_indexes_of_x_spans_touching_image_border = () => {
              let i_r = 0, i_w = 0;
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l2 = ta_xylc_x_spans[i_r++], c2 = ta_xylc_x_spans[i_r++];
                if (x === 0) {
                  indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                } else if (x + l2 === offset_width) {
                  indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                } else if (y === 0) {
                  indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                } else if (y === ohm1) {
                  indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                }
              }
            };
            iterate_to_populate_indexes_of_x_spans_touching_image_border();
            const iterate_to_count_color_0_x_spans_touching_image_border = () => {
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              let i_r = 0;
              let c_touching_image_border2 = 0;
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l2 = ta_xylc_x_spans[i_r++], c2 = ta_xylc_x_spans[i_r++];
                if (c2 === 0) {
                  if (x === 0) {
                    c_touching_image_border2++;
                  } else if (x + l2 === offset_width) {
                    c_touching_image_border2++;
                  } else if (y === 0) {
                    c_touching_image_border2++;
                  } else if (y === ohm1) {
                    c_touching_image_border2++;
                  }
                }
              }
              return c_touching_image_border2;
            };
            const c_color_0_touching_image_border = iterate_to_count_color_0_x_spans_touching_image_border();
            const indexes_of_color_0_x_spans_touching_image_border = new Uint32Array(c_color_0_touching_image_border);
            const iterate_to_populate_indexes_of_color_0_x_spans_touching_image_border = () => {
              let i_r = 0, i_w = 0;
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l2 = ta_xylc_x_spans[i_r++], c2 = ta_xylc_x_spans[i_r++];
                if (c2 === 0) {
                  if (x === 0) {
                    indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                  } else if (x + l2 === offset_width) {
                    indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                  } else if (y === 0) {
                    indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                  } else if (y === ohm1) {
                    indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                  }
                }
              }
            };
            iterate_to_populate_indexes_of_color_0_x_spans_touching_image_border();
            const invert_indexes = (indexes) => {
              const ta_l = ta_xylc_x_spans.length;
              const num_x_spans = ta_l / 4;
              let i_idx = 0;
              let res_idx = 0;
              const res3 = new Uint32Array(num_x_spans - indexes.length);
              for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                if (i_idx < indexes.length && indexes[i_idx] === i_x_span) {
                  i_idx++;
                } else {
                  res3[res_idx++] = i_x_span;
                }
              }
              return res3;
            };
            const assemble_res_from_indexes = (indexes) => {
              const l2 = indexes.length;
              let i_r = 0, i_w = 0;
              const l_res = l2 * 3;
              const res3 = new Uint32Array(l_res);
              for (let i_index = 0; i_index < l2; i_index++) {
                const i_in_main = indexes[i_index];
                const pos_in_main = i_in_main * 4;
                const x = ta_xylc_x_spans[pos_in_main];
                const y = ta_xylc_x_spans[pos_in_main + 1];
                const l3 = ta_xylc_x_spans[pos_in_main + 2];
                res3[i_w++] = x;
                res3[i_w++] = y;
                res3[i_w++] = l3;
              }
              return res3;
            };
            const res2 = assemble_res_from_indexes(invert_indexes(indexes_of_color_0_x_spans_touching_image_border));
            return res2;
          };
          return calling_other_fns_attempt();
        }
        set offset(value2) {
          if (!this._offset) {
            this._offset = new Uint32Array(2);
          }
          if (is_array(value2)) {
            this._offset[0] = value2[0];
            this._offset[1] = value2[1];
          } else {
            console.trace();
            throw "NYI";
          }
        }
        get offset() {
          if (!this._offset) {
            this._offset = new Uint32Array(2);
          }
          return this._offset;
        }
        downshifted() {
          const [x, y] = this.ta_bounding_box;
          const dx = -x, dy = -y;
          const { ta_points } = this, l2 = ta_points.length;
          const ta_downshifted_points = new Uint32Array(l2);
          let i = 0;
          while (i < l2) {
            ta_downshifted_points[i] = ta_points[i++] + dx;
            ta_downshifted_points[i] = ta_points[i++] + dy;
          }
          const res2 = new _Polygon(ta_downshifted_points);
          res2.offset = [x, y];
          return res2;
        }
        get scanline_edges() {
          const res2 = new Polygon_Scanline_Edges(this);
          return res2;
        }
      };
      Polygon.Polygon_Scanline_Edges = Polygon_Scanline_Edges;
      Polygon.ensure_is = (obj2) => {
        if (obj2 instanceof Polygon) {
          return obj2;
        } else {
          return new Polygon(obj2);
        }
      };
      module.exports = Polygon;
      if (__require.main === module) {
        const t0 = process.hrtime();
        const polygon = new Polygon([[900, 900], [200, 200], [1e3, 900], [1600, 200], [1e3, 1e3], [1e3, 1100], [1e3, 1600], [900, 1600]]);
        const ta_l = polygon.ta_points.length;
        const tabb = polygon.ta_bounding_box;
        const ds_pg = polygon.downshifted();
        const xsf = polygon.ta_x_spans_filled;
        const l_xsf = xsf.length;
        const num_x_spans = l / 3;
        let i = 0;
        for (let c2 = 0; c2 < num_x_spans; c2++) {
          const x = xsf[i++], y = xsf[i++], l2 = xsf[i++], x2 = x + l2;
        }
        const tt0 = process.hrtime(t0);
        const ms0 = tt0[0] * 1e3 + tt0[1] / 1e6;
        console.log("ms0", ms0);
        console.log("ta_l", ta_l);
        console.log("tabb", tabb);
        console.log("polygon", polygon);
        console.log("ds_pg", ds_pg);
        console.log("ds_pg.ta_bounding_box", ds_pg.ta_bounding_box);
        console.log("xsf", xsf);
      }
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/ScanlineProcessor.js
  var require_ScanlineProcessor = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/shapes/ScanlineProcessor.js"(exports, module) {
      var DEBUG = require_is_debug();
      var ScanlineProcessor = class {
        constructor(polygon_scanline_edges, width, height2, bitmap, options = {}) {
          this.edges = polygon_scanline_edges;
          this.width = width;
          this.height = height2;
          this.bitmap = bitmap;
          this.dataView = new DataView(bitmap.buffer, bitmap.byteOffset, bitmap.byteLength);
          this.draw_edges = options.draw_edges || false;
        }
        process_1bipp() {
          if (DEBUG) {
            console.log(`Processing polygon fill: width=${this.width}, height=${this.height}`);
          }
          const h = this.height, edges = this.edges;
          for (let y = 0; y < h; y++) {
            edges.update_active_edges(y);
            edges.sort_active_edges_by_x();
            if (DEBUG) {
              console.log(`Scanline ${y}: Active Edges`, edges.active_edges.slice(0, edges.num_active_edges));
            }
            if (this.draw_edges) {
              this.fill_scanline_with_edges_1bipp(y);
            } else {
              this.fill_scanline_no_edges_1bipp(y);
            }
            this._update_x_intercepts();
          }
        }
        _set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end) {
          const total_pixels = x_end - x_start + 1;
          const start_index = row_offset + x_start;
          const end_index = row_offset + x_end;
          let pixel_index = start_index;
          if (total_pixels < 12) {
            for (; pixel_index <= end_index; pixel_index++) {
              const byte_offset = pixel_index >> 3;
              bitmap[byte_offset] |= 128 >> (pixel_index & 7);
            }
          } else {
            const start_byte = start_index >> 3;
            const start_bit_offset = pixel_index & 7;
            let num_pixels_remaining = total_pixels;
            if (total_pixels < 90) {
              if (start_bit_offset !== 0) {
                const bits_to_set = Math.min(8 - start_bit_offset, num_pixels_remaining);
                bitmap[start_byte] |= 255 >> 8 - bits_to_set << 8 - start_bit_offset - bits_to_set;
                pixel_index += bits_to_set;
                num_pixels_remaining -= bits_to_set;
              }
              while (num_pixels_remaining >= 8) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= 255;
                pixel_index += 8;
                num_pixels_remaining -= 8;
              }
              if (num_pixels_remaining > 0) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= 255 << 8 - num_pixels_remaining;
              }
            } else {
              const dataView = this.dataView;
              if (start_bit_offset !== 0) {
                const bits_to_set = Math.min(8 - start_bit_offset, num_pixels_remaining);
                bitmap[start_byte] |= 255 >> 8 - bits_to_set << 8 - start_bit_offset - bits_to_set;
                pixel_index += bits_to_set;
                num_pixels_remaining -= bits_to_set;
              }
              while (num_pixels_remaining >= 64) {
                const byte_offset = pixel_index >> 3;
                dataView.setBigUint64(byte_offset, /* @__PURE__ */ BigInt("0xFFFFFFFFFFFFFFFF"), false);
                pixel_index += 64;
                num_pixels_remaining -= 64;
              }
              while (num_pixels_remaining >= 8) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= 255;
                pixel_index += 8;
                num_pixels_remaining -= 8;
              }
              if (num_pixels_remaining > 0) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= 255 << 8 - num_pixels_remaining;
              }
            }
          }
        }
        fill_scanline_with_edges_1bipp(scanline_y) {
          const { edges } = this;
          const { active_edges, num_active_edges } = this.edges;
          if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
          }
          const bitmap = this.bitmap;
          const row_offset = scanline_y * this.width;
          const naem1 = num_active_edges - 1;
          for (let i = 0; i < naem1; i += 2) {
            const x_start = Math.round(edges.get(active_edges[i], 0));
            const x_end = Math.round(edges.get(active_edges[i + 1], 0));
            this._set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end);
            if (DEBUG) {
              console.log(`Scanline ${scanline_y}: Processed span from x=${x_start} to x=${x_end}`);
            }
          }
        }
        fill_scanline_no_edges_1bipp(scanline_y) {
          const { edges } = this;
          const { active_edges, num_active_edges } = this.edges;
          if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
          }
          const bitmap = this.bitmap;
          const row_offset = scanline_y * this.width;
          const naem1 = num_active_edges - 1;
          for (let i = 0; i < naem1; i += 2) {
            const x_start = Math.ceil(edges.get(active_edges[i], 0));
            const x_end = Math.floor(edges.get(active_edges[i + 1], 0));
            this._set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end);
            if (DEBUG) {
              console.log(`Scanline ${scanline_y}: Filling span from x=${x_start} to x=${x_end}`);
            }
          }
        }
        *iterate_process() {
          const h = this.height, edges = this.edges;
          for (let y = 0; y < h; y++) {
            edges.update_active_edges(y);
            edges.sort_active_edges_by_x();
            if (DEBUG) {
              console.log(`Scanline ${y}: Active Edges`, edges.active_edges.slice(0, edges.num_active_edges));
            }
            yield* this.iterate_scanline(y);
            this._update_x_intercepts();
          }
        }
        *iterate_scanline(scanline_y) {
          const { edges } = this;
          const { active_edges, num_active_edges } = this.edges;
          if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
          }
          for (let i = 0; i < num_active_edges - 1; i += 2) {
            const x_start = Math.ceil(edges.get(active_edges[i], 0));
            const x_end = Math.floor(edges.get(active_edges[i + 1], 0));
            if (x_start <= x_end) {
              yield [scanline_y, x_start, x_end];
            }
          }
        }
        _update_x_intercepts() {
          const edges = this.edges;
          const { active_edges, num_active_edges } = edges;
          for (let i = 0; i < num_active_edges; i++) {
            const edge_index = active_edges[i];
            edges.set(edge_index, 0, edges.get(edge_index, 0) + edges.get(edge_index, 4));
            if (DEBUG) {
              console.log(`Edge ${edge_index}: Updated x=${edges.get(edge_index, 0)} using slope=${edges.get(edge_index, 4)}`);
            }
          }
        }
      };
      module.exports = ScanlineProcessor;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-1.2-core-draw-polygon.js
  var require_pixel_buffer_1_2_core_draw_polygon = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-1.2-core-draw-polygon.js"(exports, module) {
      var Pixel_Buffer_Core_Draw_Lines = require_pixel_buffer_1_1_core_draw_line();
      var Polygon_Scanline_Edges = require_Polygon_Scanline_Edges();
      var {
        resize_ta_colorspace,
        copy_rect_to_same_size_8bipp,
        copy_rect_to_same_size_24bipp,
        dest_aligned_copy_rect_1to4bypp,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        right_shift_32bit_with_carry: right_shift_32bit_with_carry2,
        xor_typed_arrays: xor_typed_arrays2,
        each_1_index: each_1_index2,
        count_1s: count_1s2,
        draw_polygon_outline_to_ta_1bipp,
        ensure_polygon_is_ta,
        calc_polygon_stroke_points_x_y
      } = require_ta_math();
      var Polygon = require_Polygon();
      var ScanlineProcessor = require_ScanlineProcessor();
      var Pixel_Buffer_Core_Draw_Polygons = class extends Pixel_Buffer_Core_Draw_Lines {
        constructor(spec) {
          super(spec);
        }
        gpt_draw_polygon_filling(polygon) {
          const edges = [];
          const num_points = polygon.length / 2;
          const [w, h] = this.size;
          for (let i = 0; i < num_points; i++) {
            const x1 = polygon[i * 2];
            const y1 = polygon[i * 2 + 1];
            const x2 = polygon[(i + 1) % num_points * 2];
            const y2 = polygon[(i + 1) % num_points * 2 + 1];
            if (x1 === x2 && y1 === y2) continue;
            if (y1 !== y2) {
              const is_y1_lower = y1 < y2;
              edges.push({
                x1: is_y1_lower ? x1 : x2,
                y1: Math.min(y1, y2),
                x2: is_y1_lower ? x2 : x1,
                y2: Math.max(y1, y2),
                slope: (x2 - x1) / (y2 - y1)
              });
            }
          }
          edges.sort((a, b) => a.y1 - b.y1 || a.x1 - b.x1);
          let active_edges = [];
          let edge_index = 0;
          for (let y = 0; y < h; y++) {
            while (edge_index < edges.length && edges[edge_index].y1 === y) {
              active_edges.push(edges[edge_index]);
              edge_index++;
            }
            active_edges = active_edges.filter((e) => e.y2 > y);
            active_edges.sort((a, b) => a.x1 - b.x1);
            const aelm1 = active_edges.length - 1;
            for (let i = 0; i < aelm1; i += 2) {
              const x_start = Math.ceil(active_edges[i].x1);
              const x_end = Math.floor(active_edges[i + 1].x1);
              for (let x = x_start; x <= x_end; x++) {
                const pixel_index = y * w + x;
                this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
              }
            }
            for (let edge of active_edges) {
              edge.x1 += edge.slope;
            }
          }
        }
        class_enh_gpt_draw_polygon_filling(polygon) {
          const [w, h] = this.size;
          polygon = Polygon.ensure_is(polygon);
          const polygon_scanline_edges = new Polygon_Scanline_Edges(polygon);
          const processor = new ScanlineProcessor(polygon_scanline_edges, w, h, this.ta);
          processor.process();
        }
        gpt_draw_filled_polygon_1bipp(polygon) {
          polygon = Polygon.ensure_is(ensure_polygon_is_ta(polygon));
          const scanline_processor = new ScanlineProcessor(
            polygon.scanline_edges,
            this.size[0],
            this.size[1],
            this.ta,
            { draw_edges: true }
            // Enable edge drawing
          );
          scanline_processor.process_1bipp();
        }
        draw_color_1_filled_polygon_1bipp(polygon) {
          return this.gpt_draw_filled_polygon_1bipp(polygon);
        }
        draw_polygon_1bipp(polygon, stroke_color, fill_color = false) {
          polygon = ensure_polygon_is_ta(polygon);
          if (fill_color === void 0 || fill_color === false) {
            let x, y;
            let prev_x, prev_y;
            let is_first = true;
            const num_points = polygon.length >>> 1;
            let r = 0;
            for (let c2 = 0; c2 < num_points; c2++) {
              x = polygon[r++];
              y = polygon[r++];
              if (!is_first) {
                this.draw_line([prev_x, prev_y], [x, y], stroke_color);
              }
              [prev_x, prev_y] = [x, y];
              is_first = false;
            }
            this.draw_line([prev_x, prev_y], [polygon[0], polygon[1]], stroke_color);
          } else {
            if (stroke_color === 1) {
              if (fill_color === 1) {
                return this.draw_color_1_filled_polygon_1bipp(polygon);
              } else if (fill_color === 0) {
                console.trace();
                throw "NYI";
              }
            } else {
              if (fill_color === 1) {
                console.trace();
                throw "NYI";
              } else if (fill_color === 0) {
                console.trace();
                throw "NYI";
              }
            }
          }
        }
        "draw_polygon"(arr_points, color, fill = false, stroke_color) {
          const { bits_per_pixel } = this;
          if (bits_per_pixel === 1) {
            if (fill === true) {
              if (stroke_color === void 0) {
                return this.draw_polygon_1bipp(arr_points, color, color);
              } else {
                console.trace();
                throw "NYI";
                if (stroke_color === 1) {
                } else {
                }
              }
            } else {
              return this.draw_polygon_1bipp(arr_points, color);
            }
          } else {
            if (fill === true) {
              const iterate_class_polygon_scanline_spans_implementation = () => {
                const draw_filling = () => {
                  const polygon = Polygon.ensure_is(ensure_polygon_is_ta(arr_points));
                  const polygon_scanline_edges = new Polygon_Scanline_Edges(polygon);
                  const [w, h] = this.size;
                  const processor = new ScanlineProcessor(polygon_scanline_edges, w, h, this.ta, { draw_edges: true });
                  if (bits_per_pixel === 24) {
                    const ppal = 64 * 3;
                    const pre_populated_array = new Uint8Array(ppal);
                    for (let i = 0; i < ppal; ) {
                      pre_populated_array[i++] = color[0];
                      pre_populated_array[i++] = color[1];
                      pre_populated_array[i++] = color[2];
                    }
                    for (const [y, x1, x2] of processor.iterate_process()) {
                      this.draw_horizontal_line_24bipp_y_x1_x2(y, x1, x2, color, pre_populated_array, false);
                    }
                  } else {
                    for (const [y, x1, x2] of processor.iterate_process()) {
                      this.draw_horizontal_line_y_x1_x2(y, x1, x2, color);
                    }
                  }
                };
                draw_filling();
              };
              iterate_class_polygon_scanline_spans_implementation();
            } else {
              let prev_x, prev_y;
              let is_first = true;
              for (const [x, y] of arr_points) {
                if (!is_first) {
                  this.draw_line([prev_x, prev_y], [x, y], color);
                }
                [prev_x, prev_y] = [x, y];
                is_first = false;
              }
              this.draw_line([prev_x, prev_y], arr_points[0], color);
            }
          }
        }
      };
      module.exports = Pixel_Buffer_Core_Draw_Polygons;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-1.5-core-mask.js
  var require_pixel_buffer_1_5_core_mask = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-1.5-core-mask.js"(exports, module) {
      var Pixel_Buffer_Core_Draw_Polygons = require_pixel_buffer_1_2_core_draw_polygon();
      var Polygon_Scanline_Edges = require_Polygon_Scanline_Edges();
      var ScanlineProcessor = require_ScanlineProcessor();
      var Pixel_Buffer_Core_Masks = class extends Pixel_Buffer_Core_Draw_Polygons {
        constructor(spec) {
          super(spec);
        }
        "draw_1bipp_pixel_buffer_mask_1bipp"(pb_1bipp_mask, dest_pos, color) {
          const arr_on_xspans_implementation = () => {
            const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
            const [width, height2] = pb_1bipp_mask.size;
            const [dest_x, dest_y] = dest_pos;
            if (color === 1) {
              for (let y = 0; y < height2; y++) {
                const target_y = y + dest_y;
                for (const xonspan of arr_rows_arr_on_xspans[y]) {
                  xonspan[0] += dest_x;
                  xonspan[1] += dest_x;
                  this.draw_horizontal_line_on_1bipp_inclusive(xonspan, target_y);
                }
              }
            } else {
              for (let y = 0; y < height2; y++) {
                const target_y = y + dest_y;
                for (const xonspan of arr_rows_arr_on_xspans[y]) {
                  xonspan[0] += dest_x;
                  xonspan[1] += dest_x;
                  this.draw_horizontal_line_off_1bipp_inclusive(xonspan, target_y);
                }
              }
            }
          };
          const bit_realigned_64_bit_implementation = () => {
            const pb_source2 = pb_1bipp_mask;
            const pb_dest = this;
            const size_source = pb_source2.size;
            const w_source = size_source[0];
            const h_source = size_source[1];
            const size_dest = pb_dest.size;
            const w_dest = size_dest[0];
            const iterate_dest_shift_reads = () => {
              const dest_start_pxi = dest_pos[1] * pb_dest.size[0] + dest_pos[0];
              const dest_start_row_end_pxi = dest_start_pxi + pb_source2.size[0];
              const num_px_from_dest_row_start_to_draw_box_start = dest_pos[0];
              const num_px_from_draw_box_end_to_dest_row_end = pb_dest.size[0] - pb_source2.size[0] - num_px_from_dest_row_start_to_draw_box_start;
              const num_px_line_jump = num_px_from_draw_box_end_to_dest_row_end + dest_pos[0];
              const num_ui64_line_jump = (num_px_line_jump >>> 6) - 1;
              const dest_start_i64 = dest_start_pxi >>> 6;
              const dest_start_i64_rb = dest_start_pxi % 64;
              const dest_start_row_end_i64 = dest_start_row_end_pxi >>> 6;
              const num_64_bit_at_least_partial_parts_per_row = dest_start_row_end_i64 - dest_start_i64 + 1;
              let i64_dest = dest_start_i64;
              let i64_source = 0;
              const y_top = dest_pos[1], y_bottom = y_top + h_source;
              const sta64 = new BigUint64Array(pb_source2.ta.buffer, pb_source2.ta.byteOffset, pb_source2.ta.byteLength / 8);
              const dta64 = new BigUint64Array(pb_dest.ta.buffer, pb_dest.ta.byteOffset, pb_dest.ta.byteLength / 8);
              const bi_dest_start_i64_rb = BigInt(dest_start_i64_rb);
              const bi_right_right_shift_bits = /* @__PURE__ */ BigInt("64") - bi_dest_start_i64_rb;
              const dest_row_middle_ui64_count = num_64_bit_at_least_partial_parts_per_row - 2;
              for (let y = y_top; y < y_bottom; y++) {
                const process_0th_64bit_part = () => {
                  dta64[i64_dest] = dta64[i64_dest] << bi_right_right_shift_bits >> bi_right_right_shift_bits | sta64[i64_source] << bi_dest_start_i64_rb;
                  i64_dest++;
                };
                const process_middle_64bit_parts = () => {
                  for (let i_mid = 0; i_mid < dest_row_middle_ui64_count; i_mid++) {
                    dta64[i64_dest++] = sta64[i64_source] >> bi_right_right_shift_bits | sta64[i64_source + 1] << bi_dest_start_i64_rb;
                    i64_source++;
                  }
                };
                const process_last_64bit_part = () => {
                  dta64[i64_dest] = dta64[i64_dest] | sta64[i64_source] >> bi_right_right_shift_bits;
                  i64_dest++;
                  i64_source++;
                };
                process_0th_64bit_part();
                process_middle_64bit_parts();
                process_last_64bit_part();
                i64_dest += num_ui64_line_jump;
              }
            };
            iterate_dest_shift_reads();
          };
          const test_can_do_aligned_64_bit = () => this.bits_per_row % 64 === 0 && this.bits_per_row >= 64 && (dest_pos[1] * pb_1bipp_mask.size[0] + dest_pos[0]) % 64 === 0 && pb_1bipp_mask.bits_per_row % 64 === 0 && pb_1bipp_mask.bits_per_row >= 64;
          const test_can_do_bit_realigned_64_bit2 = () => this.bits_per_row % 64 === 0 && this.bits_per_row >= 64 && pb_1bipp_mask.bits_per_row % 64 === 0 && pb_1bipp_mask.bits_per_row >= 64;
          const approach_selecting = () => {
            {
              const can_do_bit_realigned_64_bit = test_can_do_bit_realigned_64_bit2();
              if (can_do_bit_realigned_64_bit) {
                return arr_on_xspans_implementation();
              } else {
                return arr_on_xspans_implementation();
              }
            }
          };
          return approach_selecting();
        }
        "draw_1bipp_pixel_buffer_mask"(pb_1bipp_mask, dest_pos, color) {
          const { bipp } = this;
          if (bipp === 1) {
            return this.draw_1bipp_pixel_buffer_mask_1bipp(pb_1bipp_mask, dest_pos, color);
          } else {
            const arr_on_xspans_implementation = () => {
              const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
              const [width, height2] = pb_1bipp_mask.size;
              let y = 0;
              let [dest_x, dest_y] = dest_pos;
              for (y = 0; y < height2; y++) {
                const arr_row_xspans_on = arr_rows_arr_on_xspans[y];
                if (arr_row_xspans_on.length > 0) {
                  for (const xonspan of arr_row_xspans_on) {
                    xonspan[0] += dest_x;
                    xonspan[1] += dest_x;
                    this.draw_horizontal_line(xonspan, y + dest_y, color);
                  }
                }
              }
            };
            return arr_on_xspans_implementation();
          }
        }
        mask_each_pixel(cb_pixel) {
          const bipp = this.bits_per_pixel;
          let i_byte = 0;
          let i_px = 0;
          const bypp2 = this.bytes_per_pixel;
          const ta2 = this.ta;
          const l2 = ta2.length;
          const res_mask = new this.constructor({
            size: this.size,
            bits_per_pixel: 1
          });
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8) {
            console.trace();
            throw "NYI";
          } else if (bipp === 24 || bipp === 32) {
            while (i_byte < l2) {
              const ta_sub = ta2.slice(i_byte, i_byte + bypp2);
              const px_on = cb_pixel(ta_sub) ? 1 : 0;
              res_mask.set_pixel_by_idx(i_px, px_on);
              i_byte += bypp2;
              i_px++;
            }
          }
          return res_mask;
        }
        apply_mask(pb_mask, mr, mg, mb, ma) {
          let res2 = this.blank_copy();
          res2.flood_fill(0, 0, 255, 255, 255, 255);
          let px;
          pb_mask.each_pixel((x, y, r, g, b, a) => {
            if (r === mr && g === mg && b === mb && a === ma) {
              px = this.get_pixel(x, y);
              res2.set_pixel(x, y, px[0], px[1], px[2], px[3]);
            }
          });
          return res2;
        }
        "get_mask_each_px"(fn_mask) {
          const bipp = this.bipp;
          console.log("get_mask_each_px bipp", bipp);
          const res_mask = new this.constructor({
            size: this.size,
            bits_per_pixel: 1
          });
          if (bipp === 1) {
            let byte = 0, bit = 0;
            console.trace();
            throw "NYI";
            const ta2 = this.ta, l2 = ta2.length;
            while (byte < l2) {
            }
          } else if (bipp === 8) {
            console.trace();
            throw "NYI";
          } else if (bipp === 24) {
            let byte_pos = 0, i_px = 0;
            const l2 = this.ta.length;
            while (byte_pos < l2) {
              const ta_px = this.ta.slice(byte_pos, byte_pos + 3);
              const mask_res = fn_mask(ta_px);
              byte_pos += 3;
            }
          } else if (bipp === 32) {
            console.trace();
            throw "NYI";
          }
          return res_mask;
        }
      };
      module.exports = Pixel_Buffer_Core_Masks;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-2-core-reference-implementations.js
  var require_pixel_buffer_2_core_reference_implementations = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-2-core-reference-implementations.js"(exports, module) {
      var lang = require_lib_lang_mini4();
      var {
        each,
        fp,
        tof,
        get_a_sig,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~/* @__PURE__ */ BigInt("0");
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var Pixel_Buffer_Painter = require_pixel_buffer_painter();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Masks = require_pixel_buffer_1_5_core_mask();
      var Pixel_Buffer_Core_Reference_Implementations2 = class _Pixel_Buffer_Core_Reference_Implementations extends Pixel_Buffer_Core_Masks {
        constructor(spec) {
          if (spec instanceof _Pixel_Buffer_Core_Reference_Implementations) {
            spec = {
              bits_per_pixel: spec.bits_per_pixel,
              size: spec.size,
              ta: spec.ta
            };
          }
          let silent_update_bits_per_pixel;
          let silent_update_bytes_per_pixel;
          if (spec.window_to) {
            spec.bits_per_pixel = spec.window_to.bits_per_pixel;
          }
          const pos = new Int16Array(2);
          const size = new Int16Array(2);
          let ta2;
          super(spec);
          this.move = (ta_2d_vector) => {
            pos[0] += ta_2d_vector[0];
            pos[1] += ta_2d_vector[1];
            if (this.source) {
              this.copy_from_source();
            }
          };
          this.each_pos_within_bounds = (callback2) => {
            const has_source = !!this.source;
            for (pos[1] = pos_bounds[1]; pos[1] < pos_bounds[3]; pos[1]++) {
              for (pos[0] = pos_bounds[0]; pos[0] < pos_bounds[2]; pos[0]++) {
                if (has_source) this.copy_from_source();
                callback2();
              }
            }
          };
          this.move_next_px = () => {
            const source_size = this.source.size;
            if (pos[0] + size[0] < source_size[0]) {
              pos[0]++;
            } else {
              if (pos[1] + size[1] < source_size[1]) {
                pos[0] = 0;
                pos[1]++;
              } else {
                return false;
              }
            }
            if (this.source) {
              this.copy_from_source();
            }
            return pos;
          };
          this.paint = new Pixel_Buffer_Painter({
            pb: this
          });
        }
        // Some will need to be a bit more optimised for perf rather than readability. Do want clear code though.
        // Not quite sure why this is failing on 1 bipp right now....
        each_pixel(callback2) {
          const { ta_pos_scratch, bipp, bypp: bypp2, size, ta: ta2 } = this;
          if (bipp === 1) {
            const [w, h] = size;
            let i_byte = 0, i_bit = 0;
            const ta_cb_pos = new Uint32Array(2);
            for (let y = 0; y < h; y++) {
              ta_cb_pos[1] = y;
              for (let x = 0; x < w; x++) {
                ta_cb_pos[0] = x;
                const got_px_color = this.get_pixel_1bipp(ta_cb_pos);
                callback2(ta_cb_pos, got_px_color);
                if (i_bit === 8) {
                }
              }
            }
          } else if (bipp === 8) {
            let pixel_idx = 0;
            this.each_pixel_pos((pos, stop) => {
              callback2(pos, ta2[pixel_idx++], stop);
            });
          } else if (bipp === 24) {
            const { ta_24bit_color } = this;
            let byte_idx = 0;
            this.each_pixel_pos((pos, stop) => {
              ta_24bit_color[0] = ta2[byte_idx++];
              ta_24bit_color[1] = ta2[byte_idx++];
              ta_24bit_color[2] = ta2[byte_idx++];
              callback2(pos, ta_24bit_color, stop);
            });
          } else if (bipp === 32) {
            const { ta_32bit_color } = this;
            let byte_idx = 0;
            this.each_pixel_pos((pos, stop) => {
              ta_32bit_color[0] = ta2[byte_idx++];
              ta_32bit_color[1] = ta2[byte_idx++];
              ta_32bit_color[2] = ta2[byte_idx++];
              ta_32bit_color[3] = ta2[byte_idx++];
              callback2(pos, ta_32bit_color, stop);
            });
          }
        }
        "to_8bit_greyscale"() {
          if (this.bytes_per_pixel === 1) {
            return this;
          } else if (this.bytes_per_pixel === 3) {
            const res2 = new this.constructor({
              "size": this.size,
              "bits_per_pixel": 8
            });
            if (this.pos) res2.pos = this.pos;
            const bres = res2.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
              bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res2;
          } else if (this.bytes_per_pixel === 4) {
            const res2 = new this.constructor({
              "size": this.size,
              "bits_per_pixel": 8
            });
            if (this.pos) res2.pos = this.pos;
            const bres = res2.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
              bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res2;
          }
        }
        "to_32bit_rgba"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 32
          });
          if (this.pos) res2.pos = this.pos;
          const bres = res2.buffer;
          if (this.bytes_per_pixel === 1) {
            let i = 0, new_v;
            this.each_pixel((pos, v) => {
              bres[i++] = v;
              bres[i++] = v;
              bres[i++] = v;
              bres[i++] = 255;
            });
          } else {
            console.trace();
            throw "NYI";
          }
          return res2;
        }
        "__invert_greyscale_self"() {
          const bres = this.buffer;
          let i = 0;
          this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
          });
          return this;
        }
        "__invert_greyscale"() {
          let res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 8
          });
          if (this.pos) res2.pos = this.pos;
          const bres = res2.buffer;
          let i = 0;
          this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
          });
          return res2;
        }
        // Could have a 'paint' file / module.
        "paint_solid_border"(thickness, color) {
          return this.process((me, res2) => {
            let x, y;
            const [w, h] = this.size;
            if (this.bytes_per_pixel === 4) {
              for (y = 0; y < thickness; y++) {
                for (x = 0; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                }
              }
              for (y = h - thickness; y < h; y++) {
                for (x = 0; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                }
              }
              for (y = 0; y < h; y++) {
                for (x = 0; x < thickness; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                }
              }
              for (y = 0; y < h; y++) {
                for (x = w - thickness; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                }
              }
            } else if (this.bytes_per_pixel === 3) {
              for (y = 0; y < thickness; y++) {
                for (x = 0; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2]);
                }
              }
              for (y = h - thickness; y < h; y++) {
                for (x = 0; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2]);
                }
              }
              for (y = 0; y < h; y++) {
                for (x = 0; x < thickness; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2]);
                }
              }
              for (y = 0; y < h; y++) {
                for (x = w - thickness; x < w; x++) {
                  res2.set_pixel(x, y, color[0], color[1], color[2]);
                }
              }
            } else {
              console.trace();
              throw "NYI";
            }
            return res2;
          });
        }
        new_convolved(convolution) {
          const res2 = this.blank_copy();
          const xy_conv_center = convolution.xy_center;
          const edge_distances_from_center_px_edge = new Int16Array(4);
          edge_distances_from_center_px_edge[0] = xy_conv_center[0] * -1;
          edge_distances_from_center_px_edge[1] = xy_conv_center[1] * -1;
          edge_distances_from_center_px_edge[2] = edge_distances_from_center_px_edge[0] + convolution.size[0] - 1;
          edge_distances_from_center_px_edge[3] = edge_distances_from_center_px_edge[1] + convolution.size[1] - 1;
          const pb_window = this.new_window({
            size: convolution.size,
            pos_bounds: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1], this.size[0] - edge_distances_from_center_px_edge[2], this.size[1] - edge_distances_from_center_px_edge[3]],
            pos: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1]]
          });
          const pos_window = pb_window.pos;
          const ta_window = pb_window.ta;
          let i_write = 0;
          const ta_conv_res = res2.ta;
          pb_window.each_pos_within_bounds(() => {
            const rgb = convolution.calc_from_24bipp_ta(ta_window);
            ta_conv_res[i_write++] = rgb[0];
            ta_conv_res[i_write++] = rgb[1];
            ta_conv_res[i_write++] = rgb[2];
          });
          return res2;
        }
        new_resized(size) {
          const dest = new this.constructor({
            size,
            bits_per_pixel: this.bipp
          });
          resize_ta_colorspace(this.ta, this.ta_colorspace, dest.size, dest.ta);
          return dest;
        }
        copy_rect_by_bounds_to(ta_bounds, pb_target) {
          console.log("pb.copy_rect_by_bounds_to");
          const bipp = this.bipp;
          if (bipp === 24) {
            return this.copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        each_px_convolution(ta_size, pb_conv_window, ta_pos, callback2) {
          console.trace();
          throw "NYI";
          ta_pos[0] = 0;
          ta_pos[1] = 0;
          if (are_equal(pb_conv_window.size, ta_size)) {
          } else {
          }
        }
        toString() {
          return JSON.stringify({
            buffer: "Uint8ClampedArray length " + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
          });
        }
        /*
        [inspect]() {
            return 'Pixel_Buffer_Core ' + this.toString();
        }
        */
        color_whole(color) {
          this.each_px((pos) => {
            this.set_pixel(pos, color);
          });
          return this;
        }
        crop(size) {
          let new_size = new Uint16Array([this.size[0] - size * 2, this.size[1] - size * 2]);
          let res2 = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new_size
          });
          if (this.pos) {
            res2.pos = new Int16Array([this.pos[0] - size, this.pos[1] - size]);
          }
          this.each_pixel_ta((pos, color) => {
            const new_pos = new Int16Array([pos[0] - size, pos[1] - size]);
            if (new_pos[0] >= 0 && new_pos[0] < new_size[0] && new_pos[1] >= 0 && new_pos[1] < new_size[1]) {
              res2.set_pixel_ta(new_pos, color);
            }
          });
          return res2;
        }
        uncrop(size, color) {
          let res2 = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new Uint16Array([this.size[0] + size * 2, this.size[1] + size * 2])
          });
          if (this.pos) res2.pos = this.pos;
          if (this.pos) {
          }
          res2.color_whole(color);
          console.log("size", size);
          this.each_pixel_ta((pos, color2) => {
            res2.set_pixel_ta(new Uint16Array([pos[0] + size, pos[1] + size]), color2);
          });
          return res2;
        }
        color_rect(bounds2, color) {
          console.trace();
          throw "NYI";
        }
        each_pixel_byte_index(cb) {
          const { bipp } = this;
          let ctu = true;
          const stop = () => ctu = false;
          const [w, h] = this.size;
          const num_pixels = w * h;
          let bit_idx = 0, byte_idx = bit_idx >> 3;
          for (let c2 = 0; c2 < num_pixels; c2++) {
            byte_idx = bit_idx >> 3;
            cb(byte_idx);
          }
        }
        each_px(callback2) {
          const ta_pos = new Int32Array(2);
          const [w, h] = this.size;
          let index = 0;
          for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
              const color = this.get_pixel(ta_pos);
              callback2(ta_pos, color, index++);
            }
          }
        }
        paint_pixel_list(pixel_pos_list, color) {
          pixel_pos_list.each_pixel((pos) => {
            this.set_pixel_ta(pos, color);
          });
        }
        // Maybe a class level that has get and set pixel logic for the different bipps at this level.
        get num_px() {
          return this.size[0] * this.size[1];
        }
        get split_rgb_channels() {
          const [bipp, bypp2] = [this.bits_per_pixel, this.bytes_per_pixel];
          if (bipp === 24 || bipp === 32) {
            const res2 = [new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            })];
            const [r, g, b] = res2;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta2 = this.ta;
            while (i_px < num_px) {
              ta_r[i_px] = ta2[i_byte];
              ta_g[i_px] = ta2[i_byte + 1];
              ta_b[i_px] = ta2[i_byte + 2];
              i_px++;
              i_byte += bypp2;
            }
            return res2;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        process(fn) {
          let res2 = this.clone();
          return fn(this, res2);
        }
        /*
            function typedArraysAreEqual(a, b) {
        if (a.byteLength !== b.byteLength) return false;
        return a.every((val, i) => val === b[i]);
        }
            */
        equals(other_pixel_buffer) {
          let buf1 = this.ta;
          let buf2 = other_pixel_buffer.ta;
          const other_colorspace = other_pixel_buffer.ta_colorspace;
          const my_colorspace = other_pixel_buffer.ta_colorspace;
          if (my_colorspace.length === other_colorspace.length) {
            if (my_colorspace.every((val, i) => val === other_colorspace[i])) {
              if (buf1.length === buf2.length) {
                return buf1.every((val, i) => val === buf2[i]);
              } else {
              }
            } else {
            }
          }
          return false;
        }
        copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
          let bounds2 = pixel_pos_list.bounds;
          let size = new Uint16Array([bounds2[2] - bounds2[0] + 1, bounds2[3] - bounds2[1] + 1]);
          const res2 = new this.constructor({
            size,
            bytes_per_pixel: this.bytes_per_pixel
          });
          if (this.pos) res2.pos = this.pos;
          if (bg_color) {
            res2.color_whole(bg_color);
          }
          res2.pos = new Int16Array([bounds2[0], bounds2[1]]);
          pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([pos[0] - bounds2[0], pos[1] - bounds2[1]]);
            res2.set_pixel_ta(target_pos, color);
          });
          return res2;
        }
        // Pixel_Buffer_Pair_Complex_Operation class possibly?
        //   Or just Operation.
        // get_pre_operation_alignment_info ....
        // And could define such a class which has got requirements / invarients to do with 
        // This is used when drawing filled polygons.
        "blank_copy"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel
          });
          res2.buffer.fill(0);
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "clone"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel,
            "buffer": new this.buffer.constructor(this.buffer)
          });
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "add_alpha_channel"() {
          if (this.bytes_per_pixel === 3) {
            var res2 = new this.constructor({
              "size": this.size,
              "bytes_per_pixel": 4
            });
            if (this.pos) res2.pos = this.pos;
            const buf = this.buffer, res_buf = res2.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0, ir = 0;
            for (let p = 0; p < px_count; p++) {
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = 255;
            }
            return res2;
          }
          if (this.bytes_per_pixel === 4) {
            return this;
          }
        }
        draw_rect(pos_corner, pos_other_corner, color) {
          const l2 = Math.min(pos_corner[0], pos_other_corner[0]);
          const t = Math.min(pos_corner[1], pos_other_corner[1]);
          const r = Math.max(pos_corner[0], pos_other_corner[0]);
          const b = Math.max(pos_corner[1], pos_other_corner[1]);
          const xspan = [l2, r];
          for (let y = t; y <= b; y++) {
            this.draw_horizontal_line(xspan, y, color);
          }
        }
        *"iterate_arr_row_x_on_spans_1bipp"(y) {
        }
        get xspans() {
        }
      };
      module.exports = Pixel_Buffer_Core_Reference_Implementations2;
      if (__require.main === module) {
        const lg = console.log;
        (async () => {
          const run_examples = async () => {
            lg("Begin run examples");
            const examples = [
              async () => {
                lg("Begin example 0");
                const pb = new Pixel_Buffer_Core_Reference_Implementations2({
                  bits_per_pixel: 1,
                  size: [8, 8]
                });
                const ta_pos = new Int16Array(2);
                ta_pos[0] = 3;
                ta_pos[1] = 3;
                pb.set_pixel(ta_pos, 1);
                lg("End example 0");
                return pb;
              }
            ];
            const l2 = examples.length;
            for (var c2 = 0; c2 < l2; c2++) {
              const res_eg = await examples[c2]();
              console.log("res_eg " + c2 + ":", res_eg);
            }
            ;
            lg("End run examples");
          };
          await run_examples();
        })();
      }
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-3-core.js
  var require_pixel_buffer_3_core = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-3-core.js"(exports, module) {
      var lang = require_lib_lang_mini4();
      var {
        each,
        fp,
        tof,
        get_a_sig,
        are_equal,
        tf: tf2
      } = lang;
      var maxui64 = ~/* @__PURE__ */ BigInt("0");
      var Pixel_Pos_List = require_pixel_pos_list();
      var oext = require_oext();
      var { ro, prop } = oext;
      var Typed_Array_Binary_Read_Write = require_Typed_Array_Binary_Read_Write();
      var Pixel_Buffer_Painter = require_pixel_buffer_painter();
      var ta_math2 = require_ta_math();
      var { resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp } = ta_math2;
      var Pixel_Buffer_Core_Reference_Implementations2 = require_pixel_buffer_2_core_reference_implementations();
      var Pixel_Buffer_Core = class extends Pixel_Buffer_Core_Reference_Implementations2 {
        constructor(spec) {
          super(spec);
          const pos = new Int16Array(2);
          const size = new Int16Array(2);
          const ta_bpp = new Uint8Array(2);
          ta_bpp[1] = 8;
          const _24bipp_to_8bipp = () => {
            const old_ta = ta;
            const new_ta = ta = new Uint8Array(this.num_px);
            const l_read = old_ta.length;
            let iby_read = 0, iby_write = 0;
            while (iby_read < l_read) {
              new_ta[iby_write++] = Math.round((old_ta[iby_read++] + old_ta[iby_read++] + old_ta[iby_read++]) / 3);
            }
          };
          const _change_bipp_inner_update = (old_bipp, new_bipp) => {
            if (old_bipp === 24) {
              if (new_bipp === 8) {
                _24bipp_to_8bipp();
              } else {
                console.trace();
                throw "NYI";
              }
            } else {
              console.trace();
              throw "NYI";
            }
          };
          if (spec instanceof Pixel_Pos_List) {
            throw "NYI - change to 1bipp";
            const ppl = spec;
            const bounds2 = ppl.bounds;
            const ppl_size = new Uint16Array(2);
            ppl_size[0] = bounds2[2] - bounds2[0];
            ppl_size[1] = bounds2[3] - bounds2[1];
            this.bits_per_pixel = 8;
            const bpp = this.bytes_per_pixel = 1;
            this.size = new Uint16Array([ppl_size[0] + 4, ppl_size[1] + 4]);
            this.pos = new Int16Array([bounds2[0], bounds2[1]]);
            const bpr = this.bytes_per_row = bpp * this.size[0];
            const buf = this.ta = this.buffer = new Uint8ClampedArray(this.size[0] * this.size[1]);
            const l2 = buf.length;
            for (var c2 = 0; c2 < l2; c2++) buf[c2] = 255;
            ppl.each_pixel((pixel_pos) => {
              buf[bpr * (pixel_pos[1] - bounds2[1]) + (pixel_pos[0] - bounds2[0])] = 0;
            });
          } else {
          }
        }
        new_convolved(convolution) {
          const res2 = this.blank_copy();
          const xy_conv_center = convolution.xy_center;
          const edge_distances_from_center_px_edge = new Int16Array(4);
          edge_distances_from_center_px_edge[0] = xy_conv_center[0] * -1;
          edge_distances_from_center_px_edge[1] = xy_conv_center[1] * -1;
          edge_distances_from_center_px_edge[2] = edge_distances_from_center_px_edge[0] + convolution.size[0] - 1;
          edge_distances_from_center_px_edge[3] = edge_distances_from_center_px_edge[1] + convolution.size[1] - 1;
          const pb_window = this.new_window({
            size: convolution.size,
            pos_bounds: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1], this.size[0] - edge_distances_from_center_px_edge[2], this.size[1] - edge_distances_from_center_px_edge[3]],
            pos: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1]]
          });
          const pos_window = pb_window.pos;
          const ta_window = pb_window.ta;
          let i_write = 0;
          const ta_conv_res = res2.ta;
          pb_window.each_pos_within_bounds(() => {
            const rgb = convolution.calc_from_24bipp_ta(ta_window);
            ta_conv_res[i_write++] = rgb[0];
            ta_conv_res[i_write++] = rgb[1];
            ta_conv_res[i_write++] = rgb[2];
          });
          return res2;
        }
        new_resized(size) {
          const dest = new this.constructor({
            size,
            bits_per_pixel: this.bipp
          });
          resize_ta_colorspace(this.ta, this.ta_colorspace, dest.size, dest.ta);
          return dest;
        }
        copy_rect_by_bounds_to(ta_bounds, pb_target) {
          console.log("pb.copy_rect_by_bounds_to");
          const bipp = this.bipp;
          if (bipp === 24) {
            return this.copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        each_px_convolution(ta_size, pb_conv_window, ta_pos, callback2) {
          console.trace();
          throw "NYI";
          ta_pos[0] = 0;
          ta_pos[1] = 0;
          if (are_equal(pb_conv_window.size, ta_size)) {
          } else {
          }
        }
        get_1bipp_threshold_8bipp(ui8_threshold) {
          const bipp = this.bits_per_pixel;
          if (bipp === 8) {
            const res2 = new this.constructor({
              bits_per_pixel: 1,
              size: this.size
            });
            const rta = res2.ta;
            const ta2 = this.ta;
            const cpx = this.num_px;
            let i_px = 0;
            let i_dest_byte = 0, i_dest_bit = 7;
            let meets_threshold = false;
            let out_byte = 0;
            while (i_px < cpx) {
              meets_threshold = ta2[i_px] >= ui8_threshold;
              if (meets_threshold) {
                out_byte = out_byte | Math.pow(2, i_dest_bit);
              } else {
              }
              i_px++;
              i_dest_bit--;
              if (i_dest_bit === -1) {
                rta[i_dest_byte] = out_byte;
                i_dest_bit = 7;
                i_dest_byte++;
                out_byte = 0;
              }
            }
            return res2;
          } else {
            console.trace();
            throw "get_1bipp_threshold_8bipp: Unsupported bits_per_pixel " + bipp;
          }
        }
        to_8bipp() {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            const res2 = new this.constructor({
              size: this.size,
              bits_per_pixel: 8
            });
            let i_px = 0;
            let i_byte = 0;
            const num_bytes = this.ta.length;
            while (i_byte < num_bytes) {
              for (var b = 0; b < 8; b++) {
                const color = this.get_pixel_by_idx_1bipp(i_px) === 1 ? 255 : 0;
                res2.set_pixel_by_idx_8bipp(i_px++, color);
              }
              i_byte++;
            }
            return res2;
          } else if (bipp === 8) {
            return this.clone();
          } else if (bipp === 24) {
            console.trace();
            throw "NYI";
          } else if (bipp === 32) {
            console.trace();
            throw "NYI";
          }
        }
        to_24bipp() {
          const bipp = this.bits_per_pixel;
          const bypp2 = this.bytes_per_pixel;
          let i_px = 0;
          const num_px = this.size[0] * this.size[1];
          if (bipp === 1) {
            const res2 = new this.constructor({
              size: this.size,
              bits_per_pixel: 24
            });
            let i_byte = 0;
            const num_bytes = this.ta.length;
            while (i_byte < num_bytes) {
              for (var b = 0; b < 8; b++) {
                const color = this.get_pixel_by_idx_1bipp(i_px) === 1 ? new Uint8ClampedArray([255, 255, 255]) : new Uint8ClampedArray([0, 0, 0]);
                res2.set_pixel_by_idx_24bipp(i_px++, color);
              }
              i_byte++;
            }
            return res2;
          } else if (bipp === 8) {
            const res2 = new this.constructor({
              size: this.size,
              bits_per_pixel: 24
            });
            const ta_res = res2.ta;
            const ta2 = this.ta, l2 = ta2.length;
            let pos_w = 0, c2 = 0;
            for (c2 = 0; c2 < l2; c2++) {
              ta_res[pos_w++] = ta2[c2];
              ta_res[pos_w++] = ta2[c2];
              ta_res[pos_w++] = ta2[c2];
            }
            return res2;
          } else if (bipp === 24) {
            return this.clone();
          } else if (bipp === 32) {
            const res2 = new this.constructor({
              size: this.size,
              bits_per_pixel: 24
            });
            console.trace();
            throw "NYI";
            while (i_px < num_px) {
              const col_32 = this.get_pixel_by_idx_32bipp(i_px);
              i_px += bypp2;
            }
            return res2;
          }
        }
        toString() {
          return JSON.stringify({
            buffer: "Uint8ClampedArray length " + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
          });
        }
        /*
        [inspect]() {
            return 'Pixel_Buffer_Core ' + this.toString();
        }
        */
        color_whole(color) {
          if (this.bytes_per_pixel === 1) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1];
            const buf = this.buffer;
            let i;
            for (i = 0; i < ta_32_scratch[0]; i++) {
              buf[i] = color;
            }
          } else if (this.bytes_per_pixel === 3) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1] * 3;
            const buf = this.buffer;
            let i, c2 = 0;
            for (i = 0; i < ta_32_scratch[0]; i++) {
              buf[c2++] = color[0];
              buf[c2++] = color[1];
              buf[c2++] = color[2];
            }
          } else if (this.bytes_per_pixel === 4) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1] * 4;
            const buf = this.buffer;
            let i, c2 = 0;
            for (i = 0; i < ta_32_scratch[0]; i++) {
              buf[c2++] = color[0];
              buf[c2++] = color[1];
              buf[c2++] = color[2];
              buf[c2++] = color[3];
            }
          } else {
            throw "Unsupported this.bytes_per_pixel: " + this.bytes_per_pixel;
          }
          return this;
        }
        crop(size) {
          let new_size = new Uint16Array([this.size[0] - size * 2, this.size[1] - size * 2]);
          let res2 = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new_size
          });
          if (this.pos) {
            res2.pos = new Int16Array([this.pos[0] - size, this.pos[1] - size]);
          }
          this.each_pixel_ta((pos, color) => {
            const new_pos = new Int16Array([pos[0] - size, pos[1] - size]);
            if (new_pos[0] >= 0 && new_pos[0] < new_size[0] && new_pos[1] >= 0 && new_pos[1] < new_size[1]) {
              res2.set_pixel_ta(new_pos, color);
            }
          });
          return res2;
        }
        uncrop(size, color) {
          let res2 = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new Uint16Array([this.size[0] + size * 2, this.size[1] + size * 2])
          });
          if (this.pos) res2.pos = this.pos;
          if (this.pos) {
          }
          res2.color_whole(color);
          console.log("size", size);
          this.each_pixel_ta((pos, color2) => {
            res2.set_pixel_ta(new Uint16Array([pos[0] + size, pos[1] + size]), color2);
          });
          return res2;
        }
        color_rect(bounds2, color) {
          console.trace();
          throw "NYI";
        }
        each_pixel_byte_index(cb) {
          const { bipp } = this;
          let ctu = true;
          const stop = () => ctu = false;
          if (bipp === 8) {
            const buf = this.buffer, l2 = buf.length, bpp = this.bytes_per_pixel;
            for (let c2 = 0; ctu && c2 < l2; c2 += bpp) {
              cb(c2, stop);
            }
          } else if (bipp === 24) {
            const buf = this.buffer, l2 = buf.length, bpp = this.bytes_per_pixel;
            for (let c2 = 0; ctu && c2 < l2; c2 += bpp) {
              cb(c2, stop);
            }
          } else if (bipp === 32) {
            const buf = this.buffer, l2 = buf.length, bpp = this.bytes_per_pixel;
            for (let c2 = 0; ctu && c2 < l2; c2 += bpp) {
              cb(c2, stop);
            }
          } else {
            console.trace();
            throw "NYI";
          }
        }
        /*
        each_pixel_pos(cb) {
            const b = this.size;
            const pos = new Int16Array(2);
            for (pos[1] = 0; pos[1] < b[1]; pos[1]++) {
                for (pos[0] = 0; pos[0] < b[0]; pos[0]++) {
                    cb(pos);
                }
            }
        }
        */
        each_ta_24bipp(ta_pos, ta_px_value, ta_info, callback2) {
          const bipp = this.bipp;
          if (bipp === 24) {
            if (ta_pos instanceof Int16Array || ta_pos instanceof Int32Array && ta_pos.length >= 2) {
              if (ta_px_value instanceof Uint8ClampedArray && ta_px_value.length >= 3) {
                if (ta_info instanceof Uint32Array && ta_info.length >= 4) {
                  const ta2 = this.ta;
                  ta_info[0] = this.size[0];
                  ta_info[1] = this.size[1];
                  ta_info[2] = 0;
                  ta_info[3] = 24;
                  const update = () => {
                    ta2[ta_info[2] * 3] = ta_px_value[0];
                    ta2[ta_info[2] * 3 + 1] = ta_px_value[1];
                    ta2[ta_info[2] * 3 + 2] = ta_px_value[2];
                  };
                  for (ta_pos[1] = 0; ta_pos[1] < ta_info[1]; ta_pos[1]++) {
                    for (ta_pos[0] = 0; ta_pos[0] < ta_info[0]; ta_pos[0]++) {
                      ta_px_value[0] = ta2[ta_info[2] * 3];
                      ta_px_value[1] = ta2[ta_info[2] * 3 + 1];
                      ta_px_value[2] = ta2[ta_info[2] * 3 + 2];
                      callback2(update);
                      ta_info[2]++;
                    }
                  }
                }
              }
            }
          } else {
            throw "each_ta_24bipp error: bipp must be 24, bipp: " + bipp;
          }
        }
        each_ta_1bipp(ta_pos, ta_px_value, ta_info, callback2) {
          const bipp = this.bipp;
          if (bipp === 1) {
            const [w, h] = this.size;
            for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
              for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
                const px = this.get_pixel_1bipp(ta_pos);
                ta_px_value[0] = px;
                callback2(px, ta_pos);
              }
            }
          } else {
            throw "each_ta_1bipp error: bipp must be 1, bipp: " + bipp;
          }
        }
        each_px_on_1bipp(ta_pos, ta_px_value, ta_info, callback2) {
          const bipp = this.bipp;
          if (bipp === 1) {
            const [w, h] = this.size;
            for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
              for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
                if (this.get_pixel_1bipp(ta_pos) === 1 | 0) {
                  callback2(1 | 0, ta_pos);
                }
              }
            }
          } else {
            throw "each_ta_1bipp error: bipp must be 1, bipp: " + bipp;
          }
        }
        each_px(ta_pos, ta_px_value, ta_info, callback2) {
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.each_ta_1bipp(ta_pos, ta_px_value, ta_info, callback2);
          } else if (bipp === 8) {
            return this.each_ta_8bipp(ta_pos, ta_px_value, ta_info, callback2);
          } else if (bipp === 24) {
            return this.each_ta_24bipp(ta_pos, ta_px_value, ta_info, callback2);
          } else if (bipp === 32) {
            return this.each_ta_32bipp(ta_pos, ta_px_value, ta_info, callback2);
          } else {
            console.trace();
            throw "Unsupported bipp: " + bipp;
          }
        }
        paint_pixel_list(pixel_pos_list, color) {
          pixel_pos_list.each_pixel((pos) => {
            this.set_pixel_ta(pos, color);
          });
        }
        "get_pixel_byte_bit_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          const bit = idx & 7;
          return { byte, bit };
        }
        "get_pixel_byte_bit_BE_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          const bit = idx & 7;
          return { byte, bit };
        }
        set_pixel_on_1bipp_by_pixel_index(pixel_index) {
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        "set_pixel_on_1bipp_xy"(x, y) {
          const pixel_index = y * this.size[0] + x;
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        "set_pixel_on_1bipp"(pos) {
          const pixel_index = pos[1] * this.size[0] + pos[0];
          this.ta[pixel_index >> 3] |= 128 >> (pixel_index & 7);
        }
        set_pixel_off_1bipp_by_pixel_index(pixel_index) {
          this.ta[pixel_index >> 3] &= ~(128 >> (pixel_index & 7)) & 255;
        }
        "set_pixel_off_1bipp"(pos) {
          const pixel_idx = pos[1] * this.size[0] + pos[0];
          this.ta[pixel_idx >> 3] &= ~(128 >> (pixel_idx & 7)) & 255;
        }
        "set_pixel_1bipp"(pos, color) {
          const idx_bit = pos[1] * this.size[0] + pos[0];
          const byte = idx_bit >> 3;
          const bit = idx_bit & 7;
          if (color === 1) {
            this.ta[byte] |= 128 >> bit;
          } else {
            this.ta[byte] &= ~(128 >> bit) & 255;
          }
        }
        "set_pixel_8bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          this.ta[idx] = color;
        }
        "set_pixel_24bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          let byte = idx * 3;
          this.ta[byte++] = color[0];
          this.ta[byte++] = color[1];
          this.ta[byte] = color[2];
        }
        "set_pixel_32bipp"(pos, color) {
          const idx = pos[1] * this.size[0] + pos[0];
          let byte = idx * 4;
          this.ta[byte++] = color[0];
          this.ta[byte++] = color[1];
          this.ta[byte++] = color[2];
          this.ta[byte] = color[3];
        }
        "set_pixel_by_idx_8bipp"(idx, color) {
          const byte = idx;
          this.ta[byte] = color;
        }
        "set_pixel_by_idx_24bipp"(idx, color) {
          const byte = idx * 3;
          this.ta[byte] = color[0];
          this.ta[byte + 1] = color[1];
          this.ta[byte + 2] = color[2];
        }
        "set_pixel_by_idx_32bipp"(idx, color) {
          const byte = idx * 4;
          this.ta[byte] = color[0];
          this.ta[byte + 1] = color[1];
          this.ta[byte + 2] = color[2];
          this.ta[byte + 3] = color[3];
        }
        "set_pixel_by_idx"(idx, color) {
          const a = arguments;
          const l2 = a.length;
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.set_pixel_by_idx_1bipp(a[0], a[1]);
          } else if (bipp === 8) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_8bipp(a[0], a[1]);
            }
          } else if (bipp === 24) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_24bipp(a[0], a[1]);
            }
          } else if (bipp === 32) {
            if (l2 === 2) {
              return this.set_pixel_by_idx_32bipp(a[0], a[1]);
            }
          }
        }
        "set_pixel"(pos, color) {
          const a = arguments;
          const l2 = a.length;
          const bipp = this.bipp;
          if (bipp === 1) {
            return this.set_pixel_1bipp(a[0], a[1]);
          } else if (bipp === 8) {
            if (l2 === 2) {
              return this.set_pixel_8bipp(a[0], a[1]);
            }
          } else if (bipp === 24) {
            if (l2 === 2) {
              return this.set_pixel_24bipp(a[0], a[1]);
            }
          } else if (bipp === 32) {
            if (l2 === 2) {
              return this.set_pixel_32bipp(a[0], a[1]);
            }
          } else {
            console.trace();
            throw "unsupported bipp: " + bipp;
          }
        }
        "get_pixel_by_idx_1bipp"(idx) {
          const byte = idx >> 3;
          const bit = idx & 7;
          const pow = 128 >> bit;
          return (this.ta[byte] & pow) === pow ? 1 : 0;
        }
        "get_pixel_by_idx_8bipp"(idx) {
          const byte = idx;
          return this.ta[byte];
        }
        "get_pixel_by_idx_24bipp"(idx) {
          const byte = idx * 3;
          return this.ta.slice(byte, byte + 3);
        }
        "get_pixel_by_idx_32bipp"(idx) {
          const byte = idx * 4;
          return this.ta.slice(byte, byte + 4);
        }
        "get_pixel_by_idx"(idx) {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            return this.get_pixel_by_idx_1bipp(idx);
          } else if (bipp === 8) {
            return this.get_pixel_by_idx_8bipp(idx);
          } else if (bipp === 24) {
            return this.get_pixel_by_idx_24bipp(idx);
          } else if (bipp === 32) {
            return this.get_pixel_by_idx_32bipp(idx);
          } else {
            throw "Unsupported bipp";
          }
        }
        "get_pixel_1bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx >> 3;
          return (this.ta[byte] & 128 >> (idx & 7)) !== 0 ? 1 : 0;
        }
        "get_pixel_8bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx;
          return this.ta[byte];
        }
        "get_pixel_24bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx * 3;
          return this.ta.slice(byte, byte + 3);
        }
        "get_pixel_32bipp"(pos) {
          const idx = pos[1] * this.size[0] + pos[0];
          const byte = idx * 4;
          return this.ta.slice(byte, byte + 4);
        }
        "get_pixel"(pos) {
          const bipp = this.bits_per_pixel;
          if (bipp === 1) {
            return this.get_pixel_1bipp(pos);
          } else if (bipp === 8) {
            return this.get_pixel_8bipp(pos);
          } else if (bipp === 24) {
            return this.get_pixel_24bipp(pos);
          } else if (bipp === 32) {
            return this.get_pixel_32bipp(pos);
          } else {
            console.trace();
            throw "bits per pixels error";
          }
        }
        get num_px() {
          return this.size[0] * this.size[1];
        }
        get split_rgb_channels() {
          const [bipp, bypp2] = [this.bits_per_pixel, this.bytes_per_pixel];
          if (bipp === 24 || bipp === 32) {
            const res2 = [new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            }), new this.constructor({
              bits_per_pixel: 8,
              size: this.size
            })];
            const [r, g, b] = res2;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta2 = this.ta;
            while (i_px < num_px) {
              ta_r[i_px] = ta2[i_byte];
              ta_g[i_px] = ta2[i_byte + 1];
              ta_b[i_px] = ta2[i_byte + 2];
              i_px++;
              i_byte += bypp2;
            }
            return res2;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        process(fn) {
          let res2 = this.clone();
          return fn(this, res2);
        }
        /*
            function typedArraysAreEqual(a, b) {
        if (a.byteLength !== b.byteLength) return false;
        return a.every((val, i) => val === b[i]);
        }
            */
        equals(other_pixel_buffer) {
          let buf1 = this.ta;
          let buf2 = other_pixel_buffer.ta;
          const other_colorspace = other_pixel_buffer.ta_colorspace;
          const my_colorspace = other_pixel_buffer.ta_colorspace;
          if (my_colorspace.length === other_colorspace.length) {
            if (my_colorspace.every((val, i) => val === other_colorspace[i])) {
              if (buf1.length === buf2.length) {
                return buf1.every((val, i) => val === buf2[i]);
              } else {
              }
            } else {
            }
          }
          return false;
        }
        copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
          let bounds2 = pixel_pos_list.bounds;
          let size = new Uint16Array([bounds2[2] - bounds2[0] + 1, bounds2[3] - bounds2[1] + 1]);
          const res2 = new this.constructor({
            size,
            bytes_per_pixel: this.bytes_per_pixel
          });
          if (this.pos) res2.pos = this.pos;
          if (bg_color) {
            res2.color_whole(bg_color);
          }
          res2.pos = new Int16Array([bounds2[0], bounds2[1]]);
          pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([pos[0] - bounds2[0], pos[1] - bounds2[1]]);
            res2.set_pixel_ta(target_pos, color);
          });
          return res2;
        }
        // Pixel_Buffer_Pair_Complex_Operation class possibly?
        //   Or just Operation.
        // get_pre_operation_alignment_info ....
        // And could define such a class which has got requirements / invarients to do with 
        // This is used when drawing filled polygons.
        "draw_1bipp_pixel_buffer_mask_1bipp"(pb_1bipp_mask, dest_pos, color) {
          function draw_bitmap(target, target_width, source, source_width, source_height, target_x, target_y) {
            const target_bytes_per_row = target_width + 7 >> 3;
            const source_bytes_per_row = source_width + 7 >> 3;
            for (let row = 0; row < source_height; row++) {
              const source_row_start = row * source_bytes_per_row;
              const target_row_start = (target_y + row) * target_bytes_per_row;
              const bit_offset = target_x & 7;
              let target_byte_index = target_row_start + (target_x >> 3);
              for (let col = 0; col < source_bytes_per_row; col++) {
                const source_byte = source[source_row_start + col];
                if (bit_offset === 0) {
                  target[target_byte_index] |= source_byte;
                } else {
                  const next_byte_index = target_byte_index + 1;
                  const shifted_byte = source_byte << bit_offset;
                  const carry_over = source_byte >> 8 - bit_offset;
                  target[target_byte_index] |= shifted_byte;
                  if (next_byte_index < target.length) {
                    target[next_byte_index] |= carry_over;
                  }
                }
                target_byte_index++;
              }
            }
          }
          const chatgpto1_draw_bitmap_implementation = () => {
            draw_bitmap(this.ta, this.size[0], pb_1bipp_mask.ta, pb_1bipp_mask.size[0], pb_1bipp_mask.size[1], dest_pos[0], dest_pos[1]);
          };
          const arr_on_xspans_implementation = () => {
            const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
            const [width, height2] = pb_1bipp_mask.size;
            const [dest_x, dest_y] = dest_pos;
            if (color === 1) {
              for (let y = 0; y < height2; y++) {
                const target_y = y + dest_y;
                for (const xonspan of arr_rows_arr_on_xspans[y]) {
                  xonspan[0] += dest_x;
                  xonspan[1] += dest_x;
                  this.draw_horizontal_line_on_1bipp_inclusive(xonspan, target_y);
                }
              }
            } else {
              for (let y = 0; y < height2; y++) {
                const target_y = y + dest_y;
                for (const xonspan of arr_rows_arr_on_xspans[y]) {
                  xonspan[0] += dest_x;
                  xonspan[1] += dest_x;
                  this.draw_horizontal_line_off_1bipp_inclusive(xonspan, target_y);
                }
              }
            }
          };
          const approach_selecting = () => {
            {
              const can_do_bit_realigned_64_bit = test_can_do_bit_realigned_64_bit();
              if (can_do_bit_realigned_64_bit) {
                return arr_on_xspans_implementation();
              } else {
                return arr_on_xspans_implementation();
              }
            }
          };
          return chatgpto1_draw_bitmap_implementation();
        }
        "draw_1bipp_pixel_buffer_mask"(pb_1bipp_mask, dest_pos, color) {
          const { bipp } = this;
          if (bipp === 1) {
            return this.draw_1bipp_pixel_buffer_mask_1bipp(pb_1bipp_mask, dest_pos, color);
          } else {
            const arr_on_xspans_implementation = () => {
              const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
              const [width, height2] = pb_1bipp_mask.size;
              let y = 0;
              let [dest_x, dest_y] = dest_pos;
              for (y = 0; y < height2; y++) {
                const arr_row_xspans_on = arr_rows_arr_on_xspans[y];
                if (arr_row_xspans_on.length > 0) {
                  for (const xonspan of arr_row_xspans_on) {
                    xonspan[0] += dest_x;
                    xonspan[1] += dest_x;
                    this.draw_horizontal_line(xonspan, y + dest_y, color);
                  }
                }
              }
            };
            return arr_on_xspans_implementation();
          }
        }
        "blank_copy"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel
          });
          res2.buffer.fill(0);
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "clone"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": this.bits_per_pixel,
            "buffer": new this.buffer.constructor(this.buffer)
          });
          if (this.pos) res2.pos = this.pos;
          return res2;
        }
        "add_alpha_channel"() {
          console.log("add_alpha_channel this.bytes_per_pixel", this.bytes_per_pixel);
          if (this.bytes_per_pixel === 3) {
            var res2 = new this.constructor({
              "size": this.size,
              "bytes_per_pixel": 4
            });
            if (this.pos) res2.pos = this.pos;
            const buf = this.buffer, res_buf = res2.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0, ir = 0;
            for (let p = 0; p < px_count; p++) {
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = buf[i++];
              res_buf[ir++] = 255;
            }
            return res2;
          }
          if (this.bytes_per_pixel === 4) {
            return this;
          }
        }
        "to_8bit_greyscale"() {
          if (this.bytes_per_pixel === 1) {
            return this;
          } else if (this.bytes_per_pixel === 3) {
            const res2 = new this.constructor({
              "size": this.size,
              "bits_per_pixel": 8
            });
            if (this.pos) res2.pos = this.pos;
            const bres = res2.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
              bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res2;
          } else if (this.bytes_per_pixel === 4) {
            const res2 = new this.constructor({
              "size": this.size,
              "bits_per_pixel": 8
            });
            if (this.pos) res2.pos = this.pos;
            const bres = res2.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
              bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res2;
          }
        }
        "to_32bit_rgba"() {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 32
          });
          if (this.pos) res2.pos = this.pos;
          const bres = res2.buffer;
          if (this.bytes_per_pixel === 1) {
            let i = 0, new_v;
            this.each_pixel((pos, v) => {
              bres[i++] = v;
              bres[i++] = v;
              bres[i++] = v;
              bres[i++] = 255;
            });
          } else {
            console.trace();
            throw "NYI";
          }
          return res2;
        }
        "__invert_greyscale_self"() {
          const bres = this.buffer;
          let i = 0;
          this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
          });
          return this;
        }
        "__invert_greyscale"() {
          let res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 8
          });
          if (this.pos) res2.pos = this.pos;
          const bres = res2.buffer;
          let i = 0;
          this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
          });
          return res2;
        }
        draw_rect(pos_corner, pos_other_corner, color) {
          const l2 = Math.min(pos_corner[0], pos_other_corner[0]);
          const t = Math.min(pos_corner[1], pos_other_corner[1]);
          const r = Math.max(pos_corner[0], pos_other_corner[0]);
          const b = Math.max(pos_corner[1], pos_other_corner[1]);
          const xspan = [l2, r];
          for (let y = t; y <= b; y++) {
            this.draw_horizontal_line(xspan, y, color);
          }
        }
        *"iterate_arr_row_x_on_spans_1bipp"(y) {
        }
        get xspans() {
        }
      };
      module.exports = Pixel_Buffer_Core;
      if (__require.main === module) {
        const lg = console.log;
        (async () => {
          const run_examples = async () => {
            lg("Begin run examples");
            const examples = [
              async () => {
                lg("Begin example 0");
                const pb = new Pixel_Buffer_Core({
                  bits_per_pixel: 1,
                  size: [8, 8]
                });
                const ta_pos = new Int16Array(2);
                ta_pos[0] = 3;
                ta_pos[1] = 3;
                pb.set_pixel(ta_pos, 1);
                lg("End example 0");
                return pb;
              }
            ];
            const l2 = examples.length;
            for (var c2 = 0; c2 < l2; c2++) {
              const res_eg = await examples[c2]();
              console.log("res_eg " + c2 + ":", res_eg);
            }
            ;
            lg("End run examples");
          };
          await run_examples();
        })();
      }
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-4-advanced-typedarray-properties.js
  var require_pixel_buffer_4_advanced_typedarray_properties = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-4-advanced-typedarray-properties.js"(exports, module) {
      var lang = require_lib_lang_mini4();
      var {
        each,
        fp,
        tof,
        get_a_sig,
        are_equal,
        tf: tf2
      } = lang;
      var oext = require_oext();
      var { ro, prop } = oext;
      var Pixel_Buffer_Core = require_pixel_buffer_3_core();
      var Pixel_Buffer_Advanced_TypedArray_Properties = class extends Pixel_Buffer_Core {
        constructor(...a) {
          super(...a);
          let ta_scratch;
          let ta_pos_scratch;
          let ta_pos_iterator;
          let ta_move_vector;
          let ta_bounds;
          let ta_24bit_color;
          let ta_32bit_color;
          let ta_row_scratch;
          let ta_bounds_scratch;
          let ta_bounds2_scratch;
          let ta_bounds3_scratch;
          let ta_bounds4_scratch;
          let ta_size_scratch;
          let ta_size2_scratch;
          let ta_pointers_scratch;
          let ta_pointers2_scratch;
          let ta_pointerpair_scratch;
          let ta_offsets_scratch;
          let ta_offsets_info_scratch;
          const setup_ta_ro_props = () => {
            ro(this, "ta_scratch", () => {
              if (!ta_scratch) {
                ta_scratch = new this.ta.constructor(this.ta);
              } else {
                if (ta_scratch.length !== this.ta.length) {
                  ta_scratch = new this.ta.constructor(this.ta);
                } else {
                  const l2 = this.ta.length;
                  for (c = 0; c < l2; c++) {
                    ta_scratch[c] = this.ta[c];
                  }
                }
              }
            });
            ro(this, "ta_row_scratch", () => {
              if (!ta_row_scratch) {
                ta_row_scratch = new Uint8ClampedArray(this.bypr);
              } else {
                if (ta_row_scratch.length !== this.bypr) {
                  ta_row_scratch = new Uint8ClampedArray(this.bypr);
                }
                return ta_row_scratch;
              }
            });
            ro(this, "ta_pos_scratch", () => {
              if (!ta_pos_scratch) {
                ta_pos_scratch = new Int16Array(2);
              }
              return ta_pos_scratch;
            });
            ro(this, "ta_pos_iterator", () => {
              if (!ta_pos_iterator) {
                ta_pos_iterator = new Int16Array(2);
              }
              return ta_pos_iterator;
            });
            ro(this, "ta_move_vector", () => {
              if (!ta_move_vector) {
                ta_move_vector = new Int16Array(2);
              }
              return ta_move_vector;
            });
            ro(this, "ta_bounds", () => {
              if (!ta_bounds) {
                ta_bounds = new Int16Array(4);
              }
              return ta_bounds;
            });
            ro(this, "ta_24bit_color", () => {
              if (!ta_24bit_color) {
                ta_24bit_color = new Uint8ClampedArray(3);
              }
              return ta_24bit_color;
            });
            ro(this, "ta_32bit_color", () => {
              if (!ta_32bit_color) {
                ta_32bit_color = new Uint8ClampedArray(4);
              }
              return ta_32bit_color;
            });
            ro(this, "ta_bounds_scratch", () => {
              if (!ta_bounds_scratch) {
                ta_bounds_scratch = new Int16Array(4);
              }
              return ta_bounds_scratch;
            });
            ro(this, "ta_bounds2_scratch", () => {
              if (!ta_bounds2_scratch) {
                ta_bounds2_scratch = new Int16Array(4);
              }
              return ta_bounds2_scratch;
            });
            ro(this, "ta_bounds3_scratch", () => {
              if (!ta_bounds3_scratch) {
                ta_bounds3_scratch = new Int16Array(4);
              }
              return ta_bounds3_scratch;
            });
            ro(this, "ta_bounds4_scratch", () => {
              if (!ta_bounds4_scratch) {
                ta_bounds4_scratch = new Int16Array(4);
              }
              return ta_bounds4_scratch;
            });
            ro(this, "ta_size_scratch", () => {
              if (!ta_size_scratch) {
                ta_size_scratch = new Uint16Array(2);
              }
              return ta_size_scratch;
            });
            ro(this, "ta_size2_scratch", () => {
              if (!ta_size2_scratch) {
                ta_size2_scratch = new Uint16Array(2);
              }
              return ta_size2_scratch;
            });
            ro(this, "ta_pointers_scratch", () => {
              if (!ta_pointers_scratch) {
                ta_pointers_scratch = new Uint32Array(4);
              }
              return ta_pointers_scratch;
            });
            ro(this, "ta_pointers2_scratch", () => {
              if (!ta_pointers2_scratch) {
                ta_pointers2_scratch = new Uint32Array(4);
              }
              return ta_pointers2_scratch;
            });
            ro(this, "ta_pointerpair_scratch", () => {
              if (!ta_pointerpair_scratch) {
                ta_pointerpair_scratch = new Uint32Array(2);
              }
              return ta_pointerpair_scratch;
            });
            ro(this, "ta_offsets_scratch", () => {
              if (!ta_offsets_scratch) {
                ta_offsets_scratch = new Int32Array(4);
              }
              return ta_offsets_scratch;
            });
            ro(this, "ta_offsets_info_scratch", () => {
              if (!ta_offsets_info_scratch) {
                ta_offsets_info_scratch = new Int32Array(8);
              }
              return ta_offsets_info_scratch;
            });
          };
          setup_ta_ro_props();
          const ta_colorspace = new Int16Array(6);
          Object.defineProperty(this, "ta_colorspace", {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
              ta_colorspace[0] = this.size[0];
              ta_colorspace[1] = this.size[1];
              let bpp = 0;
              if (this.ta_bpp && typeof this.ta_bpp[0] === "number") {
                bpp = this.ta_bpp[0];
              } else if (typeof this.bits_per_pixel === "number") {
                bpp = this.bits_per_pixel;
              } else if (typeof this.bytes_per_pixel === "number") {
                bpp = this.bytes_per_pixel * 8;
              }
              ta_colorspace[2] = bpp % 8 === 0 ? bpp / 8 : 0;
              ta_colorspace[3] = ta_colorspace[2] * ta_colorspace[0];
              ta_colorspace[4] = bpp;
              ta_colorspace[5] = ta_colorspace[4] * ta_colorspace[0];
              return ta_colorspace;
            },
            enumerable: true,
            configurable: false
          });
        }
      };
      module.exports = Pixel_Buffer_Advanced_TypedArray_Properties;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/convolution-kernels/kernels.js
  var require_kernels = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/convolution-kernels/kernels.js"(exports, module) {
      function generateGaussianKernel(dimension, sigma) {
        function hypotenuse(x1, y1, x2, y2) {
          var xSquare = Math.pow(x1 - x2, 2);
          var ySquare = Math.pow(y1 - y2, 2);
          return Math.sqrt(xSquare + ySquare);
        }
        if (!(dimension % 2) || Math.floor(dimension) !== dimension || dimension < 3) {
          throw new Error(
            "The dimension must be an odd integer greater than or equal to 3"
          );
        }
        var kernel = [];
        var twoSigmaSquare = 2 * sigma * sigma;
        var centre = (dimension - 1) / 2;
        for (var i = 0; i < dimension; i++) {
          for (var j = 0; j < dimension; j++) {
            var distance = hypotenuse(i, j, centre, centre);
            var gaussian = 1 / Math.sqrt(
              Math.PI * twoSigmaSquare
            ) * Math.exp(-1 * (Math.pow(distance, 2) / twoSigmaSquare));
            kernel.push(gaussian);
          }
        }
        var sum = kernel.reduce(function(c2, p) {
          return c2 + p;
        });
        return kernel.map(function(e) {
          return e / sum;
        });
      }
      module.exports = {
        "edge": new Float32Array(
          [
            -1,
            -1,
            -1,
            -1,
            8,
            -1,
            -1,
            -1,
            -1
          ]
        ),
        "gauss_blur_5_2": generateGaussianKernel(5, 2),
        "gauss_blur_5_5": generateGaussianKernel(5, 5),
        "get_gauss": (d, sigma) => new Float32Array(generateGaussianKernel(d, sigma)),
        "lap_gauss_5": new Int8Array([
          0,
          0,
          -1,
          0,
          0,
          0,
          -1,
          -2,
          -1,
          0,
          -1,
          -2,
          16,
          -2,
          -1,
          0,
          -1,
          -2,
          -1,
          0,
          0,
          0,
          -1,
          0,
          0
        ]),
        "sobel_x": new Int8Array([
          -1,
          0,
          1,
          -2,
          0,
          2,
          -1,
          0,
          1
        ]),
        "sobel_y": new Int8Array([
          1,
          2,
          1,
          0,
          0,
          0,
          -1,
          -2,
          -1
        ]),
        "sobel_diag_1": new Int8Array([
          0,
          1,
          2,
          -1,
          0,
          1,
          -2,
          -1,
          0
        ]),
        "sobel_diag_2": new Int8Array([
          -2,
          -1,
          0,
          -1,
          0,
          1,
          0,
          1,
          2
        ])
      };
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-5-idiomatic-enh.js
  var require_pixel_buffer_5_idiomatic_enh = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-5-idiomatic-enh.js"(exports, module) {
      var Pixel_Buffer_Advanced_TypedArray_Properties = require_pixel_buffer_4_advanced_typedarray_properties();
      var kernels = require_kernels();
      var Pixel_Buffer_Idiomatic_Enh = class extends Pixel_Buffer_Advanced_TypedArray_Properties {
        constructor(...a) {
          super(...a);
        }
        each_pixel_pos(callback2) {
          const { ta_pos_scratch, size } = this;
          let ctu = true;
          const stop = () => {
            ctu = false;
          };
          for (ta_pos_scratch[1] = 0; ctu === true && ta_pos_scratch[1] < size[1]; ta_pos_scratch[1]++) {
            for (ta_pos_scratch[0] = 0; ctu === true && ta_pos_scratch[0] < size[0]; ta_pos_scratch[0]++) {
              callback2(ta_pos_scratch, stop);
            }
          }
        }
        count_colors() {
          const map_colors = {};
          let res2 = 0;
          this.each_pixel_ta((pos, color) => {
            const colstr = color.toString();
            if (!map_colors[colstr]) {
              map_colors[colstr] = true;
              res2++;
            }
          });
          return res2;
        }
        blur(size = 3, sigma = 2) {
          let kernel = kernels.get_gauss(size, sigma);
          return this.apply_square_convolution(kernel);
        }
        count_pixels_with_color(color) {
          let res2 = 0;
          console.log("idiomatic count_pixels_with_color");
          const { bipp } = this;
          if (bipp <= 8) {
            this.each_pixel((pos, pixel_color) => {
              if (pixel_color === color) res2++;
            });
          } else if (bipp === 24) {
            this.each_pixel((pos, pixel_color) => {
              if (pixel_color[0] === color[0] && pixel_color[1] === color[1] && pixel_color[2] === color[2]) {
                res2++;
              }
            });
          } else if (bipp === 32) {
            this.each_pixel((pos, pixel_color) => {
              if (pixel_color[0] === color[0] && pixel_color[1] === color[1] && pixel_color[2] === color[2] && pixel_color[3] === color[3]) {
                res2++;
              }
            });
          } else {
            console.trace();
            throw "NYI";
          }
          return res2;
        }
      };
      module.exports = Pixel_Buffer_Idiomatic_Enh;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-6-perf-focus-enh.js
  var require_pixel_buffer_6_perf_focus_enh = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-6-perf-focus-enh.js"(exports, module) {
      var Pixel_Buffer_Idiomatic_Enh = require_pixel_buffer_5_idiomatic_enh();
      var Pixel_Pos_List = require_pixel_pos_list();
      var get_idx_movement_vectors = (f32a_convolution, bpp, bpr) => {
        const c_length = f32a_convolution.length;
        const dimension_size = Math.sqrt(c_length);
        const padding = (dimension_size - 1) / 2;
        const movement_vectors = new Int8Array(c_length * 2);
        let x, y, pos = 0;
        const idx_movement_vectors = new Int16Array(c_length);
        for (y = -1 * padding; y <= padding; y++) {
          for (x = -1 * padding; x <= padding; x++) {
            movement_vectors[pos++] = x;
            movement_vectors[pos++] = y;
          }
        }
        pos = 0;
        let ii, i;
        for (i = 0; i < c_length; i++) {
          x = movement_vectors[pos++];
          y = movement_vectors[pos++];
          idx_movement_vectors[i] = x * bpp + y * bpr;
        }
        return idx_movement_vectors;
      };
      var get_points_bounding_box = (points) => {
        let min_x = Number.POSITIVE_INFINITY;
        let min_y = Number.POSITIVE_INFINITY;
        let max_x = Number.NEGATIVE_INFINITY;
        let max_y = Number.NEGATIVE_INFINITY;
        for (const [x, y] of points) {
          if (x < min_x) min_x = x;
          if (x > max_x) max_x = x;
          if (y < min_y) min_y = y;
          if (y > max_y) max_y = y;
        }
        return [
          [min_x, min_y],
          [max_x, max_y]
        ];
      };
      var Pixel_Buffer_Perf_Focus_Enh = class extends Pixel_Buffer_Idiomatic_Enh {
        constructor(spec) {
          super(spec);
        }
        get ta_is_64bit_divisible() {
          return (this.ta.length & 63) === 0;
        }
        get ta_is_32bit_divisible() {
          return (this.ta.length & 31) === 0;
        }
        get ta64() {
          if (this._ta64) {
            return this._ta64;
          } else {
          }
          if (this.ta_is_64bit_divisible) {
            if (this.ta.byteOffset % 8 === 0) {
              this._ta64 = new BigUint64Array(this.ta.buffer, this.ta.byteOffset, this.ta.byteLength / 8);
              return this._ta64;
            } else {
              console.error("The byte offset is not aligned to 8 bytes.");
            }
          } else {
            return false;
          }
        }
        get is_32bit_divisible_image() {
          return (this.ta.length & 31) === 0;
        }
        get is_32_divisible_bits_per_row() {
          return (this.bits_per_row & 31) === 0;
        }
        get number_of_32bit_segments_per_32bit_divisible_row() {
          return this.bits_per_row >> 5;
        }
        get is_64bit_divisible_image() {
          return (this.ta.length & 63) === 0;
        }
        get is_64_divisible_bits_per_row() {
          return (this.bits_per_row & 63) === 0;
        }
        get number_of_64bit_segments_per_64bit_divisible_row() {
          return this.bits_per_row >> 6;
        }
        get bits_per_image_1bipp() {
          return this.size[0] * this.size[1];
        }
        get number_of_64bit_segments_per_64bit_divisible_image() {
          return this.bits_per_image_1bipp >> 6;
        }
        iterate_all_ui32_locations_1bipp(cb) {
          const ui32a_px_range = new Uint32Array(4);
          if (this.ta_is_32bit_divisible) {
            if (this.is_32_divisible_bits_per_row) {
              const number_of_32bit_segments_per_32bit_divisible_row = this.number_of_32bit_segments_per_32bit_divisible_row;
              if (number_of_32bit_segments_per_32bit_divisible_row === 1) {
                const height2 = this.size[1];
                const first_x = 0, last_x = 31;
                ui32a_px_range[0] = first_x;
                ui32a_px_range[2] = last_x;
                let y = 0;
                for (let i = 0; i < height2; i++) {
                  ui32a_px_range[1] = y;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  y++;
                }
              } else if (number_of_32bit_segments_per_32bit_divisible_row === 2) {
                const height2 = this.size[1];
                const number_of_32bit_segments = height2 * number_of_32bit_segments_per_32bit_divisible_row;
                let even = true;
                let y = 0;
                let first_x = 0, last_x = 63;
                for (let i = 0; i < number_of_32bit_segments; i++) {
                  ui32a_px_range[0] = first_x;
                  ui32a_px_range[1] = y;
                  ui32a_px_range[2] = last_x;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  if (!even) {
                    y++;
                    first_x = 0;
                    last_x = 31;
                  } else {
                    first_x = 32;
                    last_x = 63;
                  }
                  even = !even;
                }
              } else {
                const height2 = this.size[1];
                const number_of_32bit_segments = height2 * number_of_32bit_segments_per_32bit_divisible_row;
                let y = 0;
                let first_x = 0, last_x = 31;
                let i_row_segment = 0;
                for (let i = 0; i < number_of_32bit_segments; i++) {
                  ui32a_px_range[0] = first_x;
                  ui32a_px_range[1] = y;
                  ui32a_px_range[2] = last_x;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  i_row_segment++;
                  if (i_row_segment < number_of_32bit_segments_per_32bit_divisible_row) {
                    first_x += 32;
                    last_x += 32;
                  } else {
                    i_row_segment = 0;
                    y++;
                    first_x = 0;
                    last_x = 31;
                  }
                }
              }
            } else {
            }
          } else {
          }
        }
        iterate_all_ui32_locations_values_prev_values_prev_shifted_values_toggle_locations_1bipp(cb) {
          const ui32a_res = new Uint32Array(12);
          if (this.ta_is_32bit_divisible) {
            const { ta: ta2 } = this;
            const dv = new DataView(ta2.buffer, ta2.byteOffset, ta2.byteLength);
            if (this.is_32_divisible_bits_per_row) {
              const number_of_32bit_segments_per_32bit_divisible_row = this.number_of_32bit_segments_per_32bit_divisible_row;
              if (number_of_32bit_segments_per_32bit_divisible_row === 1) {
                const height2 = this.size[1];
                const first_x = 0, last_x = 31;
                ui32a_res[0] = first_x;
                ui32a_res[2] = last_x;
                let y = 0;
                let b = 0;
                for (let i = 0; i < height2; i++) {
                  ui32a_res[1] = y;
                  ui32a_res[3] = y;
                  const ui32_value = dv.getUint32(b);
                  ui32a_res[5] = ui32_value;
                  cb(ui32a_res);
                  y++;
                  b += 4;
                }
              } else if (number_of_32bit_segments_per_32bit_divisible_row === 2) {
                const height2 = this.size[1];
                const number_of_32bit_segments = height2 * number_of_32bit_segments_per_32bit_divisible_row;
                let even = true;
                let y = 0;
                let b = 0;
                let first_x = 0, last_x = 63;
                let ui32_prev_value = 0;
                for (let i = 0; i < number_of_32bit_segments; i++) {
                  ui32a_res[0] = first_x;
                  ui32a_res[1] = y;
                  ui32a_res[2] = last_x;
                  ui32a_res[3] = y;
                  const ui32_value = dv.getUint32(b);
                  ui32a_res[4] = ui32_prev_value;
                  ui32a_res[5] = ui32_value;
                  cb(ui32a_res);
                  if (!even) {
                    y++;
                    first_x = 0;
                    last_x = 31;
                  } else {
                    first_x = 32;
                    last_x = 63;
                  }
                  even = !even;
                  b += 4;
                  ui32_prev_value = ui32_value;
                }
              } else {
                const height2 = this.size[1];
                const number_of_32bit_segments = height2 * number_of_32bit_segments_per_32bit_divisible_row;
                let y = 0;
                let first_x = 0, last_x = 31;
                let i_row_segment = 0;
                let b = 0;
                let ui32_prev_value = 0;
                for (let i = 0; i < number_of_32bit_segments; i++) {
                  ui32a_res[0] = first_x;
                  ui32a_res[1] = y;
                  ui32a_res[2] = last_x;
                  ui32a_res[3] = y;
                  const ui32_value = dv.getUint32(b);
                  ui32a_res[4] = ui32_prev_value;
                  ui32a_res[5] = ui32_value;
                  if (first_x === 0) {
                    ui32a_res[6] = 0;
                  } else {
                    ui32a_res[6] = ui32_prev_value << 31;
                  }
                  ui32a_res[7] = ui32_value >>> 1;
                  ui32a_res[8] = ui32a_res[6] | ui32a_res[7];
                  ui32a_res[9] = ui32_value ^ ui32a_res[8];
                  cb(ui32a_res);
                  i_row_segment++;
                  if (i_row_segment < number_of_32bit_segments_per_32bit_divisible_row) {
                    first_x += 32;
                    last_x += 32;
                  } else {
                    i_row_segment = 0;
                    y++;
                    first_x = 0;
                    last_x = 31;
                  }
                  b += 4;
                  ui32_prev_value = ui32_value;
                }
              }
            } else {
            }
          } else {
          }
        }
        iterate_all_ui64_locations_1bipp(cb) {
          const ui32a_px_range = new Uint32Array(4);
          if (this.ta_is_64bit_divisible) {
            if (this.is_64_divisible_bits_per_row) {
              const number_of_64bit_segments_per_64bit_divisible_row = this.number_of_64bit_segments_per_64bit_divisible_row;
              if (number_of_64bit_segments_per_64bit_divisible_row === 1) {
                const height2 = this.size[1];
                const first_x = 0, last_x = 63;
                ui32a_px_range[0] = first_x;
                ui32a_px_range[2] = last_x;
                let y = 0;
                for (let i = 0; i < height2; i++) {
                  ui32a_px_range[1] = y;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  y++;
                }
              } else if (number_of_64bit_segments_per_64bit_divisible_row === 2) {
                const height2 = this.size[1];
                const number_of_64bit_segments = height2 * number_of_64bit_segments_per_64bit_divisible_row;
                let even = true;
                let y = 0;
                let first_x = 0, last_x = 63;
                for (let i = 0; i < number_of_64bit_segments; i++) {
                  ui32a_px_range[0] = first_x;
                  ui32a_px_range[1] = y;
                  ui32a_px_range[2] = last_x;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  if (!even) {
                    y++;
                    first_x = 0;
                    last_x = 63;
                  } else {
                    first_x = 64;
                    last_x = 127;
                  }
                  even = !even;
                }
              } else {
                const height2 = this.size[1];
                const number_of_64bit_segments = height2 * number_of_64bit_segments_per_64bit_divisible_row;
                let y = 0;
                let first_x = 0, last_x = 63;
                let i_row_segment = 0;
                for (let i = 0; i < number_of_64bit_segments; i++) {
                  ui32a_px_range[0] = first_x;
                  ui32a_px_range[1] = y;
                  ui32a_px_range[2] = last_x;
                  ui32a_px_range[3] = y;
                  cb(ui32a_px_range);
                  i_row_segment++;
                  if (i_row_segment < number_of_64bit_segments_per_64bit_divisible_row) {
                    first_x += 64;
                    last_x += 64;
                  } else {
                    i_row_segment = 0;
                    y++;
                    first_x = 0;
                    last_x = 63;
                  }
                }
              }
            } else {
            }
          } else {
          }
        }
        iterate_all_ui64_values_1bipp() {
        }
        iterate_1bipp_wrapping_x_span_color_toggles(cb) {
          const { ta: ta2 } = this;
          const r1shifted_ta = right_shift_32bit_with_carry(ta2);
          const xored_against_orig = xor_typed_arrays(ta2, r1shifted_ta);
          each_1_index(xored_against_orig, cb);
        }
        count_1bipp_wrapping_x_span_color_toggles() {
          const { ta: ta2 } = this;
          const r1shifted_ta = right_shift_32bit_with_carry(ta2);
          const xored_against_orig = xor_typed_arrays(ta2, r1shifted_ta);
          return count_1s(xored_against_orig);
        }
        "place_image_from_pixel_buffer"(pixel_buffer, dest_pos, options = {}) {
          const { bipp } = this;
          const dest_buffer = this.buffer;
          const source_buffer = pixel_buffer.buffer;
          if (bipp === 32 && pixel_buffer.bits_per_pixel === 32) {
            const dest_w = this.size[0];
            const dest_h = this.size[1];
            const dest_buffer_line_length = dest_w * 4;
            const source_w = pixel_buffer.size[0];
            const source_h = pixel_buffer.size[1];
            const source_buffer_line_length = source_w * 4;
            let source_buffer_line_start_pos, source_buffer_line_end_pos, dest_buffer_subline_start_pos, dest_buffer_start_offset;
            dest_buffer_start_offset = dest_pos[0] * 4;
            for (var y = 0; y < source_h; y++) {
              source_buffer_line_start_pos = y * source_buffer_line_length;
              source_buffer_line_end_pos = source_buffer_line_start_pos + source_buffer_line_length;
              dest_buffer_subline_start_pos = (y + dest_pos[1]) * dest_buffer_line_length;
              source_buffer.copy(dest_buffer, dest_buffer_subline_start_pos + dest_buffer_start_offset, source_buffer_line_start_pos, source_buffer_line_end_pos);
            }
          } else if (bipp === 1) {
            if (pixel_buffer.bipp === 1) {
              if (options.or === true) {
                return this.draw_1bipp_pixel_buffer_mask_1bipp(pixel_buffer, dest_pos);
              } else {
                const pb_source2 = pixel_buffer;
                const ta_pos = new Int16Array(2);
                const ta_px_value = new Uint8ClampedArray(3);
                const ta_info = new Uint32Array(4);
                const px_dest_pos = new Uint16Array(2);
                pb_source2.each_ta_1bipp(ta_pos, ta_px_value, ta_info, (color, pos) => {
                  px_dest_pos[0] = pos[0] + dest_pos[0];
                  px_dest_pos[1] = pos[1] + dest_pos[1];
                  this.set_pixel(px_dest_pos, color);
                });
              }
            } else {
              console.trace();
              throw "must have matching bipp values (expected: 1)";
            }
          } else {
            console.trace();
            console.log("[pixel_buffer, dest_pos, options]", [pixel_buffer, dest_pos, options]);
            throw "not currently supported";
          }
        }
        draw_filled_polygon_to_1bipp_pixel_buffer_mask(arr_points) {
          if (arr_points.length >= 2) {
            const bb_points = get_points_bounding_box(arr_points);
            const offset2 = bb_points[0];
            const polygon_size2 = [
              [bb_points[1][0] - bb_points[0][0] + 1],
              [bb_points[1][1] - bb_points[0][1] + 1]
            ];
            if (polygon_size2[0] === 1 && polygon_size2[1] === 1) {
              const pb_polygon = new this.constructor({
                "bits_per_pixel": 1,
                "size": polygon_size2
              });
              pb_polygon.ta[0] = 128;
              pb_polygon.__offset = offset2;
              return pb_polygon;
            } else if (polygon_size2[0] === 2 && polygon_size2[1] === 1 || polygon_size2[0] === 1 && polygon_size2[1] === 2) {
              const pb_polygon = new this.constructor({
                "bits_per_pixel": 1,
                "size": polygon_size2
              });
              pb_polygon.ta[0] = 192;
              pb_polygon.__offset = offset2;
              return pb_polygon;
            } else {
              const pb_polygon = new this.constructor({
                "bits_per_pixel": 1,
                "size": polygon_size2
              });
              const down_offsetted_points = arr_points.map((point) => [point[0] - offset2[0], point[1] - offset2[1]]);
              pb_polygon.draw_polygon(down_offsetted_points, 1, false);
              pb_polygon.flood_fill_inner_pixels_off_to_on_1bipp();
              pb_polygon.__offset = offset2;
              return pb_polygon;
            }
          } else if (arr_points.length === 1) {
            const pb_polygon = new this.constructor({
              "bits_per_pixel": 1,
              "size": polygon_size
            });
            pb_polygon.ta[0] = 128;
            pb_polygon.__offset = offset;
            return pb_polygon;
          }
        }
        get ta2() {
          if (!this._ta2) {
            this._ta2 = new Uint8Array(this.ta.length);
          }
          return this._ta2;
        }
        apply_square_convolution(f32a_convolution) {
          return this.process((orig, res2) => {
            const c_length = f32a_convolution.length;
            const dimension_size = Math.sqrt(c_length);
            const padding = (dimension_size - 1) / 2;
            let x, y, pos = 0, ii, i;
            const bpp = this.bytes_per_pixel;
            const bpr = this.bytes_per_row;
            const idx_movement_vectors = get_idx_movement_vectors(f32a_convolution, bpp, bpr);
            let cr, cg, cb, ca;
            const buf = this.buffer;
            const buf_res = res2.buffer;
            if (bpp === 3) {
              this.padded_each_pixel_index(padding, (px_idx) => {
                cr = 0;
                cg = 0;
                cb = 0;
                for (ii = 0; ii < c_length; ii++) {
                  i = px_idx + idx_movement_vectors[ii];
                  cr += f32a_convolution[ii] * buf[i++];
                  cg += f32a_convolution[ii] * buf[i++];
                  cb += f32a_convolution[ii] * buf[i++];
                }
                if (cr < 0) cr = 0;
                if (cg < 0) cg = 0;
                if (cb < 0) cb = 0;
                if (cr > 255) cr = 255;
                if (cg > 255) cg = 255;
                if (cb > 255) cb = 255;
                buf_res[px_idx++] = Math.round(cr);
                buf_res[px_idx++] = Math.round(cg);
                buf_res[px_idx++] = Math.round(cb);
              });
            } else if (bpp === 4) {
              this.padded_each_pixel_index(padding, (px_idx) => {
                cr = 0;
                cg = 0;
                cb = 0;
                for (ii = 0; ii < c_length; ii++) {
                  i = px_idx + idx_movement_vectors[ii];
                  cr += f32a_convolution[ii] * buf[i++];
                  cg += f32a_convolution[ii] * buf[i++];
                  cb += f32a_convolution[ii] * buf[i++];
                }
                ca = 255;
                if (cr < 0) cr = 0;
                if (cg < 0) cg = 0;
                if (cb < 0) cb = 0;
                if (cr > 255) cr = 255;
                if (cg > 255) cg = 255;
                if (cb > 255) cb = 255;
                buf_res[px_idx++] = Math.round(cr);
                buf_res[px_idx++] = Math.round(cg);
                buf_res[px_idx++] = Math.round(cb);
                buf_res[px_idx++] = Math.round(ca);
              });
            } else {
              throw "NYI";
            }
            return res2;
          });
        }
        extract_channel(i_channel) {
          const bypp2 = this.bytes_per_pixel;
          const ta2 = this.ta;
          let i_byte = i_channel;
          let i_px = 0;
          const l2 = ta2.length;
          if (bypp2 === 3 || bypp2 === 4) {
            const res_channel_ta = new this.constructor({
              size: this.size,
              bits_per_pixel: 8
            });
            while (i_byte < l2) {
              res_channel_ta.set_pixel_by_idx(i_px, ta2[i_byte]);
              i_byte += bypp2;
              i_px++;
            }
            return res_channel_ta;
          } else {
            console.trace();
            throw "NYI";
          }
        }
        _custom_convolve(dimension_size, cb) {
          if (dimension_size % 2 !== 1) {
            throw "dimension_size must be an odd integer";
          }
          const px = new Uint16Array(2);
          const ta16 = new Int16Array(12);
          [ta16[2], ta16[3]] = this.size;
          ta16[4] = this.bytes_per_pixel;
          ta16[5] = ta16[2] * ta16[4];
          ta16[8] = dimension_size;
          ta16[9] = (ta16[8] - 1) / 2;
          ta16[10] = 0;
          ta16[11] = ta16[8] * ta16[4];
          let ta32 = new Uint32Array(4);
          ta32[0] = 0;
          ta32[1] = 0;
          ta32[2] = ta16[2] * ta16[3] * ta16[4];
          let conv_pixels = new Uint8Array(ta16[8] * ta16[8] * ta16[8]);
          const buffer = this.buffer;
          for (px[1] = 0; px[1] < ta16[3]; px[1]++) {
            for (px[0] = 0; px[0] < ta16[2]; px[0]++) {
              ta16[6] = px[0] - ta16[8];
              if (ta16[6] > 0 && ta16[6] < ta16[2] - ta16[8]) {
                ta16[7] = px[1] - ta16[8];
                if (ta16[7] > 0 && ta16[7] < ta16[3] - ta16[8]) {
                  ta32[1] = ta32[0] - ta16[9] * ta16[4] - ta16[9] * ta16[5];
                  ta16[10] = 0;
                  for (ta16[7] = ta16[1]; ta16[7] < ta16[1] + ta16[8]; ta16[7]++) {
                    let sl = buffer.slice(ta32[1], ta32[1] + ta16[11]);
                    for (let c2 = 0; c2 < ta16[11]; c2++) {
                      conv_pixels[ta16[10] + c2] = sl.readUInt8(c2);
                    }
                    ta16[10] += ta16[11];
                    ta32[1] += ta16[5];
                  }
                  cb(px, conv_pixels);
                }
              }
              ta32[0] += ta16[4];
            }
          }
        }
        get_first_pixel_matching_color(r, g, b, a) {
          let px = 0, py = 0;
          let [w, h] = this.size;
          let found = false;
          let buf = this.buffer;
          let pos_buf = 0;
          for (py = 0; !found && py < h; py++) {
            for (px = 0; !found && px < w; px++) {
              if (buf[pos_buf] === r && buf[pos_buf + 1] === g && buf[pos_buf + 2] === b && buf[pos_buf + 3] === a) {
                found = true;
              }
              pos_buf += 4;
            }
          }
          if (found) {
            return [px, py];
          }
        }
        "flood_fill_small_color_blocks"(max_size, r, g, b, a) {
          this.each_pixel((x, y, pr, pg, pb, pa) => {
            if (r !== pr || g !== pg || b !== pb || a !== pa) {
              let s = this.measure_color_region_size(x, y, max_size);
              if (s < max_size) {
                this.flood_fill(x, y, r, g, b, a);
              }
            }
          });
        }
        self_replace_color(target_color, replacement_color) {
          const bpp = this.bytes_per_pixel;
          const buf = this.buffer;
          const l2 = buf.length;
          if (bpp === 1) {
            for (let c2 = 0; c2 < l2; c2++) {
              if (buf[c2] === target_color) buf[c2] = replacement_color;
            }
          } else {
            throw "NYI";
          }
          return this;
        }
        "_replace_color"(r, g, b, a, tr, tg, tb, ta2) {
          const buf_read = this.buffer;
          let ta_u8 = new Uint8Array(8);
          ta_u8[0] = r;
          ta_u8[1] = g;
          ta_u8[2] = b;
          ta_u8[3] = a;
          ta_u8[4] = tr;
          ta_u8[5] = tg;
          ta_u8[6] = tb;
          ta_u8[7] = ta2;
          const ta_16_scratch = new Uint32Array(8);
          ta_16_scratch[0] = 0;
          ta_16_scratch[2] = buf_read.length;
          while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]] === ta_u8[0] && buf_read[ta_16_scratch[0] + 1] === ta_u8[1] && buf_read[ta_16_scratch[0] + 2] === ta_u8[2] && buf_read[ta_16_scratch[0] + 3] === ta_u8[3]) {
              buf_read[ta_16_scratch[0]] = ta_u8[4];
              buf_read[ta_16_scratch[0] + 1] = ta_u8[5];
              buf_read[ta_16_scratch[0] + 2] = ta_u8[6];
              buf_read[ta_16_scratch[0] + 3] = ta_u8[7];
            } else {
            }
            ta_16_scratch[0] += 4;
          }
        }
        "__get_single_color_mask_32"(r, g, b, a) {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 32
          });
          res2.buffer.fill(0);
          const buf_read = this.buffer;
          const buf_write = res2.buffer;
          const ta_16_scratch = new Uint32Array(8);
          ta_16_scratch[0] = 0;
          ta_16_scratch[1] = 0;
          ta_16_scratch[2] = buf_read.length;
          ta_16_scratch[3] = buf_write.length;
          let ta_u8 = new Uint8Array(4);
          ta_u8[0] = r;
          ta_u8[1] = g;
          ta_u8[2] = b;
          ta_u8[3] = a;
          while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]] === ta_u8[0] && buf_read[ta_16_scratch[0] + 1] === ta_u8[1] && buf_read[ta_16_scratch[0] + 2] === ta_u8[2] && buf_read[ta_16_scratch[0] + 3] === ta_u8[3]) {
              buf_write[ta_16_scratch[1]++] = 0;
              buf_write[ta_16_scratch[1]++] = 0;
              buf_write[ta_16_scratch[1]++] = 0;
              buf_write[ta_16_scratch[1]++] = 255;
            } else {
              buf_write[ta_16_scratch[1]++] = 255;
              buf_write[ta_16_scratch[1]++] = 255;
              buf_write[ta_16_scratch[1]++] = 255;
              buf_write[ta_16_scratch[1]++] = 255;
            }
            ta_16_scratch[0] += 4;
          }
          return res2;
        }
        count_pixels_with_color(...args) {
          const { bipp } = this;
          if (bipp === 32) {
            const [r, g, b, a] = args;
            const buf_read = this.buffer;
            const scratch_32 = new Uint32Array(5);
            scratch_32[0] = 0;
            scratch_32[2] = buf_read.length;
            scratch_32[4] = 0;
            const ta_16_scratch = new Uint16Array(8);
            let ta_u8 = new Uint8Array(4);
            ta_u8[0] = r;
            ta_u8[1] = g;
            ta_u8[2] = b;
            ta_u8[3] = a;
            while (scratch_32[0] < scratch_32[2]) {
              if (buf_read[scratch_32[0]++] === ta_u8[0] && buf_read[scratch_32[0]++] === ta_u8[1] && buf_read[scratch_32[0]++] === ta_u8[2] && buf_read[scratch_32[0]++] === ta_u8[3]) {
                scratch_32[4]++;
              }
            }
            return scratch_32[4];
          } else {
            return super.count_pixels_with_color(...args);
          }
        }
        "__get_single_color_mask"(r, g, b, a) {
          var res2 = new this.constructor({
            "size": this.size,
            "bits_per_pixel": 8
          });
          res2.buffer.fill(0);
          const buf_read = this.buffer;
          const buf_write = res2.buffer;
          const ta_16_scratch = new Uint16Array(8);
          ta_16_scratch[0] = 0;
          ta_16_scratch[1] = 0;
          ta_16_scratch[2] = buf_read.length;
          ta_16_scratch[3] = buf_write.length;
          let ta_u8 = new Uint8Array(4);
          ta_u8[0] = r;
          ta_u8[1] = g;
          ta_u8[2] = b;
          ta_u8[3] = a;
          while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]++] === ta_u8[0] && buf_read[ta_16_scratch[0]++] === ta_u8[1] && buf_read[ta_16_scratch[0]++] === ta_u8[2] && buf_read[ta_16_scratch[0]++] === ta_u8[3]) {
              buf_write[ta_16_scratch[1]] = 255;
            }
            ta_16_scratch[1]++;
          }
          return res2;
        }
        "measure_color_region_size"(x, y, max) {
          const buffer = this.buffer;
          if (this.bytes_per_pixel === 4) {
            const scratch_32 = new Uint32Array(16);
            scratch_32[0] = this.size[0];
            scratch_32[1] = this.size[1];
            scratch_32[2] = scratch_32[0] * scratch_32[1];
            scratch_32[3] = this.bytes_per_pixel;
            scratch_32[6] = 0;
            scratch_32[7] = 0;
            scratch_32[8] = 0;
            scratch_32[9] = max;
            const ta8_pixels = new Uint8Array(12);
            scratch_32[10] = 0;
            const ta16_pixels = new Uint8Array(4);
            const ta_pixels_visited = new Uint8Array(scratch_32[2]);
            const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
            scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
            ta8_pixels[0] = buffer[scratch_32[8]++];
            ta8_pixels[1] = buffer[scratch_32[8]++];
            ta8_pixels[2] = buffer[scratch_32[8]++];
            ta8_pixels[3] = buffer[scratch_32[8]++];
            ta_visiting_pixels[0] = x;
            ta_visiting_pixels[1] = y;
            scratch_32[7] = 2;
            while (scratch_32[6] < scratch_32[7] && scratch_32[10] < scratch_32[9]) {
              scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
              scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
              scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
              ta8_pixels[4] = buffer[scratch_32[8]++];
              ta8_pixels[5] = buffer[scratch_32[8]++];
              ta8_pixels[6] = buffer[scratch_32[8]++];
              ta8_pixels[7] = buffer[scratch_32[8]++];
              ta16_pixels[0] = ta8_pixels[4] - ta8_pixels[0];
              ta16_pixels[1] = ta8_pixels[5] - ta8_pixels[1];
              ta16_pixels[2] = ta8_pixels[6] - ta8_pixels[2];
              ta16_pixels[3] = ta8_pixels[7] - ta8_pixels[3];
              if (ta16_pixels[0] === 0 && ta16_pixels[1] === 0 && ta16_pixels[2] === 0 && ta16_pixels[3] === 0) {
                if (scratch_32[4] - 1 >= 0 && scratch_32[4] - 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                  ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                }
                if (scratch_32[5] - 1 >= 0 && scratch_32[5] - 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                  ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                }
                if (scratch_32[4] + 1 >= 0 && scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                  ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                }
                if (scratch_32[5] + 1 >= 0 && scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                  ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                  ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                }
              }
              scratch_32[10]++;
            }
            return scratch_32[10];
          } else if (this.bytes_per_pixel === 1) {
            return (() => {
              const scratch_32 = new Uint32Array(16);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              scratch_32[2] = scratch_32[0] * scratch_32[1];
              scratch_32[3] = this.bytes_per_pixel;
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = max;
              const ta8_pixels = new Uint8Array(12);
              scratch_32[10] = 0;
              const ta16_pixels = new Uint8Array(4);
              const ta_pixels_visited = new Uint8Array(scratch_32[2]);
              const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
              scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
              ta8_pixels[0] = buffer[scratch_32[8]++];
              ta_visiting_pixels[0] = x;
              ta_visiting_pixels[1] = y;
              scratch_32[7] = 2;
              while (scratch_32[6] < scratch_32[7] && scratch_32[10] < scratch_32[9]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
                ta8_pixels[4] = buffer[scratch_32[8]++];
                ta16_pixels[0] = ta8_pixels[4] - ta8_pixels[0];
                if (ta16_pixels[0] === 0) {
                  if (scratch_32[4] - 1 >= 0 && scratch_32[4] - 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] - 1 >= 0 && scratch_32[5] - 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                  }
                  if (scratch_32[4] + 1 >= 0 && scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] + 1 >= 0 && scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                  }
                }
                scratch_32[10]++;
              }
              return scratch_32[10];
            })();
          } else {
            throw "unsuppored bytes_per_pixel " + this.bytes_per_pixel;
          }
        }
        "get_pixel_pos_list_of_pixels_with_color"(color) {
          let res2 = new Pixel_Pos_List();
          if (this.pos) {
            console.log("this.pos", this.pos);
            this.each_pixel_ta((pos, px_color) => {
              if (px_color === color) {
                res2.add(new Uint16Array([pos[0] + this.pos[0], pos[1] + this.pos[1]]));
              }
            });
            res2.pos = this.pos;
          } else {
            this.each_pixel_ta((pos, px_color) => {
              if (px_color === color) {
                res2.add(pos);
              }
            });
          }
          res2.fix();
          return res2;
        }
        "get_ppl_color_region"(pos) {
          console.trace();
          throw "NYI";
        }
        "flood_fill_self_get_pixel_pos_list"(pos, color) {
          const size = this.size;
          if (!(pos instanceof Uint16Array || pos instanceof Uint32Array)) {
            throw "Wrong pos data type, pos " + pos;
          }
          if (this.bytes_per_pixel === 4) {
            throw "NYI";
          } else if (this.bytes_per_pixel === 1) {
            const using_ta_pixels_visited = () => {
              const res2 = new Pixel_Pos_List();
              const buffer = this.buffer;
              const scratch_32 = new Uint32Array(10);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              const size2 = scratch_32;
              scratch_32[2] = size2[0] * size2[1];
              scratch_32[3] = this.bytes_per_pixel;
              let cpos = pos.slice();
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = 0;
              const obj_pixels_visited = {};
              const ppl_visiting_pixels = new Pixel_Pos_List();
              const ta_visiting_pixels = ppl_visiting_pixels.ta;
              let ccolor;
              scratch_32[8] = scratch_32[3] * (cpos[0] + cpos[1] * size2[0]);
              ccolor = buffer[scratch_32[8]++];
              ppl_visiting_pixels.add(cpos);
              scratch_32[7] = 2;
              while (scratch_32[9] <= scratch_32[2]) {
                console.log("scratch_32[9]", scratch_32[9]);
                console.log("scratch_32[2]", scratch_32[2]);
                cpos[0] = ta_visiting_pixels[scratch_32[6]++];
                cpos[1] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (cpos[0] + cpos[1] * size2[0]);
                if (buffer[scratch_32[8]++] - ccolor === 0) {
                  buffer[scratch_32[8] - 1] = color;
                  res2.add(cpos);
                  if (cpos[0] - 1 >= 0 && !obj_pixels_visited[cpos[0] - 1 + size2[0] * cpos[1]]) {
                    ppl_visiting_pixels.add(new Uint16Array([cpos[0] - 1, cpos[1]]));
                    scratch_32[7] += 2;
                    obj_pixels_visited[cpos[0] - 1 + size2[0] * cpos[1]] = true;
                  }
                  if (cpos[1] - 1 >= 0 && !obj_pixels_visited[cpos[0] + size2[0] * (cpos[1] - 1)]) {
                    ppl_visiting_pixels.add(new Uint16Array([cpos[0], cpos[1] - 1]));
                    scratch_32[7] += 2;
                    obj_pixels_visited[cpos[0] + size2[0] * (cpos[1] - 1)] = true;
                  }
                  if (cpos[0] + 1 < size2[0] && !obj_pixels_visited[cpos[0] + 1 + size2[0] * cpos[1]]) {
                    ppl_visiting_pixels.add(new Uint16Array([cpos[0] + 1, cpos[1]]));
                    scratch_32[7] += 2;
                    obj_pixels_visited[cpos[0] + 1 + size2[0] * cpos[1]] = true;
                  }
                  if (cpos[1] + 1 < size2[1] && !obj_pixels_visited[cpos[0] + size2[0] * (cpos[1] + 1)]) {
                    ppl_visiting_pixels.add(new Uint16Array([cpos[0], cpos[1] + 1]));
                    scratch_32[7] += 2;
                    obj_pixels_visited[cpos[0] + size2[0] * (cpos[1] + 1)] = true;
                  }
                }
                scratch_32[9]++;
              }
              res2.fix();
              return res2;
            };
            return using_ta_pixels_visited();
          } else {
            console.trace();
            throw "NYI";
          }
        }
        "flood_fill_c1_1bipp"(pos) {
          const target_color = this.get_pixel_1bipp(pos);
          let [x, y] = pos;
          if (target_color === 1) {
            return 0;
          } else {
            const ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation = () => {
              let stack_capacity = 1024 * 1024 * 16;
              let ta_stack = new Uint16Array(stack_capacity);
              let i_stack_pos = 0;
              let stack_length = 0;
              let px_color;
              let ta_pos = new Uint16Array(2);
              let ta_pos2 = new Uint16Array(2);
              ta_pos[0] = pos[0];
              ta_pos[1] = pos[1];
              if (i_stack_pos < stack_capacity) {
                ta_stack[i_stack_pos++] = ta_pos[0];
                ta_stack[i_stack_pos++] = ta_pos[1];
                stack_length++;
              } else {
                console.log("stack_length", stack_length);
                console.log("i_stack_pos", i_stack_pos);
                console.trace();
                throw "NYI - stack exceeded capacity";
              }
              const [width, height2] = this.size;
              const ta_already_visited = new Uint8Array(width * height2);
              while (stack_length > 0) {
                ta_pos[0] = ta_stack[i_stack_pos - 2];
                ta_pos[1] = ta_stack[i_stack_pos - 1];
                i_stack_pos -= 2;
                stack_length--;
                if (i_stack_pos >= stack_capacity - 8) {
                  throw "Not enough stack for positions yet to visit";
                }
                px_color = this.get_pixel_1bipp(ta_pos);
                if (px_color === target_color) {
                  this.set_pixel_on_1bipp(ta_pos);
                  if (ta_pos[0] > 0) {
                    ta_pos2[0] = ta_pos[0] - 1;
                    ta_pos2[1] = ta_pos[1];
                    if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                      ta_stack[i_stack_pos++] = ta_pos2[0];
                      ta_stack[i_stack_pos++] = ta_pos2[1];
                      stack_length++;
                    }
                    ;
                  }
                  if (ta_pos[0] < width - 1) {
                    ta_pos2[0] = ta_pos[0] + 1;
                    ta_pos2[1] = ta_pos[1];
                    if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                      ta_stack[i_stack_pos++] = ta_pos2[0];
                      ta_stack[i_stack_pos++] = ta_pos2[1];
                      stack_length++;
                    }
                    ;
                  }
                  if (ta_pos[1] > 0) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] - 1;
                    if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                      ta_stack[i_stack_pos++] = ta_pos2[0];
                      ta_stack[i_stack_pos++] = ta_pos2[1];
                      stack_length++;
                    }
                    ;
                  }
                  if (ta_pos[1] < height2 - 1) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] + 1;
                    if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                      ta_stack[i_stack_pos++] = ta_pos2[0];
                      ta_stack[i_stack_pos++] = ta_pos2[1];
                      stack_length++;
                    }
                    ;
                  }
                  ta_already_visited[width * ta_pos[1] + ta_pos[0]] = 255;
                }
              }
            };
            const horizontal_line_filling_stack_to_visit_store_already_visited_implementation = () => {
              const { ta: ta2, size } = this;
              const aa_x_off_spans = this.calculate_arr_rows_arr_x_off_spans_1bipp();
              console.log("aa_x_off_spans", aa_x_off_spans);
              const find_connected_x_off_spans_below = (y2, idx_x_off_span) => {
                const res2 = [];
                if (y2 < aa_x_off_spans.length - 1) {
                  const span1 = aa_x_off_spans[y2][idx_x_off_span];
                  console.log("");
                  console.log("span1", span1);
                  const y_below = aa_x_off_spans[y2 + 1];
                  console.log("y_below", y_below);
                  const l_y_below = y_below.length;
                  for (let i_below = 0; i_below < l_y_below; i_below++) {
                    const range_below = y_below[i_below];
                    const has_overlap = range_below[0] >= span1[0] && range_below[0] <= span1[1] || range_below[1] >= span1[0] && range_below[1] <= span1[1];
                    console.log("range_below", range_below);
                    console.log("has_overlap", has_overlap);
                    if (has_overlap) {
                      res2.push(range_below);
                    }
                  }
                }
                return res2;
              };
              for (let y2 = 0; y2 < aa_x_off_spans.length; y2++) {
                const arr_row_x_off_spans = aa_x_off_spans[y2];
                for (let idx_x_off_span = 0; idx_x_off_span < arr_row_x_off_spans.length; idx_x_off_span++) {
                  const x_off_span = arr_row_x_off_spans[idx_x_off_span];
                  const path_xos = [y2, idx_x_off_span];
                  console.log("path_xos", path_xos);
                  const spans_connected_below = find_connected_x_off_spans_below(y2, idx_x_off_span);
                  console.log("spans_connected_below", spans_connected_below);
                }
              }
              const old = () => {
                const calculate_1bipp_row_arr_x_spans_off = (y2) => {
                  const res2 = [];
                  const width = this.size[0];
                  let last_color = 0;
                  let current_color;
                  let ta_pos = new Uint16Array(2);
                  ta_pos[1] = y2;
                  for (let x2 = 0; x2 < width; x2++) {
                    ta_pos[0] = x2;
                    current_color = this.get_pixel_1bipp(ta_pos);
                    if (current_color === last_color) {
                      if (res2.length === 0) {
                        res2.push([0, 1]);
                      } else {
                        res2[res2.length - 1][1]++;
                      }
                    } else {
                      if (res2.length === 0) {
                        res2.push([0, 0]);
                        res2.push([0, 1]);
                      } else {
                        res2.push([x2, x2 + 1]);
                      }
                    }
                    last_color = current_color;
                  }
                  return res2;
                };
                const row_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y);
                console.log("----------------");
                console.log("row_x_off_spans", row_x_off_spans);
                if (y > 0) {
                  const row_above_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y - 1);
                  console.log("row_above_x_off_spans", row_above_x_off_spans);
                }
                if (y < this.size[1] - 1) {
                  const row_below_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y + 1);
                  console.log("row_below_x_off_spans", row_below_x_off_spans);
                }
                console.log("----------------");
              };
            };
            return ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation();
          }
        }
        "flood_fill_1bipp"(x, y, color) {
          const new_color = color;
          const target_color = this.get_pixel_1bipp([x, y]);
          const [width, height2] = this.size;
          if (target_color === new_color) {
            return 0;
          } else {
            const ta_stack_fn_calls_inlined_implementation = () => {
              let stack_capacity = 1024 * 1024 * 8;
              let ta_stack = new Uint16Array(stack_capacity);
              let i_stack_pos = 0;
              let stack_length = 0;
              let px_color;
              let ta_pos = new Uint16Array(2);
              let ta_pos2 = new Uint16Array(2);
              ta_pos[0] = x;
              ta_pos[1] = y;
              if (i_stack_pos < stack_capacity) {
                ta_stack[i_stack_pos++] = ta_pos[0];
                ta_stack[i_stack_pos++] = ta_pos[1];
                stack_length++;
              } else {
                console.log("stack_length", stack_length);
                console.log("i_stack_pos", i_stack_pos);
                console.trace();
                throw "NYI - stack exceeded capacity";
              }
              const pb_already_visited = new Core({
                size: this.size,
                bits_per_pixel: 1
              });
              while (stack_length > 0) {
                ta_pos[0] = ta_stack[i_stack_pos - 2];
                ta_pos[1] = ta_stack[i_stack_pos - 1];
                i_stack_pos -= 2;
                stack_length--;
                px_color = this.get_pixel_1bipp(ta_pos);
                if (px_color === target_color) {
                  this.set_pixel_1bipp(ta_pos, new_color);
                  if (ta_pos[0] > 0) {
                    ta_pos2[0] = ta_pos[0] - 1;
                    ta_pos2[1] = ta_pos[1];
                    if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[0] < width - 1) {
                    ta_pos2[0] = ta_pos[0] + 1;
                    ta_pos2[1] = ta_pos[1];
                    if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[1] > 0) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] - 1;
                    if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[1] < height2 - 1) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] + 1;
                    if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  pb_already_visited.set_pixel_1bipp(ta_pos, 1);
                }
              }
            };
            const ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation = () => {
              let stack_capacity = 1024 * 1024 * 8;
              let ta_stack = new Uint16Array(stack_capacity);
              let i_stack_pos = 0;
              let stack_length = 0;
              let px_color;
              let ta_pos = new Uint16Array(2);
              let ta_pos2 = new Uint16Array(2);
              ta_pos[0] = x;
              ta_pos[1] = y;
              if (i_stack_pos < stack_capacity) {
                ta_stack[i_stack_pos++] = ta_pos[0];
                ta_stack[i_stack_pos++] = ta_pos[1];
                stack_length++;
              } else {
                console.log("stack_length", stack_length);
                console.log("i_stack_pos", i_stack_pos);
                console.trace();
                throw "NYI - stack exceeded capacity";
              }
              const [width2, height3] = this.size;
              const ta_already_visited = new Uint8Array(width2 * height3);
              while (stack_length > 0) {
                ta_pos[0] = ta_stack[i_stack_pos - 2];
                ta_pos[1] = ta_stack[i_stack_pos - 1];
                i_stack_pos -= 2;
                stack_length--;
                px_color = this.get_pixel_1bipp(ta_pos);
                if (px_color === target_color) {
                  this.set_pixel_1bipp(ta_pos, new_color);
                  if (ta_pos[0] > 0) {
                    ta_pos2[0] = ta_pos[0] - 1;
                    ta_pos2[1] = ta_pos[1];
                    if (ta_already_visited[width2 * ta_pos2[1] + ta_pos2[0]] === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[0] < width2 - 1) {
                    ta_pos2[0] = ta_pos[0] + 1;
                    ta_pos2[1] = ta_pos[1];
                    if (ta_already_visited[width2 * ta_pos2[1] + ta_pos2[0]] === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[1] > 0) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] - 1;
                    if (ta_already_visited[width2 * ta_pos2[1] + ta_pos2[0]] === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  if (ta_pos[1] < height3 - 1) {
                    ta_pos2[0] = ta_pos[0];
                    ta_pos2[1] = ta_pos[1] + 1;
                    if (ta_already_visited[width2 * ta_pos2[1] + ta_pos2[0]] === 0) {
                      if (i_stack_pos < stack_capacity) {
                        ta_stack[i_stack_pos++] = ta_pos2[0];
                        ta_stack[i_stack_pos++] = ta_pos2[1];
                        stack_length++;
                      } else {
                        console.log("stack_length", stack_length);
                        console.log("i_stack_pos", i_stack_pos);
                        console.trace();
                        throw "NYI - stack exceeded capacity";
                      }
                    }
                    ;
                  }
                  ta_already_visited[width2 * ta_pos[1] + ta_pos[0]] = 255;
                }
              }
            };
            return ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation();
          }
        }
        "flood_fill"(x, y, r, g, b, a) {
          const {
            bipp
          } = this;
          if (bipp === 24) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
              const buffer = this.buffer;
              const scratch_32 = new Uint32Array(16);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              scratch_32[2] = scratch_32[0] * scratch_32[1];
              scratch_32[3] = this.bytes_per_pixel;
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = 0;
              const ta8_pixels = new Uint8Array(12);
              ta8_pixels[8] = r;
              ta8_pixels[9] = g;
              ta8_pixels[10] = b;
              const ta_pixels_visited = new Uint8Array(scratch_32[2]);
              const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
              scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
              ta8_pixels[0] = buffer[scratch_32[8]++];
              ta8_pixels[1] = buffer[scratch_32[8]++];
              ta8_pixels[2] = buffer[scratch_32[8]++];
              ta_visiting_pixels[0] = x;
              ta_visiting_pixels[1] = y;
              scratch_32[7] = 2;
              while (scratch_32[9] <= scratch_32[2]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
                if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0 && buffer[scratch_32[8]++] - ta8_pixels[1] === 0 && buffer[scratch_32[8]++] - ta8_pixels[2] === 0) {
                  scratch_32[8] -= 3;
                  buffer[scratch_32[8]++] = ta8_pixels[8];
                  buffer[scratch_32[8]++] = ta8_pixels[9];
                  buffer[scratch_32[8]++] = ta8_pixels[10];
                  if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                  }
                  if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                  }
                }
                scratch_32[9]++;
              }
              return this;
            };
            return fast_stacked_mapped_flood_fill();
          } else if (bipp === 32) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
              const buffer = this.buffer;
              const scratch_32 = new Uint32Array(16);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              scratch_32[2] = scratch_32[0] * scratch_32[1];
              scratch_32[3] = this.bytes_per_pixel;
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = 0;
              const ta8_pixels = new Uint8Array(12);
              ta8_pixels[8] = r;
              ta8_pixels[9] = g;
              ta8_pixels[10] = b;
              ta8_pixels[11] = a;
              const ta_pixels_visited = new Uint8Array(scratch_32[2]);
              const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
              scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
              ta8_pixels[0] = buffer[scratch_32[8]++];
              ta8_pixels[1] = buffer[scratch_32[8]++];
              ta8_pixels[2] = buffer[scratch_32[8]++];
              ta8_pixels[3] = buffer[scratch_32[8]++];
              ta_visiting_pixels[0] = x;
              ta_visiting_pixels[1] = y;
              scratch_32[7] = 2;
              while (scratch_32[9] <= scratch_32[2]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
                if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0 && buffer[scratch_32[8]++] - ta8_pixels[1] === 0 && buffer[scratch_32[8]++] - ta8_pixels[2] === 0 && buffer[scratch_32[8]++] - ta8_pixels[3] === 0) {
                  scratch_32[8] -= 4;
                  buffer[scratch_32[8]++] = ta8_pixels[8];
                  buffer[scratch_32[8]++] = ta8_pixels[9];
                  buffer[scratch_32[8]++] = ta8_pixels[10];
                  buffer[scratch_32[8]++] = ta8_pixels[11];
                  if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                  }
                  if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                  }
                }
                scratch_32[9]++;
              }
              return this;
            };
            return fast_stacked_mapped_flood_fill();
          } else if (bipp === 8) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
              const v = r;
              const buffer = this.buffer;
              const scratch_32 = new Uint32Array(16);
              scratch_32[0] = this.size[0];
              scratch_32[1] = this.size[1];
              scratch_32[2] = scratch_32[0] * scratch_32[1];
              scratch_32[3] = this.bytes_per_pixel;
              scratch_32[6] = 0;
              scratch_32[7] = 0;
              scratch_32[8] = 0;
              scratch_32[9] = 0;
              const ta8_pixels = new Uint8Array(12);
              ta8_pixels[8] = v;
              const ta_pixels_visited = new Uint8Array(scratch_32[2]);
              const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
              scratch_32[8] = scratch_32[3] * (x + y * scratch_32[0]);
              ta8_pixels[0] = buffer[scratch_32[8]++];
              ta_visiting_pixels[0] = x;
              ta_visiting_pixels[1] = y;
              scratch_32[7] = 2;
              while (scratch_32[9] <= scratch_32[2]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++];
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + scratch_32[5] * scratch_32[0]);
                if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0) {
                  scratch_32[8] -= 1;
                  buffer[scratch_32[8]++] = ta8_pixels[8];
                  if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] - 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] - 1)] = 255;
                  }
                  if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                    ta_pixels_visited[scratch_32[4] + 1 + scratch_32[0] * scratch_32[5]] = 255;
                  }
                  if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] === 0) {
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                    ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                    ta_pixels_visited[scratch_32[4] + scratch_32[0] * (scratch_32[5] + 1)] = 255;
                  }
                }
                scratch_32[9]++;
              }
              return this;
            };
            return fast_stacked_mapped_flood_fill();
          } else if (bipp === 1) {
            return this.flood_fill_1bipp(x, y, r);
          } else {
            console.trace();
            throw "Unsupported bipp: " + bipp;
          }
        }
        "invert"() {
          const {
            bipp
          } = this;
          if (bipp === 1) {
            const {
              ta: ta2
            } = this;
            const l2 = ta2.length;
            for (let i = 0; i < l2; i++) {
              ta2[i] = ~ta2[i] & 255;
            }
          } else {
            console.trace();
            throw "NYI (unsupported bipp) " + bipp;
          }
        }
        "or"(other_pb) {
          const {
            bipp
          } = this;
          if (bipp === 1) {
            const other_bipp = other_pb.bipp;
            if (other_bipp === 1) {
              const {
                ta: ta2
              } = this;
              const l_my_ta = ta2.length;
              const other_ta = other_pb.ta;
              const l_other_ta = other_ta.length;
              if (l_other_ta === l_my_ta) {
                for (let i = 0; i < l_my_ta; i++) {
                  ta2[i] = ta2[i] | other_ta[i];
                }
              } else {
                console.trace();
                throw "lengths of pixel buffer typed arrays must match";
              }
            } else {
              console.trace();
              throw "bipp values must match (other_pb expected to have bipp: 1)";
            }
          } else {
            console.trace();
            throw "NYI (unsupported bipp) " + bipp;
          }
        }
        each_outer_boundary_pixel(callback2) {
          let ta_pos = new Uint16Array(2);
          const { size } = this;
          const [w, h] = size;
          ta_pos[0] = 0;
          ta_pos[1] = 0;
          for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
            const px2 = this.get_pixel(ta_pos);
            callback2(px2, ta_pos);
          }
          ta_pos[0]--;
          for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            const px2 = this.get_pixel(ta_pos);
            callback2(px2, ta_pos);
          }
          ta_pos[1]--;
          for (ta_pos[0] = w - 1; ta_pos[0] > 0; ta_pos[0]--) {
            const px2 = this.get_pixel(ta_pos);
            callback2(px2, ta_pos);
          }
          let px = this.get_pixel(ta_pos);
          callback2(px, ta_pos);
          for (ta_pos[1] = h - 1; ta_pos[1] > 0; ta_pos[1]--) {
            const px2 = this.get_pixel(ta_pos);
            callback2(px2, ta_pos);
          }
          px = this.get_pixel(ta_pos);
          callback2(px, ta_pos);
        }
        flood_fill_off_pixels_from_outer_boundary_on_1bipp() {
          this.each_outer_boundary_pixel((b_color, pos) => {
            if (b_color === 0) {
              this.flood_fill_c1_1bipp(pos);
            }
          });
        }
        flood_fill_given_color_pixels_from_outer_boundary(given_color, fill_color) {
          const {
            bits_per_pixel
          } = this;
          if (bits_per_pixel === 24) {
            this.each_outer_boundary_pixel((b_color, pos) => {
              const [r, g, b] = b_color;
              if (r === given_color[0] && g === given_color[1] && b === given_color[2]) {
                this.flood_fill(pos[0], pos[1], fill_color[0], fill_color[1], fill_color[2]);
              }
            });
          } else if (bits_per_pixel === 1) {
            this.each_outer_boundary_pixel((b_color, pos) => {
              if (b_color === given_color) {
                this.flood_fill(pos[0], pos[1], fill_color);
              }
            });
          } else {
            console.log("not flood filling");
            console.log("bits_per_pixel", bits_per_pixel);
            throw "NYI";
            console.trace();
          }
        }
        each_x_span(cb) {
          const [w, h] = this.size;
          const ta_x_span_toggle_bits = get_ta_bits_that_differ_from_previous_as_1s(this.ta);
          let prev_x, prev_y;
          let x_delta, y_delta;
          let color_leading_on_from_current_x_toggle_position;
          const found_empty_rows = (y0, y1_inclusive) => {
          };
          const found_x_span = (x0, x1, y, color) => {
            cb(x0, x1, y, color);
          };
          const complete_previous_row_x_span = () => {
          };
          const complete_any_empty_in_between_rows = () => {
          };
          const complete_current_x_span = (x, y) => {
            found_x_span(prev_x, x - 1, y, color_leading_on_from_current_x_toggle_position);
            color_leading_on_from_current_x_toggle_position ^= 1;
          };
          const found_row_beginning_color_0_x_span = (x_span_end, y) => {
            found_x_span(0, x_span_end, y, 0);
            color_leading_on_from_current_x_toggle_position = 1;
          };
          const found_row_beginning_color_1_x_span_beginning = (y) => {
            color_leading_on_from_current_x_toggle_position = 1;
          };
          const handle_xy_toggle_position = (x, y) => {
            if (prev_x === void 0) {
              if (y > 0) {
                found_empty_rows(0, y - 1);
              }
              if (x > 0) {
                found_row_beginning_color_0_x_span(x, y);
              } else {
                found_row_beginning_color_1_x_span_beginning(y);
              }
            } else {
              if (y > prev_y) {
                complete_previous_row_x_span();
                complete_any_empty_in_between_rows();
                if (x === 0) {
                  found_row_beginning_color_1_x_span_beginning(y);
                } else {
                  found_row_beginning_color_0_x_span(x - 1, y);
                }
              } else {
                complete_current_x_span(x, y);
              }
            }
            prev_x = x;
            prev_y = y;
          };
          each_1_index(ta_x_span_toggle_bits, (i) => {
            const y = Math.floor(i / w);
            const x = i % w;
            handle_xy_toggle_position(x, y);
          });
        }
        not_very_fast_flood_fill_inner_pixels_off_to_on_1bipp() {
          const identify_overlaps = (higher_row_x_spans, lower_row_x_spans) => {
            let i = 0, j = 0;
            const m = higher_row_x_spans.length, n = lower_row_x_spans.length;
            while (i < m && j < n) {
              const a = higher_row_x_spans[i], b = lower_row_x_spans[j];
              if (a.x0_span[1] < b.x0_span[0]) {
                i++;
              } else if (b.x0_span[1] < a.x0_span[0]) {
                j++;
              } else {
                a.connected_below.push(b.idx);
                b.connected_above.push(a.idx);
                if (a.x0_span[1] <= b.x0_span[1]) {
                  i++;
                }
                if (b.x0_span[1] <= a.x0_span[1]) {
                  j++;
                }
              }
            }
          };
          const rows_x0spans = this.calculate_arr_rows_arr_x_off_spans_1bipp();
          const arr_all_x_spans = [];
          const arr_y_indexed = new Array(this.size[1]);
          let i2;
          let idx = 0;
          for (let i = 0; i < rows_x0spans.length; i++) {
            const single_row_x0spans = rows_x0spans[i];
            arr_y_indexed[i] = [];
            for (i2 = 0; i2 < single_row_x0spans.length; i2++) {
              const x0_span = single_row_x0spans[i2];
              const o_x0span = {
                idx: idx++,
                y: i,
                x0_span,
                connected_above: [],
                connected_below: []
              };
              arr_all_x_spans.push(o_x0span);
              arr_y_indexed[i].push(o_x0span);
            }
          }
          let higher_row_y, lower_row_y;
          let span_above, span_below;
          for (higher_row_y = 0; higher_row_y < this.size[1] - 1; higher_row_y++) {
            identify_overlaps(arr_y_indexed[higher_row_y], arr_y_indexed[higher_row_y + 1]);
          }
          const l2 = arr_all_x_spans.length;
          let arr_stack_yet_to_visit = [];
          let ui8a_visited_already = new Uint8Array(l2);
          let i_group = 0;
          let i_current_group;
          const arr_groups = [];
          const arr_o_groups = [];
          let arr_current_group = [];
          let o_current_group;
          let i_xspan_visiting, xspan_visiting;
          const [width, height2] = this.size;
          const hm1 = height2 - 1, wm1 = width - 1;
          const is_xspan_image_boundary_adjacent = (xspan2) => {
            const { x0_span } = xspan2;
            if (xspan2.y === 0) return true;
            if (x0_span[0] === 0) return true;
            if (xspan2.y === hm1) return true;
            if (x0_span[1] === wm1) return true;
            return false;
          };
          let xspan;
          let idx_span_above, idx_span_below;
          for (let c2 = 0; c2 < l2; c2++) {
            if (ui8a_visited_already[c2] === 0) {
              ui8a_visited_already = new Uint8Array(l2);
              xspan = arr_all_x_spans[c2];
              ui8a_visited_already[c2] = 255;
              if (xspan.group === void 0) {
                i_current_group = i_group++;
                arr_current_group = [];
                o_current_group = {
                  index: i_current_group,
                  xspan_indexes: arr_current_group
                };
                arr_o_groups.push(o_current_group);
                arr_groups.push(arr_current_group);
                if (is_xspan_image_boundary_adjacent(xspan)) {
                  o_current_group.is_boundary_adjacent = true;
                }
                xspan.group = i_current_group;
                arr_current_group.push(c2);
                for (idx_span_above of xspan.connected_above) {
                  if (ui8a_visited_already[idx_span_above] === 0) arr_stack_yet_to_visit.push(idx_span_above);
                }
                for (idx_span_below of xspan.connected_below) {
                  if (ui8a_visited_already[idx_span_below] === 0) arr_stack_yet_to_visit.push(idx_span_below);
                }
                while (arr_stack_yet_to_visit.length > 0) {
                  i_xspan_visiting = arr_stack_yet_to_visit.pop();
                  if (ui8a_visited_already[i_xspan_visiting] === 0) {
                    xspan_visiting = arr_all_x_spans[i_xspan_visiting];
                    if (is_xspan_image_boundary_adjacent(xspan_visiting)) {
                      o_current_group.is_boundary_adjacent = true;
                    }
                    xspan_visiting.group = i_current_group;
                    arr_current_group.push(i_xspan_visiting);
                    ui8a_visited_already[i_xspan_visiting] = 255;
                    for (idx_span_above of xspan_visiting.connected_above) {
                      if (ui8a_visited_already[idx_span_above] === 0) arr_stack_yet_to_visit.push(idx_span_above);
                    }
                    for (idx_span_below of xspan_visiting.connected_below) {
                      if (ui8a_visited_already[idx_span_below] === 0) arr_stack_yet_to_visit.push(idx_span_below);
                    }
                  }
                }
              }
            }
          }
          const non_boundary_group_indexes = [];
          for (const g of arr_o_groups) {
            if (!g.is_boundary_adjacent) {
              for (const idx2 of g.xspan_indexes) {
                non_boundary_group_indexes.push(idx2);
              }
            }
          }
          const write_direct = () => {
            let xspan2;
            for (const idx2 of non_boundary_group_indexes) {
              xspan2 = arr_all_x_spans[idx2];
              this.draw_horizontal_line_on_1bipp_inclusive(xspan2.x0_span, xspan2.y);
            }
          };
          write_direct();
        }
        flood_fill_inner_pixels_off_to_on_1bipp() {
          return this.not_very_fast_flood_fill_inner_pixels_off_to_on_1bipp();
        }
      };
      module.exports = Pixel_Buffer_Perf_Focus_Enh;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-7-specialised-enh.js
  var require_pixel_buffer_7_specialised_enh = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-7-specialised-enh.js"(exports, module) {
      var Pixel_Buffer_Perf_Focus_Enh = require_pixel_buffer_6_perf_focus_enh();
      var {
        resize_ta_colorspace,
        copy_rect_to_same_size_8bipp,
        copy_rect_to_same_size_24bipp,
        dest_aligned_copy_rect_1to4bypp,
        get_ta_bits_that_differ_from_previous_as_1s: get_ta_bits_that_differ_from_previous_as_1s2,
        each_1_index: each_1_index2
      } = require_ta_math();
      var Pixel_Buffer_Specialised_Enh = class extends Pixel_Buffer_Perf_Focus_Enh {
        constructor(...a) {
          super(...a);
          const bounds_within_source = new Int16Array(4);
          Object.defineProperty(this, "bounds_within_source", {
            get() {
              const size = this.size;
              const pos = this.pos;
              bounds_within_source[0] = pos[0];
              bounds_within_source[1] = pos[1];
              bounds_within_source[2] = pos[0] + size[0];
              bounds_within_source[3] = pos[1] + size[1];
              return bounds_within_source;
            },
            /*
            set(value) {
            },*/
            enumerable: true,
            configurable: false
          });
          const size_bounds = new Int16Array(4);
          Object.defineProperty(this, "size_bounds", {
            get() {
              const size = this.size;
              size_bounds[0] = 0;
              size_bounds[1] = 0;
              size_bounds[2] = size[0];
              size_bounds[3] = size[1];
              return size_bounds;
            },
            enumerable: true,
            configurable: false
          });
          let pb_source2;
          Object.defineProperty(this, "source", {
            get() {
              return pb_source2;
            },
            set(value2) {
              pb_source2 = value2;
            },
            enumerable: true,
            configurable: false
          });
        }
        copy_from_source() {
          const bipp = this.bipp;
          const pb_source2 = this.source;
          const ta_source2 = pb_source2.ta;
          const ta2 = this.ta;
          const my_bounds = this.bounds_within_source;
          const source_size_bounds = pb_source2.size_bounds;
          if (bipp === 1) {
            console.trace();
            throw "NYI";
          } else if (bipp === 8 || bipp === 24 || bipp === 32) {
            dest_aligned_copy_rect_1to4bypp(ta_source2, ta2, pb_source2.bytes_per_row, this.bytes_per_pixel, ta_math.overlapping_bounds(my_bounds, source_size_bounds));
          } else {
            console.trace();
            throw "stop";
          }
        }
        threshold_gs(value2) {
          let res2 = this.clone();
          if (this.bytes_per_pixel === 1) {
            this.each_pixel((pos, color) => {
              if (color >= value2) {
                res2.set_pixel(pos[0], pos[1], 255);
              } else {
                res2.set_pixel(pos[0], pos[1], 0);
              }
            });
          }
          return res2;
        }
        padded_each_pixel_index(padding, cb) {
          const ta_32_scratch = new Uint32Array(9);
          ta_32_scratch[0] = this.bytes_per_pixel;
          ta_32_scratch[1] = 0;
          ta_32_scratch[2] = this.size[0] - padding;
          ta_32_scratch[3] = this.size[1] - padding;
          ta_32_scratch[7] = this.size[0];
          const bpp = this.bits_per_pixel;
          if (bpp === 32) {
            ((cb2) => {
              for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                  cb2((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                }
              }
            })(cb);
          } else if (bpp === 24) {
            ((cb2) => {
              for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                  cb2((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                }
              }
            })(cb);
          } else if (bpp === 8) {
            ((cb2) => {
              for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                  cb2((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                }
              }
            })(cb);
          } else {
            console.trace();
            throw "NYI";
          }
        }
        new_window(options) {
          options.window_to = this;
          const res2 = new this.constructor(options);
          res2.copy_from_source();
          return res2;
        }
        new_centered_window(size_or_options) {
          console.trace();
          throw "NYI";
          const t12 = tf(size_or_options);
          console.log("t1", t12);
          let size;
          if (t12 === "a") {
            if (size_or_options.length === 2) {
              size = new Int16Array([size_or_options, size_or_options]);
            } else {
              console.log("size_or_options", size_or_options);
              console.trace();
              throw "Size array expected length: 2";
            }
          } else if (t12 === "n") {
            size = new Int16Array([size_or_options, size_or_options]);
          } else {
            console.trace();
            throw "NYI";
          }
          const res_pb = new this.constructor({
            size,
            bits_per_pixel: this.bits_per_pixel,
            window_to: this
          });
        }
        fill_solid_rect_by_bounds() {
          const bounds2 = this.ta_bounds;
          const bipp = this.bipp;
          if (bipp === 24) {
            const rgb = this.ta_rgb;
            const bytes_per_bounds_row = (bounds2[2] - bounds2[0]) * this.bypp;
            const solid_row = new Uint8ClampedArray(bytes_per_bounds_row);
            let cc = 0;
            for (let c2 = 0; c2 < bytes_per_bounds_row; c2++) {
              solid_row[c2] = rgb[cc];
              cc++;
              if (cc === 3) cc = 0;
            }
            let write_byte_idx = bounds2[0] * this.bypp + bounds2[1] * this.bypr;
            for (let i_row = bounds2[1]; i_row < bounds2[3]; i_row++) {
              this.ta.set(solid_row, write_byte_idx);
              write_byte_idx += this.bypr;
            }
          } else {
            console.trace();
            throw "NYI";
          }
        }
        calc_source_target_valid_bounds_overlap() {
          const source = this.source;
          const my_bounds = this.bounds_within_source;
          const source_size_bounds = source.size_bounds;
          const res2 = this.ta_bounds_scratch;
          if (my_bounds[0] < source_size_bounds[0]) {
            res2[0] = source_size_bounds[0];
          } else {
            res2[0] = my_bounds[0];
          }
          if (my_bounds[1] < source_size_bounds[1]) {
            res2[1] = source_size_bounds[1];
          } else {
            res2[1] = my_bounds[1];
          }
          if (my_bounds[2] > source_size_bounds[2]) {
            res2[2] = source_size_bounds[2];
          } else {
            res2[2] = my_bounds[2];
          }
          if (my_bounds[3] > source_size_bounds[3]) {
            res2[3] = source_size_bounds[3];
          } else {
            res2[3] = my_bounds[3];
          }
          return res2;
        }
        copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target) {
          console.trace();
          throw "NYI";
          const pos = this.ta_pos_scratch;
          const rect_size = this.ta_size_scratch;
          rect_size[0] = ta_bounds[2] - ta_bounds[0];
          rect_size[1] = ta_bounds[3] - ta_bounds[1];
          console.log("rect_size", rect_size);
          const ta_pointers = this.ta_pointers_scratch;
          const ta_target_pointers = pb_target.ta_pointers_scratch;
          console.log("ta_pointers", ta_pointers);
          console.log("ta_target_pointers", ta_target_pointers);
          console.log("pos", pos);
          console.log("ta_bounds", ta_bounds);
          const ta2 = this.ta;
          const ta_target = pb_target.ta;
          console.log("pb_target.pos", pb_target.pos);
          const ta_safe_bounds_limits = this.ta_bounds_scratch;
          ta_safe_bounds_limits[0] = 0;
          ta_safe_bounds_limits[1] = 0;
          ta_safe_bounds_limits[2] = this.size[0];
          ta_safe_bounds_limits[3] = this.size[1];
          const ta_safe_adjusted_bounds = this.ta_bounds2_scratch;
          const ta_bounds_adjustments = this.ta_bounds3_scratch;
          const ta_bounds_byte_offsets = this.ta_bounds3_scratch;
          if (ta_bounds[0] >= ta_safe_bounds_limits[0]) {
            ta_safe_adjusted_bounds[0] = ta_bounds[0];
            ta_bounds_adjustments[0] = 0;
          } else {
            ta_bounds_adjustments[0] = ta_safe_bounds_limits[0] - ta_bounds[0];
            ta_safe_adjusted_bounds[0] = ta_safe_bounds_limits[0];
          }
          if (ta_bounds[1] >= ta_safe_bounds_limits[1]) {
            ta_safe_adjusted_bounds[1] = ta_bounds[1];
            ta_bounds_adjustments[1] = 0;
          } else {
            ta_bounds_adjustments[1] = ta_safe_bounds_limits[1] - ta_bounds[1];
            ta_safe_adjusted_bounds[1] = ta_safe_bounds_limits[1];
          }
          if (ta_bounds[2] <= ta_safe_bounds_limits[2]) {
            ta_safe_adjusted_bounds[2] = ta_bounds[2];
            ta_bounds_adjustments[2] = 0;
          } else {
            ta_bounds_adjustments[2] = ta_safe_bounds_limits[2] - ta_bounds[2];
            ta_safe_adjusted_bounds[2] = ta_safe_bounds_limits[2];
          }
          if (ta_bounds[3] <= ta_safe_bounds_limits[3]) {
            ta_safe_adjusted_bounds[3] = ta_bounds[3];
            ta_bounds_adjustments[3] = 0;
          } else {
            ta_bounds_adjustments[3] = ta_safe_bounds_limits[3] - ta_bounds[3];
            ta_safe_adjusted_bounds[3] = ta_safe_bounds_limits[3];
          }
          console.log("ta_safe_adjusted_bounds", ta_safe_adjusted_bounds);
          console.log("ta_bounds_adjustments", ta_bounds_adjustments);
          console.log("this.bytes_per_row", this.bytes_per_row);
          const source_bytes_per_row = this.bytes_per_row;
          const bypp2 = this.bypp;
          const adjusted_safe_bounds_source_read_byte_offsets = this.ta_offsets_scratch;
          adjusted_safe_bounds_source_read_byte_offsets[0] = ta_bounds_adjustments[0] * bypp2;
          adjusted_safe_bounds_source_read_byte_offsets[1] = ta_bounds_adjustments[1] * source_bytes_per_row;
          adjusted_safe_bounds_source_read_byte_offsets[2] = ta_bounds_adjustments[2] * bypp2;
          adjusted_safe_bounds_source_read_byte_offsets[3] = ta_bounds_adjustments[3] * source_bytes_per_row;
          console.log("adjusted_safe_bounds_source_read_byte_offsets", adjusted_safe_bounds_source_read_byte_offsets);
          const adjusted_safe_bounds_target_write_byte_offsets = pb_target.ta_offsets_scratch;
          const ta_pp_source_read = this.ta_pointerpair_scratch;
          const ta_pp_target_write = pb_target.ta_pointerpair_scratch;
          const bytes_per_row_of_safe_bounds = (ta_safe_adjusted_bounds[2] - ta_safe_adjusted_bounds[0]) * bypp2;
          console.log("bytes_per_row_of_safe_bounds", bytes_per_row_of_safe_bounds);
          ta_pp_source_read[0] = adjusted_safe_bounds_source_read_byte_offsets[0] + adjusted_safe_bounds_source_read_byte_offsets[1];
          ta_pp_source_read[1] = ta_pp_source_read[0] + bytes_per_row_of_safe_bounds;
          ta_pp_target_write[0] = 0;
          ta_pp_target_write[1] = ta_pp_target_write[0] + bytes_per_row_of_safe_bounds;
          console.log("ta_pp_source_read", ta_pp_source_read);
          console.log("ta_pp_target_write", ta_pp_target_write);
          console.log("pb_target.bytes_per_row", pb_target.bytes_per_row);
          const num_rows_to_copy = ta_safe_adjusted_bounds[3] - ta_safe_adjusted_bounds[1];
          console.log("num_rows_to_copy", num_rows_to_copy);
          for (let c2 = 0; c2 < num_rows_to_copy; c2++) {
            const sa_source_row = ta2.subarray(ta_pp_source_read[0], ta_pp_source_read[1]);
            console.log("sa_source_row", sa_source_row);
          }
          for (pos[1] = ta_bounds[1]; pos[1] < ta_bounds[3]; pos[1]++) {
          }
          if (rect_size[0] === pb_target.size[0] && rect_size[1] === pb_target.size[1]) {
            console.log("rect_size matches target size.");
          }
        }
        // And this could be done in a more optimised bitwise way.
        "get_ta_contiguous_spans_1bipp_toggle"() {
          const get_count = () => {
            const initial_color = 0;
            let color = initial_color;
            let count_color_changes = 0;
            this.each_pixel(([x, y], px_color) => {
              if (px_color !== color) {
                count_color_changes++;
              }
              color = px_color;
            });
            count_color_changes++;
            return count_color_changes;
          };
          const get_max_span_length = () => {
            const initial_color = 0;
            let color = initial_color;
            let l2 = 0;
            let max_l = 0;
            this.each_pixel(([x, y], px_color) => {
              if (px_color !== color) {
                l2 = 0;
              } else {
                l2++;
                if (l2 > max_l) max_l = l2;
              }
              color = px_color;
            });
            return max_l + 1;
          };
          const nccs = get_count();
          const max_xpan_l = get_max_span_length();
          if (max_xpan_l <= 255) {
            const res2 = new Uint8Array(nccs);
            const initial_color = 0;
            let color = initial_color;
            let count_color_changes = 0;
            let l2 = -1;
            this.each_pixel(([x, y], px_color) => {
              if (px_color !== color) {
                res2[count_color_changes] = l2 + 1;
                count_color_changes++;
                l2 = 0;
              } else {
                l2++;
              }
              color = px_color;
            });
            res2[count_color_changes] = l2 + 1;
            return res2;
          } else {
            console.trace();
            throw "stop";
          }
        }
        "count_row_on_xspans_1bipp"(y) {
          let res2 = 0;
          const width = this.size[0];
          let last_color = 1;
          let current_color;
          let ta_pos = new Uint16Array(2);
          ta_pos[1] = y;
          for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 1) {
              if (current_color === last_color) {
                if (res2 === 0) {
                  res2++;
                } else {
                }
              } else {
                res2++;
              }
            }
            last_color = current_color;
          }
          return res2;
        }
        "calculate_ta_row_x_off_x2ygbspans_1bipp"(y) {
          const count_xoffspans = this.count_row_off_xspans_1bipp(y);
          const res2 = new Uint16Array(count_xoffspans * 5);
          let i_w = 0;
          const width = this.size[0];
          let last_color = 0;
          let current_color;
          let ta_pos = new Uint16Array(2);
          ta_pos[1] = y;
          for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 0) {
              if (current_color === last_color) {
                if (res2.length === 0) {
                  res2[i_w++] = x;
                  res2[i_w++] = x;
                  res2[i_w++] = y;
                  res2[i_w++] = 0;
                  res2[i_w++] = 0;
                } else {
                  res2[i_w - 4]++;
                }
              } else {
                res2[i_w++] = x;
                res2[i_w++] = x;
                res2[i_w++] = y;
                res2[i_w++] = 0;
                res2[i_w++] = 0;
              }
            }
            last_color = current_color;
          }
          return res2;
        }
        "calculate_arr_row_x_off_spans_1bipp"(y) {
          const res2 = [];
          const width = this.size[0];
          const { ta: ta2 } = this;
          let last_color = 0;
          let current_color;
          const x_start = 0;
          let idx_bit_overall = y * this.size[0] + x_start | 0, idx_bit_within_byte = 0 | 0;
          let arr_last;
          let num_bits_remaining = width;
          let x = 0;
          let has_just_done_multi_read = false;
          let byte_val = 0 | 0;
          while (num_bits_remaining > 0) {
            idx_bit_within_byte = idx_bit_overall & 7;
            has_just_done_multi_read = false;
            if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
              byte_val = ta2[idx_bit_overall >> 3];
              if (byte_val === 255) {
                last_color = 1;
                has_just_done_multi_read = true;
                idx_bit_overall += 8;
                x += 8;
                num_bits_remaining -= 8;
              } else if (byte_val === 0) {
                if (last_color === 0) {
                  if (res2.length === 0) {
                    if (arr_last) res2.push(arr_last);
                    arr_last = [x, x + 7];
                  } else {
                    arr_last[1] += 8;
                  }
                } else {
                  if (arr_last) res2.push(arr_last);
                  arr_last = [x, x + 7];
                }
                x += 8;
                last_color = 0;
                num_bits_remaining -= 8;
                idx_bit_overall += 8;
                has_just_done_multi_read = true;
              } else {
              }
            }
            if (!has_just_done_multi_read) {
              current_color = (ta2[idx_bit_overall >> 3] & 128 >> idx_bit_within_byte) !== 0 ? 1 : 0;
              if (current_color === 0) {
                if (current_color === last_color) {
                  if (res2.length === 0) {
                    if (arr_last) res2.push(arr_last);
                    arr_last = [x, x];
                  } else {
                    arr_last[1]++;
                  }
                } else {
                  if (arr_last) res2.push(arr_last);
                  arr_last = [x, x];
                }
              }
              last_color = current_color;
              idx_bit_overall++;
              x++;
              num_bits_remaining--;
            }
          }
          if (arr_last) res2.push(arr_last);
          return res2;
        }
        // Could see about a more optimised way to do it that does not go row-by-row.
        // Do want a simpler way....
        // Want something with a callback for each y value.....
        // Does seem a bit tricky for the moment.
        // Want to streamline it more!
        "opt_calculate_arr_rows_arr_x_off_spans_1bipp"() {
          const ta_x_span_toggle_bits = get_ta_bits_that_differ_from_previous_as_1s2(this.ta);
          const [w, h] = this.size;
          const get_arr_arr_toggle_positions = () => {
            let prev_y = -1;
            let prev_x = -1;
            let arr_positions_in_row;
            const res2 = new Array(h);
            const handle_row_complete = (y, arr_x_toggle_positions) => {
              res2[y] = arr_x_toggle_positions;
            };
            each_1_index2(ta_x_span_toggle_bits, (i) => {
              const y = Math.floor(i / w);
              const x = i % w;
              if (y !== prev_y) {
                const y_diff = y - prev_y;
                if (arr_positions_in_row) {
                  arr_positions_in_row.push(prev_x);
                  handle_row_complete(prev_y, arr_positions_in_row);
                }
                if (y_diff > 1) {
                  for (let y2 = prev_y + 1; y2 < y; y2++) {
                    handle_row_complete(y2, []);
                  }
                }
                arr_positions_in_row = [x];
              } else {
                arr_positions_in_row.push(x);
              }
              prev_x = x;
              prev_y = y;
            });
            return res2;
          };
          const arr_arr_toggle_positions = get_arr_arr_toggle_positions();
          console.log("arr_arr_toggle_positions.length", arr_arr_toggle_positions.length);
          console.log("h", h);
          throw "stop";
          const _second_attempt = () => {
            let prev_y = -1;
            let current_i = 0;
            let current_color = 0;
            let arr_current_row_arr_off_spans;
            let current_span_start_x, current_span_end_x;
            let is_first_span_in_row = true;
            let res2 = [];
            const handle_row_complete = (arr_row, prev_y2, new_y) => {
              if (arr_row) {
                res2.push(arr_row);
              }
              arr_current_row_arr_off_spans = [];
            };
            const handle_span_off_start = (x, y) => {
              current_span_start_x = x;
            };
            const handle_span_off_end = (x, y) => {
              current_span_end_x = x;
              arr_current_row_arr_off_spans.push([current_span_start_x, current_span_end_x]);
            };
            const place_empty_row = () => {
              res2.push([0, w - 1]);
            };
            const handle_y_change_from_new_toggle_position = (prev_y2, y, x) => {
              handle_row_complete(arr_current_row_arr_off_spans, prev_y2, y);
              prev_y2++;
              while (prev_y2 < y) {
                place_empty_row();
                prev_y2++;
              }
              is_first_span_in_row = true;
              if (x === 0) {
                current_color = 1;
              } else {
                if (current_color === 1) {
                  handle_span_off_start(x, y);
                  current_color = 0;
                } else {
                  handle_span_off_start(0, y);
                  handle_span_off_end(x - 1, y);
                  current_color = 1;
                }
              }
            };
            each_1_index2(ta_x_span_toggle_bits, (i) => {
              const y = Math.floor(i / w);
              const x = i % w;
              if (y !== prev_y) {
                handle_y_change_from_new_toggle_position(prev_y, y, x);
              }
              current_i++;
            });
            return res2;
          };
          const old_attempt = () => {
            let prev_x = 0, prev_y = 0;
            const arr_rows_arr_x_off_spans_1bipp = [];
            let current_row = [];
            let current_color = 0;
            each_1_index2(ta_x_span_toggle_bits, (i) => {
              const y2 = Math.floor(i / w);
              const x = i % w;
              if (y2 > prev_y) {
                if (current_color === 0) {
                  current_row.push([prev_x, w - 1]);
                }
                arr_rows_arr_x_off_spans_1bipp.push(current_row);
                current_row = [];
                prev_y++;
                prev_x = 0;
                while (y2 > prev_y) {
                  current_row.push([0, w - 1]);
                  arr_rows_arr_x_off_spans_1bipp.push(current_row);
                  current_row = [];
                  prev_y++;
                  prev_x = 0;
                }
                current_color = 0;
                current_row = [[0, x]];
                prev_x = x;
              }
              if (x === 0) {
                current_color = 1;
              } else {
                if (current_color === 0) {
                  current_row.push([prev_x + 1, x]);
                }
                current_color ^= 1;
              }
              prev_y = y2;
              prev_x = x;
            });
            if (current_color === 0) {
              current_row.push([prev_x, w - 1]);
              arr_rows_arr_x_off_spans_1bipp.push(current_row);
            }
            const last_row_y = h - 1;
            let y = prev_y;
            y++;
            if (y < h) {
              while (y < h) {
                arr_rows_arr_x_off_spans_1bipp.push([[0, w - 1]]);
                y++;
              }
              arr_rows_arr_x_off_spans_1bipp.push([[0, w - 1]]);
            }
            return arr_rows_arr_x_off_spans_1bipp;
          };
        }
        "simpler_calculate_arr_rows_arr_x_off_spans_1bipp"() {
          const [width, height2] = this.size;
          const res2 = new Array(height2);
          for (let y = 0; y < height2; y++) {
            res2[y] = this.calculate_arr_row_x_off_spans_1bipp(y);
          }
          return res2;
        }
        "calculate_arr_rows_arr_x_off_spans_1bipp"() {
          return this.simpler_calculate_arr_rows_arr_x_off_spans_1bipp();
          const scalc = this.simpler_calculate_arr_rows_arr_x_off_spans_1bipp();
          console.log(JSON.stringify(scalc).slice(0, 2e3).replaceAll(",", ", "));
          const ocalc = this.opt_calculate_arr_rows_arr_x_off_spans_1bipp();
          console.log("\n\n");
          console.log(JSON.stringify(ocalc).slice(0, 2e3).replaceAll(",", ", "));
          return ocalc;
        }
        "calculate_arr_rows_arr_x_on_spans_1bipp"() {
          const [width, height2] = this.size;
          const res2 = new Array(height2);
          for (let y = 0; y < height2; y++) {
            res2[y] = this.calculate_arr_row_x_on_spans_1bipp(y);
          }
          return res2;
        }
        "count_row_off_xspans_1bipp"(y) {
          let res2 = 0;
          const width = this.size[0];
          let last_color = 0;
          let current_color;
          let ta_pos = new Uint16Array(2);
          ta_pos[1] = y;
          for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 0) {
              if (current_color === last_color) {
                if (res2.length === 0) {
                  res2++;
                } else {
                }
              } else {
                res2++;
                if (res2.length === 0) {
                } else {
                }
              }
            }
            last_color = current_color;
          }
          return res2;
        }
        "calculate_ta_row_x_on_x2ygbspans_1bipp"(y) {
          const count_xonspans = this.count_row_on_xspans_1bipp(y);
          const res2 = new Uint16Array(count_xonspans * 5);
          console.log("y, count_xonspans", y, count_xonspans);
          let i_w = 0;
          const width = this.size[0];
          let last_color = 1;
          let current_color;
          let ta_pos = new Uint16Array(2);
          ta_pos[1] = y;
          for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 1) {
              if (current_color === last_color) {
                if (res2.length === 0) {
                  res2[i_w++] = x;
                  res2[i_w++] = x;
                  res2[i_w++] = y;
                  res2[i_w++] = 0;
                  res2[i_w++] = 0;
                } else {
                  res2[i_w - 4]++;
                }
              } else {
                res2[i_w++] = x;
                res2[i_w++] = x;
                res2[i_w++] = y;
                res2[i_w++] = 0;
                res2[i_w++] = 0;
              }
            }
            last_color = current_color;
          }
          return res2;
        }
        "calculate_arr_rows_ta_x_off_x2ygbspans_1bipp"() {
          const [width, height2] = this.size;
          const res2 = new Array(height2);
          for (let y = 0; y < height2; y++) {
            res2[y] = this.calculate_ta_row_x_off_x2ygbspans_1bipp(y);
          }
          return res2;
        }
        "calculate_arr_rows_ta_x_on_x2ygbspans_1bipp"() {
          const [width, height2] = this.size;
          const res2 = new Array(height2);
          for (let y = 0; y < height2; y++) {
            res2[y] = this.calculate_ta_row_x_on_x2ygbspans_1bipp(y);
          }
          console.log("* this.ta", this.ta);
          console.log("this.size", this.size);
          return res2;
        }
        "calculate_arr_row_x_on_spans_1bipp"(y) {
          const initial_implementation = () => {
            const res2 = [];
            const width = this.size[0];
            let last_color = 1;
            let current_color;
            let ta_pos = new Uint16Array(2);
            ta_pos[1] = y;
            for (let x = 0; x < width; x++) {
              ta_pos[0] = x;
              current_color = this.get_pixel_1bipp(ta_pos);
              if (current_color === 1) {
                if (current_color === last_color) {
                  if (res2.length === 0) {
                    res2.push([x, x]);
                  } else {
                    res2[res2.length - 1][1]++;
                  }
                } else {
                  res2.push([x, x]);
                }
              }
              last_color = current_color;
            }
            return res2;
          };
          const _64x0 = BigInt(0);
          const _64x1 = ~_64x0;
          const broken_64bit_optimisation_attempt_inlined_consecutive_value_checking_no_x_loop_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res2 = [];
            const width = this.size[0];
            const { ta: ta2 } = this;
            const ab = ta2.buffer;
            const dv = new DataView(ab);
            let last_color = 1;
            let current_color;
            const x_start = 0;
            let idx_bit_overall = y * this.size[0] + x_start | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0;
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            let _8_byte_val = BigInt(0);
            while (num_bits_remaining > 0) {
              idx_bit_within_byte = idx_bit_overall & 7;
              has_just_done_multi_read = false;
              if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                if (num_bits_remaining >= 64) {
                  _8_byte_val = dv.getBigInt64(idx_bit_overall >> 3);
                  if (_8_byte_val === _64x0) {
                    last_color = 0;
                    has_just_done_multi_read = true;
                    idx_bit_overall += 64;
                    x += 64;
                    num_bits_remaining -= 64;
                  } else if (_8_byte_val === _64x1) {
                    if (last_color === 1) {
                      if (res2.length === 0) {
                        arr_last = [x, x + 63];
                        res2.push(arr_last);
                      } else {
                        arr_last[1] += 64;
                      }
                    } else {
                      arr_last = [x, x + 63];
                      res2.push(arr_last);
                    }
                    x += 8;
                    last_color = 1;
                    num_bits_remaining -= 64;
                    idx_bit_overall += 64;
                    has_just_done_multi_read = true;
                  }
                } else {
                }
                if (!has_just_done_multi_read) {
                  byte_val = ta2[idx_bit_overall >> 3];
                  if (byte_val === 255) {
                    if (last_color === 1) {
                      if (res2.length === 0) {
                        arr_last = [x, x + 7];
                        res2.push(arr_last);
                      } else {
                        arr_last[1] += 8;
                      }
                    } else {
                      arr_last = [x, x + 7];
                      res2.push(arr_last);
                    }
                    x += 8;
                    last_color = 1;
                    num_bits_remaining -= 8;
                    idx_bit_overall += 8;
                    has_just_done_multi_read = true;
                  } else if (byte_val === 0) {
                    last_color = 0;
                    has_just_done_multi_read = true;
                    idx_bit_overall += 8;
                    x += 8;
                    num_bits_remaining -= 8;
                  } else {
                  }
                }
              }
              if (!has_just_done_multi_read) {
                current_color = (ta2[idx_bit_overall >> 3] & 128 >> idx_bit_within_byte) !== 0 ? 1 : 0;
                if (current_color === 1) {
                  if (current_color === last_color) {
                    if (res2.length === 0) {
                      arr_last = [x, x];
                      res2.push(arr_last);
                    } else {
                      arr_last[1]++;
                    }
                  } else {
                    arr_last = [x, x];
                    res2.push(arr_last);
                  }
                }
                last_color = current_color;
                idx_bit_overall++;
                x++;
                num_bits_remaining--;
              }
            }
            return res2;
          };
          const inlined_consecutive_value_checking_no_x_loop_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res2 = [];
            const width = this.size[0];
            const { ta: ta2 } = this;
            const ab = ta2.buffer;
            const dv = new DataView(ab);
            let last_color = 1;
            let current_color;
            const x_start = 0;
            let idx_bit_overall = y * this.size[0] + x_start | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0;
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            while (num_bits_remaining > 0) {
              idx_bit_within_byte = idx_bit_overall & 7;
              has_just_done_multi_read = false;
              if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                byte_val = ta2[idx_bit_overall >> 3];
                if (byte_val === 255) {
                  if (last_color === 1) {
                    if (res2.length === 0) {
                      arr_last = [x, x + 7];
                      res2.push(arr_last);
                    } else {
                      arr_last[1] += 8;
                    }
                  } else {
                    arr_last = [x, x + 7];
                    res2.push(arr_last);
                  }
                  x += 8;
                  last_color = 1;
                  num_bits_remaining -= 8;
                  idx_bit_overall += 8;
                  has_just_done_multi_read = true;
                } else if (byte_val === 0) {
                  last_color = 0;
                  has_just_done_multi_read = true;
                  idx_bit_overall += 8;
                  x += 8;
                  num_bits_remaining -= 8;
                } else {
                }
              }
              if (!has_just_done_multi_read) {
                current_color = (ta2[idx_bit_overall >> 3] & 128 >> idx_bit_within_byte) !== 0 ? 1 : 0;
                if (current_color === 1) {
                  if (current_color === last_color) {
                    if (res2.length === 0) {
                      arr_last = [x, x];
                      res2.push(arr_last);
                    } else {
                      arr_last[1]++;
                    }
                  } else {
                    arr_last = [x, x];
                    res2.push(arr_last);
                  }
                }
                last_color = current_color;
                idx_bit_overall++;
                x++;
                num_bits_remaining--;
              }
            }
            return res2;
          };
          const inlined_consecutive_value_checking_no_x_loop_delayed_push_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res2 = [];
            const width = this.size[0];
            const { ta: ta2 } = this;
            const ab = ta2.buffer;
            const dv = new DataView(ab);
            let last_color = 1;
            let current_color;
            const x_start = 0;
            let idx_bit_overall = y * this.size[0] + x_start | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0;
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            while (num_bits_remaining > 0) {
              idx_bit_within_byte = idx_bit_overall & 7;
              has_just_done_multi_read = false;
              if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                byte_val = ta2[idx_bit_overall >> 3];
                if (byte_val === 255) {
                  if (last_color === 1) {
                    if (res2.length === 0) {
                      if (arr_last) {
                        res2.push(arr_last);
                      }
                      arr_last = [x, x + 7];
                    } else {
                      arr_last[1] += 8;
                    }
                  } else {
                    if (arr_last) {
                      res2.push(arr_last);
                    }
                    arr_last = [x, x + 7];
                  }
                  x += 8;
                  last_color = 1;
                  num_bits_remaining -= 8;
                  idx_bit_overall += 8;
                  has_just_done_multi_read = true;
                } else if (byte_val === 0) {
                  last_color = 0;
                  has_just_done_multi_read = true;
                  idx_bit_overall += 8;
                  x += 8;
                  num_bits_remaining -= 8;
                } else {
                }
              }
              if (!has_just_done_multi_read) {
                current_color = (ta2[idx_bit_overall >> 3] & 128 >> idx_bit_within_byte) !== 0 ? 1 : 0;
                if (current_color === 1) {
                  if (current_color === last_color) {
                    if (res2.length === 0) {
                      if (arr_last) {
                        res2.push(arr_last);
                      }
                      arr_last = [x, x];
                    } else {
                      arr_last[1]++;
                    }
                  } else {
                    if (arr_last) {
                      res2.push(arr_last);
                    }
                    arr_last = [x, x];
                  }
                }
                last_color = current_color;
                idx_bit_overall++;
                x++;
                num_bits_remaining--;
              }
            }
            if (arr_last) {
              res2.push(arr_last);
            }
            return res2;
          };
          return inlined_consecutive_value_checking_no_x_loop_delayed_push_implementation();
        }
      };
      var get_contig_x_spans_AND = (ta_contig_x_spans_1, ta_contig_x_spans_2) => {
        if (true) {
          const parallel_iterate_inputs = () => {
            const starting_color = 0;
            const l1 = ta_contig_x_spans_1.length, l2 = ta_contig_x_spans_2.length;
            let r_pos_in_1 = 0, r_pos_in_2 = 0;
            let px_idx_in_1 = 0, px_idx_in_2 = 0;
            let color_in_1 = starting_color, color_in_2 = starting_color;
            let color_in_output = starting_color;
            let pos_idx_in_output = 0;
            let are_in_sync = true;
            let i_read_step = 0;
            const arr_res = [];
            const read_step = () => {
              const span_length_from_1 = ta_contig_x_spans_1[r_pos_in_1], span_length_from_2 = ta_contig_x_spans_2[r_pos_in_2];
              console.log("");
              console.log("i_read_step", i_read_step);
              console.log("are_in_sync", are_in_sync);
              console.log("span_length_from_1", span_length_from_1);
              console.log("span_length_from_2", span_length_from_2);
              if (are_in_sync) {
                if (px_idx_in_1 === px_idx_in_2) {
                  if (span_length_from_1 === span_length_from_2) {
                    if (are_in_sync) {
                      const same_length_in_sync = span_length_from_1;
                      console.log("same_length_in_sync", same_length_in_sync);
                      px_idx_in_1 += same_length_in_sync;
                      px_idx_in_2 += same_length_in_sync;
                      pos_idx_in_output += same_length_in_sync;
                      r_pos_in_1++;
                      r_pos_in_2++;
                      arr_res.push(same_length_in_sync);
                      color_in_1 = color_in_1 === 1 ? 0 : 1;
                      color_in_2 = color_in_2 === 1 ? 0 : 1;
                      color_in_output = color_in_output === 1 ? 0 : 1;
                    } else {
                      console.trace();
                      throw "NYI";
                    }
                  } else if (span_length_from_1 > span_length_from_2) {
                    if (are_in_sync) {
                      const num_remaining_in_sync = span_length_from_2;
                      arr_res.push(num_remaining_in_sync);
                      console.trace();
                      throw "NYI";
                    } else {
                      console.trace();
                      throw "NYI";
                    }
                  } else {
                    console.trace();
                    throw "NYI";
                  }
                } else {
                  console.trace();
                  throw "NYI";
                }
              } else {
                console.trace();
                throw "NYI";
              }
              i_read_step++;
            };
            read_step();
            console.log("arr_res", arr_res);
            read_step();
          };
          parallel_iterate_inputs();
        } else {
          console.trace();
          throw "Length Mismatch";
        }
      };
      Pixel_Buffer_Specialised_Enh.get_contig_x_spans_AND = get_contig_x_spans_AND;
      module.exports = Pixel_Buffer_Specialised_Enh;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-8-enh.js
  var require_pixel_buffer_8_enh = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer-8-enh.js"(exports, module) {
      var Pixel_Buffer_Enh = require_pixel_buffer_7_specialised_enh();
      module.exports = Pixel_Buffer_Enh;
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer.js
  var require_pixel_buffer = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/pixel-buffer.js"(exports, module) {
      module.exports = require_pixel_buffer_8_enh();
    }
  });

  // ../jsgui3-html/node_modules/jsgui3-gfx-core/core/gfx-core.js
  var require_gfx_core = __commonJS({
    "../jsgui3-html/node_modules/jsgui3-gfx-core/core/gfx-core.js"(exports, module) {
      var Rectangle = require_Rectangle();
      var gfx_core = {
        Pixel_Pos_List: require_pixel_pos_list(),
        Pixel_Buffer: require_pixel_buffer(),
        Pixel_Buffer_Painter: require_pixel_buffer_painter(),
        convolution_kernels: require_kernels(),
        ta_math: require_ta_math(),
        Rectangle,
        Rect: Rectangle
      };
      module.exports = gfx_core;
    }
  });

  // ../jsgui3-html/html-core/Data.js
  var require_Data = __commonJS({
    "../jsgui3-html/html-core/Data.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Data_Model, Evented_Class } = require_lang();
      var Data = class extends Evented_Class {
        constructor(...a) {
          super(...a);
          const [spec] = a;
          if (spec.context) this.context = spec.context;
          if (spec.model) {
            if (spec.model instanceof Data_Model) {
              this._model = spec.model;
            } else {
              console.trace();
              throw new Error("Data: Expected spec.model to be a Data_Model");
            }
          }
          if (spec.model_constructor) {
            this.model_constructor = spec.model_constructor;
          }
        }
        get model() {
          if (this._model === void 0) {
            if (this.model_constructor) {
              this._model = new this.model_constructor({ context: this.context });
            } else {
              this._model = new Data_Value2({ context: this.context });
            }
          }
          return this._model;
        }
        set model(value2) {
          if (value2 !== this._model) {
            const old = this._model;
            this._model = value2;
            this.raise("change", {
              name: "model",
              old,
              value: value2
            });
          }
        }
      };
      module.exports = Data;
    }
  });

  // ../jsgui3-html/html-core/Control_Data.js
  var require_Control_Data = __commonJS({
    "../jsgui3-html/html-core/Control_Data.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Data = require_Data();
      var Control_Data = class extends Data {
        constructor(spec = {}) {
          const enriched_spec = Object.assign(
            {
              model_constructor: Data_Object
            },
            spec
          );
          super(enriched_spec);
        }
        // but will have a model on change system of some sort(s).
        // Reassigning events (change event handlers).
        //   So anything listening for change events on the old model instead listens to change events on the new model.
        // so the Control_Data would raise a 'change' event with name 'model'.
        //   maybe worth being clearer about what kinds of changes there are, ie if something's value changes, or of it gets
        //   replaced with another item.
      };
      module.exports = Control_Data;
    }
  });

  // ../jsgui3-html/html-core/Control_View_UI_Low_Level_Data.js
  var require_Control_View_UI_Low_Level_Data = __commonJS({
    "../jsgui3-html/html-core/Control_View_UI_Low_Level_Data.js"(exports, module) {
      var Control_Data = require_Control_Data();
      var Control_View_UI_Low_Level_Data = class extends Control_Data {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Control_View_UI_Low_Level_Data;
    }
  });

  // ../jsgui3-html/html-core/Control_View_UI_Low_Level.js
  var require_Control_View_UI_Low_Level = __commonJS({
    "../jsgui3-html/html-core/Control_View_UI_Low_Level.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Control_View_UI_Low_Level_Data = require_Control_View_UI_Low_Level_Data();
      var Control_View_UI_Low_Level = class extends Data_Object {
        constructor(spec = {}) {
          super(spec);
          const { context: context2 } = this;
          if (spec.data) {
            this.data = spec.data;
          } else {
            this.data = new Control_View_UI_Low_Level_Data({ context: context2 });
          }
        }
      };
      module.exports = Control_View_UI_Low_Level;
    }
  });

  // ../jsgui3-html/html-core/Control_View_UI.js
  var require_Control_View_UI = __commonJS({
    "../jsgui3-html/html-core/Control_View_UI.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Control_View_UI_Low_Level = require_Control_View_UI_Low_Level();
      var Control_View_UI_Compositional = class extends Data_Object {
        constructor(...a) {
          super(...a);
          this.models = [];
          field(this, "model", new Data_Value2());
        }
      };
      var Control_View_UI_Active_Compositional = class extends Control_View_UI_Compositional {
        constructor(...a) {
          super(...a);
        }
      };
      var Control_View_UI_Active = class extends Data_Object {
        constructor(...a) {
          super(...a);
          const compositional = new Control_View_UI_Active_Compositional();
          Object.defineProperty(this, "compositional", { get: () => compositional });
        }
      };
      var Control_View_UI = class extends Data_Object {
        constructor(...a) {
          super(...a);
          const active = new Control_View_UI_Active();
          Object.defineProperty(this, "active", { get: () => active });
          const compositional = new Control_View_UI_Compositional();
          Object.defineProperty(this, "compositional", { get: () => compositional });
        }
      };
      module.exports = Control_View_UI;
    }
  });

  // ../jsgui3-html/html-core/Control_View_Data.js
  var require_Control_View_Data = __commonJS({
    "../jsgui3-html/html-core/Control_View_Data.js"(exports, module) {
      var Control_Data = require_Control_Data();
      var Control_View_Data = class extends Control_Data {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Control_View_Data;
    }
  });

  // ../jsgui3-html/html-core/Control_View_Low_Level_Data.js
  var require_Control_View_Low_Level_Data = __commonJS({
    "../jsgui3-html/html-core/Control_View_Low_Level_Data.js"(exports, module) {
      var Control_Data = require_Control_Data();
      var Control_View_Low_Level_Data = class extends Control_Data {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Control_View_Low_Level_Data;
    }
  });

  // ../jsgui3-html/html-core/Control_View_Low_Level.js
  var require_Control_View_Low_Level = __commonJS({
    "../jsgui3-html/html-core/Control_View_Low_Level.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Control_View_Low_Level_Data = require_Control_View_Low_Level_Data();
      var Control_View_Low_Level = class extends Data_Object {
        constructor(spec = {}) {
          super(spec);
          const { context: context2 } = this;
          const data = (() => {
            if (spec.data) {
              return spec.data;
            } else {
              return new Control_View_Low_Level_Data({ context: context2 });
            }
          })();
          Object.defineProperty(this, "data", { get: () => data });
        }
      };
      module.exports = Control_View_Low_Level;
    }
  });

  // ../jsgui3-html/html-core/Control_View.js
  var require_Control_View = __commonJS({
    "../jsgui3-html/html-core/Control_View.js"(exports, module) {
      var { field, Data_Object, Evented_Class } = require_lang();
      var Data = require_Data();
      var Control_View_UI = require_Control_View_UI();
      var Control_View_Data = require_Control_View_Data();
      var Control_View_Low_Level = require_Control_View_Low_Level();
      var Control_View = class extends Evented_Class {
        // .data.model
        // .ui.data.model
        constructor(spec = {}) {
          super();
          if (spec.context) this.context = spec.context;
          const { context: context2 } = this;
          const o_data = {};
          if (spec.data) {
            if (spec.data.model) {
              o_data.model = spec.data.model;
            } else {
            }
          }
          this.data = new Control_View_Data(o_data);
          const o_ui = { context: context2 };
          if (spec.ui && spec.ui.data) {
            o_ui.data = spec.ui.data;
          }
          this.ui = new Control_View_UI(o_ui);
          if (spec.data) {
          }
          if (!this.data.model) {
          }
        }
      };
      module.exports = Control_View;
    }
  });

  // ../jsgui3-html/html-core/Control_Validation_Data.js
  var require_Control_Validation_Data = __commonJS({
    "../jsgui3-html/html-core/Control_Validation_Data.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Data = require_Data();
      var Control_Validation_Data = class extends Data {
        constructor(spec = {}) {
          super(spec);
        }
      };
      module.exports = Control_Validation_Data;
    }
  });

  // ../jsgui3-html/html-core/Validation_State.js
  var require_Validation_State = __commonJS({
    "../jsgui3-html/html-core/Validation_State.js"(exports, module) {
      var { Evented_Class, tof } = require_lang();
      var Validation_State = class _Validation_State extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          this._valid = void 0;
          this._message = void 0;
          this._code = void 0;
          this._details = void 0;
          const t_spec = tof(spec);
          if (t_spec === "boolean") {
            this._valid = spec;
          } else if (t_spec === "string") {
            this._valid = false;
            this._message = spec;
          } else if (t_spec === "object" && spec) {
            if (Object.prototype.hasOwnProperty.call(spec, "valid")) this._valid = spec.valid;
            if (Object.prototype.hasOwnProperty.call(spec, "message")) this._message = spec.message;
            if (Object.prototype.hasOwnProperty.call(spec, "code")) this._code = spec.code;
            if (Object.prototype.hasOwnProperty.call(spec, "details")) this._details = spec.details;
          }
        }
        set(value2) {
          const t_value = tof(value2);
          if (t_value === "boolean") {
            this.valid = value2;
            return;
          }
          if (t_value === "undefined" || value2 === null) {
            this.valid = void 0;
            this.message = void 0;
            this.code = void 0;
            this.details = void 0;
            return;
          }
          if (t_value === "string") {
            const str = value2.trim().toLowerCase();
            if (str === "valid" || str === "true" || str === "ok" || str === "pass") {
              this.valid = true;
              this.message = void 0;
              return;
            }
            if (str === "invalid" || str === "false" || str === "error" || str === "fail") {
              this.valid = false;
              this.message = void 0;
              return;
            }
            if (str === "neutral" || str === "unknown" || str === "") {
              this.valid = void 0;
              this.message = void 0;
              return;
            }
            this.message = value2;
            if (typeof this.valid === "undefined") this.valid = false;
            return;
          }
          if (value2 instanceof _Validation_State) {
            this.valid = value2.valid;
            this.message = value2.message;
            this.code = value2.code;
            this.details = value2.details;
            return;
          }
          if (value2 instanceof Error) {
            this.message = value2.message;
            this.details = value2;
            if (typeof this.valid === "undefined") this.valid = false;
            return;
          }
          if (t_value === "object" && value2) {
            if (Object.prototype.hasOwnProperty.call(value2, "valid")) this.valid = value2.valid;
            if (Object.prototype.hasOwnProperty.call(value2, "message")) this.message = value2.message;
            if (Object.prototype.hasOwnProperty.call(value2, "code")) this.code = value2.code;
            if (Object.prototype.hasOwnProperty.call(value2, "details")) this.details = value2.details;
            return;
          }
          this.details = value2;
          if (typeof this.valid === "undefined") this.valid = false;
        }
        get valid() {
          return this._valid;
        }
        set valid(value2) {
          if (value2 === this._valid) return;
          const old = this._valid;
          this._valid = value2;
          this.raise("change", { name: "valid", old, value: value2 });
        }
        get message() {
          return this._message;
        }
        set message(value2) {
          const message = value2 instanceof Error ? value2.message : value2;
          const new_message = typeof message === "undefined" || message === null ? message : String(message);
          if (new_message === this._message) return;
          const old = this._message;
          this._message = new_message;
          this.raise("change", { name: "message", old, value: new_message });
        }
        get code() {
          return this._code;
        }
        set code(value2) {
          if (value2 === this._code) return;
          const old = this._code;
          this._code = value2;
          this.raise("change", { name: "code", old, value: value2 });
        }
        get details() {
          return this._details;
        }
        set details(value2) {
          if (value2 === this._details) return;
          const old = this._details;
          this._details = value2;
          this.raise("change", { name: "details", old, value: value2 });
        }
      };
      module.exports = Validation_State;
    }
  });

  // ../jsgui3-html/html-core/Control_Validation_Target.js
  var require_Control_Validation_Target = __commonJS({
    "../jsgui3-html/html-core/Control_Validation_Target.js"(exports, module) {
      var { Evented_Class } = require_lang();
      var Control_Validation_Target = class {
        // will target 'data'.
        //  and that will have a .model of course.
        // this.data.model.on change etc.
      };
      module.exports = Control_Validation_Target;
    }
  });

  // ../jsgui3-html/html-core/Control_Validation_Validator.js
  var require_Control_Validation_Validator = __commonJS({
    "../jsgui3-html/html-core/Control_Validation_Validator.js"(exports, module) {
      var { Evented_Class } = require_lang();
      var Control_Validation_Validator = class extends Evented_Class {
        constructor(spec) {
          super();
        }
        // needs a 'data' property / field.
        // getter and setter in the class may be simplest for the moment....
      };
      module.exports = Control_Validation_Validator;
    }
  });

  // ../jsgui3-html/html-core/Control_Validation.js
  var require_Control_Validation = __commonJS({
    "../jsgui3-html/html-core/Control_Validation.js"(exports, module) {
      var { field, Data_Object, Data_Value: Data_Value2, Evented_Class } = require_lang();
      var Control_Validation_Data = require_Control_Validation_Data();
      var Validation_State = require_Validation_State();
      var Control_Validation_Target = require_Control_Validation_Target();
      var Control_Validation_Validator = require_Control_Validation_Validator();
      var Control_Validation = class extends Evented_Class {
        // Or set up validation on data model states?
        // Control validation will be about if the view.data.model.value is valid according to the data.model.valdate_value
        constructor(spec = {}) {
          super(spec);
          if (spec.data) {
            if (spec.data.model) {
              this.data.model = spec.data.model;
            }
          }
        }
        // and validator too....
        get validator() {
          if (this._validator === void 0) {
            this._validator = new Control_Validation_Validator({ context: this.context });
          }
          return this._validator;
        }
        set validator(value2) {
          if (value2 !== this._validator) {
            const old = this._validator;
            this._validator = value2;
            this.raise("change", {
              name: "validator",
              old,
              value: value2
            });
          }
        }
        get target() {
          if (this._target === void 0) {
            this._target = new Control_Validation_Target({ context: this.context });
          }
          return this._target;
        }
        set target(value2) {
          if (value2 !== this._target) {
            const old = this._target;
            this._target = value2;
            this.raise("change", {
              name: "target",
              old,
              value: value2
            });
          }
        }
        get state() {
          if (this._state === void 0) {
            this._state = new Validation_State();
          }
          return this._state;
        }
        // Need both .data and .view.data
        //   It may validate between them...?
        // validation.validator = ....?
        // validation.validatior.data.model = ...???
        //   Does seem logical!!!
        // Control_Validation_Target
        // validation.target.data.model = ....?
        // Control_Validation_Validator even!!!!
        // A very explicit API would help, will be a bit fiddly to code all the parts.
        // Validator and Target would be explicit names, and will be clear when a view data model is being validated according to the (backing) data model
        get data() {
          if (this._data === void 0) {
            this._data = new Control_Validation_Data({ context: this.context });
          }
          return this._data;
        }
        // And a view property too.
        // Seems somewhat easy to set up like this....
        // Though it's Control_Validation_View
        // Validation View???
        // ctrl.validation.view.data.model = ctrl.view.data.model
        // Validate view agasint non-view.
        set data(value2) {
          if (value2 !== this._data) {
            const old = this._data;
            this._data = value2;
            this.raise("change", {
              name: "data",
              old,
              value: value2
            });
          }
        }
      };
      module.exports = Control_Validation;
    }
  });

  // ../jsgui3-html/html-core/control_model_factory.js
  var require_control_model_factory = __commonJS({
    "../jsgui3-html/html-core/control_model_factory.js"(exports, module) {
      var { Data_Object } = require_lang();
      var Control_Data = require_Control_Data();
      var Control_View = require_Control_View();
      var Control_View_Data = require_Control_View_Data();
      var Control_View_UI = require_Control_View_UI();
      var ensure_control_models = (ctrl, spec = {}) => {
        const context2 = ctrl.context;
        if (!ctrl.data) {
          ctrl.data = new Control_Data({
            context: context2,
            model: spec.data && spec.data.model ? spec.data.model : void 0,
            model_constructor: Data_Object
          });
        } else if (!ctrl.data.model) {
          ctrl.data.model = spec.data && spec.data.model ? spec.data.model : new Data_Object({ context: context2 });
        }
        if (!ctrl.view) {
          ctrl.view = new Control_View({
            context: context2,
            data: spec.view && spec.view.data ? spec.view.data : void 0
          });
        } else {
          if (!ctrl.view.data) {
            ctrl.view.data = new Control_View_Data({
              context: context2,
              model: spec.view && spec.view.data ? spec.view.data.model : void 0
            });
          } else if (!ctrl.view.data.model) {
            ctrl.view.data.model = spec.view && spec.view.data && spec.view.data.model ? spec.view.data.model : new Data_Object({ context: context2 });
          }
          if (!ctrl.view.ui) {
            ctrl.view.ui = new Control_View_UI({ context: context2 });
          }
        }
        return ctrl;
      };
      module.exports = {
        ensure_control_models
      };
    }
  });

  // ../jsgui3-html/control_mixins/model_data_view_compositional_representation.js
  var require_model_data_view_compositional_representation = __commonJS({
    "../jsgui3-html/control_mixins/model_data_view_compositional_representation.js"(exports, module) {
      var {
        tof,
        each,
        Data_Model,
        Data_Value: Data_Value2,
        Immutable_Data_Model,
        Immutable_Data_Value,
        Collection
      } = require_lang();
      var Control_Data = require_Control_Data();
      var Control_View = require_Control_View();
      var Control_Validation = require_Control_Validation();
      var { ensure_control_models } = require_control_model_factory();
      var model_data_view_compositional_representation = (ctrl, options = {}) => {
        const { data } = options;
        ctrl.using_model_data_view_compositional_representation = true;
        const verify_ctrl_conditions = (ctrl2) => {
          if (ctrl2.data !== void 0) return false;
          if (ctrl2.view !== void 0) return false;
          if (ctrl2.validation !== void 0) return false;
          return true;
        };
        const can_proceed = verify_ctrl_conditions(ctrl);
        if (can_proceed) {
          const { context: context2 } = ctrl;
          ensure_control_models(ctrl, { data });
          ctrl.validation = new Control_Validation();
          ctrl.view = ctrl.view || new Control_View({
            context: context2
          });
          ctrl.view.data.model.mixins = ctrl.view.data.model.mixins || new Collection();
          ctrl.view.data.model.mixins.on("change", (e_change) => {
            const { name, value: value2 } = e_change;
            if (name === "insert") {
              const o_mxs = {};
              ctrl.view.data.model.mixins.each((mx) => {
                o_mxs[mx.name] = mx;
                if (ctrl.context.mixins) {
                  const my_mx = ctrl.context.mixins[mx.name];
                  my_mx(ctrl);
                }
              });
            }
          });
        } else {
          console.trace();
          console.log("ctrl", ctrl);
          throw "model_data_view_compositional_representation(ctrl) - ctrl must not have .data or .view properties";
        }
      };
      module.exports = model_data_view_compositional_representation;
    }
  });

  // ../jsgui3-html/html-core/control-enh.js
  var require_control_enh = __commonJS({
    "../jsgui3-html/html-core/control-enh.js"(exports, module) {
      var jsgui = require_lang();
      var {
        get_a_sig,
        each,
        tof,
        def
      } = jsgui;
      var v_subtract2 = jsgui.util.v_subtract;
      var {
        prom_or_cb
      } = require_fnl();
      var Text_Node = require_text_node();
      var Control_Core = require_control_core();
      var has_window = typeof window !== "undefined";
      var gfx = require_gfx_core();
      var { Rect } = gfx;
      var model_data_view_compositional_representation = require_model_data_view_compositional_representation();
      var desc = (ctrl, callback2) => {
        if (ctrl.get) {
          var content = ctrl.get("content");
          if (content) {
            var t_content = typeof content;
            if (t_content === "string" || t_content === "number") {
            } else {
              var arr = content._arr;
              var c2, l2 = arr.length;
              var item2, t_item;
              for (c2 = 0; c2 < l2; c2++) {
                item2 = arr[c2];
                t_item = typeof item2;
                if (t_item === "string" || t_item === "numbers") {
                } else {
                  callback2(arr[c2]);
                  desc(arr[c2], callback2);
                }
              }
            }
          }
        }
      };
      var dom_desc = (el, callback2) => {
        callback2(el);
        var cns = el.childNodes;
        var l2 = cns.length;
        for (var c2 = 0; c2 < l2; c2++) {
          dom_desc(cns[c2], callback2);
        }
      };
      var mapDomEventNames = {
        "change": true,
        "click": true,
        "dblclick": true,
        "mousedown": true,
        "mouseup": true,
        "mousemove": true,
        "mouseover": true,
        "mouseout": true,
        "blur": true,
        "focus": true,
        "keydown": true,
        "keyup": true,
        "keypress": true,
        "contextmenu": true,
        "touchstart": true,
        "touchmove": true,
        "touchend": true,
        "touchcancel": true,
        "touchforcechange": true,
        "transitionend": true,
        "abort": true,
        "canplay": true,
        "canplaythrough": true,
        "durationchange": true,
        "emptied": true,
        "ended": true,
        "error": true,
        "loadeddata": true,
        "loadedmetadata": true,
        "loadstart": true,
        "pause": true,
        "play": true,
        "playing": true,
        "progress": true,
        "ratechange": true,
        "seeked": true,
        "seeking": true,
        "submit": true,
        "stalled": true,
        "suspend": true,
        "timeupdate": true,
        "volumechange": true,
        "waiting": true
      };
      var Control2 = class extends Control_Core {
        constructor(spec, fields) {
          spec = spec || {};
          super(spec, fields);
          const o_repr = {};
          if (spec.data) o_repr.data = spec.data;
          model_data_view_compositional_representation(this, o_repr);
          if (spec.id) {
            this.__id = spec.id;
          }
          if (spec.__id) {
            this.__id = spec.__id;
          }
          if (spec.__type_name) {
            this.__type_name = spec.__type_name;
          }
          this.map_raises_dom_events = {};
          if (spec.el) {
            var jgf = spec.el.getAttribute("data-jsgui-fields");
            if (jgf) {
              this._persisted_fields = this._persisted_fields || {};
              var s_pre_parse = jgf.replace(/\[DBL_QT\]/g, '"').replace(/\[SNG_QT\]/g, "'");
              s_pre_parse = s_pre_parse.replace(/\'/g, '"');
              var props = JSON.parse(s_pre_parse);
              let exempt_prop_names = {};
              each(props, (v, i) => {
                if (exempt_prop_names[i]) {
                } else {
                  this._persisted_fields[i] = v;
                }
              });
            }
          }
          if (spec.el) {
            if (def(this.selection_scope)) {
              this.selection_scope = this.context.new_selection_scope(this);
            }
            var tn = spec.el.getAttribute("data-jsgui-type");
            if (tn) this.__type_name = tn;
            var id = spec.el.getAttribute("data-jsgui-id");
            if (id) this.__id = id;
          }
          if (!spec.el) {
            this.compose_using_compositional_model();
          }
          this.view.ui.compositional.on("change", (e) => {
            const { name } = e;
            if (name === "model") {
              this.recompose_using_compositional_model();
            }
          });
          if (spec.size) {
            this.size = spec.size;
          }
          if (spec.background) {
            if (spec.background.color) {
              this.background.color = spec.background.color;
            }
          }
          const set_view_ui_composition_model_from_spec = () => {
            if (spec.comp) {
              this.view.ui.compositional.model = spec.comp;
            } else if (spec.composition) {
              this.view.ui.compositional.model = spec.composition;
            } else if (spec.view) {
              if (spec.view.ui) {
                if (spec.view.ui.compositional) {
                  if (spec.view.ui.compositional.model) {
                    this.view.ui.compositional.model = spec.view.ui.compositional.model;
                  }
                }
              }
            }
          };
          set_view_ui_composition_model_from_spec();
        }
        recompose_using_compositional_model() {
          this.content.clear();
          this.compose_using_compositional_model();
        }
        compose_using_compositional_model() {
          let cm;
          const { context: context2 } = this;
          if (this.view.ui.compositional.model) {
            cm = this.view.ui.compositional.model;
          }
          const tcm = tof(cm);
          const compose_from_compositional_model_array = (arr_cm) => {
            const l2 = arr_cm.length;
            if (l2 > 0) {
              for (let c2 = 0; c2 < l2; c2++) {
                const composition_item = arr_cm[c2];
                const tci = tof(composition_item);
                if (tci === "function") {
                  const ctrl = new composition_item({ context: context2 });
                  this.add(ctrl);
                } else if (tci === "control") {
                  if (!composition_item.context) composition_item.context = context2;
                  this.add(composition_item);
                } else if (tci === "string" || tci === "number" || tci === "boolean") {
                  this.add("" + composition_item);
                } else if (tci === "array") {
                  if (composition_item.length === 2) {
                    const [t0, t12] = [tof(composition_item[0]), tof(composition_item[1])];
                    if (t0 === "function" && t12 === "object") {
                      const ctrl_spec = composition_item[1];
                      ctrl_spec.context = ctrl_spec.context || context2;
                      const ctrl = new composition_item[0](ctrl_spec);
                      this.add(ctrl);
                    } else if (t0 === "string" && t12 === "function") {
                      const ctrl = new composition_item[1]({ context: context2 });
                      this.add(ctrl);
                      this._ctrl_fields = this._ctrl_fields || {};
                      this._ctrl_fields[composition_item[0]] = ctrl;
                      this[composition_item[0]] = ctrl;
                    } else if (t0 === "string" && t12 === "control") {
                      const ctrl = composition_item[1];
                      if (!ctrl.context) ctrl.context = context2;
                      this.add(ctrl);
                      this._ctrl_fields = this._ctrl_fields || {};
                      this._ctrl_fields[composition_item[0]] = ctrl;
                      this[composition_item[0]] = ctrl;
                    } else {
                      throw new Error("compose_using_compositional_model: Unsupported composition item (length 2)");
                    }
                  } else if (composition_item.length === 3) {
                    const [t0, t12, t2] = [tof(composition_item[0]), tof(composition_item[1]), tof(composition_item[2])];
                    if (t0 === "string" && t12 === "function" && t2 === "object") {
                      const ctrl_spec = composition_item[2];
                      ctrl_spec.context = ctrl_spec.context || context2;
                      const ctrl = new composition_item[1](ctrl_spec);
                      this.add(ctrl);
                      this._ctrl_fields = this._ctrl_fields || {};
                      this._ctrl_fields[composition_item[0]] = ctrl;
                      this[composition_item[0]] = ctrl;
                    } else if (t0 === "string" && t12 === "control" && t2 === "object") {
                      const ctrl = composition_item[1];
                      if (!ctrl.context) ctrl.context = context2;
                      this.add(ctrl);
                      this._ctrl_fields = this._ctrl_fields || {};
                      this._ctrl_fields[composition_item[0]] = ctrl;
                      this[composition_item[0]] = ctrl;
                    } else {
                      throw new Error("compose_using_compositional_model: Unsupported composition item (length 3)");
                    }
                  } else {
                    throw new Error("compose_using_compositional_model: Unsupported composition item length: " + composition_item.length);
                  }
                }
              }
            }
          };
          if (tcm === "array") {
            compose_from_compositional_model_array(cm);
          }
        }
        "ctrls"(obj_ctrls) {
          this._ctrl_fields = this._ctrl_fields || {};
          let cf = this._ctrl_fields;
          each(obj_ctrls, (ctrl, name) => {
            cf[name] = this[name] = ctrl;
            this.add(ctrl);
          });
          return this;
        }
        "bcr"() {
          var a = arguments;
          a.l = a.length;
          var sig = get_a_sig(a, 1);
          if (sig === "[]") {
            var el = this.dom.el;
            var bcr = el.getBoundingClientRect();
            const res_rect = new Rect([bcr.width, bcr.height], [bcr.left, bcr.top]);
            return res_rect;
          } else if (sig === "[a]") {
            let [pos, br_pos, size] = a[0];
            this.style({
              "position": "absolute",
              "left": pos[0] + "px",
              "top": pos[1] + "px",
              "width": size[0] + "px",
              "height": size[1] + "px"
            });
          }
        }
        get size() {
          if (this._size) {
            return this._size;
          } else {
            if (this.dom.el) {
              var bcr = this.dom.el.getBoundingClientRect();
              return [bcr.width, bcr.height];
            }
          }
        }
        "add_text"(value2) {
          var tn = new Text_Node({
            "context": this.context,
            "text": value2 + ""
          });
          this.add(tn);
          return tn;
        }
        "computed_style"() {
          var a = arguments;
          a.l = a.length;
          var sig = get_a_sig(a, 1);
          var y;
          if (sig == "[s]") {
            var property_name = a[0];
            var el = this.dom.el;
            if (el.currentStyle)
              y = el.currentStyle[styleProp];
            else if (window.getComputedStyle)
              y = document.defaultView.getComputedStyle(el, null).getPropertyValue(property_name);
            return y;
          }
        }
        "padding"() {
          var a = arguments;
          a.l = a.length;
          var sig = get_a_sig(a, 1);
          if (sig == "[]") {
            var left, top, right, bottom;
            var c_padding = this.computed_style("padding");
            var s_c_padding = c_padding.split(" ");
            if (s_c_padding.length == 3) {
              top = parseInt(s_c_padding[0], 10);
              right = parseInt(s_c_padding[1], 10);
              bottom = parseInt(s_c_padding[2], 10);
              return [0, top, right, bottom];
            }
          } else {
            console.trace();
            throw "Required argument: (array)";
          }
        }
        "border"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig == "[]") {
            if (!has_window) return;
            if (!this.dom.el) return;
            const parse_px = (value2) => {
              const parsed = parseFloat(value2);
              return Number.isFinite(parsed) ? parsed : 0;
            };
            const left = parse_px(this.computed_style("border-left-width") || 0);
            const top = parse_px(this.computed_style("border-top-width") || 0);
            const right = parse_px(this.computed_style("border-right-width") || 0);
            const bottom = parse_px(this.computed_style("border-bottom-width") || 0);
            return [left, top, right, bottom];
          } else {
            console.trace();
            throw "Required argument: (array)";
          }
        }
        "border_thickness"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig == "[]") {
            var left, top, right, bottom;
            var c_border = this.computed_style("border");
            var b2 = c_border.split(", ").join("");
            var s_c_border = b2.split(" ");
            var thickness = parseInt(s_c_border[0], 10);
            return thickness;
          }
        }
        "activate_recursive"() {
          var el = this.dom.el;
          var context2 = this.context;
          var map_controls = context2.map_controls;
          var parent_control;
          recursive_dom_iterate_depth(el, (el2) => {
            const nt = el2.nodeType;
            if (nt == 1) {
              var jsgui_id = el2.getAttribute("data-jsgui-id");
              if (jsgui_id) {
                var ctrl = map_controls[jsgui_id];
                if (!ctrl.__active) ctrl.activate(el2);
              }
            }
          });
        }
        "add_dom_event_listener"(event_name, fn_handler) {
          if (has_window) {
            const {
              context: context2
            } = this;
            const el = this.dom.el;
            const m = this.map_handlers_to_outer_handlers = this.map_handlers_to_outer_handlers || /* @__PURE__ */ new Map();
            let outer_handler;
            if (m.has(fn_handler)) {
              outer_handler = m.get(fn_handler);
            } else {
              outer_handler = (e) => {
                const {
                  target
                } = e;
                const jid = target.getAttribute("data-jsgui-id");
                if (jid) {
                  e.ctrl_target = context2.map_controls[jid];
                }
                fn_handler(e);
              };
              m.set(fn_handler, outer_handler);
            }
            if (el) {
              el.addEventListener(event_name, outer_handler, false);
            }
          }
        }
        "remove_dom_event_listener"(event_name, fn_handler) {
          if (has_window) {
            const m = this.map_handlers_to_outer_handlers;
            let outer_handler;
            if (m) {
              if (m.has(fn_handler)) {
                outer_handler = m.get(fn_handler);
              }
            }
            outer_handler = outer_handler || fn_handler;
            const el = this.dom.el;
            if (el) {
              el.removeEventListener(event_name, outer_handler, false);
            }
          }
        }
        "remove_event_listener"() {
          const a = arguments;
          const sig = get_a_sig(a, 1);
          if (sig === "[s,f]") {
            let [event_name, fn_handler] = a;
            if (mapDomEventNames[event_name]) {
              this.remove_dom_event_listener(event_name, fn_handler);
            }
            Control_Core.prototype.remove_event_listener.apply(this, a);
          } else if (sig === "[o]") {
            each(a[0], (v, i) => {
              this.remove_event_listener(i, v);
            });
          }
        }
        "add_event_listener"() {
          const a = arguments;
          const l2 = a.length;
          const sig = get_a_sig(a, 1);
          if (l2 === 1) {
            each(a[0], (v, i) => {
              this.add_event_listener(i, v);
            });
          }
          if (l2 === 2) {
            super.add_event_listener(a[0], a[1]);
          }
          if (l2 === 3) {
            super.add_event_listener(a[0], a[2]);
          }
          if (sig === "[s,f]" || sig === "[s,b,f]") {
            let event_name = a[0];
            let using_dom = true;
            if (l2 === 3 && a[1] === false) using_dom = false;
            let fn_handler;
            if (l2 === 2) fn_handler = a[1];
            if (l2 === 3) fn_handler = a[2];
            if (mapDomEventNames[a[0]] && using_dom) {
              this.add_dom_event_listener(event_name, fn_handler);
            }
          }
        }
        "once_active"(cb) {
          if (typeof document !== "undefined") {
            return prom_or_cb((solve, jettison) => {
              if (this.__active) {
                solve();
              } else {
                let fn_activate = () => {
                  solve();
                  setTimeout(() => {
                    this.off("activate", fn_activate);
                  }, 0);
                };
                this.on("activate", fn_activate);
              }
            }, cb);
          }
        }
        "pre_activate"() {
          var _a;
          if (typeof document !== "undefined") {
            if (!this.dom.el) {
              let found_el = this.context.get_ctrl_el(this) || this.context.map_els[this._id()] || document.querySelectorAll('[data-jsgui-id="' + this._id() + '"]')[0];
              if (found_el) {
                this.dom.el = found_el;
              }
            }
            if (!this.dom.el) {
            } else {
              this.load_dom_attributes_from_dom();
              if (this.dom.attributes["data-jsgui-mixins"] !== void 0) {
                const str_mixins = (_a = this.dom.attributes["data-jsgui-mixins"]) == null ? void 0 : _a.replace(/'/g, '"');
                if (str_mixins) {
                  const o_mixins = JSON.parse(str_mixins);
                  const old_silent = this.view.data.model.mixins.silent;
                  this.view.data.model.mixins.silent = true;
                  each(o_mixins, (mixin) => {
                    const { name, options } = mixin;
                    const converted_name = name.replace(/-/g, "_");
                    this.view.data.model.mixins.push(mixin);
                    const mixins = this.context && this.context.mixins;
                    const the_mixin = mixins ? mixins[converted_name] : void 0;
                    if (the_mixin) {
                      the_mixin(this);
                    }
                  });
                  this.view.data.model.mixins.silent = old_silent;
                }
              }
              if (this._persisted_fields) {
                each(this._persisted_fields, (v, i) => {
                  this[i] = v;
                });
              }
              if (this.dom.attributes["data-jsgui-data-model-id"] !== void 0) {
                const context_referenced_data_model = this.context.map_data_models[this.dom.attributes["data-jsgui-data-model-id"]];
                if (context_referenced_data_model) {
                  this.data.model = context_referenced_data_model;
                  console.log("have used data.model referenced from context: " + context_referenced_data_model.__id);
                }
              }
              this.pre_activate_content_controls();
              this.add_content_change_event_listener();
              this.add_dom_attributes_changes_listener();
            }
          } else {
          }
        }
        "activate"(el) {
          if (typeof document !== "undefined" && !this.__active) {
            this.__active = true;
            if (!this.dom.el) {
              let found_el = this.context.get_ctrl_el(this) || this.context.map_els[this._id()] || document.querySelectorAll('[data-jsgui-id="' + this._id() + '"]')[0];
              if (found_el) {
                this.dom.el = found_el;
              }
            }
            if (!this.dom.el) {
            } else {
              this.activate_content_controls();
              this.raise("activate");
            }
          } else {
          }
        }
        "add_dom_attributes_changes_listener"() {
          var dom_attributes = this.dom.attributes;
          var el = this.dom.el;
          dom_attributes.on("change", (e_change) => {
            var property_name = e_change.name || e_change.key, val = e_change.value || e_change.new;
            if (el && el.nodeType === 1) {
              el.setAttribute(property_name, val);
            }
          });
        }
        "activate_this_and_subcontrols"() {
          this.iterate_this_and_subcontrols((ctrl) => {
            if (ctrl.dom.el) {
              ctrl.activate();
            }
          });
        }
        "add_content_change_event_listener"() {
          const {
            context: context2
          } = this;
          var map_controls = context2.map_controls;
          let el = this.dom.el;
          this.content.on("change", (e_change) => {
            let itemDomEl;
            var type = e_change.name;
            if (type === "insert") {
              var item2 = e_change.value;
              var retrieved_item_dom_el = item2.dom.el;
              var t_ret = tof(retrieved_item_dom_el);
              if (t_ret === "string") {
                itemDomEl = retrieved_item_dom_el;
              } else {
                if (retrieved_item_dom_el) {
                  itemDomEl = retrieved_item_dom_el;
                }
                if (!itemDomEl) {
                  if (context2.map_els[item2._id()]) {
                    itemDomEl = context2.map_els[item2._id()];
                  }
                }
                if (!itemDomEl) {
                  var item_tag_name = "div";
                  var dv_tag_name = item2.dom.tagName;
                  if (dv_tag_name) {
                    item_tag_name = dv_tag_name;
                  }
                  var temp_el;
                  if (item_tag_name === "circle" || item_tag_name === "line" || item_tag_name === "polyline") {
                    var temp_svg_container = e_change.item.context.document.createElement("div");
                    temp_svg_container.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">' + e_change.item.all_html_render() + "</svg>";
                    itemDomEl = temp_svg_container.childNodes[0].childNodes[0];
                  } else {
                    temp_el = e_change.item.context.document.createElement("div");
                    temp_el.innerHTML = e_change.item.all_html_render();
                    itemDomEl = temp_el.childNodes[0];
                  }
                  item2.dom.el = itemDomEl;
                  context2.map_els[item2._id()] = itemDomEl;
                }
                ;
              }
              var t_item_dom_el = tof(itemDomEl);
              if (t_item_dom_el === "string") {
                itemDomEl = document.createTextNode(itemDomEl);
              }
              if (!itemDomEl) {
              }
              if (itemDomEl) {
                el.appendChild(itemDomEl);
                e_change.item.register_this_and_subcontrols();
              }
            } else if (type === "clear") {
              if (el) {
                el.innerHTML = "";
              }
            } else if (type === "remove") {
              if (e_change.value.dom.el) {
                e_change.value.dom.el.parentNode.removeChild(e_change.value.dom.el);
              }
            } else {
              if (el) {
                el.innerHTML = "";
                this.content.each((item3) => {
                  let item_dom_el;
                  if (item3 instanceof Text_Node) {
                    item_dom_el = document.createTextNode(item3.text || "");
                    item3.dom.el = item_dom_el;
                  } else {
                    const retrieved_item_dom_el2 = item3.dom && item3.dom.el;
                    if (retrieved_item_dom_el2) {
                      item_dom_el = retrieved_item_dom_el2;
                    } else if (item3 && typeof item3.all_html_render === "function") {
                      let item_tag_name2 = "div";
                      const dv_tag_name2 = item3.dom && item3.dom.tagName;
                      if (dv_tag_name2) item_tag_name2 = dv_tag_name2;
                      let temp_el2;
                      if (item_tag_name2 === "circle" || item_tag_name2 === "line" || item_tag_name2 === "polyline") {
                        const temp_svg_container2 = context2.document.createElement("div");
                        temp_svg_container2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">' + item3.all_html_render() + "</svg>";
                        item_dom_el = temp_svg_container2.childNodes[0].childNodes[0];
                      } else {
                        temp_el2 = context2.document.createElement("div");
                        temp_el2.innerHTML = item3.all_html_render();
                        item_dom_el = temp_el2.childNodes[0];
                      }
                      item3.dom.el = item_dom_el;
                      if (item3._id && typeof item3._id === "function") {
                        context2.map_els[item3._id()] = item_dom_el;
                      }
                    }
                  }
                  const t_item_dom_el2 = tof(item_dom_el);
                  if (t_item_dom_el2 === "string") {
                    item_dom_el = document.createTextNode(item_dom_el);
                  }
                  if (item_dom_el) {
                    el.appendChild(item_dom_el);
                    if (item3 && typeof item3.register_this_and_subcontrols === "function") {
                      item3.register_this_and_subcontrols();
                    }
                  }
                });
              }
            }
          });
        }
        "rec_desc_ensure_ctrl_el_refs"(el) {
          el = el || this.dom.el;
          var context2 = this.context;
          if (el) {
            var c2, l2, cns;
            var jsgui_id;
            var map_els = {};
            dom_desc(el, (el2) => {
              if (el2.getAttribute) {
                jsgui_id = el2.getAttribute("data-jsgui-id");
                if (jsgui_id) {
                  map_els[jsgui_id] = el2;
                  context2.map_els[jsgui_id] = el2;
                }
              }
            });
            desc(this, (ctrl) => {
              var t_ctrl = tof(ctrl);
              if (ctrl !== this && t_ctrl === "control") {
                var id = ctrl._id();
                if (map_els[id]) {
                  if (ctrl.dom.el !== map_els[id]) {
                    ctrl.dom.el = map_els[id];
                  } else {
                  }
                }
                ctrl.activate();
              }
            });
          }
        }
        "rec_desc_activate"() {
          desc(this, (ctrl) => {
            const t_ctrl = tof(ctrl);
            if (t_ctrl === "control") {
              ctrl.activate();
            }
          });
        }
        "activate_content_controls"() {
          const do_activation = () => {
            if (!this.dom.el) {
              let found_el = this.context.get_ctrl_el(this);
              if (found_el) {
                this.dom.el = found_el;
              }
            }
            const el = this.dom.el;
            if (el) {
              const context2 = this.context;
              let ctrl_fields = {}, c2, l2;
              if (el.getAttribute) {
                let cns = el.childNodes;
                let content = this.content;
                for (c2 = 0, l2 = cns.length; c2 < l2; c2++) {
                  let cn = cns[c2];
                  if (cn) {
                    let nt = cn.nodeType;
                    if (nt === 1) {
                      let cn_jsgui_id = cn.getAttribute("data-jsgui-id");
                      let cctrl = context2.map_controls[cn_jsgui_id];
                      let found = false;
                      if (cctrl) {
                        cctrl.activate();
                      }
                    }
                  }
                }
              }
            } else {
            }
          };
          do_activation();
        }
        "pre_activate_content_controls"() {
          const do_pre_activation = () => {
            if (!this.dom.el) {
              let found_el = this.context.get_ctrl_el(this);
              if (found_el) {
                this.dom.el = found_el;
              }
            }
            const el = this.dom.el;
            if (el) {
              const context2 = this.context;
              let ctrl_fields = {}, c2, l2;
              if (el.getAttribute) {
                let str_ctrl_fields = el.getAttribute("data-jsgui-ctrl-fields");
                if (str_ctrl_fields) {
                  ctrl_fields = JSON.parse(str_ctrl_fields.replace(/'/g, '"'));
                }
                let ctrl_fields_keys = Object.keys(ctrl_fields);
                let l_ctrl_fields_keys = ctrl_fields_keys.length;
                let key2, value2;
                for (c2 = 0; c2 < l_ctrl_fields_keys; c2++) {
                  key2 = ctrl_fields_keys[c2];
                  value2 = ctrl_fields[key2];
                  this[key2] = context2.map_controls[value2];
                }
                let cns = el.childNodes;
                let content = this.content;
                for (c2 = 0, l2 = cns.length; c2 < l2; c2++) {
                  let cn = cns[c2];
                  if (cn) {
                    let nt = cn.nodeType;
                    if (nt === 1) {
                      let cn_jsgui_id = cn.getAttribute("data-jsgui-id");
                      let cctrl = context2.map_controls[cn_jsgui_id];
                      let found = false;
                      if (cctrl) {
                        let ctrl_id = cctrl.__id;
                        if (ctrl_id) {
                          content.each((v, i) => {
                            if (v.__id) {
                              if (v.__id === ctrl_id) found = true;
                            }
                          });
                        }
                        if (!found) {
                          content._arr.push(cctrl);
                        }
                        cctrl.parent = this;
                      }
                    }
                    if (nt === 3) {
                      const i_sibling = c2;
                      const corresponding_ctrl = content._arr[i_sibling];
                      if (corresponding_ctrl) {
                        if (corresponding_ctrl.text === cn.nodeValue) {
                          corresponding_ctrl.dom.el = cn;
                        }
                      } else {
                      }
                      const do_add = () => {
                        let val = cn.nodeValue;
                        const tn = new Text_Node({
                          context: this.context,
                          text: val,
                          el: cn
                        });
                        content.add(tn);
                      };
                    }
                  }
                }
              }
            } else {
            }
          };
          do_pre_activation();
        }
        "load_dom_attributes_from_dom"() {
          const el = this.dom.el;
          const dom_attributes = this.dom.attributes;
          let item2, name, value2, i;
          if (el) {
            const attrs = el.attributes;
            if (attrs) {
              const l2 = attrs.length;
              for (i = 0; i < l2; i++) {
                item2 = attrs.item(i);
                name = item2.name;
                value2 = item2.value;
                dom_attributes[name] = value2;
              }
            }
          }
        }
        "_search_descendents"(search) {
          const recursive_iterate = (ctrl, item_callback) => {
            const content = ctrl.content, t_content = tof(content);
            if (t_content === "collection") {
              if (content.length() > 0) {
                content.each((item2, i) => {
                  item_callback(item2);
                  recursive_iterate(item2, item_callback);
                });
              }
            }
          };
          const arr_matching = [];
          recursive_iterate(this, (item2) => {
            const item_type = item2.__type_name;
            if (item_type === search) {
              arr_matching.push(item2);
            } else {
            }
          });
          return arr_matching;
        }
        "_search_ancestor"(search) {
          const parent = this.parent;
          if (parent) {
            if (parent === search) {
              return true;
            } else {
              if (typeof parent.ancestor === "function") {
                return parent.ancestor(search);
              }
            }
          } else {
            return false;
          }
        }
        "add"(new_content) {
          const {
            context: context2
          } = this;
          if (context2) {
            const m = context2.map_controls_being_added_in_frame = context2.map_controls_being_added_in_frame || {};
            const tnc = tof(new_content);
            if (tnc === "array") {
              each(new_content, (v) => {
                const candd = v.this_and_descendents;
                if (candd) {
                  each(candd, (ctrl) => {
                    if (ctrl._id) {
                      m[ctrl._id()] = ctrl;
                    }
                  });
                }
              });
            } else {
              if (new_content) {
                const candd = new_content.this_and_descendents;
                if (candd) {
                  each(candd, (ctrl) => {
                    if (ctrl._id) {
                      m[ctrl._id()] = ctrl;
                    }
                  });
                }
              }
            }
          }
          return super.add(new_content);
        }
        "clear"() {
          const {
            context: context2
          } = this;
          context2.map_controls_being_removed_in_frame = context2.map_controls_being_removed_in_frame || {};
          each(this.descendents, (ctrl) => {
            if (ctrl._id) context2.map_controls_being_removed_in_frame[ctrl._id()] = ctrl;
          });
          super.clear();
        }
      };
      var p = Control2.prototype;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      module.exports = Control2;
    }
  });

  // ../jsgui3-html/html-core/ModelBinder.js
  var require_ModelBinder = __commonJS({
    "../jsgui3-html/html-core/ModelBinder.js"(exports, module) {
      var { Data_Object, Data_Value: Data_Value2, tof, each } = require_lang();
      var ModelBinder = class _ModelBinder {
        constructor(sourceModel, targetModel, bindings = {}, options = {}) {
          if (typeof targetModel === "string") {
            const [
              sourceProp,
              legacyTargetModel,
              targetProp,
              legacyOptions = {}
            ] = Array.prototype.slice.call(arguments, 1);
            const normalizedBindings = {
              [sourceProp]: Object.assign(
                { to: targetProp },
                legacyOptions.transform ? { transform: legacyOptions.transform } : {},
                legacyOptions.reverse ? { reverse: legacyOptions.reverse } : {}
              )
            };
            const normalizedOptions = Object.assign({
              bidirectional: legacyOptions.twoWay || legacyOptions.bidirectional || !!legacyOptions.reverse,
              immediate: legacyOptions.immediate !== false,
              debug: legacyOptions.debug || false
            }, legacyOptions);
            return new _ModelBinder(sourceModel, legacyTargetModel, normalizedBindings, normalizedOptions);
          }
          this.sourceModel = sourceModel;
          this.targetModel = targetModel;
          this.bindings = bindings;
          this.options = Object.assign({
            bidirectional: true,
            immediate: true,
            debug: false
          }, options);
          this._listeners = [];
          this._locks = /* @__PURE__ */ new Set();
          this._active = false;
          if (this.options.immediate) {
            this.activate();
          }
        }
        /**
         * Activate all bindings
         */
        activate() {
          if (this._active) return;
          this._active = true;
          each(this.bindings, (binding, sourceProp) => {
            this._setupBinding(sourceProp, binding);
          });
          if (this.options.debug) {
            console.log("[ModelBinder] Activated bindings:", Object.keys(this.bindings));
          }
        }
        /**
         * Deactivate all bindings and cleanup listeners
         */
        deactivate() {
          if (!this._active) return;
          this._active = false;
          this._listeners.forEach(({ model, event, handler }) => {
            if (model && model.off) {
              model.off(event, handler);
            }
          });
          this._listeners = [];
          if (this.options.debug) {
            console.log("[ModelBinder] Deactivated bindings");
          }
        }
        /**
         * Setup a single binding between source and target properties
         * @private
         */
        _setupBinding(sourceProp, binding) {
          const targetProp = typeof binding === "string" ? binding : binding.to;
          const transform = binding.transform;
          const reverse = binding.reverse;
          const condition = binding.condition;
          if (this.sourceModel[sourceProp] !== void 0) {
            const value2 = this.sourceModel[sourceProp];
            const transformedValue = transform ? transform(value2) : value2;
            if (!condition || condition(value2)) {
              this.targetModel[targetProp] = transformedValue;
            }
          }
          const sourceHandler = (e) => {
            if (e.name === sourceProp) {
              const value2 = e.value;
              const transformedValue = transform ? transform(value2) : value2;
              if (!condition || condition(value2)) {
                const lock_key = `${sourceProp}->${targetProp}`;
                if (this._acquire(lock_key)) {
                  this.targetModel[targetProp] = transformedValue;
                  if (this.options.debug) {
                    console.log(`[ModelBinder] ${sourceProp} \u2192 ${targetProp}:`, value2, "\u2192", transformedValue);
                  }
                  this._release(lock_key);
                }
              }
            }
          };
          this.sourceModel.on("change", sourceHandler);
          this._listeners.push({
            model: this.sourceModel,
            event: "change",
            handler: sourceHandler
          });
          if (this.options.bidirectional && reverse) {
            const targetHandler = (e) => {
              if (e.name === targetProp) {
                const value2 = e.value;
                const reversedValue = reverse(value2);
                if (!condition || condition(reversedValue)) {
                  const lock_key = `${targetProp}->${sourceProp}`;
                  if (this._acquire(lock_key)) {
                    this.sourceModel[sourceProp] = reversedValue;
                    if (this.options.debug) {
                      console.log(`[ModelBinder] ${targetProp} \u2192 ${sourceProp}:`, value2, "\u2192", reversedValue);
                    }
                    this._release(lock_key);
                  }
                }
              }
            };
            this.targetModel.on("change", targetHandler);
            this._listeners.push({
              model: this.targetModel,
              event: "change",
              handler: targetHandler
            });
          }
        }
        _acquire(key2) {
          if (!key2) return true;
          if (this._locks.has(key2)) {
            if (this.options.debug) {
              console.warn("[ModelBinder] Loop suppressed for", key2);
            }
            return false;
          }
          this._locks.add(key2);
          return true;
        }
        _release(key2) {
          if (key2) {
            this._locks.delete(key2);
          }
        }
        unbind() {
          this.deactivate();
        }
        /**
         * Update a specific binding manually
         */
        updateBinding(sourceProp) {
          const binding = this.bindings[sourceProp];
          if (!binding) return;
          const targetProp = typeof binding === "string" ? binding : binding.to;
          const transform = binding.transform;
          const value2 = this.sourceModel[sourceProp];
          const transformedValue = transform ? transform(value2) : value2;
          this.targetModel[targetProp] = transformedValue;
        }
        /**
         * Get current binding state for inspection
         */
        inspect() {
          const state = {};
          each(this.bindings, (binding, sourceProp) => {
            const targetProp = typeof binding === "string" ? binding : binding.to;
            state[sourceProp] = {
              target: targetProp,
              sourceValue: this.sourceModel[sourceProp],
              targetValue: this.targetModel[targetProp],
              hasTransform: !!binding.transform,
              hasReverse: !!binding.reverse,
              bidirectional: this.options.bidirectional && !!binding.reverse
            };
          });
          return state;
        }
      };
      var ComputedProperty = class {
        constructor(models, dependencies, computeFn, options = {}) {
          this.models = Array.isArray(models) ? models : [models];
          this.dependencies = Array.isArray(dependencies) ? dependencies : [dependencies];
          this.computeFn = computeFn;
          this.options = Object.assign({
            propertyName: "computed",
            immediate: true,
            debug: false,
            target: null
          }, options);
          this._listeners = [];
          this._active = false;
          this._lastValue = void 0;
          if (this.options.immediate) {
            this.activate();
          }
        }
        _resolve_dependency(dep) {
          for (const model of this.models) {
            if (!model) continue;
            if (typeof model.get === "function") {
              const got = model.get(dep);
              if (typeof got !== "undefined") {
                return got && got.__data_value ? got.value : got;
              }
            }
            if (dep in model) {
              const val = model[dep];
              if (typeof val !== "undefined") {
                return val && val.__data_value ? val.value : val;
              }
            }
          }
        }
        activate() {
          if (this._active) return;
          this._active = true;
          this.compute();
          const handler = (e) => {
            if (this.dependencies.includes(e.name)) {
              this.compute();
            }
          };
          this.models.forEach((model) => {
            if (model && model.on) {
              model.on("change", handler);
              this._listeners.push({ model, event: "change", handler });
            }
          });
          if (this.options.debug) {
            console.log("[ComputedProperty] Activated for dependencies:", this.dependencies);
          }
        }
        deactivate() {
          if (!this._active) return;
          this._active = false;
          this._listeners.forEach(({ model, event, handler }) => {
            if (model && model.off) {
              model.off(event, handler);
            }
          });
          this._listeners = [];
        }
        compute() {
          const args = this.dependencies.map((dep) => this._resolve_dependency(dep));
          const newValue = this.computeFn(...args);
          if (newValue !== this._lastValue) {
            this._lastValue = newValue;
            const target_model = this.options.target || this.models[0];
            const property_name = this.options.propertyName || this.options.property_name || "computed";
            if (target_model) {
              if (typeof target_model.set === "function") {
                target_model.set(property_name, newValue);
              } else {
                target_model[property_name] = newValue;
              }
            }
            if (this.options.debug) {
              console.log("[ComputedProperty] Updated:", property_name, "=", newValue);
            }
          }
          return newValue;
        }
        get value() {
          return this._lastValue;
        }
        destroy() {
          this.deactivate();
        }
      };
      var PropertyWatcher = class {
        constructor(model, property, callback2, options = {}) {
          this.model = model;
          this.properties = Array.isArray(property) ? property : [property];
          this.callback = callback2;
          this.options = Object.assign({
            immediate: false,
            deep: false,
            debug: false
          }, options);
          this._handler = null;
          this._active = false;
          this.activate();
        }
        activate() {
          if (this._active) return;
          this._active = true;
          if (this.options.immediate && this.properties.length > 0) {
            const prop = this.properties[0];
            this.callback(this.model[prop], void 0, prop);
          }
          this._handler = (e) => {
            if (this.properties.includes(e.name)) {
              this.callback(e.value, e.old, e.name);
              if (this.options.debug) {
                console.log("[PropertyWatcher] Property changed:", e.name, e.old, "\u2192", e.value);
              }
            }
          };
          this.model.on("change", this._handler);
        }
        deactivate() {
          if (!this._active) return;
          this._active = false;
          if (this._handler && this.model.off) {
            this.model.off("change", this._handler);
          }
          this._handler = null;
        }
        unwatch() {
          this.deactivate();
        }
      };
      var BindingManager = class {
        constructor(control) {
          this.control = control;
          this.binders = [];
          this.computed = [];
          this.watchers = [];
          this._bindings = this.binders;
        }
        /**
         * Create a new binding between models
         */
        bind(sourceModel, targetModel, bindings, options) {
          const binder = new ModelBinder(sourceModel, targetModel, bindings, options);
          this.binders.push(binder);
          return binder;
        }
        bind_value(sourceModel, sourceProp, targetModel, targetProp = sourceProp, options = {}) {
          const bindings = {
            [sourceProp]: Object.assign(
              { to: targetProp },
              options.transform ? { transform: options.transform } : {},
              options.reverse ? { reverse: options.reverse } : {},
              options.condition ? { condition: options.condition } : {}
            )
          };
          const binder_options = {
            bidirectional: options.bidirectional !== void 0 ? options.bidirectional : !!options.reverse,
            immediate: options.immediate !== void 0 ? options.immediate : true,
            debug: options.debug || false
          };
          return this.bind(sourceModel, targetModel, bindings, binder_options);
        }
        bind_collection(sourceModel, sourceProp, targetModel, targetProp = sourceProp, options = {}) {
          const map_fn = options.map;
          const clone = options.clone !== false;
          const transform = (collection = []) => {
            const arr = Array.isArray(collection) ? collection : [];
            const mapped = map_fn ? arr.map(map_fn) : arr.slice();
            return clone ? mapped.slice() : mapped;
          };
          const reverse = options.reverse_map ? (collection = []) => {
            const arr = Array.isArray(collection) ? collection : [];
            return arr.map(options.reverse_map);
          } : void 0;
          return this.bind_value(sourceModel, sourceProp, targetModel, targetProp, Object.assign({}, options, {
            transform,
            reverse,
            bidirectional: options.bidirectional && !!reverse
          }));
        }
        /**
         * Create a computed property
         */
        createComputed(model, dependencies, computeFn, options) {
          const computed = new ComputedProperty(model, dependencies, computeFn, options);
          this.computed.push(computed);
          return computed;
        }
        /**
         * Watch a property for changes
         */
        watch(model, property, callback2, options) {
          const watcher = new PropertyWatcher(model, property, callback2, options);
          this.watchers.push(watcher);
          return watcher;
        }
        /**
         * Cleanup all bindings
         */
        cleanup() {
          this.binders.forEach((b) => b.deactivate());
          this.computed.forEach((c2) => c2.deactivate());
          this.watchers.forEach((w) => w.deactivate());
          this.binders.length = 0;
          this.computed.length = 0;
          this.watchers.length = 0;
        }
        /**
         * Get inspection data for all bindings
         */
        inspect() {
          return {
            binders: this.binders.map((b) => b.inspect()),
            computed: this.computed.map((c2) => ({
              propertyName: c2.options.propertyName,
              dependencies: c2.dependencies,
              value: c2.value
            })),
            watchers: this.watchers.map((w) => ({
              property: w.property,
              active: w._active
            }))
          };
        }
      };
      module.exports = {
        ModelBinder,
        ComputedProperty,
        PropertyWatcher,
        BindingManager
      };
    }
  });

  // ../jsgui3-html/html-core/Transformations.js
  var require_Transformations = __commonJS({
    "../jsgui3-html/html-core/Transformations.js"(exports, module) {
      var { tof } = require_lang();
      var add_commas = (num_str) => {
        return num_str.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      };
      var DATE_I18N_FORMATS = Object.freeze({
        "en-US": "MM/DD/YYYY",
        "en-GB": "DD/MM/YYYY",
        "de-DE": "DD.MM.YYYY",
        "fr-FR": "DD/MM/YYYY",
        "es-ES": "DD/MM/YYYY",
        "it-IT": "DD/MM/YYYY",
        "nl-NL": "DD-MM-YYYY",
        "sv-SE": "YYYY-MM-DD",
        "ja-JP": "YYYY/MM/DD",
        "zh-CN": "YYYY/MM/DD",
        "ko-KR": "YYYY.MM.DD"
      });
      var escape_regex = (value2) => String(value2).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      var pad_2 = (value2) => String(value2).padStart(2, "0");
      var is_leap_year = (year) => year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      var days_in_month = (year, month) => {
        const days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        if (month === 2 && is_leap_year(year)) {
          return 29;
        }
        return days[month - 1] || 0;
      };
      var build_format_regex = (format) => {
        const tokens = [];
        const parts = String(format).split(/(YYYY|MM|DD)/g).filter((part) => part !== "");
        const regex_body = parts.map((part) => {
          if (part === "YYYY") {
            tokens.push(part);
            return "(\\d{4})";
          }
          if (part === "MM" || part === "DD") {
            tokens.push(part);
            return "(\\d{1,2})";
          }
          return escape_regex(part);
        }).join("");
        return {
          regex: new RegExp(`^${regex_body}$`),
          tokens
        };
      };
      var parse_format_parts = (value2, format = "YYYY-MM-DD") => {
        if (value2 === null || value2 === void 0) return null;
        const str = String(value2).trim();
        if (str === "") return null;
        const { regex, tokens } = build_format_regex(format);
        const match = str.match(regex);
        if (!match) return null;
        const parts = {
          year: null,
          month: null,
          day: null
        };
        tokens.forEach((token, idx) => {
          const num = parseInt(match[idx + 1], 10);
          if (Number.isNaN(num)) {
            return;
          }
          if (token === "YYYY") parts.year = num;
          if (token === "MM") parts.month = num;
          if (token === "DD") parts.day = num;
        });
        if (!parts.year || !parts.month || !parts.day) return null;
        if (parts.month < 1 || parts.month > 12) return null;
        const max_day = days_in_month(parts.year, parts.month);
        if (parts.day < 1 || parts.day > max_day) return null;
        return parts;
      };
      var format_parts = (parts, format = "YYYY-MM-DD") => {
        if (!parts || !parts.year || !parts.month || !parts.day) return "";
        const year = String(parts.year).padStart(4, "0");
        const month = pad_2(parts.month);
        const day = pad_2(parts.day);
        return String(format).replace(/YYYY/g, year).replace(/MM/g, month).replace(/DD/g, day);
      };
      var parts_to_iso = (parts) => format_parts(parts, "YYYY-MM-DD");
      var iso_to_parts = (iso_str) => parse_format_parts(iso_str, "YYYY-MM-DD");
      var resolve_i18n_format = (locale, fallback = "YYYY-MM-DD") => {
        if (!locale) return fallback;
        return DATE_I18N_FORMATS[locale] || fallback;
      };
      var Transformations = {
        date: {
          /**
           * Map of locale tags to default date formats.
           */
          i18n_formats: DATE_I18N_FORMATS,
          /**
           * Resolve a locale to a supported format string.
           * @param {string} locale - Locale tag (e.g. en-US).
           * @param {string} fallback - Fallback format string.
           * @returns {string} Format string.
           */
          resolve_i18n_format: (locale, fallback = "YYYY-MM-DD") => resolve_i18n_format(locale, fallback),
          /**
           * Parse a date string into parts using a format string.
           * @param {string} value - Date string to parse.
           * @param {string} format - Format string (e.g. DD/MM/YYYY).
           * @returns {Object|null} Parsed parts or null.
           */
          parse_format_parts: (value2, format = "YYYY-MM-DD") => parse_format_parts(value2, format),
          /**
           * Format date parts using a format string.
           * @param {Object} parts - { year, month, day }.
           * @param {string} format - Format string (e.g. YYYY-MM-DD).
           * @returns {string} Formatted date string.
           */
          format_parts: (parts, format = "YYYY-MM-DD") => format_parts(parts, format),
          /**
           * Convert date parts into ISO YYYY-MM-DD format.
           * @param {Object} parts - { year, month, day }.
           * @returns {string} ISO date string.
           */
          parts_to_iso: (parts) => parts_to_iso(parts),
          /**
           * Parse ISO YYYY-MM-DD string into date parts.
           * @param {string} iso_str - ISO date string.
           * @returns {Object|null} Parsed parts or null.
           */
          iso_to_parts: (iso_str) => iso_to_parts(iso_str),
          /**
           * Parse a locale-specific date string into ISO YYYY-MM-DD.
           * @param {string} value - Date string to parse.
           * @param {string} locale - Locale tag (e.g. en-GB).
           * @param {string} format_override - Optional format override.
           * @returns {string} ISO date string.
           */
          parse_i18n_to_iso: (value2, locale = "en-US", format_override) => {
            if (!value2) return "";
            const iso_parts = parse_format_parts(value2, "YYYY-MM-DD");
            if (iso_parts) {
              return parts_to_iso(iso_parts);
            }
            const format = format_override || resolve_i18n_format(locale);
            const parts = parse_format_parts(value2, format);
            return parts ? parts_to_iso(parts) : "";
          },
          /**
           * Format an ISO YYYY-MM-DD date string for a locale or format override.
           * @param {string} iso_str - ISO date string.
           * @param {string} locale - Locale tag (e.g. en-US).
           * @param {string} format_override - Optional format override.
           * @returns {string} Formatted date string.
           */
          format_iso_to_locale: (iso_str, locale = "en-US", format_override) => {
            if (!iso_str) return "";
            const parts = parse_format_parts(iso_str, "YYYY-MM-DD");
            if (!parts) return "";
            const format = format_override || resolve_i18n_format(locale);
            return format_parts(parts, format);
          },
          toISO: (date) => {
            if (!date) return "";
            const d = date instanceof Date ? date : new Date(date);
            return isNaN(d.getTime()) ? "" : d.toISOString();
          },
          toLocale: (date, locale = "en-US", options = {}) => {
            if (!date) return "";
            const d = date instanceof Date ? date : new Date(date);
            return isNaN(d.getTime()) ? "" : d.toLocaleDateString(locale, options);
          },
          format: (date, format = "YYYY-MM-DD") => {
            if (!date) return "";
            const d = date instanceof Date ? date : new Date(date);
            if (isNaN(d.getTime())) return "";
            const map = {
              YYYY: d.getFullYear(),
              MM: String(d.getMonth() + 1).padStart(2, "0"),
              DD: String(d.getDate()).padStart(2, "0"),
              HH: String(d.getHours()).padStart(2, "0"),
              mm: String(d.getMinutes()).padStart(2, "0"),
              ss: String(d.getSeconds()).padStart(2, "0")
            };
            return format.replace(/YYYY|MM|DD|HH|mm|ss/g, (matched) => map[matched]);
          },
          parse: (str) => {
            if (!str) return null;
            const d = new Date(str);
            return isNaN(d.getTime()) ? null : d;
          },
          parseFormat: (str, format = "YYYY-MM-DD") => {
            if (!str) return null;
            const parts = {
              YYYY: { start: format.indexOf("YYYY"), length: 4 },
              MM: { start: format.indexOf("MM"), length: 2 },
              DD: { start: format.indexOf("DD"), length: 2 }
            };
            const year = parseInt(str.substr(parts.YYYY.start, parts.YYYY.length));
            const month = parseInt(str.substr(parts.MM.start, parts.MM.length)) - 1;
            const day = parseInt(str.substr(parts.DD.start, parts.DD.length));
            return new Date(year, month, day);
          },
          relative: (date, now = /* @__PURE__ */ new Date()) => {
            if (!date) return "";
            const d = date instanceof Date ? date : new Date(date);
            if (isNaN(d.getTime())) return "";
            const diff_ms = now.getTime() - d.getTime();
            const diff_s = Math.floor(Math.abs(diff_ms) / 1e3);
            const is_past = diff_ms >= 0;
            const units = [
              ["year", 60 * 60 * 24 * 365],
              ["month", 60 * 60 * 24 * 30],
              ["day", 60 * 60 * 24],
              ["hour", 60 * 60],
              ["minute", 60],
              ["second", 1]
            ];
            let unit_name = "second";
            let unit_value = diff_s;
            for (const [name, seconds] of units) {
              if (diff_s >= seconds) {
                unit_name = name;
                unit_value = Math.floor(diff_s / seconds);
                break;
              }
            }
            const plural = unit_value === 1 ? "" : "s";
            return is_past ? `${unit_value} ${unit_name}${plural} ago` : `in ${unit_value} ${unit_name}${plural}`;
          }
        },
        number: {
          toFixed: (num, decimals = 2) => {
            if (num === null || num === void 0 || num === "") return "";
            return Number(num).toFixed(decimals);
          },
          round: (num, decimals = 0) => {
            if (num === null || num === void 0 || num === "") return 0;
            const factor = Math.pow(10, decimals);
            return Math.round(Number(num) * factor) / factor;
          },
          withCommas: (num) => {
            if (num === null || num === void 0 || num === "") return "";
            const n = Number(num);
            if (isNaN(n)) return "";
            const [int_part, dec_part] = String(n).split(".");
            const int_with = add_commas(int_part);
            return dec_part ? `${int_with}.${dec_part}` : int_with;
          },
          toCurrency: (num, symbol = "$", decimals = 2) => {
            const n = num === null || num === void 0 || num === "" ? 0 : Number(num);
            if (isNaN(n)) return `${symbol}0.00`;
            const sign = n < 0 ? "-" : "";
            const abs = Math.abs(n);
            const fixed = abs.toFixed(decimals);
            const [int_part, dec_part] = fixed.split(".");
            const int_with = add_commas(int_part);
            return `${sign}${symbol}${int_with}.${dec_part}`;
          },
          toPercent: (num, decimals = 2) => {
            if (num === null || num === void 0 || num === "") return "";
            return (Number(num) * 100).toFixed(decimals) + "%";
          },
          toLocale: (num, locale = "en-US", options = {}) => {
            if (num === null || num === void 0 || num === "") return "";
            return Number(num).toLocaleString(locale, options);
          },
          parse: (str) => {
            if (str === null || str === void 0 || str === "") return null;
            const num = parseFloat(String(str).replace(/[^0-9.-]/g, ""));
            return isNaN(num) ? null : num;
          },
          parseInt: (str) => {
            if (str === null || str === void 0 || str === "") return null;
            const num = parseInt(String(str).replace(/[^0-9-]/g, ""));
            return isNaN(num) ? null : num;
          },
          clamp: (num, min, max) => {
            const n = Number(num);
            if (isNaN(n)) return min;
            return Math.max(min, Math.min(max, n));
          },
          clamp_fn: (min, max) => (num) => Transformations.number.clamp(num, min, max)
        },
        string: {
          toUpperCase: (str) => {
            return str ? String(str).toUpperCase() : "";
          },
          toLowerCase: (str) => {
            return str ? String(str).toLowerCase() : "";
          },
          toUpper: (str) => Transformations.string.toUpperCase(str),
          toLower: (str) => Transformations.string.toLowerCase(str),
          capitalize: (str) => {
            if (!str) return "";
            const s = String(str);
            return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
          },
          titleCase: (str) => {
            if (!str) return "";
            return String(str).split(/\s+/).filter((v) => v.length > 0).map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
          },
          trim: (str) => {
            return str ? String(str).trim() : "";
          },
          truncate: (str, maxLength, suffix = "...") => {
            if (!str) return "";
            const s = String(str);
            if (s.length <= maxLength) return s;
            const head = s.substr(0, maxLength).trimEnd();
            return head + suffix;
          },
          truncate_fn: (maxLength, suffix = "...") => (str) => Transformations.string.truncate(str, maxLength, suffix),
          slugify: (str) => {
            if (!str) return "";
            return String(str).toLowerCase().replace(/&/g, " ").replace(/[^a-z0-9\s-]/g, "").trim().replace(/\s+/g, "-").replace(/-+/g, "-");
          },
          default: (defaultValue) => (str) => {
            return str ? String(str) : defaultValue;
          }
        },
        boolean: {
          toBool: (value2) => {
            if (value2 === null || value2 === void 0) return false;
            if (typeof value2 === "boolean") return value2;
            if (typeof value2 === "number") return value2 !== 0;
            const str = String(value2).toLowerCase();
            return str === "true" || str === "1" || str === "yes" || str === "on" || str === "enabled";
          },
          parse: (value2) => Transformations.boolean.toBool(value2),
          toYesNo: (value2) => Transformations.boolean.toBool(value2) ? "Yes" : "No",
          toOnOff: (value2) => Transformations.boolean.toBool(value2) ? "On" : "Off",
          toEnabledDisabled: (value2) => Transformations.boolean.toBool(value2) ? "Enabled" : "Disabled",
          not: (value2) => !Transformations.boolean.toBool(value2)
        },
        array: {
          join: (arr, separator = ", ") => {
            if (!Array.isArray(arr) || arr.length === 0) return "";
            return arr.join(separator);
          },
          first: (arr) => Array.isArray(arr) && arr.length > 0 ? arr[0] : void 0,
          last: (arr) => Array.isArray(arr) && arr.length > 0 ? arr[arr.length - 1] : void 0,
          length: (arr) => Array.isArray(arr) ? arr.length : 0,
          reverse: (arr) => Array.isArray(arr) ? arr.slice().reverse() : [],
          sort: (arr, compare_fn) => {
            if (!Array.isArray(arr)) return [];
            const copy = arr.slice();
            if (compare_fn) return copy.sort(compare_fn);
            return copy.sort((a, b) => {
              const ta2 = tof(a), tb = tof(b);
              if (ta2 === "number" && tb === "number") return a - b;
              return String(a).localeCompare(String(b));
            });
          },
          unique: (arr) => Array.isArray(arr) ? Array.from(new Set(arr)) : [],
          pluck: (arr, prop) => Array.isArray(arr) ? arr.map((item2) => item2 && item2[prop]) : []
        },
        object: {
          get: (propertyPath) => (obj2) => {
            if (!obj2) return null;
            const parts = propertyPath.split(".");
            let value2 = obj2;
            for (const part of parts) {
              if (value2 === null || value2 === void 0) return null;
              value2 = value2[part];
            }
            return value2;
          },
          has: (property) => (obj2) => obj2 && Object.prototype.hasOwnProperty.call(obj2, property),
          keys: (obj2) => obj2 ? Object.keys(obj2) : [],
          values: (obj2) => obj2 ? Object.values(obj2) : [],
          entries: (obj2) => obj2 ? Object.entries(obj2) : [],
          pick: (obj2, keys) => {
            const res2 = {};
            if (!obj2 || !Array.isArray(keys)) return res2;
            keys.forEach((k) => {
              if (Object.prototype.hasOwnProperty.call(obj2, k)) res2[k] = obj2[k];
            });
            return res2;
          },
          omit: (obj2, keys) => {
            const res2 = {};
            if (!obj2) return res2;
            const omit_set = new Set(Array.isArray(keys) ? keys : []);
            Object.keys(obj2).forEach((k) => {
              if (!omit_set.has(k)) res2[k] = obj2[k];
            });
            return res2;
          }
        },
        compose: (...fns) => (value2) => fns.reduce((acc, fn) => fn(acc), value2),
        pipe: (...fns) => (value2) => fns.reduce((acc, fn) => fn(acc), value2),
        identity: (value2) => value2,
        defaultTo: (defaultValue) => (value2) => value2 !== null && value2 !== void 0 ? value2 : defaultValue,
        when: (condition, thenTransform, elseTransform = Transformations.identity) => (value2) => condition(value2) ? thenTransform(value2) : elseTransform(value2),
        bidirectional: (forward, reverse) => ({ transform: forward, reverse })
      };
      var Validators = {
        required: (value2) => {
          if (value2 === null || value2 === void 0) return false;
          if (typeof value2 === "string" && value2.trim() === "") return false;
          if (Array.isArray(value2) && value2.length === 0) return false;
          return true;
        },
        email: (value2) => {
          if (!value2) return true;
          const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          return re.test(String(value2));
        },
        url: (value2) => {
          if (!value2) return false;
          try {
            const u = new URL(value2);
            return u.protocol === "http:" || u.protocol === "https:";
          } catch {
            return false;
          }
        },
        range: (value2, min, max) => {
          const num = Number(value2);
          if (isNaN(num)) return false;
          return num >= min && num <= max;
        },
        length: (value2, min, max) => {
          if (value2 === null || value2 === void 0) return false;
          const len = String(value2).length;
          return len >= min && len <= max;
        },
        pattern: (value2, regex) => {
          if (value2 === null || value2 === void 0) return false;
          return regex.test(String(value2));
        },
        min: (value2, min) => Number(value2) >= min,
        max: (value2, max) => Number(value2) <= max,
        custom: (fn) => fn
      };
      Transformations.validators = Validators;
      Transformations.Validators = Validators;
      module.exports = Object.assign(Transformations, {
        Transformations,
        Validators,
        validators: Validators
      });
    }
  });

  // ../jsgui3-html/control_mixins/theme.js
  var require_theme = __commonJS({
    "../jsgui3-html/control_mixins/theme.js"(exports, module) {
      var is_plain_object = (value2) => value2 && typeof value2 === "object" && !Array.isArray(value2);
      var ensure_dom_style = (ctrl) => {
        if (!ctrl || !ctrl.dom) return null;
        ctrl.dom.attributes = ctrl.dom.attributes || {};
        ctrl.dom.attributes.style = ctrl.dom.attributes.style || {};
        return ctrl.dom.attributes.style;
      };
      var normalize_token_key = (token_key, options = {}) => {
        if (token_key === void 0 || token_key === null) return null;
        const prefix = options.prefix || "--theme-";
        let key2 = String(token_key).trim();
        if (!key2) return null;
        if (key2.startsWith("--")) return key2;
        const normalized = key2.replace(/_/g, "-");
        const prefix_name = prefix.replace(/^--/, "");
        if (normalized.startsWith(prefix_name)) {
          return `--${normalized}`;
        }
        return `${prefix}${normalized}`;
      };
      var apply_theme_tokens = (ctrl, tokens, options = {}) => {
        if (!ctrl || !tokens || !is_plain_object(tokens)) return;
        const style = ensure_dom_style(ctrl);
        if (!style) return;
        const prefix = options.prefix || "--theme-";
        Object.keys(tokens).forEach((token_key) => {
          const css_var = normalize_token_key(token_key, { prefix });
          if (!css_var) return;
          const value2 = tokens[token_key];
          if (value2 === void 0 || value2 === null) return;
          style[css_var] = String(value2);
        });
      };
      var apply_theme = (ctrl, theme, options = {}) => {
        if (!ctrl || !theme) return;
        ctrl.dom.attributes = ctrl.dom.attributes || {};
        if (typeof theme === "string") {
          ctrl.dom.attributes["data-theme"] = theme;
          return;
        }
        if (!is_plain_object(theme)) return;
        const theme_name = theme.name || theme.theme || theme.mode;
        if (theme_name) {
          ctrl.dom.attributes["data-theme"] = String(theme_name);
        }
        const tokens = theme.tokens || theme.variables || (theme_name || theme.overrides || theme.mode ? null : theme);
        if (tokens) {
          apply_theme_tokens(ctrl, tokens, options);
        }
        if (theme.overrides) {
          apply_theme_tokens(ctrl, theme.overrides, options);
        }
      };
      var apply_theme_overrides = (ctrl, overrides, options = {}) => {
        apply_theme_tokens(ctrl, overrides, options);
      };
      module.exports = {
        apply_theme,
        apply_theme_overrides,
        apply_theme_tokens,
        normalize_token_key
      };
    }
  });

  // ../jsgui3-html/html-core/Data_Model_View_Model_Control.js
  var require_Data_Model_View_Model_Control = __commonJS({
    "../jsgui3-html/html-core/Data_Model_View_Model_Control.js"(exports, module) {
      var Ctrl_Enh = require_control_enh();
      var { Data_Object } = require_lang();
      var { ModelBinder, ComputedProperty, PropertyWatcher, BindingManager } = require_ModelBinder();
      var { Transformations, Validators } = require_Transformations();
      var {
        apply_theme,
        apply_theme_overrides
      } = require_theme();
      var Control_Data = require_Control_Data();
      var Control_View = require_Control_View();
      var { ensure_control_models } = require_control_model_factory();
      var Data_Model_View_Model_Control = class extends Ctrl_Enh {
        constructor(...a) {
          super(...a);
          const spec = a[0] || {};
          const theme_context = spec.theme || this.context && this.context.theme;
          if (theme_context) {
            this.theme_context = theme_context;
            apply_theme(this, theme_context);
          }
          if (spec.theme_tokens) {
            apply_theme_overrides(this, spec.theme_tokens);
          }
          if (spec.theme_overrides) {
            apply_theme_overrides(this, spec.theme_overrides);
          }
          this._binding_manager = new BindingManager(this);
          const { context: context2 } = this;
          ensure_control_models(this, spec);
          if (this.data && this.data.model) {
            this.data.model.on("change", (e) => {
            });
            if (this.dom && this.dom.attributes) {
              this.dom.attributes["data-jsgui-data-model"] = this.data.model._id();
            }
          }
          if (this.view && this.view.data && this.view.data.model) {
            this.view.data.model.on("change", (e) => {
            });
            if (this.dom && this.dom.attributes) {
              this.dom.attributes["data-jsgui-view-data-model"] = this.view.data.model._id();
            }
          }
          if (spec.view && spec.view.model) {
            this.view.model = spec.view.model;
            this.view.model.on("change", (e) => {
              console.log("Data_Model_View_Model_Control this.view.model change e:", e);
            });
            if (this.dom && this.dom.attributes) {
              this.dom.attributes["data-jsgui-view-model"] = this.view.model._id();
            }
          }
          if (this.dom.el) {
            const context_keys = Array.from(Object.keys(this.context));
            const context_map_controls_keys = Array.from(Object.keys(this.context.map_controls));
            if (this.dom.el.hasAttribute("data-jsgui-data-model")) {
              const data_model_jsgui_id = this.dom.el.getAttribute("data-jsgui-data-model");
              const data_model = this.context.map_controls[data_model_jsgui_id];
              if (data_model) {
                this.data = this.data || new Control_Data({ context: context2 });
                this.data.model = data_model;
                data_model.on("change", (e) => {
                });
              }
            }
            if (this.dom.el.hasAttribute("data-jsgui-view-model")) {
              this.view = this.view || new Control_View({ context: context2 });
              const view_model_jsgui_id = this.dom.el.getAttribute("data-jsgui-view-model");
              const view_model = this.context.map_controls[view_model_jsgui_id];
              if (!!view_model) {
                this.view.model = view_model;
                view_model.on("change", (e) => {
                });
              } else {
              }
            } else {
              this.view = this.view || {};
              this.view.model = new Data_Object({
                context: context2
              });
            }
          }
        }
        pre_activate() {
          super.pre_activate();
        }
        /**
         * Create a binding between data model and view model
         * @param {Object} bindings - Property binding definitions
         * @param {Object} options - Binding options
         * @example
         * this.bind({
         *     'date': {
         *         to: 'formattedDate',
         *         transform: (date) => formatDate(date, 'YYYY-MM-DD'),
         *         reverse: (str) => parseDate(str)
         *     }
         * });
         */
        bind(bindings, options = {}) {
          if (!this.data || !this.data.model) {
            console.warn("Data_Model_View_Model_Control.bind: No data.model available");
            return null;
          }
          if (!this.view || !this.view.data || !this.view.data.model) {
            console.warn("Data_Model_View_Model_Control.bind: No view.data.model available");
            return null;
          }
          return this._binding_manager.bind(
            this.data.model,
            this.view.data.model,
            bindings,
            options
          );
        }
        /**
         * Create a computed property on a model
         * @param {Object} model - Target model (data.model or view.data.model)
         * @param {Array|string} dependencies - Property names to watch
         * @param {Function} computeFn - Function to compute the value
         * @param {Object} options - Options including propertyName
         * @example
         * this.computed(this.view.data.model, ['firstName', 'lastName'], 
         *     (first, last) => `${first} ${last}`,
         *     { propertyName: 'fullName' }
         * );
         */
        computed(model, dependencies, computeFn, options = {}) {
          return this._binding_manager.createComputed(model, dependencies, computeFn, options);
        }
        /**
         * Watch a property for changes
         * @param {Object} model - Model to watch
         * @param {string} property - Property name to watch
         * @param {Function} callback - Callback function (newVal, oldVal) => void
         * @param {Object} options - Watch options
         * @example
         * this.watch(this.data.model, 'selectedItem', (newVal, oldVal) => {
         *     console.log('Selection changed:', oldVal, '', newVal);
         * });
         */
        watch(model, property, callback2, options = {}) {
          return this._binding_manager.watch(model, property, callback2, options);
        }
        /**
         * Get transformations library
         */
        get transforms() {
          return Transformations;
        }
        /**
         * Get validators library
         */
        get validators() {
          return Validators;
        }
        /**
         * Inspect all bindings for debugging
         */
        inspectBindings() {
          return this._binding_manager.inspect();
        }
        /**
         * Cleanup bindings when control is destroyed
         */
        destroy() {
          if (this._binding_manager) {
            this._binding_manager.cleanup();
          }
          if (super.destroy) {
            super.destroy();
          }
        }
      };
      module.exports = Data_Model_View_Model_Control;
    }
  });

  // ../jsgui3-html/html-core/control.js
  var require_control = __commonJS({
    "../jsgui3-html/html-core/control.js"(exports, module) {
      var Control2 = require_Data_Model_View_Model_Control();
      module.exports = Control2;
    }
  });

  // ../jsgui3-html/html-core/selection-scope.js
  var require_selection_scope = __commonJS({
    "../jsgui3-html/html-core/selection-scope.js"(exports, module) {
      var jsgui = require_lang();
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = require_control();
      var Selection_Scope = class extends jsgui.Data_Object {
        //var Selection_Scope = jsgui.Class.extend({
        constructor(spec) {
          super(spec);
          if (spec.context) this.context = spec.context;
          if (typeof spec.id !== "undefined") this.id = spec.id;
          if (spec.ctrl) this.control = spec.ctrl;
          if (spec.control) this.control = spec.control;
          this.map_selected_controls = {};
        }
        "select_only"(ctrl, silent = false) {
          var currently_selected;
          var count_deselected = 0;
          var selected;
          each(this.map_selected_controls, (v, i) => {
            if (v && v !== ctrl && v !== this.control) {
              if (v.selected) {
                v.selected = false;
                count_deselected++;
              }
            }
            if (v === ctrl && v !== this.control) {
              currently_selected = v.selected;
            }
          });
          this.map_selected_controls = {};
          if (typeof ctrl._id === "function") {
            this.map_selected_controls[ctrl._id()] = ctrl;
          } else {
          }
          if (!currently_selected) {
            ctrl.selected = true;
            if (!silent) {
              this.raise("change", {
                name: "selected",
                value: ctrl
              });
              ctrl.raise("select");
            }
          }
          if (count_deselected > 0 & !currently_selected) {
          }
        }
        "deselect_all"(silent = false) {
          each(this.map_selected_controls, (v, i) => {
            if (v) {
              if (v.selected) {
                v.selected = false;
                v.raise("deselect");
              }
            }
          });
          if (!silent) {
            this.raise("change", {
              name: "selected",
              value: void 0
            });
          }
          this.map_selected_controls = {};
        }
        "deselect"(ctrl, silent = false) {
          if (ctrl.selected === true) {
            ctrl.selected = false;
          }
          if (!silent) {
            ctrl.raise("deselected");
            this.raise("change", {
              name: "selected",
              map_selected_controls: this.map_selected_controls
            });
          }
        }
        "select"(ctrl, silent = false) {
          if (!ctrl.selected) {
            ctrl.selected = true;
          }
          if (!silent) {
            ctrl.raise("selected");
            this.raise("change", {
              name: "selected",
              map_selected_controls: this.map_selected_controls
            });
          }
        }
        // deselect controls internal to a control.
        // When selecting a control, we want to make it so that controls inside it, in the same selection context are not selected.
        //  The Selection Scope does a fair bit of the management of the selections.
        "deselect_ctrl_content"(ctrl, silent = false) {
          var cs = ctrl.selection_scope;
          var msc = this.map_selected_controls;
          ctrl.content.each((v) => {
            if (v instanceof Control2) {
              v.selected = false;
              var id = v._id();
              if (msc[id]) msc[id] = false;
              this.deselect_ctrl_content(v);
              if (!silent) v.raise("deselected");
            }
          });
          if (!silent) {
            this.raise("change", {
              name: "selected",
              map_selected_controls: this.map_selected_controls
            });
          }
        }
        "select_toggle"(ctrl, silent = false) {
          var sel = ctrl.selected;
          var msc = this.map_selected_controls;
          var id = ctrl._id();
          if (!sel) {
            var sel_anc = ctrl.find_selected_ancestor_in_scope();
            if (sel_anc) {
              console.log("1) not selecting because a selected ancestor in the selection scope has been found.");
            } else {
              ctrl.selected = true;
              this.deselect_ctrl_content(ctrl, silent);
              msc[id] = ctrl;
            }
          } else {
            var tsel = tof(sel);
            if (tsel === "boolean") {
              if (sel) {
                ctrl.selected = false;
                msc[id] = false;
              } else {
                var sel_anc = ctrl.find_selected_ancestor_in_scope();
                if (sel_anc) {
                  console.log("2) not selecting because a selected ancestor in the selection scope has been found.");
                } else {
                  this.deselect_ctrl_content(ctrl, silent);
                  ctrl.selected = true;
                  msc[id] = ctrl;
                }
              }
            }
          }
          if (!silent) {
            this.raise("change");
          }
        }
      };
      module.exports = Selection_Scope;
    }
  });

  // ../jsgui3-html/html-core/page-context.js
  var require_page_context = __commonJS({
    "../jsgui3-html/html-core/page-context.js"(exports, module) {
      var jsgui = require_lang();
      var { each, tof, is_defined, get_a_sig, Evented_Class, Data_Model } = jsgui;
      var Selection_Scope = require_selection_scope();
      var Page_Context = class extends Evented_Class {
        constructor(spec) {
          spec = spec || {};
          super(spec);
          this.map_els = this.map_els || {};
          if (spec.document) {
            this.document = spec.document;
          } else if (typeof document !== "undefined") {
            this.document = document;
          }
          if (spec.browser_info) {
            this.browser_info = spec.browser_info;
          }
          ;
          if (spec.resource_pool) {
            this.resource_pool = spec.resource_pool;
          }
          this.get_vector_methodology = function() {
            if (this.browser_info.ie) {
              return "vml";
            } else {
              return "svg";
            }
          };
          this.selection_scopes = {};
          this.selection_scope_id_counter = 0;
          var map_new_ids = {};
          var map_objects = {};
          var _get_new_typed_object_id = (type_name) => {
            if (!is_defined(map_new_ids[type_name])) {
              map_new_ids[type_name] = 0;
            }
            var res2 = type_name + "_" + map_new_ids[type_name];
            map_new_ids[type_name]++;
            return res2;
          };
          this.new_id = _get_new_typed_object_id;
          this.set_max_ids = (map_max_ids) => {
            each(map_max_ids, (v, i) => {
              map_new_ids[i] = v + 1;
            });
          };
          var map_Controls = this.map_Controls = {};
          var map_controls = this.map_controls = {};
          this.map_data_models = this.map_data_models || {};
          this.map_data_model_iids = this.map_data_model_iids || {};
          this.map_control_iids = {};
          this.next_iid = 1;
        }
        "get_ctrl_el"(ctrl) {
          if (!ctrl) return void 0;
          const ctrl_el = ctrl.dom && ctrl.dom.el;
          if (ctrl_el) return ctrl_el;
          let ctrl_id;
          if (typeof ctrl === "string") {
            ctrl_id = ctrl;
          } else if (typeof ctrl._id === "function") {
            ctrl_id = ctrl._id();
          } else if (ctrl.__id) {
            ctrl_id = ctrl.__id;
          }
          if (!ctrl_id) return void 0;
          const cached = this.map_els && this.map_els[ctrl_id];
          if (cached) return cached;
          const doc = this.document;
          if (doc && typeof doc.querySelector === "function") {
            const found = doc.querySelector('[data-jsgui-id="' + ctrl_id + '"]');
            if (found) {
              this.map_els[ctrl_id] = found;
              return found;
            }
          }
          return void 0;
        }
        "body"() {
          if (this._body_control) return this._body_control;
          const doc = this.document;
          if (!doc || !doc.body) return void 0;
          const Control2 = require_control();
          const body_control = new Control2({
            context: this,
            __type_name: "body",
            tag_name: "body",
            el: doc.body
          });
          this._body_control = body_control;
          if (typeof body_control._id === "function") {
            this.map_els[body_control._id()] = doc.body;
          }
          if (typeof body_control.add_content_change_event_listener === "function") {
            body_control.add_content_change_event_listener();
          }
          if (typeof body_control.add_dom_attributes_changes_listener === "function") {
            body_control.add_dom_attributes_changes_listener();
          }
          return body_control;
        }
        "new_selection_scope"(ctrl) {
          var res2 = new Selection_Scope({
            "context": this,
            "id": this.selection_scope_id_counter++,
            "ctrl": ctrl
          });
          this.selection_scopes[res2.id] = res2;
          if (ctrl) {
            ctrl.selection_scope = res2;
            if (typeof document === "undefined") {
              ctrl._fields = ctrl._fields || {};
              ctrl._fields.selection_scope = res2.id;
            }
          }
          return res2;
        }
        "make"(source) {
          let t_source = tof(source);
          if (t_source === "string") {
            let parsed = jsgui.parse_and_mount(source, this);
          }
        }
        "update_Controls"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig === "[o]") {
            var o = a[0];
            var map_Controls = this.map_Controls;
            each(o, (name2, Constructor2) => {
              name2 = name2.toLowerCase();
              map_Controls[name2] = Constructor2;
            });
          }
          if (sig === "[s,f]") {
            var name = a[0];
            var Constructor = a[1];
            name = name.toLowerCase();
            this.map_Controls[name] = Constructor;
          }
        }
        "register_control"(control) {
          control.context = this;
          var id = control._id();
          this.map_controls[id] = control;
          control.iid = this.next_iid;
          this.map_control_iids[id] = this.next_iid++;
        }
        register_data_model(data_model) {
          if (data_model instanceof Data_Model) {
            const id = data_model._id();
            this.map_data_models[id] = data_model;
            data_model.iid = this.next_iid;
            this.map_data_model_iids[id] = this.next_iid++;
          } else {
            console.trace();
            throw "Expected Data_Model instance";
          }
        }
        "first_ctrl_matching_type"(type_name) {
          var res2;
          each(this.map_controls, (ctrl, ctrl_id, fn_stop) => {
            if (ctrl.__type_name === type_name) {
              fn_stop();
              res2 = ctrl;
            }
          });
          return res2;
        }
      };
      module.exports = Page_Context;
    }
  });

  // ../jsgui3-html/html-core/html_parser.js
  var require_html_parser = __commonJS({
    "../jsgui3-html/html-core/html_parser.js"(exports, module) {
      var void_elements = /* @__PURE__ */ new Set([
        "area",
        "base",
        "br",
        "col",
        "embed",
        "hr",
        "img",
        "input",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]);
      var raw_text_elements = /* @__PURE__ */ new Set(["script", "style"]);
      var auto_close_on_start = {
        li: /* @__PURE__ */ new Set(["li"]),
        p: /* @__PURE__ */ new Set(["p"]),
        td: /* @__PURE__ */ new Set(["td", "th"]),
        th: /* @__PURE__ */ new Set(["td", "th"]),
        tr: /* @__PURE__ */ new Set(["tr"]),
        option: /* @__PURE__ */ new Set(["option"]),
        optgroup: /* @__PURE__ */ new Set(["optgroup"])
      };
      var is_whitespace = (ch) => ch === " " || ch === "\n" || ch === "\r" || ch === "	" || ch === "\f";
      var is_name_char = (ch) => {
        const code = ch.charCodeAt(0);
        return code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || ch === "_" || ch === "-" || ch === ":" || ch === ".";
      };
      var skip_whitespace = (str, pos) => {
        const len = str.length;
        while (pos < len && is_whitespace(str[pos])) pos++;
        return pos;
      };
      var find_raw_text_close = (str_html, start_pos, tag_name, lowercase_tags) => {
        const len = str_html.length;
        const expected_name = lowercase_tags ? tag_name.toLowerCase() : tag_name;
        for (let i = start_pos; i < len; i++) {
          if (str_html[i] !== "<") continue;
          let j = i + 1;
          j = skip_whitespace(str_html, j);
          if (str_html[j] !== "/") continue;
          j++;
          j = skip_whitespace(str_html, j);
          const name_start = j;
          while (j < len && is_name_char(str_html[j])) j++;
          let found_name = str_html.slice(name_start, j);
          if (lowercase_tags) found_name = found_name.toLowerCase();
          if (found_name !== expected_name) continue;
          const gt_index = str_html.indexOf(">", j);
          if (gt_index === -1) return null;
          return { start: i, end: gt_index + 1 };
        }
        return null;
      };
      var parse_html = (str_html, options = {}) => {
        if (typeof str_html !== "string") str_html = String(str_html || "");
        const ignore_whitespace = !!options.ignore_whitespace;
        const lowercase_tags = options.lowercase_tags !== false;
        const lowercase_attrs = options.lowercase_attrs !== false;
        const len = str_html.length;
        const root = [];
        const stack = [{ name: null, children: root }];
        let pos = 0;
        const push_text_node = (raw_text) => {
          if (raw_text.length === 0) return;
          if (ignore_whitespace && raw_text.trim().length === 0) return;
          stack[stack.length - 1].children.push({
            raw: raw_text,
            data: raw_text,
            type: "text"
          });
        };
        const push_node = (node) => {
          stack[stack.length - 1].children.push(node);
        };
        while (pos < len) {
          const ch = str_html[pos];
          if (ch !== "<") {
            const next_lt = str_html.indexOf("<", pos);
            const text_end = next_lt === -1 ? len : next_lt;
            push_text_node(str_html.slice(pos, text_end));
            pos = text_end;
            continue;
          }
          if (str_html.startsWith("<!--", pos)) {
            const end_index = str_html.indexOf("-->", pos + 4);
            const comment_end = end_index === -1 ? len : end_index + 3;
            const raw_comment = str_html.slice(pos, comment_end);
            push_node({
              raw: raw_comment,
              data: raw_comment,
              type: "comment"
            });
            pos = comment_end;
            continue;
          }
          if (str_html.startsWith("</", pos)) {
            let close_pos = pos + 2;
            close_pos = skip_whitespace(str_html, close_pos);
            const name_start2 = close_pos;
            while (close_pos < len && is_name_char(str_html[close_pos])) close_pos++;
            let close_name = str_html.slice(name_start2, close_pos);
            if (lowercase_tags) close_name = close_name.toLowerCase();
            const gt_index = str_html.indexOf(">", close_pos);
            pos = gt_index === -1 ? len : gt_index + 1;
            if (close_name) {
              for (let i = stack.length - 1; i > 0; i--) {
                if (stack[i].name === close_name) {
                  stack.length = i;
                  break;
                }
              }
            }
            continue;
          }
          if (str_html.startsWith("<!", pos) && !str_html.startsWith("<!--", pos)) {
            const gt_index = str_html.indexOf(">", pos + 2);
            const dir_end = gt_index === -1 ? len : gt_index + 1;
            const raw_dir = str_html.slice(pos, dir_end);
            push_node({
              raw: raw_dir,
              data: raw_dir,
              type: "directive"
            });
            pos = dir_end;
            continue;
          }
          if (str_html.startsWith("<?", pos)) {
            const end_index = str_html.indexOf("?>", pos + 2);
            const pi_end = end_index === -1 ? len : end_index + 2;
            const raw_pi = str_html.slice(pos, pi_end);
            push_node({
              raw: raw_pi,
              data: raw_pi,
              type: "directive"
            });
            pos = pi_end;
            continue;
          }
          const tag_start = pos;
          pos++;
          pos = skip_whitespace(str_html, pos);
          const name_start = pos;
          while (pos < len && is_name_char(str_html[pos])) pos++;
          let tag_name = str_html.slice(name_start, pos);
          if (!tag_name) {
            push_text_node("<");
            continue;
          }
          if (lowercase_tags) tag_name = tag_name.toLowerCase();
          const auto_close_set = auto_close_on_start[tag_name];
          if (auto_close_set) {
            const top = stack[stack.length - 1];
            if (top.name && auto_close_set.has(top.name)) stack.pop();
          }
          const attribs = {};
          let is_self_closing = false;
          let tag_end_index = null;
          while (pos < len) {
            pos = skip_whitespace(str_html, pos);
            if (pos >= len) break;
            const c2 = str_html[pos];
            if (c2 === ">") {
              tag_end_index = pos;
              pos++;
              break;
            }
            if (c2 === "/") {
              pos++;
              pos = skip_whitespace(str_html, pos);
              if (str_html[pos] === ">") {
                is_self_closing = true;
                tag_end_index = pos;
                pos++;
                break;
              }
              continue;
            }
            const attr_name_start = pos;
            while (pos < len && !is_whitespace(str_html[pos]) && str_html[pos] !== "=" && str_html[pos] !== ">" && str_html[pos] !== "/") {
              pos++;
            }
            let attr_name = str_html.slice(attr_name_start, pos);
            if (!attr_name) continue;
            if (lowercase_attrs) attr_name = attr_name.toLowerCase();
            pos = skip_whitespace(str_html, pos);
            let attr_value = attr_name;
            if (str_html[pos] === "=") {
              pos++;
              pos = skip_whitespace(str_html, pos);
              if (pos < len) {
                const quote = str_html[pos];
                if (quote === '"' || quote === "'") {
                  pos++;
                  const value_start = pos;
                  while (pos < len && str_html[pos] !== quote) pos++;
                  attr_value = str_html.slice(value_start, pos);
                  if (str_html[pos] === quote) pos++;
                } else {
                  const value_start = pos;
                  while (pos < len && !is_whitespace(str_html[pos]) && str_html[pos] !== ">" && str_html[pos] !== "/") {
                    pos++;
                  }
                  attr_value = str_html.slice(value_start, pos);
                }
              } else {
                attr_value = "";
              }
            }
            attribs[attr_name] = attr_value;
          }
          if (tag_end_index === null) tag_end_index = len;
          let raw_inner = str_html.slice(tag_start + 1, tag_end_index);
          raw_inner = raw_inner.trim();
          if (raw_inner.endsWith("/")) raw_inner = raw_inner.slice(0, -1).trim();
          const node_type = raw_text_elements.has(tag_name) ? tag_name : "tag";
          const node = {
            raw: raw_inner,
            data: raw_inner,
            type: node_type,
            name: tag_name,
            attribs,
            children: []
          };
          push_node(node);
          if (raw_text_elements.has(tag_name)) {
            const close_match = find_raw_text_close(str_html, pos, tag_name, lowercase_tags);
            const text_end = close_match ? close_match.start : len;
            const raw_text = str_html.slice(pos, text_end);
            if (!(ignore_whitespace && raw_text.trim().length === 0) && raw_text.length > 0) {
              node.children.push({
                raw: raw_text,
                data: raw_text,
                type: "text"
              });
            }
            pos = close_match ? close_match.end : len;
            continue;
          }
          if (!is_self_closing && !void_elements.has(tag_name)) {
            stack.push(node);
          }
        }
        return root;
      };
      var Default_Handler = class {
        constructor(callback2, options = {}) {
          this.callback = callback2;
          this.options = options;
          this.dom = null;
        }
        on_complete(dom) {
          this.dom = dom;
          if (this.callback) this.callback(null, dom);
        }
        on_error(err) {
          if (this.callback) this.callback(err);
        }
      };
      var Html_Parser = class {
        constructor(handler, options = {}) {
          this.handler = handler;
          this.options = options;
        }
        parse_complete(str_html) {
          try {
            const dom = parse_html(str_html, this.options);
            if (this.handler && this.handler.on_complete) this.handler.on_complete(dom);
            return dom;
          } catch (err) {
            if (this.handler && this.handler.on_error) this.handler.on_error(err);
            else throw err;
          }
        }
      };
      module.exports = {
        parse_html,
        Default_Handler,
        Html_Parser
      };
    }
  });

  // ../jsgui3-html/html-core/parse-mount.js
  var require_parse_mount = __commonJS({
    "../jsgui3-html/html-core/parse-mount.js"(exports, module) {
      var { Default_Handler, Html_Parser } = require_html_parser();
      var { tof, each } = require_lang();
      var map_jsgui_attr_names = {
        "name": true,
        "class": true,
        "content": true,
        "__type_name": true,
        "context": true,
        "key": true,
        "size": true
      };
      var log = () => {
      };
      var parse = function(str_content, context2, control_set, callback2) {
        str_content = str_content.trim();
        const handler = new Default_Handler(function(error2, dom) {
          if (error2) {
            log("parse error", error2);
          } else {
            log("dom", dom);
            let recurse = (dom2, depth, callback3) => {
              let tdom = tof(dom2);
              let res3;
              log("tdom", tdom);
              log("dom item", dom2);
              if (tdom === "array") {
                each(dom2, (v, i) => {
                  recurse(v, depth + 1, callback3);
                  callback3(v, depth, i);
                });
              } else if (tdom === "object") {
                if (dom2.children) {
                  each(dom2.children, (child, i) => {
                    recurse(child, depth + 1, callback3);
                    callback3(child, depth, i);
                  });
                }
              } else {
                log("dom", dom2);
              }
            };
            let last_depth = 0;
            let map_siblings_at_depth = {};
            let res_controls = {};
            const handle_text = (text, depth, sibling_index) => {
              let tn = new control_set.Text_Node({
                text,
                context: context2,
                sibling_index
              });
              res_controls.unnamed = res_controls.unnamed || [];
              res_controls.unnamed.push(tn);
              map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
              map_siblings_at_depth[depth].push(tn);
              last_depth = depth;
            };
            const handle_tag = (tag, depth, sibling_index) => {
              const tag_with_no_children = {};
              if (tag.raw) tag_with_no_children.raw = tag.raw;
              if (tag.data) tag_with_no_children.data = tag.data;
              if (tag.type) tag_with_no_children.type = tag.type;
              if (tag.name) tag_with_no_children.name = tag.name;
              if (tag.attribs) tag_with_no_children.attribs = tag.attribs;
              const create_ctrl = (tag2, content) => {
                if (control_set[tag2.name]) {
                  let Ctrl = control_set[tag2.name];
                  log("tag", tag2);
                  let a = tag2.attribs || {};
                  if (content) a.content = content;
                  each(content, (item2) => {
                  });
                  log("attribs a", a);
                  log("\n\n");
                  a.context = context2;
                  let ctrl2 = new Ctrl(a);
                  if (a.name) {
                    res_controls.named = res_controls.named || {};
                    res_controls.named[a.name] = ctrl2;
                  } else {
                    res_controls.unnamed = res_controls.unnamed || [];
                    res_controls.unnamed.push(ctrl2);
                  }
                  const arr_dom_attrs = [];
                  each(a, (a_value, a_name) => {
                    if (!map_jsgui_attr_names[a_name]) {
                      arr_dom_attrs.push([a_name, a_value]);
                    }
                  });
                  each(arr_dom_attrs, (attr) => {
                    const [name, value2] = attr;
                    ctrl2.dom.attributes[name] = value2;
                  });
                  return ctrl2;
                } else {
                  console.trace();
                  throw "lacking jsgui control for " + tag2.name;
                }
              };
              let my_children;
              let ctrl;
              if (depth > last_depth) {
                ctrl = create_ctrl(tag_with_no_children);
                map_siblings_at_depth[depth] = [];
                map_siblings_at_depth[depth].push(ctrl);
              } else if (depth < last_depth) {
                my_children = map_siblings_at_depth[last_depth];
                if (my_children) {
                  ctrl = create_ctrl(tag_with_no_children, my_children);
                } else {
                  ctrl = create_ctrl(tag_with_no_children);
                }
                map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                map_siblings_at_depth[last_depth] = null;
                map_siblings_at_depth[depth].push(ctrl);
              } else {
                ctrl = create_ctrl(tag_with_no_children);
                map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                map_siblings_at_depth[depth].push(ctrl);
              }
              last_depth = depth;
            };
            recurse(dom, 0, (item2, depth, sibling_index) => {
              if (item2.type === "text") {
                let trimmed = item2.data.trim();
                if (trimmed.length > 0) {
                  handle_text(item2.raw, depth, sibling_index);
                }
              } else if (item2.type === "tag" || item2.type === "script" || item2.type === "style") {
                handle_tag(item2, depth, sibling_index);
              }
            });
            const depth_0_ctrls = map_siblings_at_depth[0];
            callback2(null, [depth_0_ctrls, res_controls]);
          }
        });
        var parser = new Html_Parser(handler);
        parser.parse_complete(str_content);
      };
      var parse_mount = function(str_content, target, control_set) {
        return new Promise(async (solve, jettison) => {
          let container;
          let a = arguments;
          let l2 = a.length;
          if (l2 === 4) {
            container = a[2];
            control_set = a[3];
          } else {
            container = target;
          }
          const { context: context2 } = target;
          parse(str_content, context2, control_set, (err, res_parse) => {
            if (err) {
              jettison(err);
            } else {
              const [depth_0_ctrls, res_controls] = res_parse;
              each(res_controls.named, (ctrl, name) => {
                target[name] = ctrl;
              });
              const is_active_context = context2.__is_active;
              each(depth_0_ctrls, (new_ctrl) => {
                container.add(new_ctrl);
                if (is_active_context) {
                  setTimeout(() => {
                    new_ctrl.activate();
                  }, 0);
                }
              });
              if (res_controls.named) {
                target._ctrl_fields = target._ctrl_fields || {};
                Object.assign(target._ctrl_fields, res_controls.named);
              }
              solve(depth_0_ctrls);
            }
          });
        });
      };
      var res2 = {
        parse,
        parse_mount
      };
      module.exports = res2;
    }
  });

  // ../jsgui3-html/html-core/html-core.js
  var require_html_core = __commonJS({
    "../jsgui3-html/html-core/html-core.js"(exports, module) {
      var jsgui = require_lang();
      var { patch_lang_tools } = require_lang_tools_compat();
      patch_lang_tools();
      var Text_Node = require_text_node();
      var Page_Context = require_page_context();
      var Selection_Scope = require_selection_scope();
      var Control_Data = require_Control_Data();
      var Control_View = require_Control_View();
      var { parse_mount, parse } = require_parse_mount();
      var { str_arr_mapify, get_a_sig, each, prop } = jsgui;
      var Control2 = jsgui.Control = require_Data_Model_View_Model_Control();
      jsgui.load_type("control", "C", (item2) => item2 instanceof Control2);
      var Evented_Class = jsgui.Evented_Class;
      var tof = jsgui.tof;
      var map_Controls = jsgui.map_Controls = {};
      var def = jsgui.is_defined;
      var core_extension = str_arr_mapify(function(tagName) {
        jsgui.controls[tagName] = jsgui[tagName] = class extends Control2 {
          constructor(spec) {
            let str;
            if (typeof spec === "string") {
              str = spec;
              spec = {
                __type_name: tagName
              };
            } else {
              if (typeof spec === "object") {
                spec.__type_name = tagName;
              }
            }
            super(spec);
            this.dom.tagName = tagName;
          }
        };
        jsgui[tagName].prototype._tag_name = tagName;
        map_Controls[tagName] = jsgui[tagName];
      });
      var core_extension_no_closing_tag = str_arr_mapify(function(tagName) {
        jsgui[tagName] = class extends Control2 {
          constructor(spec) {
            spec.__type_name = tagName;
            super(spec);
            this.dom.tagName = tagName;
            this.dom.noClosingTag = true;
          }
        };
        jsgui[tagName].prototype._tag_name = tagName;
        map_Controls[tagName] = jsgui[tagName];
      });
      var recursive_dom_iterate = function(el, callback2) {
        callback2(el);
        var cns = el.childNodes;
        for (var c2 = 0, l2 = cns.length; c2 < l2; c2++) {
          recursive_dom_iterate(cns[c2], callback2);
        }
      };
      var recursive_dom_iterate_depth2 = function(el, callback2) {
        var cns = el.childNodes;
        for (var c2 = 0, l2 = cns.length; c2 < l2; c2++) {
          recursive_dom_iterate_depth2(cns[c2], callback2);
        }
        callback2(el);
      };
      var pre_activate = (context2) => {
        console.log("jsgui html-core pre_activate");
        if (!context2) {
          throw "jsgui-html-enh pre_activate(context) - need to supply context parameter.";
        }
        const map_controls = context2.map_controls || {};
        var map_jsgui_els = {};
        var map_jsgui_types = {};
        var arr_controls = [];
        var max_typed_ids = {};
        const map_ctrl_parent_ids_by_ctrl_ids = {};
        var id_before__ = function(id) {
          var pos1 = id.lastIndexOf("_");
          var res2 = id.substr(0, pos1);
          return res2;
        };
        var num_after = function(id) {
          return parseInt(id.substr(id.lastIndexOf("_") + 1), 10);
        };
        let map_els = () => {
          recursive_dom_iterate(document, (el) => {
            const nt = el.nodeType;
            if (nt === 1) {
              const jsgui_id = el.getAttribute("data-jsgui-id");
              if (jsgui_id) {
                if (el.parentNode) {
                  if (el.parentNode.nodeType === 1) {
                    const parent_jsgui_id = el.parentNode.getAttribute("data-jsgui-id");
                    if (parent_jsgui_id) {
                      map_ctrl_parent_ids_by_ctrl_ids[jsgui_id] = parent_jsgui_id;
                    }
                  }
                }
                const ib = id_before__(jsgui_id), num = num_after(jsgui_id);
                if (!def(max_typed_ids[ib])) {
                  max_typed_ids[ib] = num;
                } else {
                  if (num > max_typed_ids[ib]) max_typed_ids[ib] = num;
                }
                map_jsgui_els[jsgui_id] = el;
                var jsgui_type = el.getAttribute("data-jsgui-type");
                if (jsgui_type) map_jsgui_types[jsgui_id] = jsgui_type;
              }
            }
          });
        };
        map_els();
        context2.set_max_ids(max_typed_ids);
        each(map_jsgui_els, (el, jsgui_id) => {
          const l_tag_name = el.tagName.toLowerCase();
          if (jsgui_id) {
            var type = map_jsgui_types[jsgui_id];
            if (!map_controls[jsgui_id]) {
              var Cstr = context2.map_Controls[type];
              if (Cstr) {
                const parent_jsgui_id = map_ctrl_parent_ids_by_ctrl_ids[jsgui_id];
                const ctrl_spec = {
                  "context": context2,
                  "__type_name": type,
                  "id": jsgui_id,
                  "el": el
                };
                if (parent_jsgui_id) {
                  if (map_controls[parent_jsgui_id]) {
                  }
                }
                var ctrl = new Cstr(ctrl_spec);
                if (parent_jsgui_id) {
                  if (map_controls[parent_jsgui_id]) {
                  }
                }
                arr_controls.push(ctrl);
                if (l_tag_name === "html") {
                  context2.ctrl_document = ctrl;
                }
                map_controls[jsgui_id] = ctrl;
              } else {
                console.log("Missing context.map_Controls for type " + type + ", using generic Control");
                var ctrl = new Control2({
                  "context": context2,
                  "__type_name": type,
                  "id": jsgui_id,
                  "el": el
                });
                arr_controls.push(ctrl);
                map_controls[jsgui_id] = ctrl;
              }
            } else {
              var ctrl = map_controls[jsgui_id];
              ctrl.dom.el = el;
              if (ctrl.attach_dom_events) ctrl.attach_dom_events();
            }
          }
        });
        recursive_dom_iterate_depth2(document, (el) => {
          var nt = el.nodeType;
          if (nt === 1) {
            var jsgui_id = el.getAttribute("data-jsgui-id");
            if (jsgui_id) {
              const ctrl = map_controls[jsgui_id];
              ctrl.pre_activate(ctrl.dom.el);
            }
          }
        });
      };
      var activate = function(context2) {
        const map_controls = context2.map_controls;
        console.log("jsgui html-core activate");
        console.log("jsgui.def_server_resources", jsgui.def_server_resources);
        if (!context2) {
          throw "jsgui-html-enh activate(context) - need to supply context parameter.";
        }
        recursive_dom_iterate_depth2(document, (el) => {
          var nt = el.nodeType;
          if (nt === 1) {
            var jsgui_id = el.getAttribute("data-jsgui-id");
            if (jsgui_id) {
              const ctrl = map_controls[jsgui_id];
              ctrl.activate(ctrl.dom.el);
            }
          }
        });
      };
      jsgui.controls = jsgui.controls || {
        Control: Control2
      };
      jsgui.controls.span = jsgui.span = class span extends Control2 {
        constructor(spec) {
          spec.__type_name = "span";
          super(spec);
          this.dom.tagName = "span";
          spec = spec || {};
          prop(this, "text", spec.text || "");
          this.on("change", (e_change) => {
            const { name } = e_change;
            if (name === "text") {
              const new_text = typeof e_change.value === "undefined" || e_change.value === null ? "" : String(e_change.value);
              const content_arr = this.content._arr;
              if (content_arr.length === 1 && content_arr[0] instanceof Text_Node) {
                content_arr[0].text = new_text;
              } else {
                let existing_text_node;
                for (let idx = 0; idx < content_arr.length; idx++) {
                  if (content_arr[idx] instanceof Text_Node) {
                    existing_text_node = content_arr[idx];
                    break;
                  }
                }
                if (existing_text_node) {
                  existing_text_node.text = new_text;
                } else {
                  const tn = new Text_Node({
                    context: this.context,
                    text: new_text
                  });
                  if (this.content && typeof this.content.insert === "function") {
                    this.content.insert(tn, 0);
                  } else {
                    this.add(tn);
                  }
                  this.tn = this.text_node = tn;
                }
              }
            }
          });
          if (!spec.el) {
            this.compose_span();
          }
        }
        compose_span() {
          if (this.text && this.text.length > 0) {
            this.add(this.tn = this.text_node = new Text_Node({
              context: this.context,
              text: this.text
            }));
          }
        }
      };
      var String_Control = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = "string_control";
          super(spec);
          this.dom.tagName = void 0;
          spec = spec || {};
          if (typeof spec.text !== "undefined") {
            this._text = spec.text;
          } else {
            this._text = "";
          }
          if (!spec.el) {
          }
        }
        get text() {
          return this._text;
        }
        set text(value2) {
          this._text = value2;
          this.raise("change", {
            "name": "text",
            "value": value2
          });
        }
        all_html_render() {
          return this._text;
        }
        activate() {
        }
      };
      jsgui.pre_activate = pre_activate;
      jsgui.activate = activate;
      core_extension("html head title body div select option h1 h2 h3 h4 h5 h6 label p a script link button form textarea img ul li audio video table tr td caption thead colgroup col svg defs marker polygon line section code samp canvas");
      core_extension_no_closing_tag("link input meta");
      var HTML_Document = class extends jsgui.Control {
        constructor(spec = {}) {
          spec.tag_name = "html";
          super(spec);
        }
      };
      var Blank_HTML_Document = class extends HTML_Document {
        constructor(spec = {}) {
          super(spec);
          var context2 = this.context;
          if (!spec.el) {
            var head = new jsgui.head({
              "context": context2
            });
            this.content.add(head);
            var title = new jsgui.title({
              "context": context2
            });
            head.content.add(title);
            var body = new jsgui.body({
              "context": context2
            });
            this.content.add(body);
            this.head = head;
            this.title = title;
            this.body = body;
          }
        }
        "body"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig == "[]") {
            var content = this.content;
            var body = content.get(1);
            return body;
          }
        }
      };
      var Intersection_Finder = class extends Evented_Class {
        constructor(spec) {
          super(spec);
          let coords_ctrls;
          let update_ctrl_coords = () => {
            coords_ctrls = [];
            each(spec.controls || spec.ctrls, (ctrl) => {
              coords_ctrls.push([ctrl.bcr(), ctrl]);
            });
          };
          let map_selected = /* @__PURE__ */ new Map();
          let find_intersections = (coords) => {
            update_ctrl_coords();
            let intersecting = [], newly_intersecting = [], previously_intersecting = [];
            ;
            let [btl, bbr] = coords;
            each(coords_ctrls, (cc) => {
              let [ccoords, ctrl] = cc;
              let [cpos, cbr, csize] = ccoords;
              let intersect = cpos[0] <= bbr[0] && btl[0] <= cbr[0] && cpos[1] <= bbr[1] && btl[1] <= cbr[1];
              if (intersect) {
                if (map_selected.get(ctrl) !== true) {
                  newly_intersecting.push(ctrl);
                  map_selected.set(ctrl, true);
                }
                intersecting.push(ctrl);
              } else {
                if (map_selected.get(ctrl) === true) {
                  previously_intersecting.push(ctrl);
                  map_selected.set(ctrl, false);
                }
              }
            });
            return [intersecting, newly_intersecting, previously_intersecting];
          };
          prop(this, "coords", (transform_coords) => {
            if (transform_coords[0][1] > transform_coords[1][1]) {
              let [a, b] = transform_coords;
              transform_coords = [b, a];
            }
            if (transform_coords[0][0] > transform_coords[1][0]) {
              let a = transform_coords[1][0];
              transform_coords[1][0] = transform_coords[0][0];
              transform_coords[0][0] = a;
            }
            return transform_coords;
          }, (change_coords) => {
            let intersections = find_intersections(change_coords[0]);
            if (intersections[1].length > 0 || intersections[2].length > 0) {
              this.raise("change", {
                "name": "intersections",
                "value": intersections
              });
            }
          });
          this.find_intersections = find_intersections;
        }
      };
      var Relative = class extends Control2 {
        constructor(spec) {
          spec.class = "relative";
          super(spec);
        }
      };
      jsgui.Control_Data = Control_Data;
      jsgui.Control_View = Control_View;
      jsgui.Relative = Relative;
      jsgui.String_Control = jsgui.controls.String_Control = String_Control;
      jsgui.HTML_Document = HTML_Document;
      jsgui.Blank_HTML_Document = Blank_HTML_Document;
      jsgui.Text_Node = jsgui.controls.Text_Node = jsgui.Text_Node = jsgui.controls.Text_Node = Text_Node;
      jsgui.Page_Context = Page_Context;
      jsgui.Selection_Scope = Selection_Scope;
      jsgui.Intersection_Finder = Intersection_Finder;
      jsgui.parse_mount = parse_mount;
      jsgui.parse = parse;
      module.exports = jsgui;
    }
  });

  // ../jsgui3-html/node_modules/requires-port/index.js
  var require_requires_port = __commonJS({
    "../jsgui3-html/node_modules/requires-port/index.js"(exports, module) {
      "use strict";
      module.exports = function required(port, protocol) {
        protocol = protocol.split(":")[0];
        port = +port;
        if (!port) return false;
        switch (protocol) {
          case "http":
          case "ws":
            return port !== 80;
          case "https":
          case "wss":
            return port !== 443;
          case "ftp":
            return port !== 21;
          case "gopher":
            return port !== 70;
          case "file":
            return false;
        }
        return port !== 0;
      };
    }
  });

  // ../jsgui3-html/node_modules/querystringify/index.js
  var require_querystringify = __commonJS({
    "../jsgui3-html/node_modules/querystringify/index.js"(exports) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var undef;
      function decode(input) {
        try {
          return decodeURIComponent(input.replace(/\+/g, " "));
        } catch (e) {
          return null;
        }
      }
      function encode(input) {
        try {
          return encodeURIComponent(input);
        } catch (e) {
          return null;
        }
      }
      function querystring(query) {
        var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
        while (part = parser.exec(query)) {
          var key2 = decode(part[1]), value2 = decode(part[2]);
          if (key2 === null || value2 === null || key2 in result) continue;
          result[key2] = value2;
        }
        return result;
      }
      function querystringify(obj2, prefix) {
        prefix = prefix || "";
        var pairs = [], value2, key2;
        if ("string" !== typeof prefix) prefix = "?";
        for (key2 in obj2) {
          if (has.call(obj2, key2)) {
            value2 = obj2[key2];
            if (!value2 && (value2 === null || value2 === undef || isNaN(value2))) {
              value2 = "";
            }
            key2 = encode(key2);
            value2 = encode(value2);
            if (key2 === null || value2 === null) continue;
            pairs.push(key2 + "=" + value2);
          }
        }
        return pairs.length ? prefix + pairs.join("&") : "";
      }
      exports.stringify = querystringify;
      exports.parse = querystring;
    }
  });

  // ../jsgui3-html/node_modules/url-parse/index.js
  var require_url_parse = __commonJS({
    "../jsgui3-html/node_modules/url-parse/index.js"(exports, module) {
      "use strict";
      var required = require_requires_port();
      var qs = require_querystringify();
      var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      var CRHTLF = /[\n\r\t]/g;
      var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
      var port = /:\d+$/;
      var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
      var windowsDriveLetter = /^[a-zA-Z]:/;
      function trimLeft(str) {
        return (str ? str : "").toString().replace(controlOrWhitespace, "");
      }
      var rules = [
        ["#", "hash"],
        // Extract from the back.
        ["?", "query"],
        // Extract from the back.
        function sanitize(address, url) {
          return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
        },
        ["/", "pathname"],
        // Extract from the back.
        ["@", "auth", 1],
        // Extract from the front.
        [NaN, "host", void 0, 1, 1],
        // Set left over value.
        [/:(\d*)$/, "port", void 0, 1],
        // RegExp the back.
        [NaN, "hostname", void 0, 1, 1]
        // Set left over.
      ];
      var ignore = { hash: 1, query: 1 };
      function lolcation(loc) {
        var globalVar;
        if (typeof window !== "undefined") globalVar = window;
        else if (typeof global !== "undefined") globalVar = global;
        else if (typeof self !== "undefined") globalVar = self;
        else globalVar = {};
        var location = globalVar.location || {};
        loc = loc || location;
        var finaldestination = {}, type = typeof loc, key2;
        if ("blob:" === loc.protocol) {
          finaldestination = new Url(unescape(loc.pathname), {});
        } else if ("string" === type) {
          finaldestination = new Url(loc, {});
          for (key2 in ignore) delete finaldestination[key2];
        } else if ("object" === type) {
          for (key2 in loc) {
            if (key2 in ignore) continue;
            finaldestination[key2] = loc[key2];
          }
          if (finaldestination.slashes === void 0) {
            finaldestination.slashes = slashes.test(loc.href);
          }
        }
        return finaldestination;
      }
      function isSpecial(scheme) {
        return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
      }
      function extractProtocol(address, location) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        location = location || {};
        var match = protocolre.exec(address);
        var protocol = match[1] ? match[1].toLowerCase() : "";
        var forwardSlashes = !!match[2];
        var otherSlashes = !!match[3];
        var slashesCount = 0;
        var rest;
        if (forwardSlashes) {
          if (otherSlashes) {
            rest = match[2] + match[3] + match[4];
            slashesCount = match[2].length + match[3].length;
          } else {
            rest = match[2] + match[4];
            slashesCount = match[2].length;
          }
        } else {
          if (otherSlashes) {
            rest = match[3] + match[4];
            slashesCount = match[3].length;
          } else {
            rest = match[4];
          }
        }
        if (protocol === "file:") {
          if (slashesCount >= 2) {
            rest = rest.slice(2);
          }
        } else if (isSpecial(protocol)) {
          rest = match[4];
        } else if (protocol) {
          if (forwardSlashes) {
            rest = rest.slice(2);
          }
        } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
          rest = match[4];
        }
        return {
          protocol,
          slashes: forwardSlashes || isSpecial(protocol),
          slashesCount,
          rest
        };
      }
      function resolve(relative, base) {
        if (relative === "") return base;
        var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
        while (i--) {
          if (path[i] === ".") {
            path.splice(i, 1);
          } else if (path[i] === "..") {
            path.splice(i, 1);
            up++;
          } else if (up) {
            if (i === 0) unshift = true;
            path.splice(i, 1);
            up--;
          }
        }
        if (unshift) path.unshift("");
        if (last === "." || last === "..") path.push("");
        return path.join("/");
      }
      function Url(address, location, parser) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        if (!(this instanceof Url)) {
          return new Url(address, location, parser);
        }
        var relative, extracted, parse, instruction, index, key2, instructions = rules.slice(), type = typeof location, url = this, i = 0;
        if ("object" !== type && "string" !== type) {
          parser = location;
          location = null;
        }
        if (parser && "function" !== typeof parser) parser = qs.parse;
        location = lolcation(location);
        extracted = extractProtocol(address || "", location);
        relative = !extracted.protocol && !extracted.slashes;
        url.slashes = extracted.slashes || relative && location.slashes;
        url.protocol = extracted.protocol || location.protocol || "";
        address = extracted.rest;
        if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
          instructions[3] = [/(.*)/, "pathname"];
        }
        for (; i < instructions.length; i++) {
          instruction = instructions[i];
          if (typeof instruction === "function") {
            address = instruction(address, url);
            continue;
          }
          parse = instruction[0];
          key2 = instruction[1];
          if (parse !== parse) {
            url[key2] = address;
          } else if ("string" === typeof parse) {
            index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
            if (~index) {
              if ("number" === typeof instruction[2]) {
                url[key2] = address.slice(0, index);
                address = address.slice(index + instruction[2]);
              } else {
                url[key2] = address.slice(index);
                address = address.slice(0, index);
              }
            }
          } else if (index = parse.exec(address)) {
            url[key2] = index[1];
            address = address.slice(0, index.index);
          }
          url[key2] = url[key2] || (relative && instruction[3] ? location[key2] || "" : "");
          if (instruction[4]) url[key2] = url[key2].toLowerCase();
        }
        if (parser) url.query = parser(url.query);
        if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
          url.pathname = resolve(url.pathname, location.pathname);
        }
        if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
          url.pathname = "/" + url.pathname;
        }
        if (!required(url.port, url.protocol)) {
          url.host = url.hostname;
          url.port = "";
        }
        url.username = url.password = "";
        if (url.auth) {
          index = url.auth.indexOf(":");
          if (~index) {
            url.username = url.auth.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = url.auth.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(url.auth));
          }
          url.auth = url.password ? url.username + ":" + url.password : url.username;
        }
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
      }
      function set(part, value2, fn) {
        var url = this;
        switch (part) {
          case "query":
            if ("string" === typeof value2 && value2.length) {
              value2 = (fn || qs.parse)(value2);
            }
            url[part] = value2;
            break;
          case "port":
            url[part] = value2;
            if (!required(value2, url.protocol)) {
              url.host = url.hostname;
              url[part] = "";
            } else if (value2) {
              url.host = url.hostname + ":" + value2;
            }
            break;
          case "hostname":
            url[part] = value2;
            if (url.port) value2 += ":" + url.port;
            url.host = value2;
            break;
          case "host":
            url[part] = value2;
            if (port.test(value2)) {
              value2 = value2.split(":");
              url.port = value2.pop();
              url.hostname = value2.join(":");
            } else {
              url.hostname = value2;
              url.port = "";
            }
            break;
          case "protocol":
            url.protocol = value2.toLowerCase();
            url.slashes = !fn;
            break;
          case "pathname":
          case "hash":
            if (value2) {
              var char = part === "pathname" ? "/" : "#";
              url[part] = value2.charAt(0) !== char ? char + value2 : value2;
            } else {
              url[part] = value2;
            }
            break;
          case "username":
          case "password":
            url[part] = encodeURIComponent(value2);
            break;
          case "auth":
            var index = value2.indexOf(":");
            if (~index) {
              url.username = value2.slice(0, index);
              url.username = encodeURIComponent(decodeURIComponent(url.username));
              url.password = value2.slice(index + 1);
              url.password = encodeURIComponent(decodeURIComponent(url.password));
            } else {
              url.username = encodeURIComponent(decodeURIComponent(value2));
            }
        }
        for (var i = 0; i < rules.length; i++) {
          var ins = rules[i];
          if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
        return url;
      }
      function toString(stringify) {
        if (!stringify || "function" !== typeof stringify) stringify = qs.stringify;
        var query, url = this, host = url.host, protocol = url.protocol;
        if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
        var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
        if (url.username) {
          result += url.username;
          if (url.password) result += ":" + url.password;
          result += "@";
        } else if (url.password) {
          result += ":" + url.password;
          result += "@";
        } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
          result += "@";
        }
        if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
          host += ":";
        }
        result += host + url.pathname;
        query = "object" === typeof url.query ? stringify(url.query) : url.query;
        if (query) result += "?" !== query.charAt(0) ? "?" + query : query;
        if (url.hash) result += url.hash;
        return result;
      }
      Url.prototype = { set, toString };
      Url.extractProtocol = extractProtocol;
      Url.location = lolcation;
      Url.trimLeft = trimLeft;
      Url.qs = qs;
      module.exports = Url;
    }
  });

  // ../jsgui3-html/router/routing-tree.js
  var require_routing_tree = __commonJS({
    "../jsgui3-html/router/routing-tree.js"(exports, module) {
      var Routing_Tree_Node = class {
        constructor(spec) {
          spec = spec || {};
          if (spec.handler) this.handler = spec.handler;
          this.mapNormalPathChildren = {};
        }
      };
      var Variable_Routing_Tree_Node = class {
        constructor(spec) {
          this.name = spec.name;
          if (spec.handler) this.handler = spec.handler;
          this.mapNormalPathChildren = {};
        }
      };
      var Wildcard_Routing_Tree_Node = class {
        constructor(spec) {
        }
      };
      var Routing_Tree = class {
        constructor(spec) {
          this.root = new Routing_Tree_Node();
        }
        get arr_paths() {
          const res2 = [];
          const iterate = (node) => {
            if (node.mapNormalPathChildren) {
              console.log("node.name", node.name);
              const children = Object.entries(node.mapNormalPathChildren);
              if (children.length > 0) {
                for (let c2 = 0; c2 < children.length; c2++) {
                  iterate(children[c2]);
                }
              }
            }
          };
          return res2;
        }
        "setRoot404"(handler) {
          this.root404Handler = handler;
        }
        "set"(strRoute, context2, handler) {
          if (!handler) {
            handler = context2;
            context2 = void 0;
          }
          if (strRoute == "/") {
            if (context2) this.root.context = context2;
            this.root.handler = handler;
          } else {
            var splitRoute = strRoute.split("/");
            var currentNode = this.root;
            var c2 = 0;
            while (c2 < splitRoute.length) {
              var strLevel = splitRoute[c2];
              var isVariable = strLevel.substr(0, 1) == ":";
              var isWildcard = strLevel == "*";
              if (isVariable) {
                var variableName = strLevel.substr(1);
                if (!currentNode.variableChild) {
                  currentNode.variableChild = new Variable_Routing_Tree_Node({
                    "name": variableName
                  });
                  if (c2 == splitRoute.length - 1) {
                    currentNode.variableChild.handler = handler;
                    if (context2) currentNode.variableChild.context = context2;
                  }
                  currentNode = currentNode.variableChild;
                } else {
                  currentNode = currentNode.variableChild;
                }
              } else {
                if (isWildcard) {
                  currentNode.wildcardChild = new Wildcard_Routing_Tree_Node();
                  currentNode.wildcardChild.handler = handler;
                  if (context2) currentNode.wildcardChild.context = context2;
                } else {
                  var next_level_node = currentNode.mapNormalPathChildren[strLevel];
                  if (!next_level_node) {
                    currentNode.mapNormalPathChildren[strLevel] = new Routing_Tree_Node();
                    next_level_node = currentNode.mapNormalPathChildren[strLevel];
                  }
                  if (c2 === splitRoute.length - 1) {
                    currentNode.mapNormalPathChildren[strLevel].handler = handler;
                    if (context2) currentNode.mapNormalPathChildren[strLevel].context = context2;
                  }
                  currentNode = next_level_node;
                }
              }
              c2++;
            }
          }
        }
        "get"(url) {
          var params;
          if (url == "/") {
            var root = this.root;
            if (root.context) {
              return [root.context, this.root.handler, {}];
            } else {
              var res2;
              if (this.root.handler) {
                res2 = this.root.handler;
              } else {
                if (this.root.wildcardChild) {
                  if (this.root.wildcardChild.handler) {
                    if (this.root.wildcardChild.context) {
                      return [this.root.wildcardChild.context, this.root.wildcardChild.handler, {}];
                    } else {
                      return this.root.wildcardChild.handler;
                    }
                    throw "stop";
                  }
                }
              }
              return res2;
            }
          } else {
            var posQM = url.indexOf("?");
            if (posQM > -1) {
              url = url.substr(0, posQM);
            }
            var splitUrl = url.split("/");
            var currentNode = this.root;
            var c2 = 0;
            while (c2 < splitUrl.length) {
              var strLevel = splitUrl[c2];
              if (currentNode) {
                var next_level_node = currentNode.mapNormalPathChildren[strLevel];
                if (next_level_node) {
                } else {
                  if (currentNode.variableChild) {
                    next_level_node = currentNode.variableChild;
                    params = params || {};
                    params[currentNode.variableChild.name] = decodeURI(strLevel);
                  } else {
                    if (currentNode.wildcardChild) {
                      var arr_the_rest = splitUrl.slice(c2);
                      var str_wildcard_value = arr_the_rest.join("/");
                      if (url.endsWith("/")) str_wildcard_value += "/";
                      if (currentNode.wildcardChild.context) {
                        return [currentNode.wildcardChild.context, currentNode.wildcardChild.handler, {
                          "wildcard_value": str_wildcard_value
                        }];
                      } else {
                        return [currentNode.wildcardChild.handler, {
                          "wildcard_value": str_wildcard_value
                        }];
                      }
                    }
                  }
                }
              }
              if (c2 === splitUrl.length - 1) {
                if (next_level_node) {
                  if (next_level_node.handler) {
                    if (params) {
                      if (next_level_node.context) {
                        return [next_level_node.context, next_level_node.handler, params];
                      } else {
                        return [next_level_node.handler, params];
                      }
                    } else {
                      if (next_level_node.context) {
                        return [next_level_node.context, next_level_node.handler];
                      } else {
                        return next_level_node.handler;
                      }
                    }
                  } else {
                    if (next_level_node.wildcardChild) {
                      var arr_the_rest = splitUrl.slice(c2);
                      var str_wildcard_value = arr_the_rest.join("/");
                      if (params) {
                        params.wildcard_value = decodeURI(str_wildcard_value);
                        if (next_level_node.wildcardChild.context) {
                          return [next_level_node.wildcardChild.context, next_level_node.wildcardChild.handler, params];
                        } else {
                          return [next_level_node.wildcardChild.handler, params];
                        }
                      } else {
                        if (next_level_node.wildcardChild.context) {
                          return [next_level_node.wildcardChild.context, next_level_node.wildcardChild.handler, params];
                        } else {
                          return [next_level_node.wildcardChild.handler, {
                            "wildcard_value": str_wildcard_value
                          }];
                        }
                      }
                    }
                  }
                } else {
                  if (currentNode) {
                    return [currentNode.handler, params];
                  }
                }
              }
              currentNode = next_level_node;
              c2++;
            }
            return this.root404Handler;
          }
        }
      };
      Routing_Tree.Node = Routing_Tree_Node;
      Routing_Tree.Variable_Node = Variable_Routing_Tree_Node;
      Routing_Tree.Wildcard_Node = Wildcard_Routing_Tree_Node;
      module.exports = Routing_Tree;
    }
  });

  // ../jsgui3-html/router/router.js
  var require_router = __commonJS({
    "../jsgui3-html/router/router.js"(exports, module) {
      var url = require_url_parse();
      var jsgui = require_lang();
      var tof = jsgui.tof;
      var get_item_sig = jsgui.get_item_sig;
      var Routing_Tree = require_routing_tree();
      var default_logger = (level, message, meta) => {
        const log_meta = meta && Object.keys(meta).length ? meta : void 0;
        if (level === "error" && console.error) {
          console.error("[router]", message, log_meta || "");
        } else if (level === "warn" && console.warn) {
          console.warn("[router]", message, log_meta || "");
        } else if (console.log) {
          console.log("[router]", message, log_meta || "");
        }
      };
      var default_not_found_handler = (req, res2) => {
        if (res2) {
          if (typeof res2.statusCode === "number") {
            res2.statusCode = res2.statusCode && res2.statusCode !== 200 ? res2.statusCode : 404;
          }
          if (typeof res2.setHeader === "function" && !res2.headersSent) {
            res2.setHeader("Content-Type", "text/plain; charset=utf-8");
          }
          if (typeof res2.end === "function" && !res2.writableEnded) {
            res2.end("Not Found");
          }
        }
      };
      var Router = class {
        constructor(spec) {
          spec = spec || {};
          if (spec.name) {
            this.name = spec.name;
          } else {
            this.name = "Router";
          }
          this.routing_tree = new Routing_Tree();
          this.logger = spec.logger || default_logger;
          this.handle_not_found_fn = spec.handle_not_found || default_not_found_handler;
          this.handle_error_fn = spec.handle_error;
          this._listeners = /* @__PURE__ */ new Map();
        }
        on(event_name, handler) {
          if (!handler) return this;
          let set_listeners = this._listeners.get(event_name);
          if (!set_listeners) {
            set_listeners = /* @__PURE__ */ new Set();
            this._listeners.set(event_name, set_listeners);
          }
          set_listeners.add(handler);
          return this;
        }
        off(event_name, handler) {
          if (!handler) return this;
          const set_listeners = this._listeners.get(event_name);
          if (set_listeners) {
            set_listeners.delete(handler);
            if (set_listeners.size === 0) {
              this._listeners.delete(event_name);
            }
          }
          return this;
        }
        emit(event_name, ...args) {
          const set_listeners = this._listeners.get(event_name);
          if (!set_listeners || set_listeners.size === 0) return false;
          for (const listener of Array.from(set_listeners)) {
            try {
              listener(...args);
            } catch (err) {
              this._log("error", "router_listener_error", {
                event: event_name,
                error: err
              });
            }
          }
          return true;
        }
        _log(level, message, meta) {
          if (this.logger) {
            try {
              this.logger(level, message, meta || {});
            } catch (err) {
              if (console && console.error) {
                console.error("[router] logger error", err);
              }
            }
          }
        }
        set_logger(fn_logger) {
          this.logger = fn_logger || default_logger;
        }
        set_not_found_handler(fn_handler) {
          this.handle_not_found_fn = fn_handler || default_not_found_handler;
        }
        set_error_handler(fn_handler) {
          this.handle_error_fn = fn_handler;
        }
        "start"(callback2) {
          callback2(null, true);
        }
        "set_route"(str_route, context2, fn_handler) {
          this._log("debug", "set_route", {
            route: str_route
          });
          return this.routing_tree.set(str_route, context2, fn_handler);
        }
        "meets_requirements"() {
          return true;
        }
        _invoke_handler(handler, context2, req, res2, params, result) {
          try {
            if (params && typeof params === "object") {
              req.params = params;
            }
            if (context2) {
              handler.call(context2, req, res2);
            } else {
              handler(req, res2);
            }
            result.handled = true;
            result.params = params;
          } catch (err) {
            result.handled = true;
            result.params = params;
            result.handlerError = err;
            this._log("error", "handler_error", {
              url: req && req.url,
              error: err,
              params
            });
            this.emit("error", err, {
              req,
              res: res2,
              params,
              handler
            });
            if (this.handle_error_fn) {
              try {
                this.handle_error_fn(err, req, res2, params);
              } catch (secondary_err) {
                this._log("error", "error_handler_failure", {
                  url: req && req.url,
                  error: secondary_err
                });
                this.emit("error", secondary_err, {
                  req,
                  res: res2,
                  params,
                  handler: this.handle_error_fn,
                  stage: "error-handler"
                });
              }
            }
          }
        }
        _handle_not_found(req, res2, meta, result) {
          const details = Object.assign({
            url: req && req.url
          }, meta || {});
          this._log("warn", "route_not_found", details);
          this.emit("not-found", {
            req,
            res: res2,
            meta: details
          });
          if (this.handle_not_found_fn) {
            try {
              this.handle_not_found_fn(req, res2);
            } catch (err) {
              result.handlerError = err;
              this._log("error", "not_found_handler_error", {
                url: req && req.url,
                error: err
              });
              this.emit("error", err, {
                req,
                res: res2,
                stage: "not-found"
              });
            }
          }
        }
        get arr_paths() {
          return this.routing_tree.arr_paths;
        }
        "process"(req, res2) {
          const result = {
            handled: false,
            params: void 0,
            handlerError: void 0
          };
          var rt = this.routing_tree;
          let parsed_url;
          try {
            parsed_url = url(req.url, true);
          } catch (err) {
            this._log("error", "url_parse_error", {
              url: req && req.url,
              error: err
            });
            result.handlerError = err;
            this.emit("error", err, {
              req,
              res: res2,
              stage: "url-parse"
            });
            return result;
          }
          if (!parsed_url) {
            return result;
          }
          var route_res = rt.get(req.url);
          var handler;
          var context2;
          var params;
          var route_type = tof(route_res);
          if (route_type === "array") {
            var rr_sig = get_item_sig(route_res, 1);
            if (route_res.length === 3) {
              context2 = route_res[0];
              handler = route_res[1];
              params = route_res[2];
            } else if (rr_sig == "[D,f]") {
              context2 = route_res[0];
              handler = route_res[1];
            } else if (rr_sig == "[f,o]") {
              handler = route_res[0];
              params = route_res[1];
            } else if (rr_sig == "[o,f]") {
              context2 = route_res[0];
              handler = route_res[1];
            } else if (route_res.length === 2 && typeof route_res[0] === "function" && tof(route_res[1]) === "object") {
              handler = route_res[0];
              params = route_res[1];
            }
          } else if (route_type === "function") {
            handler = route_res;
          } else if (route_type === "object" && route_res) {
            if (typeof route_res.handler === "function") {
              handler = route_res.handler;
              context2 = route_res.context;
              if (route_res.params) {
                params = route_res.params;
              }
            }
          }
          if (handler && typeof handler === "function") {
            this._invoke_handler(handler, context2, req, res2, params, result);
            return result;
          }
          this._handle_not_found(req, res2, {
            url: req && req.url
          }, result);
          return result;
        }
      };
      Router.Routing_Tree = Routing_Tree;
      module.exports = Router;
    }
  });

  // ../jsgui3-html/resource/pool.js
  var require_pool = __commonJS({
    "../jsgui3-html/resource/pool.js"(exports, module) {
      var jsgui = require_lang();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var arrayify = jsgui.arrayify;
      var tof = jsgui.tof;
      var get_a_sig = jsgui.get_a_sig;
      var filter_map_by_regex = jsgui.filter_map_by_regex;
      var Evented_Class = jsgui.Evented_Class;
      var Data_Object = jsgui.Data_Object;
      var fp = jsgui.fp;
      var is_defined = jsgui.is_defined;
      var Collection = jsgui.Collection;
      var Resource_Pool = class extends Evented_Class {
        constructor(spec) {
          super(spec);
          this.resources = new Collection({
            //'index_by': 'name'
            "fn_index": (item2) => {
              var key2 = item2.name;
              return key2;
            }
          });
        }
        "add"(obj2) {
          var obj_name = obj2.name;
          let log_trace = () => {
            console.log("");
            console.log("** obj_name " + obj_name);
            console.trace();
            console.log("");
          };
          if (obj_name === void 0) {
            console.log("Resource_Pool.add error: obj_name is undefined for object:", obj2);
            try {
              console.trace();
            } catch (e) {
            }
            throw "Resource_Pool.add(undefined) error";
          }
          if (this.has_resource(obj_name)) {
            throw "Resource pool already has resource with name " + obj_name;
          } else {
            this.resources.add(obj2);
            obj2.pool = this;
            if (obj2.name !== void 0) {
              Object.defineProperty(this, obj2.name, {
                get() {
                  return obj2;
                }
              });
            }
            this.raise_event("added", obj2);
          }
        }
        "push"(obj2) {
          return this.add(obj2);
        }
        "has_resource"() {
          const a = arguments;
          const sig = get_a_sig(a, 1);
          if (sig == "[s]") {
            const obj_lookup_val = a[0];
            return this.resources.has(obj_lookup_val);
          }
        }
        get resource_names() {
          var res2 = [];
          each(this.resources, (resource) => {
            res2.push(resource.name);
          });
          return res2;
        }
        "get_resource"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig === "[s]") {
            var obj_lookup_val = a[0];
            var find_result = this.resources.find(obj_lookup_val);
            if (find_result) {
              var res2 = find_result;
            }
            return res2;
          }
        }
        "count"() {
          return this.resources.length;
        }
        // May be useful to have a callback parameter here rather than just publish / subscribe.
        "start"(callback2) {
          var arr_resources_meeting_requirements = [];
          this.resources.each(function(v, i) {
            var mr = v.meets_requirements();
            if (mr) {
              arr_resources_meeting_requirements.push(v);
            }
          });
          var l_resources = this.resources.length();
          if (arr_resources_meeting_requirements.length === l_resources) {
            var fns = [];
            var num_to_start = arr_resources_meeting_requirements.length;
            var num_starting = 0, num_started = 0;
            var cb = function(err, start_res) {
              num_starting--;
              num_started++;
              if (num_started == num_to_start) {
                if (callback2) callback2(null, true);
              }
            };
            each(arr_resources_meeting_requirements, (resource_ready_to_start) => {
              resource_ready_to_start.start(cb);
              num_starting++;
            });
          }
        }
      };
      module.exports = Resource_Pool;
    }
  });

  // ../jsgui3-html/resource/resource.js
  var require_resource = __commonJS({
    "../jsgui3-html/resource/resource.js"(exports, module) {
      var jsgui = require_lang();
      var Pool = require_pool();
      var Evented_Class = jsgui.Evented_Class;
      var Class = jsgui.Class;
      var Collection = jsgui.Collection;
      var is_defined = jsgui.is_defined;
      var fp = jsgui.fp;
      var stringify = jsgui.stringify;
      var tof = jsgui.tof;
      var call_multi = jsgui.call_multi;
      var get_a_sig = jsgui.get_a_sig;
      var each = jsgui.each;
      var Resource = class extends Evented_Class {
        // The link between the abstract resource and the resource on the internet / network / computer.
        //'fields': {
        //	//'meta': Data_Object
        //	'meta': 'data_object'
        //},
        // Problem with how it sets the fields.
        constructor(spec) {
          if (!is_defined(spec)) spec = {};
          super(spec);
          if (spec.name) this.name = spec.name;
          if (spec.pool) this.pool = spec.pool;
          if (is_defined(spec.startup_type)) {
            this.startup_type = spec.startup_type;
          }
          this.getters = {};
          this.setters = {};
        }
        "start"(callback2) {
          callback2(null, true);
        }
        // meets_requirements
        //  check if all the prerequisite resources are active
        //  maybe check for login status if applicable.
        "meets_requirements"() {
          return true;
        }
        // 'get' will be the function to use.
        // may have toJson / to_json.
        "get_abstract"() {
        }
        "authenticate"(token) {
          return true;
        }
        // Resources could also operate in connected mode.
        //  How the connection gets handled will be outside of the scope of the resource itself.
        // the last item in the signature is the callback
        /*
        
            'set'(name, value, callback) {
                var al = arguments.length;
        
                // self setter?
        
                if (al === 3) {
                    if (this.setters[name]) {
                        this.setters[name](value, callback);
                    }
                }
            }
        
            'get'(name, callback) {
                var al = arguments.length;
                if (al === 2) {
                    if (this.getters[name]) {
                        this.getters[name](callback);
                    }
                }
            }
        
            */
      };
      Resource.Pool = Pool;
      module.exports = Resource;
    }
  });

  // ../jsgui3-html/resource/data-kv-resource.js
  var require_data_kv_resource = __commonJS({
    "../jsgui3-html/resource/data-kv-resource.js"(exports, module) {
      var jsgui = require_lang();
      var Pool = require_pool();
      var Evented_Class = jsgui.Evented_Class;
      var Class = jsgui.Class;
      var Collection = jsgui.Collection;
      var is_defined = jsgui.is_defined;
      var fp = jsgui.fp;
      var stringify = jsgui.stringify;
      var tof = jsgui.tof;
      var call_multi = jsgui.call_multi;
      var get_a_sig = jsgui.get_a_sig;
      var each = jsgui.each;
      var Resource = require_resource();
      var Data_KV_Resource = class extends Resource {
        // The link between the abstract resource and the resource on the internet / network / computer.
        //'fields': {
        //	//'meta': Data_Object
        //	'meta': 'data_object'
        //},
        // Problem with how it sets the fields.
        constructor(spec) {
          if (!is_defined(spec)) spec = {};
          super(spec);
          if (is_defined(spec.name)) {
          }
          if (spec.name) this.name = spec.name;
          if (spec.pool) this.pool = spec.pool;
          if (is_defined(spec.startup_type)) {
            this.startup_type = spec.startup_type;
          }
          this.getters = {};
          this.setters = {};
        }
        "start"(callback2) {
          callback2(null, true);
        }
        // meets_requirements
        //  check if all the prerequisite resources are active
        //  maybe check for login status if applicable.
        "meets_requirements"() {
          return true;
        }
        // 'get' will be the function to use.
        // may have toJson / to_json.
        "get_abstract"() {
        }
        "authenticate"(token) {
          return true;
        }
        // Resources could also operate in connected mode.
        //  How the connection gets handled will be outside of the scope of the resource itself.
        // the last item in the signature is the callback
        "set"(name, value2, callback2) {
          var al = arguments.length;
          if (al === 3) {
            if (this.setters[name]) {
              this.setters[name](value2, callback2);
            }
          }
        }
        "get"(name, callback2) {
          var al = arguments.length;
          if (al === 2) {
            if (this.getters[name]) {
              this.getters[name](callback2);
            }
          }
        }
      };
      Resource.Pool = Pool;
      module.exports = Data_KV_Resource;
    }
  });

  // ../jsgui3-html/resource/data-transform-resource.js
  var require_data_transform_resource = __commonJS({
    "../jsgui3-html/resource/data-transform-resource.js"(exports, module) {
      var jsgui = require_lang();
      var Pool = require_pool();
      var Evented_Class = jsgui.Evented_Class;
      var Class = jsgui.Class;
      var Collection = jsgui.Collection;
      var is_defined = jsgui.is_defined;
      var fp = jsgui.fp;
      var stringify = jsgui.stringify;
      var tof = jsgui.tof;
      var call_multi = jsgui.call_multi;
      var get_a_sig = jsgui.get_a_sig;
      var each = jsgui.each;
      var Resource = require_resource();
      var Data_Transform_Resource = class extends Resource {
        // The link between the abstract resource and the resource on the internet / network / computer.
        //'fields': {
        //	//'meta': Data_Object
        //	'meta': 'data_object'
        //},
        // Problem with how it sets the fields.
        // JSON input data description info object
        // JSON output data description info object
        // JSON transformation data description info object.
        // .info
        // .meta.info
        // Will be POJOs.???
        // .i.i .i.o .i.t
        //  input schema, output schema, transformation function
        //  make it possible to express the algo here / in the constructor.
        //  also should be able to work remotely when the resource is remote.
        // .m.i.i
        constructor(spec) {
          if (!is_defined(spec)) spec = {};
          super(spec);
          if (is_defined(spec.name)) {
          }
          if (spec.name) this.name = spec.name;
          if (spec.pool) this.pool = spec.pool;
          const meta = {
            info: {},
            fn: {}
          };
          Object.defineProperty(this, "meta", {
            get() {
              return meta;
            }
          });
          Object.defineProperty(this, "m", {
            get() {
              return meta;
            }
          });
          Object.defineProperty(meta, "i", {
            get() {
              return meta.info;
            }
          });
          Object.defineProperty(meta, "fns", {
            get() {
              return meta.fn;
            }
          });
          Object.defineProperty(meta, "fn", {
            get() {
              return meta.fn;
            }
          });
          Object.defineProperty(meta, "f", {
            get() {
              return meta.fn;
            }
          });
          if (spec.fn_transform) {
            if (tof(spec.transform) === "function") {
              meta.fn.transform = spec.fn_transform;
            } else {
            }
          }
          if (is_defined(spec.startup_type)) {
            this.startup_type = spec.startup_type;
          }
        }
        "start"(callback2) {
          callback2(null, true);
        }
        // meets_requirements
        //  check if all the prerequisite resources are active
        //  maybe check for login status if applicable.
        "meets_requirements"() {
          return true;
        }
        // 'get' will be the function to use.
        // may have toJson / to_json.
        "get_abstract"() {
        }
        "authenticate"(token) {
          return true;
        }
        // Resources could also operate in connected mode.
        //  How the connection gets handled will be outside of the scope of the resource itself.
        // the last item in the signature is the callback
        "transform"(value2, options) {
          throw "Need specific implementation";
        }
      };
      Resource.Pool = Pool;
      module.exports = Data_Transform_Resource;
    }
  });

  // ../jsgui3-html/resource/compilation-resource.js
  var require_compilation_resource = __commonJS({
    "../jsgui3-html/resource/compilation-resource.js"(exports, module) {
      var Data_Transform_Resource = require_data_transform_resource();
      var Compilation_Resource = class extends Data_Transform_Resource {
        constructor(spec) {
          super(spec);
        }
        // Which languages?
        //  String names
        //  Or objects describing the languages / formats....
        // With templating, will need to provide it with various values as well....
        //  A single values object should be OK.
        //   Or a promise / observable that will return them.
        // Could be either remote or local....
        // Call through web API, other means, or directly calling a function in the JS codebase.
      };
      module.exports = Compilation_Resource;
    }
  });

  // ../jsgui3-html/resource/compiler-resource.js
  var require_compiler_resource = __commonJS({
    "../jsgui3-html/resource/compiler-resource.js"(exports, module) {
      var Data_Transform_Resource = require_data_transform_resource();
      var Compiler_Resource = class extends Data_Transform_Resource {
        constructor(spec) {
          super(spec);
        }
        // Which languages?
        //  String names
        //  Or objects describing the languages / formats....
        // With templating, will need to provide it with various values as well....
        //  A single values object should be OK.
        //   Or a promise / observable that will return them.
        // Could be either remote or local....
        // Call through web API, other means, or directly calling a function in the JS codebase.
      };
      module.exports = Compiler_Resource;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/Active_HTML_Document.js
  var require_Active_HTML_Document = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/Active_HTML_Document.js"(exports, module) {
      var jsgui = require_html_core();
      var { Blank_HTML_Document } = jsgui;
      var Active_HTML_Document = class extends Blank_HTML_Document {
        constructor(spec = {}) {
          super(spec);
          this.active();
        }
        // Seems a bit like 'view features'.
        "include_js"(url) {
          const body = this.get("body");
          var script = new jsgui.script({
            //<script type="text/JavaScript" src="abc.js"><\/script>
            "context": this.context
          });
          var dom = script.dom;
          var domAttributes = dom.attributes;
          domAttributes.type = "text/javascript";
          domAttributes.src = url;
          body.add(script);
        }
        "include_css"(url) {
          var head = this.get("head");
          var link = new jsgui.link({
            //<script type="text/JavaScript" src="abc.js"><\/script>
            "context": this.context
          });
          var dom = link.dom;
          var domAttributes = dom.attributes;
          domAttributes["rel"] = "stylesheet";
          domAttributes["type"] = "text/css";
          domAttributes["href"] = url;
          head.content.add(link);
        }
        "include_jsgui_client"(js_file_require_data_main) {
          js_file_require_data_main = js_file_require_data_main || "/js/web/jsgui-html-client";
          var head = this.head;
          var body = this.body;
          var script = new jsgui.script({
            //<script type="text/JavaScript" src="abc.js"><\/script>
            "context": this.context
          });
          var domAttributes = script.dom.attributes;
          domAttributes.set({
            "type": "text/javascript",
            "src": "/js/web/require.js",
            "data-main": js_file_require_data_main
          });
          body.add(script);
        }
        "include_client_css"() {
          var head = this.get("head");
          var link = new jsgui.link({
            //<script type="text/JavaScript" src="abc.js"><\/script>
            "context": this.context
          });
          var domAttributes = link.dom.attributes;
          domAttributes.rel = "stylesheet";
          domAttributes.type = "text/css";
          domAttributes.href = "/css/basic.css";
          head.content.add(link);
        }
        // also need to include jsgui client css
      };
      module.exports = Active_HTML_Document;
    }
  });

  // ../jsgui3-html/themes/variants.js
  var require_variants = __commonJS({
    "../jsgui3-html/themes/variants.js"(exports, module) {
      var window_variants = {
        /**
         * Default variant - matches current Window behavior exactly.
         * Right-aligned buttons in minimize/maximize/close order.
         */
        "default": {
          button_position: "right",
          button_order: ["minimize", "maximize", "close"],
          button_style: "icons",
          show_minimize: true,
          show_maximize: true,
          show_close: true,
          show_buttons: true,
          title_alignment: "left",
          draggable: true,
          resizable: true
        },
        /**
         * macOS-style variant.
         * Left-aligned traffic light buttons in close/minimize/maximize order.
         */
        "macos": {
          button_position: "left",
          button_order: ["close", "minimize", "maximize"],
          button_style: "traffic-light",
          show_minimize: true,
          show_maximize: true,
          show_close: true,
          show_buttons: true,
          title_alignment: "center",
          draggable: true,
          resizable: true
        },
        /**
         * Windows 11 style variant.
         * Right-aligned Segoe icon buttons.
         */
        "windows-11": {
          button_position: "right",
          button_order: ["minimize", "maximize", "close"],
          button_style: "segoe",
          show_minimize: true,
          show_maximize: true,
          show_close: true,
          show_buttons: true,
          title_alignment: "left",
          draggable: true,
          resizable: true
        },
        /**
         * Minimal variant - close button only.
         */
        "minimal": {
          button_position: "right",
          button_order: ["close"],
          button_style: "icons",
          show_minimize: false,
          show_maximize: false,
          show_close: true,
          show_buttons: true,
          title_alignment: "left",
          draggable: true,
          resizable: false
        }
      };
      var button_variants = {
        "default": {
          size: "medium",
          variant: "secondary",
          icon_position: "left",
          full_width: false
        },
        "primary": {
          size: "medium",
          variant: "primary",
          icon_position: "left",
          full_width: false
        },
        "secondary": {
          size: "medium",
          variant: "secondary",
          icon_position: "left",
          full_width: false
        },
        "ghost": {
          size: "medium",
          variant: "ghost",
          icon_position: "left",
          full_width: false
        },
        "danger": {
          size: "medium",
          variant: "danger",
          icon_position: "left",
          full_width: false
        },
        "success": {
          size: "medium",
          variant: "success",
          icon_position: "left",
          full_width: false
        },
        "outline": {
          size: "medium",
          variant: "outline",
          icon_position: "left",
          full_width: false
        },
        "link": {
          size: "medium",
          variant: "link",
          icon_position: "left",
          full_width: false
        },
        "icon": {
          size: "medium",
          variant: "ghost",
          icon_position: "only",
          shape: "circle"
        },
        "fab": {
          size: "large",
          variant: "primary",
          icon_position: "only",
          shape: "circle",
          shadow: "large"
        }
      };
      var panel_variants = {
        "default": {
          padding: "medium",
          border: false,
          shadow: "none",
          radius: "none",
          header: true,
          collapsible: false
        },
        "card": {
          padding: "medium",
          border: true,
          shadow: "small",
          radius: "medium",
          header: true,
          collapsible: false
        },
        "elevated": {
          padding: "large",
          border: false,
          shadow: "large",
          radius: "large",
          header: true,
          collapsible: false
        },
        "flush": {
          padding: "none",
          border: false,
          shadow: "none",
          radius: "none",
          header: false,
          collapsible: false
        },
        "well": {
          padding: "medium",
          border: true,
          shadow: "inset",
          radius: "small",
          header: false,
          collapsible: false
        },
        "glass": {
          padding: "medium",
          border: true,
          shadow: "medium",
          radius: "large",
          header: true,
          collapsible: false
        },
        "outline": {
          padding: "medium",
          border: true,
          shadow: "none",
          radius: "medium",
          header: true,
          collapsible: false
        },
        "hero": {
          padding: "xlarge",
          border: false,
          shadow: "none",
          radius: "none",
          header: false,
          collapsible: false
        },
        "collapsible": {
          padding: "medium",
          border: true,
          shadow: "small",
          radius: "medium",
          header: true,
          collapsible: true
        }
      };
      var input_variants = {
        /**
         * Default input - standard text field with outline.
         */
        "default": {
          size: "medium",
          label_position: "top",
          fill_style: "outline",
          validation_style: "inline",
          clear_button: false,
          show_count: false,
          radius: "medium"
        },
        /**
         * Compact - smaller, label on left.
         */
        "compact": {
          size: "small",
          label_position: "left",
          fill_style: "outline",
          validation_style: "tooltip",
          radius: "small"
        },
        /**
         * Floating - animated floating label.
         */
        "floating": {
          size: "medium",
          label_position: "floating",
          fill_style: "outline",
          validation_style: "inline",
          radius: "medium"
        },
        /**
         * Filled - solid background.
         */
        "filled": {
          size: "medium",
          label_position: "top",
          fill_style: "filled",
          validation_style: "inline",
          radius: "medium"
        },
        /**
         * Underline - only bottom border.
         */
        "underline": {
          size: "medium",
          label_position: "floating",
          fill_style: "underline",
          validation_style: "inline",
          radius: "none"
        },
        /**
         * Search - with search styling and clear button.
         */
        "search": {
          size: "medium",
          label_position: "hidden",
          fill_style: "outline",
          shape: "pill",
          clear_button: true,
          radius: "full"
        },
        /**
         * Inline - minimal, blends with text.
         */
        "inline": {
          size: "small",
          label_position: "hidden",
          fill_style: "transparent",
          border_on_focus: true,
          radius: "none"
        }
      };
      var tabbed_panel_variants = {
        /**
         * Default tabs - top position, underline indicator.
         */
        "default": {
          tab_position: "top",
          indicator: "underline",
          spacing: "medium",
          size: "medium",
          fill_style: "none",
          radius: "none"
        },
        /**
         * Pill tabs - rounded background indicator.
         */
        "pills": {
          tab_position: "top",
          indicator: "background",
          spacing: "small",
          size: "medium",
          fill_style: "filled",
          radius: "full"
        },
        /**
         * Card tabs - tab appears connected to panel.
         */
        "card": {
          tab_position: "top",
          indicator: "card",
          spacing: "none",
          size: "medium",
          fill_style: "filled",
          radius: "top"
        },
        /**
         * Vertical tabs on left side.
         */
        "vertical": {
          tab_position: "left",
          indicator: "left-border",
          spacing: "small",
          size: "medium",
          fill_style: "none",
          radius: "none"
        },
        /**
         * Vertical tabs on right side.
         */
        "vertical-right": {
          tab_position: "right",
          indicator: "right-border",
          spacing: "small",
          size: "medium",
          fill_style: "none",
          radius: "none"
        },
        /**
         * Bottom tabs.
         */
        "bottom": {
          tab_position: "bottom",
          indicator: "underline",
          spacing: "medium",
          size: "medium",
          fill_style: "none",
          radius: "none"
        },
        /**
         * Icon tabs - tabs with icons only.
         */
        "icon": {
          tab_position: "top",
          indicator: "background",
          spacing: "small",
          size: "large",
          fill_style: "none",
          radius: "medium",
          icon_only: true
        },
        /**
         * Compact tabs - minimal space usage.
         */
        "compact": {
          tab_position: "top",
          indicator: "underline",
          spacing: "small",
          size: "small",
          fill_style: "none",
          radius: "none"
        }
      };
      var menu_variants = {
        /**
         * Default horizontal menu bar.
         */
        "default": {
          direction: "horizontal",
          spacing: "medium",
          indicator: "none",
          size: "medium",
          separator: false
        },
        /**
         * Vertical menu (sidebar style).
         */
        "vertical": {
          direction: "vertical",
          spacing: "small",
          indicator: "left-border",
          size: "medium",
          separator: false
        },
        /**
         * Compact menu with smaller items.
         */
        "compact": {
          direction: "horizontal",
          spacing: "small",
          indicator: "none",
          size: "small",
          separator: false
        },
        /**
         * Menu with separators between items.
         */
        "divided": {
          direction: "horizontal",
          spacing: "none",
          indicator: "none",
          size: "medium",
          separator: true
        },
        /**
         * Pill-style menu.
         */
        "pills": {
          direction: "horizontal",
          spacing: "small",
          indicator: "background",
          size: "medium",
          separator: false,
          radius: "full"
        },
        /**
         * Icon menu (icons only).
         */
        "icon": {
          direction: "horizontal",
          spacing: "small",
          indicator: "none",
          size: "large",
          separator: false,
          icon_only: true
        }
      };
      var dropdown_menu_variants = {
        /**
         * Default dropdown - standard appearance.
         */
        "default": {
          size: "medium",
          fill_style: "outline",
          radius: "medium",
          icon: "chevron"
        },
        /**
         * Compact dropdown - smaller size.
         */
        "compact": {
          size: "small",
          fill_style: "outline",
          radius: "small",
          icon: "chevron"
        },
        /**
         * Filled dropdown - solid background.
         */
        "filled": {
          size: "medium",
          fill_style: "filled",
          radius: "medium",
          icon: "chevron"
        },
        /**
         * Ghost dropdown - minimal styling.
         */
        "ghost": {
          size: "medium",
          fill_style: "transparent",
          radius: "none",
          icon: "chevron"
        },
        /**
         * Native-like dropdown.
         */
        "native": {
          size: "medium",
          fill_style: "outline",
          radius: "small",
          icon: "triangle"
        }
      };
      var context_menu_variants = {
        /**
         * Default context menu.
         */
        "default": {
          size: "medium",
          shadow: "medium",
          radius: "small"
        },
        /**
         * Compact context menu - smaller items.
         */
        "compact": {
          size: "small",
          shadow: "small",
          radius: "small"
        },
        /**
         * Dark context menu.
         */
        "dark": {
          size: "medium",
          shadow: "large",
          radius: "small",
          theme: "dark"
        }
      };
      var list_variants = {
        /**
         * Default list.
         */
        "default": {
          size: "medium",
          spacing: "medium",
          dividers: false
        },
        /**
         * Compact list - smaller items and spacing.
         */
        "compact": {
          size: "small",
          spacing: "small",
          dividers: false
        },
        /**
         * List with dividers between items.
         */
        "divided": {
          size: "medium",
          spacing: "none",
          dividers: true
        },
        /**
         * Large list items.
         */
        "large": {
          size: "large",
          spacing: "medium",
          dividers: false
        },
        /**
         * Card-style list items.
         */
        "cards": {
          size: "medium",
          spacing: "small",
          dividers: false,
          item_style: "card"
        }
      };
      var chart_variants = {
        /**
         * Default chart - categorical colors with grid.
         */
        "default": {
          size: "medium",
          palette: "categorical",
          grid: true,
          legend: "bottom",
          animation: true
        },
        /**
         * Minimal chart - clean, no grid.
         */
        "minimal": {
          size: "medium",
          palette: "monochrome",
          grid: false,
          legend: "none",
          animation: false
        },
        /**
         * Colorful chart - vibrant colors.
         */
        "colorful": {
          size: "medium",
          palette: "vibrant",
          grid: true,
          legend: "right",
          animation: true
        },
        /**
         * Dark chart - for dark themes.
         */
        "dark": {
          size: "medium",
          palette: "dark",
          grid: true,
          legend: "bottom",
          animation: true
        },
        /**
         * Compact chart - smaller size.
         */
        "compact": {
          size: "small",
          palette: "categorical",
          grid: false,
          legend: "none",
          animation: false
        },
        /**
         * Large chart - presentation size.
         */
        "presentation": {
          size: "large",
          palette: "categorical",
          grid: true,
          legend: "bottom",
          animation: true
        }
      };
      var variants = {
        window: window_variants,
        button: button_variants,
        panel: panel_variants,
        input: input_variants,
        text_input: input_variants,
        tabbed_panel: tabbed_panel_variants,
        menu: menu_variants,
        horizontal_menu: menu_variants,
        dropdown_menu: dropdown_menu_variants,
        context_menu: context_menu_variants,
        list: list_variants,
        chart: chart_variants,
        bar_chart: chart_variants,
        line_chart: chart_variants,
        pie_chart: chart_variants,
        area_chart: chart_variants,
        scatter_chart: chart_variants
      };
      var get_variant_params = (control_type, variant_name) => {
        const type_key = String(control_type).toLowerCase().replace(/-/g, "_");
        const registry = variants[type_key];
        if (!registry) return {};
        const name = variant_name || "default";
        return registry[name] || registry["default"] || {};
      };
      var register_variant = (control_type, variant_name, params) => {
        const type_key = String(control_type).toLowerCase().replace(/-/g, "_");
        if (!variants[type_key]) {
          variants[type_key] = {};
        }
        variants[type_key][variant_name] = { ...params };
      };
      var get_variant_names = (control_type) => {
        const type_key = String(control_type).toLowerCase().replace(/-/g, "_");
        const registry = variants[type_key];
        return registry ? Object.keys(registry) : [];
      };
      module.exports = {
        variants,
        get_variant_params,
        register_variant,
        get_variant_names,
        // Export individual registries for direct access
        window_variants,
        button_variants,
        panel_variants,
        input_variants,
        tabbed_panel_variants,
        menu_variants
      };
    }
  });

  // ../jsgui3-html/control_mixins/theme_params.js
  var require_theme_params = __commonJS({
    "../jsgui3-html/control_mixins/theme_params.js"(exports, module) {
      var { get_variant_params } = require_variants();
      var default_warning_handler = (message) => {
        if (typeof process !== "undefined" && process.env && true) {
          console.warn("[theme_params]", message);
        }
      };
      var validate_param = (name, value2, allowed, fallback, warn = default_warning_handler) => {
        if (value2 === void 0 || value2 === null) return fallback;
        if (allowed && Array.isArray(allowed) && !allowed.includes(value2)) {
          warn(`Param "${name}" has invalid value "${value2}". Expected one of: ${allowed.join(", ")}. Using "${fallback}".`);
          return fallback;
        }
        return value2;
      };
      var param_schemas = {
        window: {
          button_position: ["left", "right"],
          button_style: ["traffic-light", "icons", "text", "outlined", "minimal", "segoe"],
          title_alignment: ["left", "center", "right"]
        },
        button: {
          size: ["small", "medium", "large", "xlarge"],
          variant: ["primary", "secondary", "ghost", "danger", "success", "outline", "link"]
        },
        panel: {
          padding: ["none", "small", "medium", "large", "xlarge"],
          shadow: ["none", "small", "medium", "large", "inset"],
          radius: ["none", "small", "medium", "large", "full"]
        },
        input: {
          size: ["small", "medium", "large"],
          label_position: ["top", "left", "right", "floating", "hidden"],
          fill_style: ["outline", "filled", "underline", "transparent"],
          validation_style: ["inline", "tooltip", "popover", "none"],
          radius: ["none", "small", "medium", "large", "full"]
        },
        text_input: {
          size: ["small", "medium", "large"],
          label_position: ["top", "left", "right", "floating", "hidden"],
          fill_style: ["outline", "filled", "underline", "transparent"],
          validation_style: ["inline", "tooltip", "popover", "none"],
          radius: ["none", "small", "medium", "large", "full"]
        },
        tabbed_panel: {
          tab_position: ["top", "bottom", "left", "right"],
          indicator: ["underline", "background", "card", "left-border", "right-border", "none"],
          spacing: ["none", "small", "medium", "large"],
          size: ["small", "medium", "large"],
          fill_style: ["none", "filled"],
          radius: ["none", "small", "medium", "large", "full", "top"]
        },
        menu: {
          direction: ["horizontal", "vertical"],
          spacing: ["none", "small", "medium", "large"],
          indicator: ["none", "underline", "background", "left-border", "right-border"],
          size: ["small", "medium", "large"],
          radius: ["none", "small", "medium", "large", "full"]
        },
        horizontal_menu: {
          direction: ["horizontal", "vertical"],
          spacing: ["none", "small", "medium", "large"],
          indicator: ["none", "underline", "background", "left-border", "right-border"],
          size: ["small", "medium", "large"],
          radius: ["none", "small", "medium", "large", "full"]
        },
        dropdown_menu: {
          size: ["small", "medium", "large"],
          fill_style: ["outline", "filled", "transparent"],
          radius: ["none", "small", "medium", "large", "full"],
          icon: ["chevron", "triangle", "none"]
        },
        context_menu: {
          size: ["small", "medium", "large"],
          shadow: ["none", "small", "medium", "large"],
          radius: ["none", "small", "medium", "large"]
        },
        list: {
          size: ["small", "medium", "large"],
          spacing: ["none", "small", "medium", "large"],
          dividers: [true, false]
        },
        chart: {
          size: ["small", "medium", "large"],
          palette: ["categorical", "monochrome", "vibrant", "dark"],
          grid: [true, false],
          legend: ["none", "top", "bottom", "left", "right"],
          animation: [true, false]
        }
      };
      var derive_hooks = (control_type, params) => {
        const attrs = {};
        const classes = [];
        const type_key = String(control_type).toLowerCase();
        if (type_key === "window") {
          if (params.button_style) {
            attrs["data-button-style"] = params.button_style;
          }
          if (params.title_alignment && params.title_alignment !== "left") {
            attrs["data-title-align"] = params.title_alignment;
          }
          if (params.button_position) {
            attrs["data-button-position"] = params.button_position;
          }
        }
        if (type_key === "button") {
          if (params.variant) {
            classes.push(`btn-${params.variant}`);
          }
          if (params.size && params.size !== "medium") {
            classes.push(`btn-${params.size}`);
          }
        }
        if (type_key === "panel") {
          if (params.padding && params.padding !== "medium") {
            classes.push(`padding-${params.padding}`);
          }
          if (params.border) {
            classes.push("bordered");
          }
        }
        if (type_key === "input" || type_key === "text_input") {
          if (params.fill_style) {
            attrs["data-fill-style"] = params.fill_style;
          }
          if (params.label_position) {
            attrs["data-label-position"] = params.label_position;
          }
          if (params.size && params.size !== "medium") {
            classes.push(`input-${params.size}`);
          }
          if (params.shape === "pill") {
            classes.push("input-pill");
          }
          if (params.clear_button) {
            classes.push("has-clear-button");
          }
        }
        if (type_key === "tabbed_panel") {
          if (params.tab_position) {
            attrs["data-tab-position"] = params.tab_position;
          }
          if (params.indicator) {
            attrs["data-indicator"] = params.indicator;
          }
          if (params.size && params.size !== "medium") {
            classes.push(`tabs-${params.size}`);
          }
          if (params.fill_style === "filled") {
            classes.push("tabs-filled");
          }
        }
        if (type_key === "menu" || type_key === "horizontal_menu") {
          if (params.direction) {
            attrs["data-direction"] = params.direction;
          }
          if (params.indicator && params.indicator !== "none") {
            attrs["data-indicator"] = params.indicator;
          }
          if (params.size && params.size !== "medium") {
            classes.push(`menu-${params.size}`);
          }
          if (params.separator) {
            classes.push("menu-divided");
          }
          if (params.icon_only) {
            classes.push("menu-icon-only");
          }
        }
        if (type_key === "dropdown_menu") {
          if (params.fill_style) {
            attrs["data-fill-style"] = params.fill_style;
          }
          if (params.icon && params.icon !== "chevron") {
            attrs["data-icon"] = params.icon;
          }
          if (params.size && params.size !== "medium") {
            classes.push(`dropdown-${params.size}`);
          }
        }
        if (type_key === "context_menu") {
          if (params.size && params.size !== "medium") {
            classes.push(`context-menu-${params.size}`);
          }
          if (params.theme === "dark") {
            classes.push("dark-theme");
          }
        }
        if (type_key === "list") {
          if (params.size && params.size !== "medium") {
            classes.push(`list-${params.size}`);
          }
          if (params.dividers) {
            classes.push("list-divided");
          }
          if (params.item_style === "card") {
            classes.push("list-cards");
          }
        }
        return { attrs, classes };
      };
      var resolve_params = (control_type, spec = {}, context2 = {}, options = {}) => {
        var _a, _b, _c, _d;
        const warn = options.warn || default_warning_handler;
        const type_key = String(control_type).toLowerCase();
        const variant_name = spec.variant || ((_a = context2 == null ? void 0 : context2.theme) == null ? void 0 : _a.extends) || "default";
        const variant_params = get_variant_params(type_key, variant_name);
        const theme_params = ((_c = (_b = context2 == null ? void 0 : context2.theme) == null ? void 0 : _b.params) == null ? void 0 : _c[type_key]) || {};
        const spec_params = spec.params || {};
        const merged = { ...variant_params, ...theme_params, ...spec_params };
        const schema = param_schemas[type_key];
        if (schema) {
          for (const [key2, allowed] of Object.entries(schema)) {
            if (merged[key2] !== void 0) {
              const fallback = (_d = variant_params[key2]) != null ? _d : merged[key2];
              merged[key2] = validate_param(key2, merged[key2], allowed, fallback, warn);
            }
          }
        }
        const hooks = derive_hooks(type_key, merged);
        return { params: merged, hooks };
      };
      var apply_hooks = (ctrl, hooks) => {
        if (!ctrl || !hooks) return;
        if (hooks.attrs) {
          ctrl.dom = ctrl.dom || {};
          ctrl.dom.attributes = ctrl.dom.attributes || {};
          for (const [key2, value2] of Object.entries(hooks.attrs)) {
            ctrl.dom.attributes[key2] = value2;
          }
        }
        if (hooks.classes && hooks.classes.length > 0) {
          for (const cls of hooks.classes) {
            if (ctrl.add_class) {
              ctrl.add_class(cls);
            }
          }
        }
      };
      var resolve_and_apply = (ctrl, control_type, spec, options = {}) => {
        const context2 = (ctrl == null ? void 0 : ctrl.context) || (spec == null ? void 0 : spec.context) || {};
        const { params, hooks } = resolve_params(control_type, spec, context2, options);
        apply_hooks(ctrl, hooks);
        return params;
      };
      module.exports = {
        resolve_params,
        apply_hooks,
        resolve_and_apply,
        validate_param,
        derive_hooks,
        param_schemas,
        default_warning_handler
      };
    }
  });

  // ../jsgui3-html/control_mixins/themeable.js
  var require_themeable = __commonJS({
    "../jsgui3-html/control_mixins/themeable.js"(exports, module) {
      var { resolve_params, apply_hooks } = require_theme_params();
      var themeable = (ctrl, control_type, spec, options = {}) => {
        ctrl.__type_name = ctrl.__type_name || control_type;
        const { params, hooks } = resolve_params(control_type, spec, ctrl.context, options);
        const merged = options.defaults ? { ...options.defaults, ...params } : params;
        ctrl._theme_params = merged;
        apply_hooks(ctrl, hooks);
        if (spec && spec.variant) {
          ctrl.dom = ctrl.dom || {};
          ctrl.dom.attributes = ctrl.dom.attributes || {};
          ctrl.dom.attributes["data-variant"] = spec.variant;
        }
        return merged;
      };
      var get_theme_params = (control_type, spec, context2, options = {}) => {
        const { params } = resolve_params(control_type, spec, context2, options);
        return params;
      };
      var is_themed = (ctrl) => {
        return ctrl && typeof ctrl._theme_params === "object";
      };
      var get_param = (ctrl, param_name, fallback) => {
        if (!ctrl || !ctrl._theme_params) return fallback;
        const value2 = ctrl._theme_params[param_name];
        return value2 !== void 0 ? value2 : fallback;
      };
      module.exports = {
        themeable,
        get_theme_params,
        is_themed,
        get_param
      };
    }
  });

  // ../jsgui3-html/themes/token_maps.js
  var require_token_maps = __commonJS({
    "../jsgui3-html/themes/token_maps.js"(exports, module) {
      var SIZE_TOKENS = {
        button: {
          small: {
            "--btn-height": "28px",
            "--btn-padding-x": "12px",
            "--btn-font-size": "12px",
            "--btn-icon-size": "14px",
            "--btn-border-radius": "4px",
            "--btn-gap": "4px"
          },
          medium: {
            "--btn-height": "36px",
            "--btn-padding-x": "16px",
            "--btn-font-size": "14px",
            "--btn-icon-size": "16px",
            "--btn-border-radius": "6px",
            "--btn-gap": "6px"
          },
          large: {
            "--btn-height": "44px",
            "--btn-padding-x": "20px",
            "--btn-font-size": "16px",
            "--btn-icon-size": "20px",
            "--btn-border-radius": "8px",
            "--btn-gap": "8px"
          },
          xlarge: {
            "--btn-height": "56px",
            "--btn-padding-x": "28px",
            "--btn-font-size": "18px",
            "--btn-icon-size": "24px",
            "--btn-border-radius": "12px",
            "--btn-gap": "10px"
          }
        },
        input: {
          small: {
            "--input-height": "32px",
            "--input-padding-x": "10px",
            "--input-font-size": "13px",
            "--input-border-radius": "4px"
          },
          medium: {
            "--input-height": "40px",
            "--input-padding-x": "12px",
            "--input-font-size": "14px",
            "--input-border-radius": "6px"
          },
          large: {
            "--input-height": "48px",
            "--input-padding-x": "16px",
            "--input-font-size": "16px",
            "--input-border-radius": "8px"
          }
        },
        panel: {
          // Panel uses padding sizes instead of height
          none: { "--panel-padding": "0" },
          small: { "--panel-padding": "8px" },
          medium: { "--panel-padding": "16px" },
          large: { "--panel-padding": "24px" },
          xlarge: { "--panel-padding": "40px" }
        },
        tab: {
          small: {
            "--tab-height": "28px",
            "--tab-padding-x": "8px",
            "--tab-font-size": "12px"
          },
          medium: {
            "--tab-height": "36px",
            "--tab-padding-x": "16px",
            "--tab-font-size": "14px"
          },
          large: {
            "--tab-height": "44px",
            "--tab-padding-x": "24px",
            "--tab-font-size": "16px"
          }
        },
        menu: {
          small: {
            "--menu-item-height": "28px",
            "--menu-item-padding-x": "8px",
            "--menu-font-size": "12px"
          },
          medium: {
            "--menu-item-height": "36px",
            "--menu-item-padding-x": "12px",
            "--menu-font-size": "14px"
          },
          large: {
            "--menu-item-height": "44px",
            "--menu-item-padding-x": "16px",
            "--menu-font-size": "16px"
          }
        }
      };
      var SHADOW_TOKENS = {
        none: { "--shadow": "none" },
        small: { "--shadow": "0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.08)" },
        medium: { "--shadow": "0 4px 6px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06)" },
        large: { "--shadow": "0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.1)" },
        xlarge: { "--shadow": "0 20px 40px rgba(0,0,0,0.2), 0 8px 16px rgba(0,0,0,0.1)" },
        inset: { "--shadow": "inset 0 2px 4px rgba(0,0,0,0.1)" }
      };
      var RADIUS_TOKENS = {
        none: { "--radius": "0" },
        small: { "--radius": "4px" },
        medium: { "--radius": "8px" },
        large: { "--radius": "12px" },
        xlarge: { "--radius": "16px" },
        full: { "--radius": "9999px" }
      };
      var SPACING_TOKENS = {
        none: { "--spacing": "0" },
        xs: { "--spacing": "4px" },
        small: { "--spacing": "8px" },
        medium: { "--spacing": "16px" },
        large: { "--spacing": "24px" },
        xlarge: { "--spacing": "32px" },
        xxlarge: { "--spacing": "48px" }
      };
      var apply_size_tokens = (ctrl, control_type, size) => {
        const type_tokens = SIZE_TOKENS[control_type];
        if (!type_tokens) return;
        const tokens = type_tokens[size];
        if (!tokens) return;
        ctrl.dom = ctrl.dom || {};
        ctrl.dom.attributes = ctrl.dom.attributes || {};
        ctrl.dom.attributes.style = ctrl.dom.attributes.style || {};
        Object.assign(ctrl.dom.attributes.style, tokens);
      };
      var apply_shadow_tokens = (ctrl, shadow) => {
        const tokens = SHADOW_TOKENS[shadow];
        if (!tokens) return;
        ctrl.dom = ctrl.dom || {};
        ctrl.dom.attributes = ctrl.dom.attributes || {};
        ctrl.dom.attributes.style = ctrl.dom.attributes.style || {};
        Object.assign(ctrl.dom.attributes.style, tokens);
      };
      var apply_radius_tokens = (ctrl, radius) => {
        const tokens = RADIUS_TOKENS[radius];
        if (!tokens) return;
        ctrl.dom = ctrl.dom || {};
        ctrl.dom.attributes = ctrl.dom.attributes || {};
        ctrl.dom.attributes.style = ctrl.dom.attributes.style || {};
        Object.assign(ctrl.dom.attributes.style, tokens);
      };
      var apply_token_map = (ctrl, control_type, params) => {
        if (!ctrl || !params) return;
        ctrl.dom = ctrl.dom || {};
        ctrl.dom.attributes = ctrl.dom.attributes || {};
        ctrl.dom.attributes.style = ctrl.dom.attributes.style || {};
        if (params.size && SIZE_TOKENS[control_type]) {
          const size_tokens = SIZE_TOKENS[control_type][params.size];
          if (size_tokens) {
            Object.assign(ctrl.dom.attributes.style, size_tokens);
          }
        }
        if (params.padding && SIZE_TOKENS.panel) {
          const padding_tokens = SIZE_TOKENS.panel[params.padding];
          if (padding_tokens) {
            Object.assign(ctrl.dom.attributes.style, padding_tokens);
          }
        }
        if (params.shadow && SHADOW_TOKENS[params.shadow]) {
          Object.assign(ctrl.dom.attributes.style, SHADOW_TOKENS[params.shadow]);
        }
        if (params.radius && RADIUS_TOKENS[params.radius]) {
          Object.assign(ctrl.dom.attributes.style, RADIUS_TOKENS[params.radius]);
        }
      };
      var get_size_tokens = (control_type, size) => {
        var _a;
        return ((_a = SIZE_TOKENS[control_type]) == null ? void 0 : _a[size]) || {};
      };
      module.exports = {
        SIZE_TOKENS,
        SHADOW_TOKENS,
        RADIUS_TOKENS,
        SPACING_TOKENS,
        apply_size_tokens,
        apply_shadow_tokens,
        apply_radius_tokens,
        apply_token_map,
        get_size_tokens
      };
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/button.js
  var require_button = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/button.js"(exports, module) {
      var jsgui = require_html_core();
      var { themeable } = require_themeable();
      var { apply_token_map } = require_token_maps();
      var Control2 = jsgui.Control;
      var Button = class extends Control2 {
        constructor(spec = {}, add, make) {
          spec.__type_name = spec.__type_name || "button";
          spec.tag_name = "button";
          super(spec);
          this.add_class("button");
          const params = themeable(this, "button", spec);
          apply_token_map(this, "button", params);
          if (spec.text || spec.label) {
            this.text = spec.text || spec.label;
          }
          if (spec.icon) {
            this.icon = spec.icon;
          }
          if (!spec.el) {
            this._compose(params);
          }
        }
        /**
         * Compose the button contents based on params.
         * @param {Object} params - Resolved theme params
         */
        _compose(params) {
          const { context: context2 } = this;
          const icon_position = params.icon_position || "left";
          let icon_element = null;
          if (this.icon && icon_position !== "none") {
            icon_element = new jsgui.controls.span({ context: context2 });
            icon_element.add_class("button-icon");
            icon_element.add(this.icon);
          }
          let text_element = null;
          if (this.text && icon_position !== "only") {
            text_element = new jsgui.controls.span({ context: context2 });
            text_element.add_class("button-text");
            text_element.add(this.text);
          }
          if (icon_position === "only" && icon_element) {
            this.add(icon_element);
          } else if (icon_position === "right") {
            if (text_element) this.add(text_element);
            if (icon_element) this.add(icon_element);
          } else {
            if (icon_element) this.add(icon_element);
            if (text_element) this.add(text_element);
          }
          if (!icon_element && !text_element && this.text) {
            this.add(this.text);
          }
        }
        /**
         * Legacy compose method for backward compatibility.
         * @deprecated Use _compose instead
         */
        "compose_button"() {
          if (this.text && !this._theme_params) {
            this.add(this.text);
          }
        }
        "activate"() {
          super.activate();
        }
        /**
         * Set the button disabled state.
         * @param {boolean} disabled - Whether button is disabled
         */
        set_disabled(disabled) {
          this.dom.attributes = this.dom.attributes || {};
          if (disabled) {
            this.dom.attributes.disabled = "disabled";
            this.add_class("disabled");
          } else {
            delete this.dom.attributes.disabled;
            this.remove_class("disabled");
          }
        }
        /**
         * Set loading state with optional spinner.
         * @param {boolean} loading - Whether button is loading
         */
        set_loading(loading) {
          if (loading) {
            this.add_class("loading");
            this.set_disabled(true);
          } else {
            this.remove_class("loading");
            this.set_disabled(false);
          }
        }
      };
      module.exports = Button;
      if (__require.main === module) {
        class London_Button extends Button {
          constructor(spec = {}, add, make) {
            spec.text = "London, England";
            super(spec, add, make);
          }
        }
        const lbtn = new London_Button();
        console.log(lbtn.all_html_render());
        const primary_btn = new Button({
          text: "Primary",
          variant: "primary",
          params: { size: "large" }
        });
        console.log("Primary button params:", primary_btn._theme_params);
      }
    }
  });

  // ../jsgui3-html/controls/organised/0-core/1-advanced/vector/arrow-button.js
  var require_arrow_button = __commonJS({
    "../jsgui3-html/controls/organised/0-core/1-advanced/vector/arrow-button.js"(exports, module) {
      var jsgui = require_html_core();
      var Control2 = jsgui.Control;
      var def = jsgui.is_defined;
      var Button = require_button();
      var Arrow_Button = class extends Button {
        constructor(spec, add, make) {
          spec.size = spec.size || [32, 32];
          spec.text = void 0;
          spec.__type_name = spec.__type_name || "arrow_button";
          super(spec);
          let rotation = 0;
          Object.defineProperty(this, "rotation", {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
              return rotation;
            },
            set(value2) {
              rotation = value2;
              this.raise("change", {
                "name": "rotation",
                "value": value2
              });
            },
            enumerable: true,
            configurable: true
          });
          let direction;
          this.on("change", (e) => {
            if (e.name === "rotation") {
              this.line.dom.attributes.transform = "rotate(" + e.value + ", 50, 50)";
              this.polygon.dom.attributes.transform = "rotate(" + e.value + ", 50, 50)";
            }
            if (e.name === "direction") {
              if (e.value === "left") this.rotation = 270;
              if (e.value === "up") this.rotation = 0;
              if (e.value === "right") this.rotation = 90;
              if (e.value === "down") this.rotation = 180;
            }
          });
          Object.defineProperty(this, "direction", {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
              return direction;
            },
            set(value2) {
              direction = value2;
              this.raise("change", {
                "name": "direction",
                "value": value2
              });
            },
            enumerable: true,
            configurable: true
          });
          if (def(spec.rotation)) {
            rotation = spec.rotation;
          }
          if (!spec.el) {
            this.compose_arrow_button();
          }
          if (def(spec.direction)) {
            this.direction = spec.direction;
          }
        }
        "compose_arrow_button"() {
          this.add_class("arrow");
          let svg = this.svg = new jsgui.svg({
            "context": this.context
          });
          svg.dom.attributes.viewBox = "0 0 100 100";
          let polygon = this.polygon = new jsgui.polygon({
            context: this.context
          });
          polygon.dom.attributes.points = "50 0, 70 20, 30 20";
          let line = this.line = new jsgui.line({
            "context": this.context
          });
          line.dom.attributes.x1 = 50;
          line.dom.attributes.y1 = 96;
          line.dom.attributes.x2 = 50;
          line.dom.attributes.y2 = 10;
          line.dom.attributes.transform = "rotate(" + this.rotation + ", 50, 50)";
          polygon.dom.attributes.transform = "rotate(" + this.rotation + ", 50, 50)";
          line.dom.attributes["stroke-width"] = 8;
          svg.add(line);
          svg.add(polygon);
          this.add(svg);
        }
        "activate"() {
          super.activate();
        }
      };
      module.exports = Arrow_Button;
    }
  });

  // ../jsgui3-html/control_mixins/dragable.js
  var require_dragable = __commonJS({
    "../jsgui3-html/control_mixins/dragable.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var {
        each,
        tof
      } = require_lang();
      var dragable = (ctrl, opts = {}) => {
        let {
          bounds: bounds2,
          handle,
          mode,
          start_action,
          condition
        } = opts;
        start_action = start_action || ["touchstart", "mousedown"];
        if (tof(start_action) === "string") start_action = [start_action];
        let bounds_pos;
        let bounds_is_parent = bounds2 && bounds2 === ctrl.parent;
        if (bounds2 === "parent") {
          bounds2 = ctrl.parent;
          bounds_is_parent = true;
        }
        if (bounds2) {
          bounds_pos = bounds2.pos || [bounds2.dom.el.offsetLeft, bounds2.dom.el.offsetTop];
        }
        handle = handle || ctrl;
        const old_dragable = ctrl.dragable;
        if (old_dragable) {
          return;
        }
        let drag_mode = opts.drag_mode || opts.mode || "translate";
        if (bounds_is_parent) {
        }
        let pos_md, pos_mm, pos_mu, pos_md_within_ctrl;
        const setup_isomorphic = () => {
          const old_silent = ctrl.view.data.model.mixins.silent;
          ctrl.view.data.model.mixins.silent = true;
          ctrl.view.data.model.mixins.push({
            name: "dragable"
          });
          ctrl.view.data.model.mixins.silent = old_silent;
          field(ctrl, "dragable");
        };
        setup_isomorphic();
        if (typeof document === "undefined") {
          ctrl.on("server-pre-render", (e) => {
            if (ctrl.dragable === true) {
              ctrl._fields = ctrl._fields || {};
              ctrl._fields.dragable = true;
            }
          });
        }
        if (ctrl.dom.el) {
          let ctrl_body = ctrl.context.body();
          let dragging = false;
          let drag_offset_distance = opts.start_distance || 6;
          let movement_offset;
          let item_start_pos;
          let bounds_size;
          let bounds_offset;
          let half_item_width, item_width;
          let initial_bounds_bcr2, initial_bcr;
          let initial_bcr_offset_from_bounds2;
          const el = ctrl.dom.el;
          let ctrl_translation3d = new Float32Array(3);
          let initial_ctrl_translation3d;
          let initial_ctrl_translate;
          const begin_drag = (pos) => {
            initial_bcr = ctrl.bcr();
            if (bounds2) {
              if (typeof bounds2.bcr === "function") {
                initial_bounds_bcr2 = bounds2.bcr();
                initial_bcr_offset_from_bounds2 = [
                  [initial_bcr[0][0] - initial_bounds_bcr2[0][0], initial_bcr[0][1] - initial_bounds_bcr2[0][1]],
                  [initial_bcr[1][0] - initial_bounds_bcr2[1][0], initial_bcr[1][1] - initial_bounds_bcr2[1][1]],
                  [initial_bcr[2][0] - initial_bounds_bcr2[2][0], initial_bcr[2][1] - initial_bounds_bcr2[2][1]]
                ];
              }
            }
            if (drag_mode === "within-parent") {
              dragging = true;
              item_start_pos = ctrl.pos;
              const ctrl_pos_to_be = [item_start_pos[0] - movement_offset[0], item_start_pos[1] - movement_offset[1]];
              ctrl.pos = ctrl_pos_to_be;
            } else if (drag_mode === "translate") {
              initial_ctrl_translate = ctrl.ta.slice(6, 8);
              dragging = true;
            } else {
              if (drag_mode === "y") {
                dragging = true;
                item_start_pos = ctrl.pos || [ctrl.dom.el.offsetLeft, ctrl.dom.el.offsetTop];
                ctrl.pos = [item_start_pos[0], item_start_pos[1] + movement_offset[1]];
              } else if (drag_mode === "x") {
                dragging = true;
                item_start_pos = ctrl.pos || [ctrl.dom.el.offsetLeft, ctrl.dom.el.offsetTop];
                half_item_width = Math.round(ctrl.dom.el.offsetWidth / 2);
                item_width = ctrl.dom.el.offsetWidth;
                bounds_offset = [bounds2.dom.el.offsetLeft, bounds2.dom.el.offsetTop];
                ctrl.pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1]];
              } else {
                throw new Error("Unsupported drag_mode: " + drag_mode);
              }
            }
            ctrl.raise("dragstart");
          };
          const move_drag = (pos) => {
            let ctrl_size = [ctrl.dom.el.offsetWidth, ctrl.dom.el.offsetHeight];
            if (drag_mode === "translate") {
              let tr_x = movement_offset[0] + initial_ctrl_translate[0];
              let tr_y = movement_offset[1] + initial_ctrl_translate[1];
              if (bounds2) {
                const current_bounds_bcr = bounds2.bcr();
                const bounds_left = current_bounds_bcr[0][0];
                const bounds_top = current_bounds_bcr[0][1];
                const bounds_right = current_bounds_bcr[1][0] - ctrl_size[0];
                const bounds_bottom = current_bounds_bcr[1][1] - ctrl_size[1];
                const min_x_offset = bounds_left - initial_ctrl_translate[0];
                const max_x_offset = bounds_right - initial_ctrl_translate[0];
                const min_y_offset = bounds_top - initial_ctrl_translate[1];
                const max_y_offset = bounds_bottom - initial_ctrl_translate[1];
                if (tr_x < min_x_offset) tr_x = min_x_offset;
                if (tr_x > max_x_offset) tr_x = max_x_offset;
                if (tr_y < min_y_offset) tr_y = min_y_offset;
                if (tr_y > max_y_offset) tr_y = max_y_offset;
              }
              ctrl.ta[6] = tr_x;
              ctrl.ta[7] = tr_y;
            } else if (drag_mode === "within-parent") {
              bounds2 = bounds2 || ctrl.parent;
              bounds_size = bounds2.bcr()[2];
              let new_pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1] + movement_offset[1]];
              if (new_pos[0] < 0) new_pos[0] = 0;
              if (new_pos[1] < 0) new_pos[1] = 0;
              if (new_pos[0] > bounds_size[0] - ctrl_size[0]) new_pos[0] = bounds_size[0] - ctrl_size[0];
              if (new_pos[1] > bounds_size[1] - ctrl_size[1]) new_pos[1] = bounds_size[1] - ctrl_size[1];
              ctrl.pos = new_pos;
            } else if (drag_mode === "y") {
              let new_pos = [item_start_pos[0], item_start_pos[1] + movement_offset[1]];
              ctrl.pos = new_pos;
            } else if (drag_mode === "x") {
              bounds_size = [bounds2.dom.el.offsetWidth, bounds2.dom.el.offsetHeight];
              let new_pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1]];
              if (new_pos[0] < bounds_pos[0] - half_item_width) new_pos[0] = bounds_pos[0] - half_item_width;
              if (new_pos[0] > bounds_size[0] - ctrl_size[0] + bounds_offset[0] + half_item_width) new_pos[0] = bounds_size[0] - ctrl_size[0] + bounds_offset[0] + half_item_width;
              ctrl.pos = new_pos;
            }
          };
          const body_mm = (e_mm) => {
            let touch_count = 0;
            if (e_mm.touches) touch_count = e_mm.touches.length;
            if (e_mm.touches) {
              pos_mm = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
            } else {
              pos_mm = [e_mm.pageX, e_mm.pageY];
            }
            if (touch_count === 0 || touch_count === 1) {
              if (e_mm.buttons === 0) {
                body_mu();
              } else {
                if (e_mm.pageX || e_mm.touches) {
                  let pos_mm2;
                  if (e_mm.touches) {
                    pos_mm2 = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
                  } else {
                    pos_mm2 = [e_mm.pageX, e_mm.pageY];
                  }
                  if (pos_mm2[0] !== void 0 && pos_mm2[1] !== void 0) {
                    movement_offset = [pos_mm2[0] - pos_md[0], pos_mm2[1] - pos_md[1]];
                    if (!dragging) {
                      let abs_offset = [Math.abs(movement_offset[0]), Math.abs(movement_offset[1])];
                      let abs_offset_dist = Math.sqrt(Math.pow(abs_offset[0], 2) + Math.pow(abs_offset[1], 2));
                      if (abs_offset_dist >= drag_offset_distance) {
                        begin_drag(pos_mm2);
                      }
                    } else {
                      move_drag(pos_mm2);
                    }
                  }
                }
              }
            }
          };
          const end_drag = (e_mu) => {
            ctrl_body.off("mousemove", body_mm);
            ctrl_body.off("mouseup", body_mu);
            ctrl_body.off("touchmove", body_mm);
            ctrl_body.off("touchend", body_mu);
            if (dragging) {
              dragging = false;
              ctrl.raise("dragend", {
                movement_offset
              });
            }
          };
          const body_mu = (e_mu) => {
            end_drag(e_mu);
          };
          const h_md = (e_md) => {
            if (!condition || condition()) {
              if (e_md.pageX) {
                pos_md_within_ctrl = [e_md.offsetX, e_md.offsetX];
              } else {
                pos_md_within_ctrl = [0, 0];
              }
              dragging = false;
              pos_md = [e_md.pageX || e_md.touches[0].pageX, e_md.pageY || e_md.touches[0].pageY];
              ctrl_body.on("mousemove", body_mm);
              ctrl_body.on("mouseup", body_mu);
              ctrl_body.on("touchmove", body_mm);
              ctrl_body.on("touchend", body_mu);
            }
          };
          ctrl.on("change", (e_change) => {
            let n = e_change.name, value2 = e_change.value;
            if (n === "dragable") {
              if (value2 === true) {
                if (typeof document === "undefined") {
                } else {
                  let apply_start_handlers = (start_action2) => {
                    if (!handle.has_drag_md_handler) {
                      handle.has_drag_md_handler = true;
                      each(start_action2, (sa) => {
                        handle.on(sa, h_md);
                      });
                    }
                  };
                  ctrl.once_active(() => {
                    apply_start_handlers(start_action);
                  });
                }
              } else {
                if (typeof document === "undefined") {
                } else {
                  ((start_action2) => {
                    each(start_action2, (sa) => {
                      handle.off(sa, h_md);
                    });
                  })(start_action);
                  handle.has_drag_md_handler = false;
                }
              }
            }
          });
        }
        if (!old_dragable) {
        }
      };
      module.exports = dragable;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/horizontal-slider.js
  var require_horizontal_slider = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/horizontal-slider.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var v_subtract2 = jsgui.v_subtract;
      var {
        prop,
        field
      } = require_oext();
      var mx_dragable = require_dragable();
      var Horizontal_Slider = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        // This should be customizable in which values it holds.
        //  For the moment, set up the value range on the server, and send that to the client as fields which we get back from the DOM when
        //  the Control gets activated.
        // I think this can take a min, a max, and a value.
        //  Perhaps operating in 'proportion' mode between 0 and 1 is easiest?
        //  Also having it handle time values - could use ms.
        // Basically, this needs to be told its min value, its max value, and its current value.
        // Also, want 'ghost' drag mode so that the handle can be dragged, and only changes position on release
        //  For different scrubber behaviour to what is in the iPod app.
        constructor(spec, add, make) {
          spec.__type_name = spec.__type_name || "horizontal_slider";
          super(spec);
          field(this, "min", spec.min || 0);
          field(this, "value", spec.value || 0);
          field(this, "max", spec.max || 100);
          if (!spec.el) {
            this.compose_horizontal_slider();
          }
        }
        "compose_horizontal_slider"() {
          let h_bar, v_bar;
          const context2 = this.context;
          let div_relative = this.add(new Control2({
            "class": "relative",
            "context": context2
          }));
          this.add_class("horizontal slider");
          h_bar = new Control2({
            "class": "h-bar",
            "context": context2
          });
          v_bar = new Control2({
            "class": "v-bar",
            "context": context2
          });
          div_relative.add(h_bar);
          div_relative.add(v_bar);
          let ctrl_fields = {
            "div_relative": div_relative,
            "h_bar": h_bar,
            "v_bar": v_bar
          };
          this._ctrl_fields = this._ctrl_fields || {};
          Object.assign(this._ctrl_fields, ctrl_fields);
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            console.log("Horizontal Slider activate");
            var h_bar = this.h_bar;
            var v_bar = this.v_bar;
            mx_dragable(v_bar, {
              mode: "x",
              bounds: h_bar,
              start_distance: 1
            });
            v_bar.dragable = true;
            v_bar.on("dragend", (e_complete) => {
              let bar_left = v_bar.dom.el.offsetLeft;
              let h_v_width = Math.round(v_bar.dom.el.offsetWidth / 2);
              let bar_x = bar_left - h_v_width;
              let h_width = h_bar.dom.el.offsetWidth;
              let prop2 = bar_x / h_width;
              let range_diff = this.max - this.min;
              let v = prop2 * range_diff + this.min;
              this._.value = v;
              this.raise("choose-value", v);
            });
            this.on("change", (e_change) => {
              var name = e_change.name, value2 = e_change.value;
              if (name === "value") {
                this.bar_value = value2;
              }
            });
            this.on("resize", (e) => {
              this.bar_value = this._.value;
            });
          }
        }
        set bar_value(value2) {
          const {
            h_bar,
            v_bar
          } = this;
          var min = this.min;
          var max = this.max;
          let prop2 = (value2 - min) / (max - min);
          var size_h_bar = h_bar.size || [h_bar.dom.el.offsetWidth, h_bar.dom.el.offsetHeight];
          let v_bar_center_pos = Math.round(size_h_bar[0] * prop2) + h_bar.dom.el.offsetLeft;
          let v_bar_left_pos = v_bar_center_pos - Math.round(v_bar.dom.el.offsetWidth / 2);
          let v_bar_top = v_bar.dom.el.offsetTop;
          if (v_bar.pos) {
            v_bar.pos = [v_bar_left_pos, v_bar.pos[1]];
          } else {
            v_bar.dom.attributes.style.left = v_bar_left_pos;
          }
          this._.value = value2;
        }
      };
      module.exports = Horizontal_Slider;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/audio-volume.js
  var require_audio_volume = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/audio-volume.js"(exports, module) {
      var jsgui = require_html_core();
      var Horizontal_Slider = require_horizontal_slider();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var v_subtract2 = jsgui.v_subtract;
      var Audio_Volume = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //'fields': [
        //	['text', String]
        //],
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "audio_volume";
          if (!spec.abstract && !spec.el) {
            this.add_class("audio-volume");
            var h_slider = add(Horizontal_Slider({
              "min": 0,
              "max": 100,
              "value": 100
            }));
            var ctrl_fields = {
              "h_slider": h_slider._id()
            };
            this.active();
          }
        }
        "activate"() {
          super.activate();
          console.log("Audio Volume activate");
          var h_slider = this.h_slider;
        }
      };
      module.exports = Audio_Volume;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/alert_banner.js
  var require_alert_banner = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/alert_banner.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var get_status_class = (status) => status ? `alert-banner-${status}` : "";
      var Alert_Banner = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "alert_banner";
          super(spec);
          this.add_class("alert-banner");
          this.dom.tagName = "div";
          this.dom.attributes.role = "alert";
          this.status = is_defined(spec.status) ? String(spec.status) : "";
          this.message = is_defined(spec.message) ? String(spec.message) : is_defined(spec.text) ? String(spec.text) : "";
          this.dismissible = !!spec.dismissible;
          if (this.status) {
            this.add_class(get_status_class(this.status));
          }
          if (!spec.el) {
            this.compose_alert();
          }
        }
        compose_alert() {
          const message_ctrl = new Control2({ context: this.context });
          message_ctrl.dom.tagName = "span";
          message_ctrl.add_class("alert-banner-message");
          if (this.message) {
            message_ctrl.add(this.message);
          }
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.message = message_ctrl;
          this.add(message_ctrl);
          if (this.dismissible) {
            const dismiss_ctrl = new Control2({ context: this.context });
            dismiss_ctrl.dom.tagName = "button";
            dismiss_ctrl.dom.attributes.type = "button";
            dismiss_ctrl.add_class("alert-banner-dismiss");
            dismiss_ctrl.add("x");
            this._ctrl_fields.dismiss = dismiss_ctrl;
            this.add(dismiss_ctrl);
          }
        }
        /**
         * Set the alert message text.
         * @param {string} message - The message to set.
         */
        set_message(message) {
          this.message = is_defined(message) ? String(message) : "";
          const message_ctrl = this._ctrl_fields && this._ctrl_fields.message;
          if (message_ctrl) {
            message_ctrl.clear();
            if (this.message) {
              message_ctrl.add(this.message);
            }
          }
        }
        /**
         * Set the alert status.
         * @param {string} status - The status to set.
         */
        set_status(status) {
          if (this.status) {
            this.remove_class(get_status_class(this.status));
          }
          this.status = is_defined(status) ? String(status) : "";
          if (this.status) {
            this.add_class(get_status_class(this.status));
          }
        }
        /**
         * Dismiss the alert banner.
         */
        dismiss() {
          this.add_class("alert-banner-hidden");
          if (this.dom.el) {
            this.dom.el.style.display = "none";
          }
          this.raise("dismiss");
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const dismiss_ctrl = this._ctrl_fields && this._ctrl_fields.dismiss;
            if (!dismiss_ctrl || !dismiss_ctrl.dom.el) return;
            dismiss_ctrl.on("click", () => this.dismiss());
          }
        }
      };
      Alert_Banner.css = `
.alert-banner {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 8px 12px;
    border-radius: 6px;
    background: #f0f0f0;
    color: #333;
}
.alert-banner-info {
    background: #e3f2fd;
    color: #0d47a1;
}
.alert-banner-success {
    background: #e8f5e9;
    color: #1b5e20;
}
.alert-banner-warn {
    background: #fff8e1;
    color: #ff6f00;
}
.alert-banner-error {
    background: #ffebee;
    color: #b71c1c;
}
.alert-banner-dismiss {
    border: none;
    background: transparent;
    cursor: pointer;
    color: inherit;
}
.alert-banner-hidden {
    display: none;
}
`;
      module.exports = Alert_Banner;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/vertical-expander.js
  var require_vertical_expander = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/vertical-expander.js"(exports, module) {
      var jsgui = require_html_core();
      var Control2 = jsgui.Control;
      var { prop, field } = require_oext();
      var Vertical_Expander = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //'fields': [
        //	['text', String]
        //],
        //  and can have other fields possibly.
        constructor(spec) {
          spec.__type_name = "vertical_expander";
          super(spec);
          this.add_class("vertical expander");
          field(this, "state");
          field(this, "states");
          this.state = spec.state;
          this.states = spec.states;
        }
        "activate"() {
          super.activate();
          var orig_height;
          var el = this.dom.el;
          if (el) {
            el.style.transition = "height 0.125s linear";
            var ui_close = () => {
              var h = el.childNodes[0].offsetHeight;
              orig_height = h;
              el.style.height = orig_height + "px";
              setTimeout(function() {
                el.style.overflow = "hidden";
                el.style.height = "0px";
              }, 0);
            };
            var ui_open = () => {
              var fnTransitionEnd = function(e_end) {
                el.removeEventListener("transitionend", fnTransitionEnd);
              };
              el.addEventListener("transitionend", fnTransitionEnd, false);
              el.style.height = orig_height + "px";
            };
            this.on("change", (e_change) => {
              var val = e_change.value;
              if (val == "closed") {
                ui_close();
              }
              if (val == "open") {
                ui_open();
              }
            });
          } else {
            console.log("WARNING: vertical_expander expected el to activate");
            console.trace();
          }
        }
        "toggle"() {
          if (this.state == "open") {
            this.state = "closed";
          }
          if (this.state == "closed") {
            this.state = "open";
          }
        }
        "open"() {
          this.state = "open";
        }
        "close"() {
          this.state = "closed";
        }
        // Open, close, expand, contract
        //  Could have a state variable as well.
        //  Will listen to changes in that state variable.
      };
      module.exports = Vertical_Expander;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/accordion.js
  var require_accordion = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/accordion.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var Vertical_Expander = require_vertical_expander();
      var normalize_sections = (sections) => {
        if (!Array.isArray(sections)) return [];
        return sections.map((section, index) => {
          if (section && typeof section === "object") {
            const id = is_defined(section.id) ? String(section.id) : `section-${index}`;
            return {
              id,
              title: is_defined(section.title) ? section.title : `Section ${index + 1}`,
              content: section.content,
              open: !!section.open
            };
          }
          return {
            id: `section-${index}`,
            title: String(section),
            content: void 0,
            open: false
          };
        });
      };
      var Accordion = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "accordion";
          super(spec);
          this.add_class("accordion");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.allow_multiple = !!spec.allow_multiple;
          this.set_sections(spec.sections || []);
          if (Array.isArray(spec.open_ids)) {
            this.set_open_ids(spec.open_ids);
          } else {
            const initial_open = (this.sections || []).filter((section) => section.open).map((section) => section.id);
            this.set_open_ids(initial_open);
          }
          if (!spec.el) {
            this.compose_accordion();
          }
          this.bind_model();
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            if (e_change.name === "sections") {
              this.sections = normalize_sections(e_change.value);
              this.render_sections();
            }
            if (e_change.name === "open_ids") {
              this.open_ids = Array.isArray(e_change.value) ? e_change.value.map(String) : [];
              this.sync_open_state();
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set accordion sections.
         * @param {Array} sections - Sections to set.
         */
        set_sections(sections) {
          const normalized = normalize_sections(sections);
          this.set_model_value("sections", normalized);
          this.sections = normalized;
        }
        /**
         * Set open section ids.
         * @param {Array} open_ids - Ids to open.
         */
        set_open_ids(open_ids) {
          const ids = Array.isArray(open_ids) ? open_ids.map(String) : [];
          this.set_model_value("open_ids", ids);
          this.open_ids = ids;
        }
        /**
         * Get open section ids.
         * @returns {Array}
         */
        get_open_ids() {
          return this.open_ids || [];
        }
        /**
         * Toggle section by id.
         * @param {string} section_id - Section id to toggle.
         */
        toggle_section(section_id) {
          const id = String(section_id);
          const open_ids = this.get_open_ids().slice();
          const index = open_ids.indexOf(id);
          if (index >= 0) {
            open_ids.splice(index, 1);
          } else {
            if (!this.allow_multiple) {
              open_ids.length = 0;
            }
            open_ids.push(id);
          }
          this.set_open_ids(open_ids);
          this.raise("toggle", { open_ids });
        }
        compose_accordion() {
          this.render_sections();
        }
        render_sections() {
          this.clear();
          this.section_controls = [];
          (this.sections || []).forEach((section, index) => {
            const header_ctrl = new Control2({ context: this.context, tag_name: "button" });
            header_ctrl.add_class("accordion-header");
            header_ctrl.dom.attributes.type = "button";
            header_ctrl.dom.attributes["data-section-id"] = section.id;
            header_ctrl.add(section.title);
            const expander_ctrl = new Vertical_Expander({
              context: this.context,
              state: section.open ? "open" : "closed"
            });
            expander_ctrl.add_class("accordion-expander");
            expander_ctrl.dom.attributes["data-section-id"] = section.id;
            const content_ctrl = new Control2({ context: this.context, tag_name: "div" });
            content_ctrl.add_class("accordion-content");
            if (is_defined(section.content)) {
              content_ctrl.add(section.content);
            }
            expander_ctrl.add(content_ctrl);
            const section_ctrl = new Control2({ context: this.context, tag_name: "div" });
            section_ctrl.add_class("accordion-section");
            section_ctrl.add(header_ctrl);
            section_ctrl.add(expander_ctrl);
            this.section_controls.push({
              id: section.id,
              header: header_ctrl,
              expander: expander_ctrl,
              section: section_ctrl
            });
            this.add(section_ctrl);
          });
          this.sync_open_state();
        }
        sync_open_state() {
          const open_ids = this.get_open_ids();
          (this.section_controls || []).forEach((section) => {
            const is_open = open_ids.includes(section.id);
            if (section.header) {
              if (is_open) {
                section.header.add_class("is-open");
              } else {
                section.header.remove_class("is-open");
              }
            }
            if (section.expander) {
              section.expander.state = is_open ? "open" : "closed";
            }
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            this.add_dom_event_listener("click", (e_click) => {
              const target = e_click.target;
              if (!target || !target.getAttribute) return;
              const section_id = target.getAttribute("data-section-id");
              if (!is_defined(section_id)) return;
              this.toggle_section(section_id);
            });
          }
        }
      };
      Accordion.css = `
.accordion {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.accordion-section {
    border: 1px solid #ddd;
    border-radius: 6px;
    overflow: hidden;
}
.accordion-header {
    width: 100%;
    text-align: left;
    padding: 8px 12px;
    background: #f2f2f2;
    border: none;
    cursor: pointer;
}
.accordion-header.is-open {
    background: #e6e6e6;
}
.accordion-content {
    padding: 10px 12px;
    background: #fff;
}
`;
      module.exports = Accordion;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/badge.js
  var require_badge = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/badge.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var get_status_class = (status) => status ? `badge-${status}` : "";
      var Badge = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "badge";
          super(spec);
          this.add_class("badge");
          this.dom.tagName = "span";
          this.status = is_defined(spec.status) ? String(spec.status) : "";
          if (this.status) {
            this.add_class(get_status_class(this.status));
          }
          this.text = is_defined(spec.text) ? String(spec.text) : is_defined(spec.label) ? String(spec.label) : "";
          if (!spec.el && this.text) {
            this.add(this.text);
          }
        }
        /**
         * Set badge text.
         * @param {string} text - The text to set.
         */
        set_text(text) {
          this.text = is_defined(text) ? String(text) : "";
          this.clear();
          if (this.text) {
            this.add(this.text);
          }
        }
        /**
         * Get badge text.
         * @returns {string}
         */
        get_text() {
          return this.text || "";
        }
        /**
         * Set badge status.
         * @param {string} status - The status to set.
         */
        set_status(status) {
          if (this.status) {
            this.remove_class(get_status_class(this.status));
          }
          this.status = is_defined(status) ? String(status) : "";
          if (this.status) {
            this.add_class(get_status_class(this.status));
          }
        }
      };
      Badge.css = `
.badge {
    display: inline-flex;
    align-items: center;
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 0.75em;
    background: #eee;
    color: #333;
}
.badge-info {
    background: #e3f2fd;
    color: #0d47a1;
}
.badge-success {
    background: #e8f5e9;
    color: #1b5e20;
}
.badge-warn {
    background: #fff8e1;
    color: #ff6f00;
}
.badge-error {
    background: #ffebee;
    color: #b71c1c;
}
`;
      module.exports = Badge;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/1-advanced/Canvas.js
  var require_Canvas = __commonJS({
    "../jsgui3-html/controls/organised/0-core/1-advanced/Canvas.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var Canvas = class extends Control2 {
        constructor(spec, add, make) {
          spec.tagName = "canvas";
          super(spec);
          this.__type_name = "canvas";
          const context2 = this.context;
          if (!spec.abstract && !spec.el) {
          }
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            super.activate();
          }
        }
      };
      Canvas.css = `
}
`;
      module.exports = Canvas;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/breadcrumbs.js
  var require_breadcrumbs = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/breadcrumbs.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Breadcrumbs = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "breadcrumbs";
          super(spec);
          this.add_class("breadcrumbs");
          this.dom.tagName = "nav";
          this.dom.attributes["aria-label"] = "Breadcrumb";
          this.items = Array.isArray(spec.items) ? spec.items.slice() : [];
          if (!spec.el) {
            this.compose_breadcrumbs();
          }
        }
        compose_breadcrumbs() {
          const { context: context2 } = this;
          const list_ctrl = new Control2({ context: context2 });
          list_ctrl.dom.tagName = "ol";
          list_ctrl.add_class("breadcrumbs-list");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.list = list_ctrl;
          this.add(list_ctrl);
          this.render_items();
        }
        render_items() {
          const list_ctrl = this._ctrl_fields && this._ctrl_fields.list;
          if (!list_ctrl) return;
          list_ctrl.clear();
          this.items.forEach((item2, index) => {
            const li_ctrl = new Control2({ context: this.context });
            li_ctrl.dom.tagName = "li";
            li_ctrl.add_class("breadcrumbs-item");
            const label = is_defined(item2.label) ? String(item2.label) : String(item2);
            const href = is_defined(item2.href) ? String(item2.href) : "";
            const link_ctrl = new Control2({ context: this.context });
            link_ctrl.dom.tagName = href ? "a" : "button";
            link_ctrl.add_class("breadcrumbs-link");
            link_ctrl.dom.attributes["data-breadcrumb-index"] = String(index);
            if (href) {
              link_ctrl.dom.attributes.href = href;
            } else {
              link_ctrl.dom.attributes.type = "button";
            }
            link_ctrl.add(label);
            li_ctrl.add(link_ctrl);
            list_ctrl.add(li_ctrl);
          });
        }
        /**
         * Set breadcrumb items.
         * @param {Array} items - The items to set.
         */
        set_items(items) {
          this.items = Array.isArray(items) ? items.slice() : [];
          this.render_items();
        }
        /**
         * Get breadcrumb items.
         * @returns {Array}
         */
        get_items() {
          return this.items;
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const list_ctrl = this._ctrl_fields && this._ctrl_fields.list;
            if (!list_ctrl || !list_ctrl.dom.el) return;
            list_ctrl.add_dom_event_listener("click", (e_click) => {
              const target = e_click.target;
              if (!target || !target.getAttribute) return;
              const index_str = target.getAttribute("data-breadcrumb-index");
              if (!is_defined(index_str)) return;
              const index = parseInt(index_str, 10);
              if (Number.isNaN(index)) return;
              e_click.preventDefault();
              const item2 = this.items[index];
              this.raise("navigate", { index, item: item2 });
            });
          }
        }
      };
      Breadcrumbs.css = `
.breadcrumbs-list {
    list-style: none;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    padding: 0;
    margin: 0;
}
.breadcrumbs-item::after {
    content: '/';
    margin-left: 6px;
    color: #888;
}
.breadcrumbs-item:last-child::after {
    content: '';
}
.breadcrumbs-link {
    text-decoration: none;
    color: inherit;
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 0;
}
`;
      module.exports = Breadcrumbs;
    }
  });

  // ../jsgui3-html/control_mixins/selectable.js
  var require_selectable = __commonJS({
    "../jsgui3-html/control_mixins/selectable.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var { each, is_array, is_def } = require_lib_lang_mini2();
      var selectable = (ctrl, ctrl_handle, opts) => {
        ctrl._selectable_mixin_state = ctrl._selectable_mixin_state || {};
        const mx_state = ctrl._selectable_mixin_state;
        const setup_isomorphic = () => {
          var _a, _b, _c;
          if (mx_state.isomorphic_applied) return;
          mx_state.isomorphic_applied = true;
          const mixins = (_c = (_b = (_a = ctrl.view) == null ? void 0 : _a.data) == null ? void 0 : _b.model) == null ? void 0 : _c.mixins;
          if (mixins && typeof mixins.each === "function" && typeof mixins.push === "function") {
            let has_selectable = false;
            mixins.each((mixin) => {
              if (mixin && mixin.name === "selectable") has_selectable = true;
            });
            if (!has_selectable) {
              const old_silent = mixins.silent;
              mixins.silent = true;
              mixins.push({
                name: "selectable"
              });
              mixins.silent = old_silent;
            }
          }
          ctrl.on("change", (e_change) => {
            let {
              name,
              value: value2
            } = e_change;
            if (name === "selected") {
              if (value2) {
                ctrl.add_class("selected");
              } else {
                ctrl.remove_class("selected");
              }
            }
            ;
            return true;
          });
        };
        setup_isomorphic();
        if (typeof document === "undefined") {
          if (!mx_state.server_pre_render_applied) {
            mx_state.server_pre_render_applied = true;
            ctrl.on("server-pre-render", (e) => {
              if (ctrl.selectable === true) {
                ctrl._fields = ctrl._fields || {};
                ctrl._fields.selectable = true;
                if (ctrl.selected === true) {
                  ctrl._fields.selected = true;
                }
              }
            });
          }
        }
        if (ctrl.dom.el) {
          if (mx_state.dom_applied) return;
          mx_state.dom_applied = true;
          let select_toggle = false;
          let select_multi = false;
          let condition;
          let preventDefault = true;
          let selection_action = ["mousedown", "touchstart"];
          if (!opts) {
            if (ctrl_handle) {
              if (!ctrl_handle.activate) {
                opts = ctrl_handle;
                ctrl_handle = void 0;
              }
            }
          }
          if (opts) {
            if (opts.handle) {
              ctrl_handle = opts.handle;
            }
            if (opts.select_toggle || opts.toggle) {
              select_toggle = true;
            }
            if (opts.select_multi || opts.multi) {
              select_multi = true;
            }
            if (opts.single) {
              select_multi = false;
            }
            if (opts.selection_action) {
              selection_action = opts.selection_action;
            }
            if (opts.condition) {
              condition = opts.condition;
            }
            if (opts.preventDefault === false) {
              preventDefault = false;
            }
          }
          ctrl_handle = ctrl_handle || ctrl;
          let click_handler = (e) => {
            if (ctrl.selectable && !ctrl.selection_scope && !ctrl.disabled) {
              if (!condition || condition()) {
                var ctrl_key2 = e.ctrlKey;
                var meta_key = e.metaKey;
                if (select_multi) {
                  if (ctrl_key2 || meta_key) {
                    ctrl.action_select_toggle();
                  } else {
                    if (select_toggle) {
                      ctrl.action_select_toggle();
                    } else {
                      ctrl.action_select_only();
                    }
                  }
                } else {
                  if (select_toggle) {
                    if (ctrl.selected) {
                      ctrl.deselect();
                    } else {
                      ctrl.action_select_only();
                    }
                  } else {
                    ctrl.action_select_only();
                  }
                }
                if (preventDefault) {
                  e.preventDefault();
                }
              } else {
                console.log("failed condition check");
              }
            } else {
            }
          };
          let ss;
          const apply_all = (ctrl2) => {
            let id = ctrl2._id();
            ctrl2.on("change", (e_change) => {
              let n = e_change.name, value2 = e_change.value;
              let ss2 = ctrl2.find_selection_scope();
              if (n === "selected") {
                if (value2 === true) {
                  ctrl2.add_class("selected");
                  if (ss2) ss2.map_selected_controls[id] = ctrl2;
                } else {
                  ctrl2.remove_class("selected");
                  if (ss2) ss2.map_selected_controls[id] = null;
                }
              }
              if (n === "selectable") {
                if (value2 === true) {
                  apply_active_selectable(ctrl2);
                } else {
                  if (typeof document === "undefined") {
                  } else {
                    if (is_array(selection_action)) {
                      selection_action.forEach((i) => {
                        ctrl_handle.off(i, click_handler);
                      });
                    } else {
                      ctrl_handle.off(selection_action, click_handler);
                    }
                    ctrl_handle.has_selection_click_handler = false;
                  }
                }
              }
            });
          };
          const apply_active_selectable = (ctrl2) => {
            ctrl2.deselect = ctrl2.deselect || (() => {
              ss = ss || ctrl2.find_selection_scope();
              if (ss) ss.deselect(ctrl2);
              ctrl2.raise("deselect");
            });
            ctrl2.select = ctrl2.select || (() => {
              ss = ss || ctrl2.find_selection_scope();
              if (ss) ss.select(ctrl2);
              ctrl2.raise("select");
            });
            ctrl2.action_select_only = ctrl2.action_select_only || (() => {
              ss = ss || ctrl2.find_selection_scope();
              if (ss) {
                ss.select_only(ctrl2);
              } else {
                each(ctrl2.siblings, (sibling) => {
                  sibling.selected = false;
                });
                ctrl2.selected = true;
              }
            });
            ctrl2.action_select_toggle = ctrl2.action_select_toggle || (() => {
              ss = ss || ctrl2.find_selection_scope();
              ss.select_toggle(ctrl2);
            });
            if (typeof document === "undefined") {
            } else {
              ctrl2.once_active(() => {
                if (!ctrl_handle.has_selection_click_handler) {
                  ctrl_handle.has_selection_click_handler = true;
                  if (Array.isArray(selection_action)) {
                    selection_action.forEach((i) => {
                      ctrl_handle.on(i, click_handler);
                    });
                  } else {
                    ctrl_handle.on(selection_action, click_handler);
                  }
                }
              });
            }
          };
          field(ctrl, "selected");
          field(ctrl, "selectable");
          apply_all(ctrl);
          ctrl.on("activate", (e) => {
            if (ctrl.selectable) apply_all(ctrl);
          });
        }
      };
      module.exports = selectable;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Cell.js
  var require_Cell = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Cell.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var mx_selectable = require_selectable();
      var { field } = require_oext();
      var Control2 = jsgui.Control;
      var Cell = class extends Control2 {
        constructor(spec) {
          (spec = spec || {}).__type_name = "cell";
          super(spec);
          this.add_class("cell");
          field(this, "x", spec.x);
          field(this, "y", spec.y);
          field(this, "data", spec.data);
          if (!spec.el) {
            this.compose_grid_cell();
          }
          mx_selectable(this);
        }
        compose_grid_cell() {
          let o = {
            context: this.context
          };
          if (this.data) o.text = this.data;
          this.add(this.span = new jsgui.span(o));
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.span = this.span;
        }
        activate() {
          if (!this.__active) {
            super.activate();
          }
        }
      };
      module.exports = Cell;
    }
  });

  // ../jsgui3-html/control_mixins/a11y.js
  var require_a11y = __commonJS({
    "../jsgui3-html/control_mixins/a11y.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var ensure_dom_attributes = (ctrl) => {
        if (!ctrl || !ctrl.dom) return null;
        ctrl.dom.attributes = ctrl.dom.attributes || {};
        return ctrl.dom.attributes;
      };
      var apply_role = (ctrl, role, options = {}) => {
        if (!ctrl || !role) return;
        const attributes = ensure_dom_attributes(ctrl);
        if (!attributes) return;
        if (!attributes.role || options.force) {
          attributes.role = role;
        }
      };
      var apply_label = (ctrl, label_text, options = {}) => {
        if (!ctrl || label_text === void 0 || label_text === null) return;
        const attributes = ensure_dom_attributes(ctrl);
        if (!attributes) return;
        if (!attributes["aria-label"] || options.force) {
          attributes["aria-label"] = String(label_text);
        }
      };
      var apply_focus_ring = (ctrl, options = {}) => {
        if (!ctrl || !ctrl.add_class) return;
        ctrl.add_class("focus-ring");
        if (options.include_tabindex) {
          const attributes = ensure_dom_attributes(ctrl);
          if (attributes && attributes.tabindex === void 0) {
            attributes.tabindex = "0";
          }
        }
      };
      var has_sr_only_text = (ctrl) => {
        if (!ctrl || !ctrl.content || typeof ctrl.content.each !== "function") return false;
        let has_sr_only = false;
        ctrl.content.each((child) => {
          if (child && child.has_class && child.has_class("sr-only")) {
            has_sr_only = true;
          }
        });
        return has_sr_only;
      };
      var ensure_sr_text = (ctrl, sr_text, options = {}) => {
        if (!ctrl || sr_text === void 0 || sr_text === null) return;
        const text_value = String(sr_text);
        apply_label(ctrl, text_value, options);
        if (options.add_sr_only === false) return;
        if (has_sr_only_text(ctrl)) return;
        const sr_span = new Control2({
          context: ctrl.context,
          tag_name: "span"
        });
        sr_span.add_class("sr-only");
        sr_span.add(text_value);
        ctrl.add(sr_span);
      };
      module.exports = {
        apply_role,
        apply_label,
        apply_focus_ring,
        ensure_sr_text
      };
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/menu-node.js
  var require_menu_node = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/menu-node.js"(exports, module) {
      var jsgui = require_html_core();
      var {
        apply_focus_ring,
        apply_role
      } = require_a11y();
      var { stringify, each, tof, Control: Control2 } = jsgui;
      var Menu_Node = class _Menu_Node extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        // Actually having a different content?
        //  Or use inner_content.
        // Menu node having expanded and contracted states.
        // Menu Node has an image and some text, and a contrainer control for othe Menu nodes.
        //  Can be collapsed so that the internal items don't show
        //'fields': [
        //['text', String]
        //],
        //'fields': {
        //	'img_src': 'string',
        //	'text': 'string'
        //},
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "menu_node";
          this.dom.attributes.role = "none";
          if (!this._abstract) {
            if (!spec.el) {
              this.add_class("menu-node");
              var spec_state = spec.state, state;
              var main_control = make(Control2({ "class": "main" }));
              this.add(main_control);
              this.main_control = main_control;
              apply_role(main_control, "menuitem");
              apply_focus_ring(main_control);
              main_control.dom.attributes.tabindex = "-1";
              if (spec.img_src) {
              }
              if (spec.text) {
                this.text = spec.text;
                var span = make(jsgui.span({}));
                span.add(spec.text);
                main_control.add(span);
              }
              var menu = spec.menu;
              if (menu) {
                this.set("menu", menu);
              }
              var inner_control = this.inner_control = make(Control2({ "class": "inner hidden" }));
              inner_control.dom.attributes.role = "menu";
              inner_control.dom.attributes.id = inner_control._id();
              this.add(inner_control);
              if (spec.value) {
                var obj_menu = spec.value;
                var t_obj_menu = tof(obj_menu);
                console.log("t_obj_menu", t_obj_menu);
                if (t_obj_menu == "array") {
                  each(obj_menu, function(v) {
                    var tv = tof(v);
                    if (tv == "string") {
                      var nested_menu_node = make(_Menu_Node({
                        "text": v,
                        "menu": menu
                      }));
                      inner_control.add(nested_menu_node);
                    }
                  });
                }
              }
              var ctrl_fields = {
                "inner_control": inner_control._id(),
                "main_control": main_control._id(),
                "menu": spec.menu._id()
              };
              this.set("dom.attributes.data-jsgui-ctrl-fields", stringify(ctrl_fields).replace(/"/g, "'"));
              if (spec_state) {
                if (spec_state == "open" || spec_state == "closed") {
                  state = this.set("state", spec_state);
                } else {
                  throw 'spec.state expects "open" or "closed".';
                }
              } else {
                state = this.set("state", "open");
              }
              this.update_aria_state();
            }
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            var inner_control = this.inner_control;
            var main_control = this.main_control;
            var menu = this.menu;
            var that2 = this;
          }
        }
        update_aria_state() {
          const main_control = this.main_control;
          if (!main_control || !main_control.dom) return;
          const has_children = !!(this.inner_control && this.inner_control.content && this.inner_control.content._arr.length);
          if (has_children) {
            main_control.dom.attributes["aria-haspopup"] = "true";
            main_control.dom.attributes["aria-controls"] = this.inner_control.dom.attributes.id;
            main_control.dom.attributes["aria-expanded"] = this.state === "open" ? "true" : "false";
          } else {
            main_control.dom.attributes["aria-haspopup"] = "false";
            main_control.dom.attributes["aria-expanded"] = "false";
          }
        }
        "close_all"() {
          console.log("menu-node close_all");
          var inner_control = this.inner_control;
          inner_control.content.each(function(v, i) {
            var tn = v.__type_name;
            if (tn == "menu_node") {
              v.close_all();
            }
          });
          inner_control.hide();
          this.set("state", "closed", true);
          this.update_aria_state();
        }
        "close"() {
          var inner_control = this.inner_control;
          inner_control.hide();
          this.set("state", "closed", true);
          this.update_aria_state();
        }
        "open"() {
          var inner_control = this.inner_control;
          inner_control.show();
          this.set("state", "open", true);
          this.update_aria_state();
        }
      };
      module.exports = Menu_Node;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/context-menu.js
  var require_context_menu = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/context-menu.js"(exports, module) {
      var jsgui = require_html_core();
      var Menu_Node = require_menu_node();
      var { each, tof } = jsgui;
      var Control2 = jsgui.Control;
      var { themeable } = require_themeable();
      var { apply_token_map } = require_token_maps();
      var Context_Menu = class extends Control2 {
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "context_menu";
          const params = themeable(this, "context_menu", spec);
          apply_token_map(this, "menu", params);
          this.add_class("context menu");
          if (!spec.abstract) {
            const obj2 = spec.value;
            const tobj = tof(obj2);
            if (tobj === "object") {
              each(obj2, (v, key2) => {
                const menu_node = make(Menu_Node({
                  "text": key2,
                  "value": v,
                  "menu": this
                }));
                this.add(menu_node);
              });
            }
            if (tobj === "array") {
              each(obj2, (v, index) => {
                var vsig = jsgui.get_item_sig(v, 1);
                if (vsig == "[s,f]") {
                  var text = v[0];
                  var item_callback = v[1];
                  var menu_node = make(Menu_Node({
                    "text": text,
                    "value": text,
                    "menu": this
                  }));
                  this.add(menu_node);
                }
              });
            }
          }
          this._features = this._features || [];
          this._features.push("menu");
        }
        "activate"() {
          super.activate();
        }
        "close_all"() {
          console.log("menu close_all");
          this.content.each(function(v, i) {
            v.close_all();
          });
        }
      };
      module.exports = Context_Menu;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/grid.js
  var require_grid = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/grid.js"(exports, module) {
      var jsgui = require_html_core();
      var {
        stringify,
        each,
        tof,
        def,
        Control: Control2
      } = jsgui;
      var mx_selectable = require_selectable();
      var {
        prop,
        field
      } = require_oext();
      var Cell = require_Cell();
      var Grid_Cell = Cell;
      var Grid = class extends Control2 {
        constructor(spec, add, make) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "grid";
          super(spec);
          if (spec.cell_selection) {
            this.cell_selection = spec.cell_selection;
          }
          this.add_class("grid");
          var spec_data = spec.data;
          this._arr_rows = [];
          field(this, "composition_mode");
          if (spec.composition_mode) {
            this.composition_mode = spec.composition_mode;
          } else {
            this.composition_mode = "divs";
          }
          prop(this, "grid_size", spec.grid_size || [12, 12]);
          field(this, "cell_size");
          if (spec.cell_size) this.cell_size = spec.cell_size;
          field(this, "column_headers", false);
          field(this, "row_headers", false);
          prop(this, "data", false);
          this.map_cells = {};
          this.arr_cells = {};
          if (spec.data) {
            let t_data = tof(spec.data);
            if (t_data === "array") {
              let max_x = -1;
              let y, x, ly, lx, arr = spec.data, arr_row;
              ly = arr.length;
              for (y = 0; y < ly; y++) {
                arr_row = arr[y];
                lx = arr_row.length;
                if (lx > max_x) max_x = lx;
                for (x = 0; x < lx; x++) {
                }
              }
              _grid_size = [max_x, ly];
            }
          }
          if (!spec.el) {
            var data;
            this.full_compose_as_divs();
            this._fields = this._fields || {};
            Object.assign(this._fields, {
              "composition_mode": this.composition_mode,
              "grid_size": this.grid_size
            });
            if (this.cell_size) {
              this._fields.cell_size = this.cell_size;
            }
          }
          this.changes({
            grid_size: (v) => {
              if (!spec.el) {
                this.clear();
                this.full_compose_as_divs();
              }
            }
          });
        }
        //  Have the size system set up within the 'view model'.
        "refresh_size"() {
          if (this.composition_mode === "divs") {
            let [num_columns, num_rows] = this.grid_size;
            var cell_border_thickness = 1;
            var _2_cell_border_thickness = cell_border_thickness * 2;
            if (this.size) {
              var cell_size = this.cell_size || [Math.floor(this.size[0] / num_columns) - _2_cell_border_thickness, Math.floor(this.size[1] / num_rows) - _2_cell_border_thickness];
              var cell_v_border_thickness = 2;
              this.each_row((row) => {
                row.size = [this.size[0], cell_size[1] + cell_v_border_thickness];
              });
              this.each_cell((cell) => {
                cell.size = cell_size;
              });
            } else {
              console.log(".size was not available");
            }
          }
        }
        "each_row"(cb_row) {
          each(this._arr_rows, cb_row);
        }
        "each_cell"(cb_cell) {
          each(this._arr_rows, (row, i_row) => {
            row.content.each((cell, i_cell) => {
              cb_cell(cell, [i_cell, i_row]);
            });
          });
        }
        "get_cell"(x, y) {
          let cell_x = x;
          let cell_y = y;
          if (typeof cell_x === "object" && cell_x !== null) {
            if (Array.isArray(cell_x)) {
              cell_y = cell_x[1];
              cell_x = cell_x[0];
            } else if (typeof cell_y === "undefined") {
              cell_y = cell_x.y;
              cell_x = cell_x.x;
            }
          }
          if (typeof cell_x === "undefined" || typeof cell_y === "undefined") return void 0;
          const x_num = typeof cell_x === "number" ? cell_x : parseInt(cell_x, 10);
          const y_num = typeof cell_y === "number" ? cell_y : parseInt(cell_y, 10);
          if (!Number.isFinite(x_num) || !Number.isFinite(y_num)) return void 0;
          const key2 = "[" + x_num + "," + y_num + "]";
          if (this.map_cells && this.map_cells[key2]) return this.map_cells[key2];
          if (this.arr_cells && this.arr_cells[x_num] && this.arr_cells[x_num][y_num]) {
            return this.arr_cells[x_num][y_num];
          }
          if (this._arr_rows && this._arr_rows[y_num]) {
            const row = this._arr_rows[y_num];
            const offset2 = this.row_headers ? 1 : 0;
            const idx = x_num + offset2;
            if (row && row.content && row.content._arr && row.content._arr[idx]) {
              return row.content._arr[idx];
            }
          }
          return void 0;
        }
        "add_cell"(content) {
          var cell = new Grid_Cell({
            context: this.context
          });
          if (this.cell_selection) {
            cell.selectable = true;
          } else {
          }
          if (content) {
            cell.add(content);
          }
          cell.active();
          this.main.add(cell);
          return cell;
        }
        "full_compose_as_divs"() {
          let main = this.main = new Control2({
            context: this.context,
            class: "main"
          });
          this.add(main);
          let rows = this.main = new Control2({
            context: this.context,
            class: "rows"
          });
          main.add(rows);
          let map_cells = this.map_cells, arr_cells = this.arr_cells;
          if (this.grid_size) {
            let [num_columns, num_rows] = this.grid_size;
            var cell_border_thickness = 0;
            var _2_cell_border_thickness = cell_border_thickness * 2;
            let cell_size;
            if (this.size) {
              cell_size = this.cell_size || [Math.floor(this.size[0] / num_columns) - _2_cell_border_thickness, Math.floor(this.size[1] / num_rows) - _2_cell_border_thickness];
            } else {
              cell_size = this.cell_size;
            }
            let row_width, row_height;
            let row_header_width;
            if (this.cell_size) {
              if (this.row_headers) {
                row_header_width = this.row_headers.width || row_header_width;
                row_width = this.cell_size[0] * num_columns + row_header_width;
              } else {
                row_width = this.cell_size[0] * num_columns;
              }
              row_height = this.cell_size[1];
            } else {
              if (this.size) row_height = Math.floor(this.size[1] / num_rows);
            }
            const data = this.data;
            var x, y;
            if (this.column_headers) {
              let header_row = new Control2({
                context: this.context
              });
              header_row.add_class("header");
              header_row.add_class("row");
              if (row_height) {
                header_row.style("height", row_height);
              }
              if (row_width) {
                header_row.style("width", row_width);
              }
              rows.add(header_row);
              if (this.row_headers) {
                var cell = new Control2({
                  context: this.context,
                  __type_name: "grid_cell"
                });
                cell.add_class("grid-header");
                cell.add_class("cell");
                if (row_header_width) {
                  cell.size = [row_header_width, cell_size[1]];
                } else {
                  cell.size = cell_size;
                }
                header_row.add(cell);
              }
              for (x = 0; x < num_columns; x++) {
                var cell = new Control2({
                  context: this.context,
                  __type_name: "grid_cell"
                });
                cell.add_class("column-header");
                cell.add_class("cell");
                cell.size = cell_size;
                header_row.add(cell);
              }
            }
            for (y = 0; y < num_rows; y++) {
              var row_container = new Control2({
                context: this.context
              });
              if (row_height) {
                row_container.style("height", row_height);
              }
              if (row_width) {
                row_container.style("width", row_width);
              }
              row_container.add_class("row");
              this._arr_rows.push(row_container);
              rows.add(row_container);
              if (this.row_headers) {
                var cell = new Control2({
                  context: this.context,
                  __type_name: "grid_cell"
                });
                cell.add_class("row-header");
                cell.add_class("cell");
                if (row_header_width) {
                  cell.size = [row_header_width, cell_size[1]];
                } else {
                  cell.size = cell_size;
                }
                row_container.add(cell);
              }
              for (x = 0; x < num_columns; x++) {
                let o = {
                  context: this.context,
                  x,
                  y
                };
                if (data) {
                  o.data = data[y][x];
                }
                var cell = new Grid_Cell(o);
                cell.selectable = true;
                if (cell_size) cell.size = cell_size;
                row_container.add(cell);
                arr_cells[x] = arr_cells[x] || [];
                arr_cells[x][y] = cell;
                map_cells["[" + x + "," + y + "]"] = cell;
              }
            }
          }
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.main = main;
          this._ctrl_fields.rows = rows;
        }
        "full_compose_as_table"() {
          this.dom.tagName = table;
          var data = this.data;
          var range = data.range;
          var value2;
          if (tof(data) === "data_grid") {
            var x, y, max_x = range[0], max_y = range[1];
            var ctrl_cell, ctrl_row;
            var size = this.size().value();
            var tbody_params = {
              "context": this.context,
              "tagName": "tbody"
            };
            if (size) {
              tbody_params.size = [size[0][0], size[1][0]];
            }
            var tbody = new Control2(tbody_params);
            this.add(tbody);
            for (y = 0; y <= max_y; y++) {
              ctrl_row = new jsgui.tr({
                "context": this.context
              });
              tbody.add(ctrl_row);
              for (x = 0; x <= max_x; x++) {
                ctrl_cell = new jsgui.td({
                  "context": this.context
                });
                ctrl_row.add(ctrl_cell);
                value2 = data.get(x, y);
                ctrl_cell.add_text(value2);
              }
            }
          } else {
            throw "Unexpected data type. Expected data_grid, got " + tof(data);
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            this.selection_scope = this.selection_scope || this.context.new_selection_scope(this);
            var load_rows = () => {
              var _arr_rows = this._arr_rows = [];
              this.rows.content._arr.forEach((v) => {
                _arr_rows.push(v);
              });
            };
            load_rows();
            var load_cells = () => {
              each(this._arr_rows, (row) => {
                each(row.content._arr, (cell) => {
                });
              });
            };
          }
        }
      };
      Grid.css = `
table.grid {
    background-color: #eceff1;
    border: 1px solid #546e7a;
    padding: 2px;
    cursor: default;
}
table.grid tbody {
    overflow: hidden;
    display: block;
}
table.grid td {
    padding: 1px;
}
.data-row .data-item {
    display: inline;
    margin-left: 2px;
    padding: 2px;
}
.mid-width {
    width: 450px;
}
div.grid {
    user-select: none;
    clear: both;
}
div.grid .header.row .cell {
    text-align: center
}
div.grid .row {
    clear: both;
}
div.grid .header.row .cell span {
    position: relative;
    top: 4px;
    left: 0px;
    font-size: 11pt;
}
div.grid .row .cell {
    float: left;
    box-sizing: border-box;
    border-right: 1px solid #AAAAAA;
    border-bottom: 1px solid #999999;
}
div.grid .row .cell.selected {
    float: left;
    box-sizing: border-box;
    border: 2px solid #2046df;
    border-radius: 4px;
}
div.grid .row .cell.selected span {
    position: relative;
    left: 3px;
    top: -1px;
    font-size: 16pt;
}
div.grid .row .cell span {
    position: relative;
    left: 5px;
    top: 1px;
    font-size: 16pt;
}
`;
      Grid.Cell = Grid.Grid_Cell = Grid_Cell;
      module.exports = Grid;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/color-grid.js
  var require_color_grid = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/color-grid.js"(exports, module) {
      var jsgui = require_html_core();
      var Grid = require_grid();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var v_subtract2 = jsgui.util.v_subtract;
      var {
        field,
        prop
      } = require_oext();
      var Color_Grid = class extends Grid {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "color_grid";
          super(spec);
          this.add_class("color-grid");
          this.internal_relative_div = true;
          prop(this, "palette", spec.palette);
          if (!spec.abstract && !spec.el) {
            this.compose_color_palette_grid();
          }
          this.on("resize", (e_resize) => {
            if (this.grid) {
              var _2_padding = 12;
              var new_grid_size = v_subtract2(e_resize.value, [_2_padding, _2_padding]);
              this.grid.size = new_grid_size;
            }
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            this.grid.selection_scope.on("change", (e) => {
              const {
                name,
                value: value2
              } = e;
              if (name === "selected") {
                const selected_ctrl = value2;
                if (selected_ctrl) {
                  let color = selected_ctrl._color;
                  this.raise("choose-color", {
                    value: color
                  });
                }
              }
            });
            const old_make_grid_cells_selectable = () => {
              this.grid.each_cell((cell) => {
              });
            };
          }
        }
        each_cell(cb) {
          return this.grid.each_cell(cb);
        }
        add_grid_cells() {
          if (this.palette) {
            let c2 = 0;
            this.grid.each_cell((cell) => {
              var item2 = this.palette[c2++];
              if (item2) {
                if (item2.hex) {
                  cell.color = item2.hex;
                } else {
                  if (typeof item2 === "string") {
                    cell.color = item2;
                  }
                }
              }
            });
          }
        }
        compose_color_palette_grid() {
          var padding = 6;
          const grid = this.grid = new Grid({
            "context": this.context,
            "grid_size": this.grid_size,
            "size": this.size,
            "cell_selection": "single"
          });
          grid.each_cell((cell, [x, y]) => {
          });
          this.add(grid);
          this.add_grid_cells();
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.grid = grid;
        }
      };
      if (__require.main === module) {
        console.log("pal_crayola.length", pal_crayola.length);
      } else {
      }
      module.exports = Color_Grid;
    }
  });

  // ../jsgui3-html/html-core/arr_colors.js
  var require_arr_colors = __commonJS({
    "../jsgui3-html/html-core/arr_colors.js"(exports, module) {
      var pal_crayola2 = [
        {
          "hex": "#EFDECD",
          "name": "Almond",
          "rgb": "(239, 222, 205)"
        },
        {
          "hex": "#CD9575",
          "name": "Antique Brass",
          "rgb": "(205, 149, 117)"
        },
        {
          "hex": "#FDD9B5",
          "name": "Apricot",
          "rgb": "(253, 217, 181)"
        },
        {
          "hex": "#78DBE2",
          "name": "Aquamarine",
          "rgb": "(120, 219, 226)"
        },
        {
          "hex": "#87A96B",
          "name": "Asparagus",
          "rgb": "(135, 169, 107)"
        },
        {
          "hex": "#FFA474",
          "name": "Atomic Tangerine",
          "rgb": "(255, 164, 116)"
        },
        {
          "hex": "#FAE7B5",
          "name": "Banana Mania",
          "rgb": "(250, 231, 181)"
        },
        {
          "hex": "#9F8170",
          "name": "Beaver",
          "rgb": "(159, 129, 112)"
        },
        {
          "hex": "#FD7C6E",
          "name": "Bittersweet",
          "rgb": "(253, 124, 110)"
        },
        {
          "hex": "#000000",
          "name": "Black",
          "rgb": "(0,0,0)"
        },
        {
          "hex": "#ACE5EE",
          "name": "Blizzard Blue",
          "rgb": "(172, 229, 238)"
        },
        {
          "hex": "#1F75FE",
          "name": "Blue",
          "rgb": "(31, 117, 254)"
        },
        {
          "hex": "#A2A2D0",
          "name": "Blue Bell",
          "rgb": "(162, 162, 208)"
        },
        {
          "hex": "#6699CC",
          "name": "Blue Gray",
          "rgb": "(102, 153, 204)"
        },
        {
          "hex": "#0D98BA",
          "name": "Blue Green",
          "rgb": "(13, 152, 186)"
        },
        {
          "hex": "#7366BD",
          "name": "Blue Violet",
          "rgb": "(115, 102, 189)"
        },
        {
          "hex": "#DE5D83",
          "name": "Blush",
          "rgb": "(222, 93, 131)"
        },
        {
          "hex": "#CB4154",
          "name": "Brick Red",
          "rgb": "(203, 65, 84)"
        },
        {
          "hex": "#B4674D",
          "name": "Brown",
          "rgb": "(180, 103, 77)"
        },
        {
          "hex": "#FF7F49",
          "name": "Burnt Orange",
          "rgb": "(255, 127, 73)"
        },
        {
          "hex": "#EA7E5D",
          "name": "Burnt Sienna",
          "rgb": "(234, 126, 93)"
        },
        {
          "hex": "#B0B7C6",
          "name": "Cadet Blue",
          "rgb": "(176, 183, 198)"
        },
        {
          "hex": "#FFFF99",
          "name": "Canary",
          "rgb": "(255, 255, 153)"
        },
        {
          "hex": "#1CD3A2",
          "name": "Caribbean Green",
          "rgb": "(28, 211, 162)"
        },
        {
          "hex": "#FFAACC",
          "name": "Carnation Pink",
          "rgb": "(255, 170, 204)"
        },
        {
          "hex": "#DD4492",
          "name": "Cerise",
          "rgb": "(221, 68, 146)"
        },
        {
          "hex": "#1DACD6",
          "name": "Cerulean",
          "rgb": "(29, 172, 214)"
        },
        {
          "hex": "#BC5D58",
          "name": "Chestnut",
          "rgb": "(188, 93, 88)"
        },
        {
          "hex": "#DD9475",
          "name": "Copper",
          "rgb": "(221, 148, 117)"
        },
        {
          "hex": "#9ACEEB",
          "name": "Cornflower",
          "rgb": "(154, 206, 235)"
        },
        {
          "hex": "#FFBCD9",
          "name": "Cotton Candy",
          "rgb": "(255, 188, 217)"
        },
        {
          "hex": "#FDDB6D",
          "name": "Dandelion",
          "rgb": "(253, 219, 109)"
        },
        {
          "hex": "#2B6CC4",
          "name": "Denim",
          "rgb": "(43, 108, 196)"
        },
        {
          "hex": "#EFCDB8",
          "name": "Desert Sand",
          "rgb": "(239, 205, 184)"
        },
        {
          "hex": "#6E5160",
          "name": "Eggplant",
          "rgb": "(110, 81, 96)"
        },
        {
          "hex": "#CEFF1D",
          "name": "Electric Lime",
          "rgb": "(206, 255, 29)"
        },
        {
          "hex": "#71BC78",
          "name": "Fern",
          "rgb": "(113, 188, 120)"
        },
        {
          "hex": "#6DAE81",
          "name": "Forest Green",
          "rgb": "(109, 174, 129)"
        },
        {
          "hex": "#C364C5",
          "name": "Fuchsia",
          "rgb": "(195, 100, 197)"
        },
        {
          "hex": "#CC6666",
          "name": "Fuzzy Wuzzy",
          "rgb": "(204, 102, 102)"
        },
        {
          "hex": "#E7C697",
          "name": "Gold",
          "rgb": "(231, 198, 151)"
        },
        {
          "hex": "#FCD975",
          "name": "Goldenrod",
          "rgb": "(252, 217, 117)"
        },
        {
          "hex": "#A8E4A0",
          "name": "Granny Smith Apple",
          "rgb": "(168, 228, 160)"
        },
        {
          "hex": "#95918C",
          "name": "Gray",
          "rgb": "(149, 145, 140)"
        },
        {
          "hex": "#1CAC78",
          "name": "Green",
          "rgb": "(28, 172, 120)"
        },
        {
          "hex": "#1164B4",
          "name": "Green Blue",
          "rgb": "(17, 100, 180)"
        },
        {
          "hex": "#F0E891",
          "name": "Green Yellow",
          "rgb": "(240, 232, 145)"
        },
        {
          "hex": "#FF1DCE",
          "name": "Hot Magenta",
          "rgb": "(255, 29, 206)"
        },
        {
          "hex": "#B2EC5D",
          "name": "Inchworm",
          "rgb": "(178, 236, 93)"
        },
        {
          "hex": "#5D76CB",
          "name": "Indigo",
          "rgb": "(93, 118, 203)"
        },
        {
          "hex": "#CA3767",
          "name": "Jazzberry Jam",
          "rgb": "(202, 55, 103)"
        },
        {
          "hex": "#3BB08F",
          "name": "Jungle Green",
          "rgb": "(59, 176, 143)"
        },
        {
          "hex": "#FEFE22",
          "name": "Laser Lemon",
          "rgb": "(254, 254, 34)"
        },
        {
          "hex": "#FCB4D5",
          "name": "Lavender",
          "rgb": "(252, 180, 213)"
        },
        {
          "hex": "#FFF44F",
          "name": "Lemon Yellow",
          "rgb": "(255, 244, 79)"
        },
        {
          "hex": "#FFBD88",
          "name": "Macaroni and Cheese",
          "rgb": "(255, 189, 136)"
        },
        {
          "hex": "#F664AF",
          "name": "Magenta",
          "rgb": "(246, 100, 175)"
        },
        {
          "hex": "#AAF0D1",
          "name": "Magic Mint",
          "rgb": "(170, 240, 209)"
        },
        {
          "hex": "#CD4A4C",
          "name": "Mahogany",
          "rgb": "(205, 74, 76)"
        },
        {
          "hex": "#EDD19C",
          "name": "Maize",
          "rgb": "(237, 209, 156)"
        },
        {
          "hex": "#979AAA",
          "name": "Manatee",
          "rgb": "(151, 154, 170)"
        },
        {
          "hex": "#FF8243",
          "name": "Mango Tango",
          "rgb": "(255, 130, 67)"
        },
        {
          "hex": "#C8385A",
          "name": "Maroon",
          "rgb": "(200, 56, 90)"
        },
        {
          "hex": "#EF98AA",
          "name": "Mauvelous",
          "rgb": "(239, 152, 170)"
        },
        {
          "hex": "#FDBCB4",
          "name": "Melon",
          "rgb": "(253, 188, 180)"
        },
        {
          "hex": "#1A4876",
          "name": "Midnight Blue",
          "rgb": "(26, 72, 118)"
        },
        {
          "hex": "#30BA8F",
          "name": "Mountain Meadow",
          "rgb": "(48, 186, 143)"
        },
        {
          "hex": "#C54B8C",
          "name": "Mulberry",
          "rgb": "(197, 75, 140)"
        },
        {
          "hex": "#1974D2",
          "name": "Navy Blue",
          "rgb": "(25, 116, 210)"
        },
        {
          "hex": "#FFA343",
          "name": "Neon Carrot",
          "rgb": "(255, 163, 67)"
        },
        {
          "hex": "#BAB86C",
          "name": "Olive Green",
          "rgb": "(186, 184, 108)"
        },
        {
          "hex": "#FF7538",
          "name": "Orange",
          "rgb": "(255, 117, 56)"
        },
        {
          "hex": "#FF2B2B",
          "name": "Orange Red",
          "rgb": "(255, 43, 43)"
        },
        {
          "hex": "#F8D568",
          "name": "Orange Yellow",
          "rgb": "(248, 213, 104)"
        },
        {
          "hex": "#E6A8D7",
          "name": "Orchid",
          "rgb": "(230, 168, 215)"
        },
        {
          "hex": "#414A4C",
          "name": "Outer Space",
          "rgb": "(65, 74, 76)"
        },
        {
          "hex": "#FF6E4A",
          "name": "Outrageous Orange",
          "rgb": "(255, 110, 74)"
        },
        {
          "hex": "#1CA9C9",
          "name": "Pacific Blue",
          "rgb": "(28, 169, 201)"
        },
        {
          "hex": "#FFCFAB",
          "name": "Peach",
          "rgb": "(255, 207, 171)"
        },
        {
          "hex": "#C5D0E6",
          "name": "Periwinkle",
          "rgb": "(197, 208, 230)"
        },
        {
          "hex": "#FDDDE6",
          "name": "Piggy Pink",
          "rgb": "(253, 221, 230)"
        },
        {
          "hex": "#158078",
          "name": "Pine Green",
          "rgb": "(21, 128, 120)"
        },
        {
          "hex": "#FC74FD",
          "name": "Pink Flamingo",
          "rgb": "(252, 116, 253)"
        },
        {
          "hex": "#F78FA7",
          "name": "Pink Sherbet",
          "rgb": "(247, 143, 167)"
        },
        {
          "hex": "#8E4585",
          "name": "Plum",
          "rgb": "(142, 69, 133)"
        },
        {
          "hex": "#7442C8",
          "name": "Purple Heart",
          "rgb": "(116, 66, 200)"
        },
        {
          "hex": "#9D81BA",
          "name": "Purple Mountain's Majesty",
          "rgb": "(157, 129, 186)"
        },
        {
          "hex": "#FE4EDA",
          "name": "Purple Pizzazz",
          "rgb": "(254, 78, 218)"
        },
        {
          "hex": "#FF496C",
          "name": "Radical Red",
          "rgb": "(255, 73, 108)"
        },
        {
          "hex": "#D68A59",
          "name": "Raw Sienna",
          "rgb": "(214, 138, 89)"
        },
        {
          "hex": "#714B23",
          "name": "Raw Umber",
          "rgb": "(113, 75, 35)"
        },
        {
          "hex": "#FF48D0",
          "name": "Razzle Dazzle Rose",
          "rgb": "(255, 72, 208)"
        },
        {
          "hex": "#E3256B",
          "name": "Razzmatazz",
          "rgb": "(227, 37, 107)"
        },
        {
          "hex": "#EE204D",
          "name": "Red",
          "rgb": "(238,32 ,77 )"
        },
        {
          "hex": "#FF5349",
          "name": "Red Orange",
          "rgb": "(255, 83, 73)"
        },
        {
          "hex": "#C0448F",
          "name": "Red Violet",
          "rgb": "(192, 68, 143)"
        },
        {
          "hex": "#1FCECB",
          "name": "Robin's Egg Blue",
          "rgb": "(31, 206, 203)"
        },
        {
          "hex": "#7851A9",
          "name": "Royal Purple",
          "rgb": "(120, 81, 169)"
        },
        {
          "hex": "#FF9BAA",
          "name": "Salmon",
          "rgb": "(255, 155, 170)"
        },
        {
          "hex": "#FC2847",
          "name": "Scarlet",
          "rgb": "(252, 40, 71)"
        },
        {
          "hex": "#76FF7A",
          "name": "Screamin' Green",
          "rgb": "(118, 255, 122)"
        },
        {
          "hex": "#9FE2BF",
          "name": "Sea Green",
          "rgb": "(159, 226, 191)"
        },
        {
          "hex": "#A5694F",
          "name": "Sepia",
          "rgb": "(165, 105, 79)"
        },
        {
          "hex": "#8A795D",
          "name": "Shadow",
          "rgb": "(138, 121, 93)"
        },
        {
          "hex": "#45CEA2",
          "name": "Shamrock",
          "rgb": "(69, 206, 162)"
        },
        {
          "hex": "#FB7EFD",
          "name": "Shocking Pink",
          "rgb": "(251, 126, 253)"
        },
        {
          "hex": "#CDC5C2",
          "name": "Silver",
          "rgb": "(205, 197, 194)"
        },
        {
          "hex": "#80DAEB",
          "name": "Sky Blue",
          "rgb": "(128, 218, 235)"
        },
        {
          "hex": "#ECEABE",
          "name": "Spring Green",
          "rgb": "(236, 234, 190)"
        },
        {
          "hex": "#FFCF48",
          "name": "Sunglow",
          "rgb": "(255, 207, 72)"
        },
        {
          "hex": "#FD5E53",
          "name": "Sunset Orange",
          "rgb": "(253, 94, 83)"
        },
        {
          "hex": "#FAA76C",
          "name": "Tan",
          "rgb": "(250, 167, 108)"
        },
        {
          "hex": "#18A7B5",
          "name": "Teal Blue",
          "rgb": "(24, 167, 181)"
        },
        {
          "hex": "#EBC7DF",
          "name": "Thistle",
          "rgb": "(235, 199, 223)"
        },
        {
          "hex": "#FC89AC",
          "name": "Tickle Me Pink",
          "rgb": "(252, 137, 172)"
        },
        {
          "hex": "#DBD7D2",
          "name": "Timberwolf",
          "rgb": "(219, 215, 210)"
        },
        {
          "hex": "#17806D",
          "name": "Tropical Rain Forest",
          "rgb": "(23, 128, 109)"
        },
        {
          "hex": "#DEAA88",
          "name": "Tumbleweed",
          "rgb": "(222, 170, 136)"
        },
        {
          "hex": "#77DDE7",
          "name": "Turquoise Blue",
          "rgb": "(119, 221, 231)"
        },
        {
          "hex": "#FFFF66",
          "name": "Unmellow Yellow",
          "rgb": "(255, 255, 102)"
        },
        {
          "hex": "#926EAE",
          "name": "Violet (Purple)",
          "rgb": "(146, 110, 174)"
        },
        {
          "hex": "#324AB2",
          "name": "Violet Blue",
          "rgb": "(50, 74, 178)"
        },
        {
          "hex": "#F75394",
          "name": "Violet Red",
          "rgb": "(247, 83, 148)"
        },
        {
          "hex": "#FFA089",
          "name": "Vivid Tangerine",
          "rgb": "(255, 160, 137)"
        },
        {
          "hex": "#8F509D",
          "name": "Vivid Violet",
          "rgb": "(143, 80, 157)"
        },
        {
          "hex": "#FFFFFF",
          "name": "White",
          "rgb": "(255, 255, 255)"
        },
        {
          "hex": "#A2ADD0",
          "name": "Wild Blue Yonder",
          "rgb": "(162, 173, 208)"
        },
        {
          "hex": "#FF43A4",
          "name": "Wild Strawberry",
          "rgb": "(255, 67, 164)"
        },
        {
          "hex": "#FC6C85",
          "name": "Wild Watermelon",
          "rgb": "(252, 108, 133)"
        },
        {
          "hex": "#CDA4DE",
          "name": "Wisteria",
          "rgb": "(205, 164, 222)"
        },
        {
          "hex": "#FCE883",
          "name": "Yellow",
          "rgb": "(252, 232, 131)"
        },
        {
          "hex": "#C5E384",
          "name": "Yellow Green",
          "rgb": "(197, 227, 132)"
        },
        {
          "hex": "#FFAE42",
          "name": "Yellow Orange",
          "rgb": "(255, 174, 66)"
        }
      ];
      module.exports = pal_crayola2;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/color-palette.js
  var require_color_palette = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/color-palette.js"(exports, module) {
      var jsgui = require_html_core();
      var Color_Grid = require_color_grid();
      var { v_subtract: v_subtract2 } = jsgui;
      var Control2 = jsgui.Control;
      var {
        field,
        prop
      } = require_oext();
      var pal_crayola2 = require_arr_colors();
      var Color_Palette = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "color_palette";
          super(spec);
          this.add_class("color-palette");
          prop(this, "palette", spec.palette || pal_crayola2);
          prop(this, "grid_size", spec.grid_size || [12, 12]);
          if (!spec.abstract && !spec.el) {
            this.compose_color_grid();
          }
          this.on("resize", (e_resize) => {
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const attach_on_change_named_property_handler = (obj2, property_name, fn_handler) => {
              obj2.on("change", (e) => {
                if (property_name === e.name) {
                  fn_handler(e);
                }
              });
            };
            attach_on_change_named_property_handler(this, "selected", (e) => {
              const selected_ctrl = e.value;
              if (selected_ctrl) {
                let color = selected_ctrl._color;
                this.raise("choose-color", {
                  value: color
                });
              }
            });
            const old_make_grid_cells_selectable = () => {
              this.grid.each_cell((cell) => {
              });
            };
          }
        }
        compose_color_grid() {
          console.log("compose_color_grid");
          var padding = 6;
          const fg_bg_color_grid = new Color_Grid({
            "context": this.context,
            "grid_size": [2, 1],
            "size": [80, 40]
          });
          this.add(fg_bg_color_grid);
          const color_grid_pxsize = v_subtract2(this.size, [0, 46]);
          const color_grid = this.grid = new Color_Grid({
            "context": this.context,
            "grid_size": this.grid_size,
            "palette": this.palette,
            "size": color_grid_pxsize,
            "cell_selection": "single"
          });
          this.add(color_grid);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.color_grid = color_grid;
          this._ctrl_fields.fg_bg_color_grid = fg_bg_color_grid;
        }
      };
      if (__require.main === module) {
        console.log("pal_crayola.length", pal_crayola2.length);
      } else {
      }
      module.exports = Color_Palette;
    }
  });

  // ../jsgui3-html/control_mixins/input_base.js
  var require_input_base = __commonJS({
    "../jsgui3-html/control_mixins/input_base.js"(exports, module) {
      "use strict";
      var jsgui = require_html_core();
      var { tof } = jsgui;
      var { apply_focus_ring } = require_a11y();
      var resolve_input_element = (ctrl, options = {}) => {
        const option_el = options.input_el || ctrl._input_base_el;
        if (option_el) {
          if (option_el.dom && option_el.dom.el) return option_el.dom.el;
          return option_el;
        }
        const check_ctrl = ctrl._ctrl_fields && ctrl._ctrl_fields.check;
        if (check_ctrl && check_ctrl.dom && check_ctrl.dom.el) return check_ctrl.dom.el;
        return ctrl._native_el || ctrl._native_input_el || ctrl._native_check_el || ctrl._native_radio_el || (ctrl.dom ? ctrl.dom.el : null);
      };
      var normalize_value_mode = (ctrl, options = {}) => {
        if (options.value_mode) return options.value_mode;
        const el = resolve_input_element(ctrl, options);
        const type = el && el.type ? el.type : "";
        if (type === "checkbox" || type === "radio") return "checked";
        return "value";
      };
      var has_prop_descriptor = (ctrl, name) => {
        const own_descriptor = Object.getOwnPropertyDescriptor(ctrl, name);
        if (own_descriptor) return true;
        const proto = Object.getPrototypeOf(ctrl);
        if (!proto) return false;
        const proto_descriptor = Object.getOwnPropertyDescriptor(proto, name);
        return !!proto_descriptor;
      };
      var default_get_value = (ctrl, options = {}) => {
        const value_mode = normalize_value_mode(ctrl, options);
        const el = resolve_input_element(ctrl, options);
        if (value_mode === "checked") {
          if (el) return !!el.checked;
          if (typeof ctrl.checked !== "undefined") return !!ctrl.checked;
          return false;
        }
        if (el && typeof el.value !== "undefined") return el.value;
        if (ctrl.dom && ctrl.dom.attributes && ctrl.dom.attributes.value !== void 0) {
          return ctrl.dom.attributes.value;
        }
        return ctrl._input_base_value;
      };
      var default_set_value = (ctrl, value2, options = {}) => {
        const value_mode = normalize_value_mode(ctrl, options);
        const el = resolve_input_element(ctrl, options);
        ctrl._input_base_value = value2;
        if (value_mode === "checked") {
          const checked_value = !!value2;
          if (typeof ctrl.set_checked === "function") {
            ctrl.set_checked(checked_value);
            return;
          }
          if (el) {
            el.checked = checked_value;
            if (typeof el.setAttribute === "function") {
              el.setAttribute("aria-checked", checked_value ? "true" : "false");
            }
          }
          ctrl.checked = checked_value;
          return;
        }
        if (has_prop_descriptor(ctrl, "value") && !(ctrl.__mx && ctrl.__mx.input_base_value_property)) {
          ctrl.value = value2;
          return;
        }
        const value_str = value2 === void 0 || value2 === null ? "" : String(value2);
        if (ctrl.dom && ctrl.dom.attributes) {
          ctrl.dom.attributes.value = value_str;
        }
        if (el && typeof el.value !== "undefined") {
          el.value = value_str;
        }
      };
      var define_prop_if_missing = (ctrl, name, getter, setter) => {
        if (has_prop_descriptor(ctrl, name)) return;
        Object.defineProperty(ctrl, name, {
          configurable: true,
          enumerable: true,
          get: getter,
          set: setter
        });
      };
      var apply_input_base = (ctrl, options = {}) => {
        if (!ctrl) return;
        ctrl.__mx = ctrl.__mx || {};
        ctrl.__mx.input_base = true;
        const original_get_value = options.get_value || (typeof ctrl.get_value === "function" ? ctrl.get_value.bind(ctrl) : () => default_get_value(ctrl, options));
        const original_set_value = options.set_value || (typeof ctrl.set_value === "function" ? ctrl.set_value.bind(ctrl) : (value2) => default_set_value(ctrl, value2, options));
        const get_value = () => original_get_value();
        const set_value = (value2) => {
          const old_value = get_value();
          ctrl._input_base_setting = true;
          original_set_value(value2);
          ctrl._input_base_setting = false;
          const next_value = get_value();
          ctrl._input_base_value = next_value;
          if (next_value !== old_value) {
            ctrl.raise("value_change", {
              value: next_value,
              old_value
            });
          }
        };
        if (typeof ctrl.get_value !== "function") {
          ctrl.get_value = get_value;
        }
        if (typeof ctrl.set_value !== "function" || options.wrap_set_value !== false) {
          ctrl.set_value = set_value;
        }
        const ctrl_has_own_get_value = options.get_value || typeof ctrl.get_value === "function" && ctrl.get_value !== get_value;
        if (!ctrl_has_own_get_value) {
          const has_value_prop_before = has_prop_descriptor(ctrl, "value");
          define_prop_if_missing(ctrl, "value", () => get_value(), (value2) => {
            if (ctrl._input_base_setting) {
              ctrl._input_base_value = value2;
              return;
            }
            set_value(value2);
          });
          if (!has_value_prop_before) {
            ctrl.__mx.input_base_value_property = true;
          }
        }
        const set_flag = (name, value2) => {
          const value_bool = !!value2;
          ctrl[name] = value_bool;
          if (ctrl.dom && ctrl.dom.attributes) {
            if (value_bool) {
              ctrl.dom.attributes[name] = name;
            } else {
              delete ctrl.dom.attributes[name];
            }
          }
          const el = resolve_input_element(ctrl, options);
          if (el) {
            el[name] = value_bool;
            if (typeof el.setAttribute === "function") {
              if (value_bool) {
                el.setAttribute(name, name);
              } else {
                el.removeAttribute(name);
              }
            }
          }
        };
        if (options.disabled !== void 0) set_flag("disabled", options.disabled);
        if (options.readonly !== void 0) set_flag("readonly", options.readonly);
        if (options.required !== void 0) set_flag("required", options.required);
        define_prop_if_missing(ctrl, "disabled", () => !!ctrl.disabled, (value2) => set_flag("disabled", value2));
        define_prop_if_missing(ctrl, "readonly", () => !!ctrl.readonly, (value2) => set_flag("readonly", value2));
        define_prop_if_missing(ctrl, "required", () => !!ctrl.required, (value2) => set_flag("required", value2));
        if (typeof ctrl.focus !== "function") {
          ctrl.focus = () => {
            const el = resolve_input_element(ctrl, options);
            if (el && typeof el.focus === "function") el.focus();
          };
        }
        if (typeof ctrl.blur !== "function") {
          ctrl.blur = () => {
            const el = resolve_input_element(ctrl, options);
            if (el && typeof el.blur === "function") el.blur();
          };
        }
        if (typeof ctrl.select !== "function") {
          ctrl.select = () => {
            const el = resolve_input_element(ctrl, options);
            if (el && typeof el.select === "function") el.select();
          };
        }
        ctrl._get_input_element = ctrl._get_input_element || (() => resolve_input_element(ctrl, options));
        const attach_dom_listeners = () => {
          const el = ctrl._get_input_element();
          if (!el || typeof ctrl.add_dom_event_listener !== "function") return;
          const sync_value = (event_name) => {
            if (ctrl._input_base_setting) return;
            const next_value = get_value();
            if (next_value !== ctrl._input_base_value) {
              ctrl._input_base_value = next_value;
            }
            ctrl.raise(event_name, {
              name: "value",
              value: next_value
            });
          };
          ctrl.add_dom_event_listener("input", () => sync_value("input"));
          ctrl.add_dom_event_listener("change", () => sync_value("change"));
          ctrl.add_dom_event_listener("focus", () => {
            ctrl.raise("focus", {});
          });
          ctrl.add_dom_event_listener("blur", () => {
            ctrl.raise("blur", {});
          });
          if (options.apply_focus_ring) {
            apply_focus_ring(ctrl, options.focus_ring_options || {});
          }
        };
        if (options.wire_dom_events !== false) {
          if (ctrl.__active) {
            attach_dom_listeners();
          } else if (typeof ctrl.once_active === "function") {
            ctrl.once_active(attach_dom_listeners);
          } else if (typeof ctrl.on === "function") {
            ctrl.on("activate", attach_dom_listeners);
          }
        }
        if (ctrl._input_base_value === void 0) {
          ctrl._input_base_value = get_value();
        }
      };
      module.exports = {
        apply_input_base
      };
    }
  });

  // ../jsgui3-html/control_mixins/input_validation.js
  var require_input_validation = __commonJS({
    "../jsgui3-html/control_mixins/input_validation.js"(exports, module) {
      "use strict";
      var ensure_class = (ctrl, class_name) => {
        if (!ctrl || typeof ctrl.add_class !== "function") return;
        ctrl.add_class(class_name);
      };
      var remove_class = (ctrl, class_name) => {
        if (!ctrl || typeof ctrl.remove_class !== "function") return;
        ctrl.remove_class(class_name);
      };
      var get_input_element = (ctrl) => {
        if (!ctrl) return null;
        if (typeof ctrl._get_input_element === "function") {
          return ctrl._get_input_element();
        }
        return ctrl.dom ? ctrl.dom.el : null;
      };
      var apply_input_validation = (ctrl, options = {}) => {
        if (!ctrl) return;
        ctrl.__mx = ctrl.__mx || {};
        ctrl.__mx.input_validation = true;
        ctrl._validation_state = "none";
        ctrl._validation_message = "";
        ctrl._validators = options.validators ? options.validators.slice() : [];
        Object.defineProperty(ctrl, "validation_state", {
          get() {
            return ctrl._validation_state;
          }
        });
        Object.defineProperty(ctrl, "validation_message", {
          get() {
            return ctrl._validation_message;
          }
        });
        Object.defineProperty(ctrl, "is_valid", {
          get() {
            return ctrl._validation_state === "valid" || ctrl._validation_state === "none";
          }
        });
        ctrl.add_validator = function(validator) {
          if (typeof validator !== "function") return;
          ctrl._validators.push(validator);
        };
        ctrl.remove_validator = function(validator) {
          const index = ctrl._validators.indexOf(validator);
          if (index > -1) ctrl._validators.splice(index, 1);
        };
        ctrl.validate = async function() {
          const value2 = typeof ctrl.get_value === "function" ? ctrl.get_value() : ctrl.value;
          ctrl._set_validation_state("pending", "");
          for (const validator of ctrl._validators) {
            try {
              const result = await Promise.resolve(validator(value2, ctrl));
              if (result === false || result && result.valid === false) {
                const message = typeof result === "object" ? result.message : "";
                ctrl._set_validation_state("invalid", message);
                return { valid: false, message };
              }
            } catch (error2) {
              const message = error2 && error2.message ? error2.message : "Validation error";
              ctrl._set_validation_state("invalid", message);
              return { valid: false, message };
            }
          }
          const el = get_input_element(ctrl);
          if (el && typeof el.checkValidity === "function" && !el.checkValidity()) {
            const message = el.validationMessage || "Invalid value";
            ctrl._set_validation_state("invalid", message);
            return { valid: false, message };
          }
          ctrl._set_validation_state("valid", "");
          return { valid: true };
        };
        ctrl.clear_validation = function() {
          ctrl._set_validation_state("none", "");
        };
        ctrl._set_validation_state = function(state, message) {
          const old_state = ctrl._validation_state;
          ctrl._validation_state = state;
          ctrl._validation_message = message;
          remove_class(ctrl, "validation-none");
          remove_class(ctrl, "validation-valid");
          remove_class(ctrl, "validation-invalid");
          remove_class(ctrl, "validation-pending");
          ensure_class(ctrl, `validation-${state}`);
          const el = get_input_element(ctrl);
          if (el && typeof el.setAttribute === "function") {
            el.setAttribute("aria-invalid", state === "invalid" ? "true" : "false");
          }
          if (state !== old_state) {
            ctrl.raise("validation_change", {
              state,
              message,
              old_state
            });
          }
        };
        if (options.validate_on_change && typeof ctrl.on === "function") {
          ctrl.on("change", () => ctrl.validate());
        }
        if (options.validate_on_blur && typeof ctrl.on === "function") {
          ctrl.on("blur", () => ctrl.validate());
        }
      };
      var validators = {
        required: (value2) => ({
          valid: value2 !== "" && value2 !== null && value2 !== void 0,
          message: "This field is required"
        }),
        min_length: (min) => (value2) => ({
          valid: String(value2 || "").length >= min,
          message: `Must be at least ${min} characters`
        }),
        max_length: (max) => (value2) => ({
          valid: String(value2 || "").length <= max,
          message: `Must be no more than ${max} characters`
        }),
        pattern: (regex, message = "Invalid format") => (value2) => ({
          valid: regex.test(String(value2 || "")),
          message
        }),
        email: (value2) => ({
          valid: /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(value2 || "")),
          message: "Invalid email address"
        }),
        number_range: (min, max) => (value2) => {
          const num = Number(value2);
          return {
            valid: !Number.isNaN(num) && num >= min && num <= max,
            message: `Must be between ${min} and ${max}`
          };
        },
        custom: (fn, message) => (value2) => ({
          valid: fn(value2),
          message
        })
      };
      module.exports = {
        apply_input_validation,
        validators
      };
    }
  });

  // ../jsgui3-html/control_mixins/input_api.js
  var require_input_api = __commonJS({
    "../jsgui3-html/control_mixins/input_api.js"(exports, module) {
      "use strict";
      var apply_full_input_api = (ctrl, options = {}) => {
        const { apply_input_base } = require_input_base();
        const { apply_input_validation } = require_input_validation();
        apply_input_base(ctrl, options);
        apply_input_validation(ctrl, options);
      };
      module.exports = {
        apply_full_input_api
      };
    }
  });

  // ../jsgui3-html/control_mixins/swap_registry.js
  var require_swap_registry = __commonJS({
    "../jsgui3-html/control_mixins/swap_registry.js"(exports, module) {
      "use strict";
      var swap_registry = /* @__PURE__ */ new Map();
      function register_swap(native_selector, control_class, options = {}) {
        if (typeof native_selector !== "string" || !native_selector.trim()) {
          throw new Error("register_swap requires a non-empty selector string.");
        }
        if (!control_class) {
          throw new Error("register_swap requires a control class.");
        }
        const predicate = typeof options.predicate === "function" ? options.predicate : () => true;
        const priority = Number.isFinite(options.priority) ? options.priority : 0;
        const enhancement_mode = options.enhancement_mode || "full";
        const config = {
          control_class,
          priority,
          predicate,
          enhancement_mode
        };
        swap_registry.set(native_selector, config);
        return config;
      }
      function get_swap(element) {
        if (!element || typeof element.matches !== "function") return null;
        let matched = null;
        let matched_priority = Number.NEGATIVE_INFINITY;
        for (const [selector, config] of swap_registry) {
          if (!element.matches(selector)) continue;
          if (config.predicate && !config.predicate(element)) continue;
          const priority = Number.isFinite(config.priority) ? config.priority : 0;
          if (matched === null || priority > matched_priority) {
            matched = config;
            matched_priority = priority;
          }
        }
        return matched;
      }
      function unregister_swap(native_selector) {
        return swap_registry.delete(native_selector);
      }
      function get_all_swaps() {
        return Array.from(swap_registry.entries());
      }
      function clear_swaps() {
        swap_registry.clear();
      }
      module.exports = {
        register_swap,
        unregister_swap,
        get_swap,
        get_all_swaps,
        clear_swaps,
        swap_registry
      };
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/checkbox.js
  var require_checkbox = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/checkbox.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var { apply_full_input_api } = require_input_api();
      var Checkbox = class extends Control2 {
        constructor(spec, add, make) {
          var _a;
          spec = spec || {};
          super(spec);
          this.__type_name = "checkbox";
          this.add_class("checkbox");
          const context2 = this.context;
          const enhance_only = !!spec.enhance_only && !!spec.el;
          const has_checked = is_defined(spec.checked);
          const initial_checked = has_checked ? !!spec.checked : enhance_only ? !!spec.el.checked : false;
          this.checked = initial_checked;
          if (enhance_only) {
            this._native_check_el = spec.el;
            this._input_base_el = spec.el;
          }
          if (!spec.abstract && !spec.el) {
            const name = this.name;
            const html_check = new Control2({
              "context": context2
            });
            html_check.dom.tagName = "input";
            html_check.dom.attributes.type = "checkbox";
            html_check.dom.attributes.name = name;
            html_check.dom.attributes.id = html_check._id();
            if (has_checked && initial_checked) {
              html_check.dom.attributes.checked = "checked";
            }
            html_check.dom.attributes["aria-checked"] = initial_checked ? "true" : "false";
            var html_label = new Control2({
              "context": context2
            });
            html_label.dom.tagName = "label";
            if (is_defined(spec.text)) {
              html_label.add(spec.text);
            } else {
              if (is_defined((_a = spec.label) == null ? void 0 : _a.text)) html_label.add(spec.label.text);
            }
            html_label.dom.attributes.for = html_check._id();
            this.add(html_check);
            this.add(html_label);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.check = html_check;
            this._ctrl_fields.label = html_label;
            this._input_base_el = html_check;
            this._fields = this._fields || {};
            if (is_defined(this.value)) this._fields.value = this.value;
            if (has_checked) this._fields.checked = this.checked;
            this.set_checked(initial_checked);
          }
          apply_full_input_api(this, {
            value_mode: "checked"
          });
          if (enhance_only) {
            this.set_checked(initial_checked);
          }
        }
        /**
         * Set the checked state.
         * @param {boolean} checked - The checked state.
         */
        set_checked(checked) {
          const next_checked = !!checked;
          this.checked = next_checked;
          this._fields = this._fields || {};
          this._fields.checked = next_checked;
          const html_check = this.check || this._ctrl_fields && this._ctrl_fields.check;
          const native_check = this._native_check_el || this.dom && this.dom.el;
          if (html_check) {
            html_check.dom.attributes["aria-checked"] = next_checked ? "true" : "false";
            if (next_checked) {
              html_check.dom.attributes.checked = "checked";
            } else {
              html_check.dom.attributes.checked = "";
            }
            if (html_check.dom.el) {
              html_check.dom.el.checked = next_checked;
            }
          } else if (native_check) {
            if (typeof native_check.setAttribute === "function") {
              native_check.setAttribute("aria-checked", next_checked ? "true" : "false");
              if (next_checked) {
                native_check.setAttribute("checked", "checked");
              } else {
                native_check.removeAttribute("checked");
              }
            }
            native_check.checked = next_checked;
          }
        }
        /**
         * Get the checked state.
         * @returns {boolean}
         */
        get_checked() {
          return !!this.checked;
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            super.activate();
            var html_check = this.check || this._ctrl_fields && this._ctrl_fields.check;
            var el_checkbox = html_check && html_check.dom ? html_check.dom.el : null;
            if (!el_checkbox) {
              el_checkbox = this._native_check_el || this.dom && this.dom.el;
            }
            if (!el_checkbox) return;
            const handle_change = () => {
              const checked = !!el_checkbox.checked;
              this.set_checked(checked);
              this.raise("change", {
                name: "checked",
                value: checked
              });
            };
            if (html_check) {
              html_check.on("change", handle_change);
            } else {
              this.add_dom_event_listener("change", handle_change);
            }
          }
        }
      };
      Checkbox.css = `
.checkbox input + label {
    margin-left: 6px;
}
.checkbox input:focus-visible + label {
    outline: 2px solid currentColor;
    outline-offset: 2px;
}
`;
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="checkbox"]', Checkbox, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Checkbox;
    }
  });

  // ../jsgui3-html/control_mixins/input_mask.js
  var require_input_mask = __commonJS({
    "../jsgui3-html/control_mixins/input_mask.js"(exports, module) {
      var jsgui = require_html_core();
      var { is_defined } = jsgui;
      var strip_non_digits = (value2) => String(value2 || "").replace(/\D/g, "");
      var strip_currency = (value2) => String(value2 || "").replace(/[^0-9.]/g, "");
      var format_date = (raw) => {
        const digits = strip_non_digits(raw).slice(0, 8);
        const year = digits.slice(0, 4);
        const month = digits.slice(4, 6);
        const day = digits.slice(6, 8);
        if (!month) return year;
        if (!day) return `${year}-${month}`;
        return `${year}-${month}-${day}`;
      };
      var parse_date = (value2) => strip_non_digits(value2).slice(0, 8);
      var format_phone = (raw) => {
        const digits = strip_non_digits(raw).slice(0, 10);
        const area = digits.slice(0, 3);
        const exchange = digits.slice(3, 6);
        const line = digits.slice(6, 10);
        if (!exchange) return area;
        if (!line) return `(${area}) ${exchange}`;
        return `(${area}) ${exchange}-${line}`;
      };
      var parse_phone = (value2) => strip_non_digits(value2).slice(0, 10);
      var format_currency = (raw) => {
        const cleaned = strip_currency(raw);
        const parts = cleaned.split(".");
        const whole = parts[0] || "0";
        const fraction_raw = parts[1] || "";
        const fraction = fraction_raw.slice(0, 2).padEnd(2, "0");
        const normalized_whole = whole.replace(/^0+(?=\d)/, "");
        const with_commas = normalized_whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return `${with_commas || "0"}.${fraction}`;
      };
      var parse_currency = (value2) => {
        const cleaned = strip_currency(value2);
        const parts = cleaned.split(".");
        const whole = parts[0] || "0";
        const fraction = (parts[1] || "").slice(0, 2);
        return fraction ? `${whole}.${fraction}` : whole;
      };
      var DEFAULT_MASKS = {
        date: {
          format: format_date,
          parse: parse_date
        },
        phone: {
          format: format_phone,
          parse: parse_phone
        },
        currency: {
          format: format_currency,
          parse: parse_currency
        }
      };
      var resolve_mask = (mask_type, mask_pattern) => {
        if (mask_pattern) {
          if (typeof mask_pattern === "function") {
            return {
              format: mask_pattern,
              parse: (value2) => value2
            };
          }
          if (mask_pattern && typeof mask_pattern === "object") {
            return {
              format: mask_pattern.format || ((value2) => value2),
              parse: mask_pattern.parse || ((value2) => value2)
            };
          }
        }
        if (mask_type && DEFAULT_MASKS[mask_type]) {
          return DEFAULT_MASKS[mask_type];
        }
        return null;
      };
      var apply_input_mask = (ctrl, spec = {}) => {
        const mask_type = spec.mask_type || spec.mask;
        const mask_pattern = spec.mask_pattern;
        const mask = resolve_mask(mask_type, mask_pattern);
        if (!mask) return ctrl;
        ctrl.mask_type = mask_type;
        ctrl.raw_value = "";
        ctrl.apply_input_mask_value = (value2) => {
          const parsed = mask.parse ? mask.parse(value2) : value2;
          const raw_value = is_defined(parsed) ? String(parsed) : "";
          const masked = mask.format ? mask.format(raw_value) : raw_value;
          ctrl.raw_value = raw_value;
          return masked;
        };
        ctrl.get_raw_value = () => ctrl.raw_value || "";
        ctrl.set_raw_value = (value2) => {
          const masked = ctrl.apply_input_mask_value(value2);
          if (ctrl.dom && ctrl.dom.el) {
            ctrl.dom.el.value = masked;
          }
          if (is_defined(ctrl.value)) {
            ctrl.value = masked;
          }
          if (ctrl.view && ctrl.view.data && ctrl.view.data.model) {
            ctrl.view.data.model.value = masked;
          }
          return masked;
        };
        return ctrl;
      };
      module.exports = apply_input_mask;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/Text_Input.js
  var require_Text_Input = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/Text_Input.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var { Control: Control2, Control_Data, Control_View, Data_Object, Data_Model, Data_Value: Data_Value2 } = jsgui;
      var { prop, field } = require_oext();
      var apply_input_mask = require_input_mask();
      var { apply_full_input_api } = require_input_api();
      var { themeable } = require_themeable();
      var { apply_token_map } = require_token_maps();
      var Text_Input = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "text_input";
          spec.class = "text-input";
          super(spec);
          const { context: context2 } = this;
          const params = themeable(this, "text_input", spec);
          apply_token_map(this, "input", params);
          this.enhance_only = !!spec.enhance_only && !!spec.el;
          apply_input_mask(this, spec || {});
          apply_full_input_api(this, {
            disabled: spec.disabled,
            readonly: spec.readonly,
            required: spec.required
          });
          if (spec.placeholder) this.placeholder = spec.placeholder;
          if (this.placeholder) {
            this.dom.attributes.placeholder = this.placeholder;
          }
          if (!spec.el) {
          }
          const view_data_model_change_handler = (e) => {
            const { name, value: value2, old } = e;
            if (name === "value") {
              const masked_value = this.apply_input_mask_value ? this.apply_input_mask_value(value2) : value2;
              this.dom.attributes.value = masked_value;
              if (this.dom.el) {
                this.dom.el.value = masked_value + "";
              }
              this.data.model.value = masked_value;
            }
          };
          this.view.data.model.on("change", view_data_model_change_handler);
          this.view.data.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (name === "model") {
              if (old instanceof Data_Model) {
                old.off("change", view_data_model_change_handler);
              }
              value2.on("change", view_data_model_change_handler);
            }
          });
          const data_model_change_handler = (e) => {
            const { name, value: value2, old } = e;
            if (name === "value") {
              this.view.data.model.value = value2;
            }
          };
          this.data.model.on("change", data_model_change_handler);
          const setup_handle_data_model_itself_changing = () => {
            this.data.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "model") {
                if (old instanceof Data_Model) {
                  old.off("change", data_model_change_handler);
                }
                if (value2 instanceof Data_Model) {
                  value2.on("change", data_model_change_handler);
                }
              }
            });
          };
          setup_handle_data_model_itself_changing();
          if (this.data.model.value !== void 0) {
            this.view.data.model.value = this.data.model.value;
          }
          if (spec.value !== void 0) {
            if (this.data && this.data.model && typeof this.data.model.set === "function") {
              this.data.model.set("value", spec.value, true);
            } else {
              this.data.model.value = spec.value;
            }
            this.dom.attributes.value = spec.value;
          }
          this.dom.tagName = "input";
          this.dom.attributes.type = "text";
        }
        get value() {
          return this.data.model.value;
        }
        set value(v) {
          this.data.model.value = v;
        }
        /*
            compose_text_input() {
        
                // More like the DOM settings rather than composition.
        
                
        
                // And it's placeholder text
                //   That's not part of the data model.
                //   Maybe it's the presentation data model? Presentation model?
        
        
        
                // ui.data.model perhaps....
                // ui.model perhaps???
                //   want some kind of consistency to calling things data models.
        
        
                //   And would define types there.
                
        
        
                // ui is the presentation basically.
        
        
        
        
        
                if (this.placeholder) this.dom.attributes.placeholder = this.placeholder;
        
        
            }
            */
        // A ll getter for the string value???
        // ll_value???
        // ll_value_type???
        activate() {
          if (!this.__active) {
            super.activate();
            const { dom } = this;
            this.view.data.model.value = dom.el.value;
            const activate_sync_dom_to_view_ui_ll_data_model = () => {
              const dm = this.view.ui.ll.data.model;
              this.add_dom_event_listener("change", (e) => {
                dm.value = dom.el.value;
              });
              this.add_dom_event_listener("keypress", (e_keypress) => {
                dm.value = dom.el.value;
              });
              this.add_dom_event_listener("keyup", (e_keyup) => {
                dm.value = dom.el.value;
              });
              this.add_dom_event_listener("keydown", (e_keydown) => {
                dm.value = dom.el.value;
              });
            };
            const handle_change_event = (e) => {
              const masked_value = this.apply_input_mask_value ? this.apply_input_mask_value(dom.el.value) : dom.el.value;
              if (dom.el.value !== masked_value) {
                dom.el.value = masked_value;
              }
              this.view.data.model.value = masked_value;
            };
            const activate_sync_dom_to_view_ll_data_model = () => {
              this.add_dom_event_listener("change", (e) => {
                handle_change_event(e);
              });
              this.add_dom_event_listener("keypress", (e) => {
                handle_change_event(e);
              });
              this.add_dom_event_listener("keyup", (e) => {
                handle_change_event(e);
              });
              this.add_dom_event_listener("keydown", (e) => {
                handle_change_event(e);
              });
            };
            activate_sync_dom_to_view_ll_data_model();
          }
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="text"], input:not([type])', Text_Input, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Text_Input;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/icon.js
  var require_icon = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/icon.js"(exports, module) {
      var jsgui = require_html_core();
      var {
        Control: Control2,
        parse_mount,
        parse,
        field
      } = jsgui;
      var Icon = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "icon";
          let size = spec.size = spec.size || [64, 64];
          super(spec);
          const {
            context: context2
          } = this;
          this.add_class("icon");
          field(this, "key", spec.icon_key || spec.key);
          const compose = () => {
            const {
              key: key2
            } = this;
            const imgurl = "/img/icons/" + key2;
            const img = new jsgui.img({
              context: context2,
              size: [64, 64]
            });
            img.dom.attributes.src = imgurl;
            this.add(img);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.img = img;
          };
          if (!spec.el) {
            compose();
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const {
              img
            } = this;
            this.on("change", ({
              name,
              value: value2
            }) => {
              if (name === "key") {
                const imgurl = "/img/icons/" + value2;
                img.dom.attributes.src = imgurl;
              }
            });
          }
        }
      };
      module.exports = Icon;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/item.js
  var require_item = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/item.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2, controls, tf: tf2, are_equal, each } = jsgui;
      var { span } = controls;
      var { prop, field } = require_oext();
      var Icon = require_icon();
      var c_left_right = (context2, l_content, r_content) => {
        const left = new Control2({
          context: context2,
          class: "left"
        });
        left.add(l_content);
        const right = new Control2({
          context: context2,
          class: "right"
        });
        right.add(r_content);
        const res2 = [left, right];
        return res2;
      };
      var Item = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "item";
          super(spec);
          this.add_class("item");
          const { context: context2 } = this;
          const item_value = typeof spec.value !== "undefined" ? spec.value : spec.item;
          const compose_item = () => {
            const t_item = tf2(item_value);
            if (t_item === "s" || t_item === "n" || t_item === "b") {
              this.add(String(item_value));
              return;
            }
            if (item_value && (item_value instanceof Control2 || item_value.__type === "control")) {
              this.add(item_value);
              return;
            }
            if (t_item === "o" && item_value) {
              const item_keys = Object.keys(item_value).sort();
              if (item_keys.length === 2 && are_equal(item_keys, ["icon", "text"])) {
                const main_content = new span({ context: context2 });
                main_content.add(item_value.text);
                const lr = c_left_right(context2, new Icon({
                  context: context2,
                  key: item_value.icon,
                  size: [64, 64]
                }), main_content);
                each(lr, (ctrl) => this.add(ctrl));
                return;
              }
              if (typeof item_value.text !== "undefined") {
                this.add(String(item_value.text));
                return;
              }
              this.add(JSON.stringify(item_value));
              return;
            }
            if (t_item === "a") {
              this.add(JSON.stringify(item_value));
            }
          };
          if (!spec.el && typeof item_value !== "undefined") {
            compose_item();
          }
        }
      };
      module.exports = Item;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/item_utils.js
  var require_item_utils = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/item_utils.js"(exports, module) {
      var is_defined = (value2) => value2 !== void 0 && value2 !== null;
      var is_plain_object = (value2) => {
        if (!value2 || typeof value2 !== "object") return false;
        if (Array.isArray(value2)) return false;
        return true;
      };
      var normalize_item = (raw_item, index, options = {}) => {
        const id_prefix = options.id_prefix || "item";
        const value_key = options.value_key || "value";
        const label_key = options.label_key || "label";
        let value2 = raw_item;
        let label = raw_item;
        let disabled = false;
        let id = void 0;
        if (Array.isArray(raw_item)) {
          value2 = raw_item[0];
          label = raw_item.length > 1 ? raw_item[1] : raw_item[0];
        } else if (is_plain_object(raw_item)) {
          if (is_defined(raw_item[value_key])) value2 = raw_item[value_key];
          if (is_defined(raw_item[label_key])) label = raw_item[label_key];
          if (is_defined(raw_item.text) && !is_defined(label)) label = raw_item.text;
          if (is_defined(raw_item.value) && !is_defined(value2)) value2 = raw_item.value;
          if (is_defined(raw_item.label) && !is_defined(label)) label = raw_item.label;
          if (is_defined(raw_item.id)) id = raw_item.id;
          if (is_defined(raw_item.dom_id) && !is_defined(id)) id = raw_item.dom_id;
          disabled = !!raw_item.disabled;
        }
        if (!is_defined(label)) label = value2;
        const normalized_id = is_defined(id) ? String(id) : `${id_prefix}-${index}`;
        return {
          id: normalized_id,
          value: value2,
          label: is_defined(label) ? String(label) : "",
          disabled: !!disabled,
          original: raw_item,
          index
        };
      };
      var normalize_items = (raw_items, options = {}) => {
        if (!Array.isArray(raw_items)) return [];
        return raw_items.map((raw_item, index) => normalize_item(raw_item, index, options));
      };
      var find_item_by_value = (items, value2) => {
        if (!Array.isArray(items)) return void 0;
        return items.find((item2) => item2.value === value2 || String(item2.value) === String(value2));
      };
      var filter_items = (items, filter_text) => {
        if (!Array.isArray(items)) return [];
        if (!is_defined(filter_text) || filter_text === "") return items.slice();
        const needle = String(filter_text).toLowerCase();
        return items.filter((item2) => {
          const label = String(item2.label || "").toLowerCase();
          const value2 = String(item2.value || "").toLowerCase();
          return label.includes(needle) || value2.includes(needle);
        });
      };
      module.exports = {
        normalize_item,
        normalize_items,
        find_item_by_value,
        filter_items
      };
    }
  });

  // ../jsgui3-html/control_mixins/keyboard_navigation.js
  var require_keyboard_navigation = __commonJS({
    "../jsgui3-html/control_mixins/keyboard_navigation.js"(exports, module) {
      var clamp_index = (value2, max_index, options = {}) => {
        if (!Number.isFinite(value2)) return 0;
        if (options.wrap && max_index >= 0) {
          const normalized = (value2 % (max_index + 1) + (max_index + 1)) % (max_index + 1);
          return normalized;
        }
        if (value2 < 0) return 0;
        if (value2 > max_index) return max_index;
        return value2;
      };
      var keyboard_navigation = (ctrl, options = {}) => {
        if (!ctrl) return null;
        const nav_state = ctrl._keyboard_nav_state || {};
        if (nav_state.applied) return nav_state;
        nav_state.applied = true;
        ctrl._keyboard_nav_state = nav_state;
        const get_items = typeof options.get_items === "function" ? options.get_items : () => [];
        const get_active_index = () => {
          if (typeof options.get_active_index === "function") {
            const idx = options.get_active_index();
            if (Number.isFinite(idx)) return idx;
          }
          return Number.isFinite(nav_state.active_index) ? nav_state.active_index : 0;
        };
        const apply_roving_tabindex = (items, active_index) => {
          if (!options.roving_tabindex) return;
          items.forEach((item2, idx) => {
            if (!item2 || !item2.dom) return;
            item2.dom.attributes = item2.dom.attributes || {};
            item2.dom.attributes.tabindex = idx === active_index ? "0" : "-1";
          });
        };
        const focus_item = (items, active_index) => {
          if (!options.focus_item) return;
          const item2 = items[active_index];
          if (item2 && item2.dom && item2.dom.el && typeof item2.dom.el.focus === "function") {
            item2.dom.el.focus();
          }
        };
        const set_active_index = (next_index, options_set = {}) => {
          const items = get_items();
          if (!items.length) return;
          const max_index = items.length - 1;
          const clamped = clamp_index(next_index, max_index, options);
          if (typeof options.set_active_index === "function") {
            options.set_active_index(clamped, options_set);
          } else {
            nav_state.active_index = clamped;
          }
          apply_roving_tabindex(items, clamped);
          focus_item(items, clamped);
        };
        const move_active = (delta) => {
          const items = get_items();
          if (!items.length) return;
          const current = get_active_index();
          const next = clamp_index(current + delta, items.length - 1, options);
          set_active_index(next, { from_keyboard: true });
        };
        const handle_keydown = (event) => {
          if (!event || !event.key) return;
          const key2 = event.key;
          const use_vertical = options.orientation === "vertical" || options.orientation === "both";
          const use_horizontal = options.orientation === "horizontal" || options.orientation === "both";
          if (key2 === "Home" && options.on_home) {
            event.preventDefault();
            options.on_home();
            return;
          }
          if (key2 === "End" && options.on_end) {
            event.preventDefault();
            options.on_end();
            return;
          }
          if (key2 === "ArrowUp" && use_vertical) {
            event.preventDefault();
            if (options.on_up) {
              options.on_up();
            } else {
              move_active(-1);
            }
            return;
          }
          if (key2 === "ArrowDown" && use_vertical) {
            event.preventDefault();
            if (options.on_down) {
              options.on_down();
            } else {
              move_active(1);
            }
            return;
          }
          if (key2 === "ArrowLeft" && use_horizontal) {
            event.preventDefault();
            if (options.on_left) {
              options.on_left();
            } else {
              move_active(-1);
            }
            return;
          }
          if (key2 === "ArrowRight" && use_horizontal) {
            event.preventDefault();
            if (options.on_right) {
              options.on_right();
            } else {
              move_active(1);
            }
            return;
          }
          if ((key2 === "Enter" || key2 === " ") && options.on_activate) {
            event.preventDefault();
            options.on_activate();
          }
        };
        nav_state.handle_keydown = handle_keydown;
        if (ctrl.add_dom_event_listener) {
          ctrl.add_dom_event_listener("keydown", handle_keydown);
        } else if (ctrl.dom && ctrl.dom.el) {
          ctrl.dom.el.addEventListener("keydown", handle_keydown);
        }
        return nav_state;
      };
      module.exports = keyboard_navigation;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/list.js
  var require_list = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/list.js"(exports, module) {
      var jsgui = require_html_core();
      var Item = require_item();
      var { each } = jsgui;
      var { prop } = require_lang();
      var { field } = require_oext();
      var {
        normalize_items,
        find_item_by_value,
        filter_items
      } = require_item_utils();
      var { Control: Control2, Control_Data, Control_View, Data_Object } = jsgui;
      var mx_selectable = require_selectable();
      var keyboard_navigation = require_keyboard_navigation();
      var {
        apply_focus_ring,
        apply_label
      } = require_a11y();
      var { themeable } = require_themeable();
      var { apply_token_map, SPACING_TOKENS } = require_token_maps();
      var List = class extends Control2 {
        constructor(spec = {}) {
          super(spec);
          this.__type_name = "list";
          const params = themeable(this, "list", spec);
          if (params.spacing && SPACING_TOKENS[params.spacing]) {
            this.dom.attributes.style = this.dom.attributes.style || {};
            Object.assign(this.dom.attributes.style, SPACING_TOKENS[params.spacing]);
          }
          prop(this, "ordered", spec.ordered || false);
          if (this.ordered) {
            this.dom.tagName = "ol";
          } else {
            this.dom.tagName = "ul";
          }
          this.add_class("list");
          this.items = [];
          this.filtered_items = [];
          this.filter_text = "";
          this.selected_item = null;
          this.selected_index = -1;
          this.multi_select = !!spec.multi_select;
          this.select_toggle = !!spec.select_toggle;
          this.aria_label = spec.aria_label;
          this.focusable = spec.focusable !== false;
          this.enable_keyboard = spec.enable_keyboard !== false;
          this.item_id_prefix = `${this._id()}-item`;
          this.item_controls = [];
          this.load_items_fn = typeof spec.load_items === "function" ? spec.load_items : null;
          this.auto_load = spec.auto_load !== false;
          this.construct_synchronised_data_and_view_models(spec);
          if (spec.items) {
            this.set_items(spec.items, { from_model: true });
          }
          if (spec.filter_text !== void 0) {
            this.set_filter_text(spec.filter_text, { from_model: true });
          }
          if (spec.selected_item !== void 0) {
            this.set_selected_item(spec.selected_item, { from_model: true });
          }
          if (this.focusable) {
            if (spec.tabindex !== void 0) {
              this.dom.attributes.tabindex = String(spec.tabindex);
            } else {
              this.dom.attributes.tabindex = "0";
            }
            apply_focus_ring(this);
          }
          if (this.aria_label !== void 0) {
            apply_label(this, this.aria_label);
          }
          if (!spec.el) {
            this.compose_list();
          }
        }
        construct_synchronised_data_and_view_models(spec) {
          const { context: context2 } = this;
          this.data = new Control_Data({ context: context2 });
          if (spec.data && spec.data.model) {
            this.data.model = spec.data.model;
          } else {
            this.data.model = new Data_Object({ context: context2 });
          }
          field(this.data.model, "items");
          field(this.data.model, "selected_item");
          field(this.data.model, "filter_text");
          this.view = new Control_View({ context: context2 });
          if (spec.view && spec.view.data && spec.view.data.model) {
            this.view.data.model = spec.view.data.model;
          } else {
            this.view.data.model = new Data_Object({ context: context2 });
          }
          field(this.view.data.model, "items");
          field(this.view.data.model, "selected_item");
          field(this.view.data.model, "filter_text");
          this.data.model.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (value2 === old) return;
            if (name === "items") {
              this.view.data.model.items = value2;
              this.set_items(value2, { from_model: true });
            } else if (name === "selected_item") {
              this.view.data.model.selected_item = value2;
              this.set_selected_item(value2, { from_model: true });
            } else if (name === "filter_text") {
              this.view.data.model.filter_text = value2;
              this.set_filter_text(value2, { from_model: true });
            }
          });
          this.view.data.model.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (value2 === old) return;
            if (name === "items") {
              this.data.model.items = value2;
              this.set_items(value2, { from_model: true });
            } else if (name === "selected_item") {
              this.data.model.selected_item = value2;
              this.set_selected_item(value2, { from_model: true });
            } else if (name === "filter_text") {
              this.data.model.filter_text = value2;
              this.set_filter_text(value2, { from_model: true });
            }
          });
        }
        /**
         * Set list items.
         * @param {Array} items - Items to set.
         * @param {Object} [options] - Optional settings.
         */
        set_items(items, options = {}) {
          this.items = normalize_items(items, { id_prefix: this.item_id_prefix });
          this.filtered_items = filter_items(this.items, this.filter_text);
          if (!options.from_model) {
            this.set_model_value("items", items);
          }
          this.compose_list();
        }
        /**
         * Set filter text for typeahead filtering.
         * @param {string} filter_text - Filter text.
         * @param {Object} [options] - Optional settings.
         */
        set_filter_text(filter_text, options = {}) {
          this.filter_text = filter_text || "";
          this.filtered_items = filter_items(this.items, this.filter_text);
          if (!options.from_model) {
            this.set_model_value("filter_text", this.filter_text);
          }
          this.compose_list();
        }
        /**
         * Set selected item.
         * @param {*} selected_item - Item or value to select.
         * @param {Object} [options] - Optional settings.
         */
        set_selected_item(selected_item, options = {}) {
          if (!selected_item) {
            this.selected_item = null;
          } else if (selected_item.value !== void 0) {
            this.selected_item = find_item_by_value(this.items, selected_item.value) || null;
          } else {
            this.selected_item = find_item_by_value(this.items, selected_item) || null;
          }
          if (!options.from_model) {
            this.set_model_value("selected_item", this.selected_item);
          }
          this.selected_index = this.selected_item ? this.filtered_items.findIndex((item2) => item2.id === this.selected_item.id) : -1;
          this.apply_selection_to_items();
          this.update_aria_active_descendant();
        }
        /**
         * Set selected item by value.
         * @param {*} value - Value to select.
         * @param {Object} [options] - Optional settings.
         */
        set_selected_value(value2, options = {}) {
          const matched_item = find_item_by_value(this.items, value2);
          this.set_selected_item(matched_item, options);
        }
        /**
         * Get selected item.
         * @returns {Object|null}
         */
        get_selected_item() {
          return this.selected_item || null;
        }
        /**
         * Set active index for keyboard navigation.
         * @param {number} index - Index to activate.
         * @param {Object} [options] - Optional settings.
         */
        set_active_index(index, options = {}) {
          if (index < 0 || index >= this.filtered_items.length) return;
          const item2 = this.filtered_items[index];
          this.selected_index = index;
          this.selected_item = item2;
          if (!options.from_model) {
            this.set_model_value("selected_item", item2);
          }
          this.apply_selection_to_items();
          this.update_aria_active_descendant();
          if (options.raise_change) {
            this.raise("change", {
              name: "selected_item",
              value: this.selected_item,
              index: this.selected_index
            });
          }
        }
        /**
         * Load items asynchronously using the configured loader.
         * @param {Object} [options] - Options passed to the loader.
         * @returns {Promise<Array>}
         */
        async load_items(options = {}) {
          if (!this.load_items_fn) return [];
          const loaded_items = await this.load_items_fn(options);
          this.set_items(loaded_items || []);
          return this.items;
        }
        set_model_value(name, value2) {
          if (this.data && this.data.model && this.data.model[name] !== value2) {
            this.data.model[name] = value2;
          }
          if (this.view && this.view.data && this.view.data.model && this.view.data.model[name] !== value2) {
            this.view.data.model[name] = value2;
          }
        }
        apply_selection_to_items() {
          if (!this.item_controls.length) return;
          each(this.item_controls, (ctrl_item) => {
            const item_id = ctrl_item._fields && ctrl_item._fields.item_id;
            const is_selected = !!(this.selected_item && item_id === this.selected_item.id);
            ctrl_item.dom.attributes["aria-selected"] = is_selected ? "true" : "false";
            if (ctrl_item.selected !== is_selected) {
              ctrl_item.selected = is_selected;
            }
          });
        }
        update_aria_active_descendant() {
          const active_item = this.selected_item;
          if (active_item && active_item.id) {
            this.dom.attributes["aria-activedescendant"] = active_item.id;
          } else {
            this.dom.attributes["aria-activedescendant"] = "";
          }
        }
        compose_list() {
          this.clear();
          this.dom.attributes.role = "listbox";
          if (this.multi_select) {
            this.dom.attributes["aria-multiselectable"] = "true";
          }
          this.item_controls = [];
          each(this.filtered_items, (item2, index) => {
            let display_value = item2.label;
            if (item2.original && typeof item2.original === "object" && !Array.isArray(item2.original)) {
              if (item2.original.icon || item2.original.text) {
                display_value = item2.original;
              }
            }
            const ctrl_item = new Item({
              context: this.context,
              value: display_value
            });
            ctrl_item._fields = ctrl_item._fields || {};
            ctrl_item._fields.index = index;
            ctrl_item._fields.item_id = item2.id;
            ctrl_item._fields.item_value = item2.value;
            ctrl_item.dom.attributes.id = item2.id;
            ctrl_item.dom.attributes["data-index"] = String(item2.index);
            ctrl_item.dom.attributes["data-value"] = String(item2.value);
            ctrl_item.dom.attributes.role = "option";
            ctrl_item.dom.attributes["aria-selected"] = "false";
            mx_selectable(ctrl_item, null, {
              multi: this.multi_select,
              toggle: this.select_toggle
            });
            ctrl_item.selectable = true;
            ctrl_item.on("change", (e_change) => {
              if (e_change.name === "selected" && e_change.value) {
                this.set_selected_item(item2, { from_model: true });
                this.raise("change", {
                  name: "selected_item",
                  value: this.selected_item,
                  index: this.selected_index
                });
              }
            });
            this.add(ctrl_item);
            this.item_controls.push(ctrl_item);
          });
          this.apply_selection_to_items();
          this.update_aria_active_descendant();
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const selection_scope = this.find_selection_scope();
            if (selection_scope && selection_scope.on) {
              selection_scope.on("change", (e_change) => {
                const selected_ctrl = e_change.value;
                if (selected_ctrl && selected_ctrl._fields && selected_ctrl._fields.item_id) {
                  const item2 = this.items.find((entry) => entry.id === selected_ctrl._fields.item_id);
                  if (item2) {
                    this.set_selected_item(item2, { from_model: true });
                  }
                } else {
                  this.set_selected_item(null, { from_model: true });
                }
                this.raise("change", {
                  name: "selected_item",
                  value: this.selected_item,
                  index: this.selected_index
                });
              });
            }
            if (this.auto_load && this.load_items_fn && !this.items.length) {
              this.load_items();
            }
            if (this.enable_keyboard) {
              keyboard_navigation(this, {
                orientation: "vertical",
                get_items: () => this.item_controls,
                get_active_index: () => this.selected_index,
                set_active_index: (index) => {
                  this.set_active_index(index, { from_model: true, raise_change: true });
                },
                on_activate: () => {
                  if (this.selected_item) {
                    this.raise("change", {
                      name: "selected_item",
                      value: this.selected_item,
                      index: this.selected_index
                    });
                  }
                }
              });
            }
          }
        }
      };
      module.exports = List;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/combo-box.js
  var require_combo_box = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/combo-box.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2, Control_Data, Control_View, Data_Object } = jsgui;
      var { field } = require_oext();
      var Text_Input = require_Text_Input();
      var List = require_list();
      var {
        normalize_items,
        find_item_by_value,
        filter_items
      } = require_item_utils();
      var {
        apply_focus_ring,
        apply_label
      } = require_a11y();
      var Combo_Box = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "combo_box";
          super(spec);
          this.add_class("combo-box");
          this.items = [];
          this.filtered_items = [];
          this.filter_text = "";
          this.selected_item = null;
          this.open = false;
          this.active_index = -1;
          this.item_id_prefix = `${this._id()}-combo-item`;
          this.load_items_fn = typeof spec.load_items === "function" ? spec.load_items : null;
          this.auto_load = spec.auto_load !== false;
          this.typeahead = spec.typeahead !== false;
          this.allow_custom_value = !!spec.allow_custom_value;
          this.placeholder = spec.placeholder || "";
          this.aria_label = spec.aria_label;
          this.construct_synchronised_data_and_view_models(spec);
          if (spec.items) {
            this.set_items(spec.items, { from_model: true });
          }
          if (spec.filter_text !== void 0) {
            this.set_filter_text(spec.filter_text, { from_model: true });
          }
          if (spec.value !== void 0) {
            this.set_selected_value(spec.value, { from_model: true });
          }
          if (spec.selected_item !== void 0) {
            this.set_selected_item(spec.selected_item, { from_model: true });
          }
          if (spec.open !== void 0) {
            this.set_open(!!spec.open, { from_model: true });
          }
          if (!spec.el) {
            this.compose_combo_box();
          }
        }
        construct_synchronised_data_and_view_models(spec) {
          const { context: context2 } = this;
          this.data = new Control_Data({ context: context2 });
          if (spec.data && spec.data.model) {
            this.data.model = spec.data.model;
          } else {
            this.data.model = new Data_Object({ context: context2 });
          }
          field(this.data.model, "value");
          field(this.data.model, "items");
          field(this.data.model, "filter_text");
          field(this.data.model, "selected_item");
          field(this.data.model, "open");
          this.view = new Control_View({ context: context2 });
          if (spec.view && spec.view.data && spec.view.data.model) {
            this.view.data.model = spec.view.data.model;
          } else {
            this.view.data.model = new Data_Object({ context: context2 });
          }
          field(this.view.data.model, "value");
          field(this.view.data.model, "items");
          field(this.view.data.model, "filter_text");
          field(this.view.data.model, "selected_item");
          field(this.view.data.model, "open");
          this.data.model.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (value2 === old) return;
            if (name === "value") {
              this.view.data.model.value = value2;
              this.set_selected_value(value2, { from_model: true });
            } else if (name === "items") {
              this.view.data.model.items = value2;
              this.set_items(value2, { from_model: true });
            } else if (name === "filter_text") {
              this.view.data.model.filter_text = value2;
              this.set_filter_text(value2, { from_model: true });
            } else if (name === "selected_item") {
              this.view.data.model.selected_item = value2;
              this.set_selected_item(value2, { from_model: true });
            } else if (name === "open") {
              this.view.data.model.open = value2;
              this.set_open(!!value2, { from_model: true });
            }
          });
          this.view.data.model.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (value2 === old) return;
            if (name === "value") {
              this.data.model.value = value2;
              this.set_selected_value(value2, { from_model: true });
            } else if (name === "items") {
              this.data.model.items = value2;
              this.set_items(value2, { from_model: true });
            } else if (name === "filter_text") {
              this.data.model.filter_text = value2;
              this.set_filter_text(value2, { from_model: true });
            } else if (name === "selected_item") {
              this.data.model.selected_item = value2;
              this.set_selected_item(value2, { from_model: true });
            } else if (name === "open") {
              this.data.model.open = value2;
              this.set_open(!!value2, { from_model: true });
            }
          });
        }
        compose_combo_box() {
          const { context: context2 } = this;
          const input_ctrl = new Text_Input({
            context: context2,
            placeholder: this.placeholder
          });
          input_ctrl.add_class("combo-box-input");
          input_ctrl.dom.attributes.role = "combobox";
          input_ctrl.dom.attributes["aria-autocomplete"] = this.typeahead ? "list" : "none";
          input_ctrl.dom.attributes["aria-expanded"] = this.open ? "true" : "false";
          input_ctrl.dom.attributes["aria-haspopup"] = "listbox";
          apply_focus_ring(input_ctrl);
          if (this.aria_label !== void 0) {
            apply_label(input_ctrl, this.aria_label);
          }
          const dropdown = new Control2({
            context: context2,
            class: "combo-box-dropdown"
          });
          const list_ctrl = new List({
            context: context2,
            items: this.items,
            focusable: false,
            enable_keyboard: false
          });
          list_ctrl.add_class("combo-box-list");
          list_ctrl.dom.attributes.id = `${this._id()}-list`;
          list_ctrl.dom.attributes.role = "listbox";
          dropdown.add(list_ctrl);
          if (!this.open) {
            dropdown.hide();
          }
          input_ctrl.dom.attributes["aria-controls"] = list_ctrl.dom.attributes.id;
          this.add(input_ctrl);
          this.add(dropdown);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.input = input_ctrl;
          this._ctrl_fields.dropdown = dropdown;
          this._ctrl_fields.list = list_ctrl;
          this.input = input_ctrl;
          this.dropdown = dropdown;
          this.list = list_ctrl;
          this.sync_input_to_selection();
          this.update_aria_active_descendant();
        }
        /**
         * Set items for the combo box.
         * @param {Array} items - Items to set.
         * @param {Object} [options] - Optional settings.
         */
        set_items(items, options = {}) {
          this.items = normalize_items(items, { id_prefix: this.item_id_prefix });
          this.filtered_items = filter_items(this.items, this.filter_text);
          if (!options.from_model) {
            this.set_model_value("items", items);
          }
          if (this.list && this.list.set_items) {
            this.list.set_items(this.items.map((item2) => ({
              value: item2.value,
              label: item2.label,
              id: item2.id,
              disabled: item2.disabled
            })), { from_model: true });
            if (this.list.set_filter_text) {
              this.list.set_filter_text(this.filter_text, { from_model: true });
            }
          }
          this.update_aria_active_descendant();
        }
        /**
         * Set filter text for typeahead filtering.
         * @param {string} filter_text - Filter text.
         * @param {Object} [options] - Optional settings.
         */
        set_filter_text(filter_text, options = {}) {
          this.filter_text = filter_text || "";
          this.filtered_items = filter_items(this.items, this.filter_text);
          if (!options.from_model) {
            this.set_model_value("filter_text", this.filter_text);
          }
          if (this.list && this.list.set_filter_text) {
            this.list.set_filter_text(this.filter_text, { from_model: true });
          }
        }
        /**
         * Set selected item by value.
         * @param {*} value - Selected value.
         * @param {Object} [options] - Optional settings.
         */
        set_selected_value(value2, options = {}) {
          const matched_item = find_item_by_value(this.items, value2);
          if (matched_item) {
            this.selected_item = matched_item;
            this.active_index = this.filtered_items.findIndex((item2) => item2.id === matched_item.id);
          } else {
            this.selected_item = null;
            this.active_index = -1;
          }
          if (!options.from_model) {
            this.set_model_value("value", value2);
            this.set_model_value("selected_item", this.selected_item);
          }
          this.sync_input_to_selection();
          this.update_aria_active_descendant();
        }
        /**
         * Set selected item directly.
         * @param {Object} item - Selected item.
         * @param {Object} [options] - Optional settings.
         */
        set_selected_item(item2, options = {}) {
          if (!item2) {
            this.selected_item = null;
            this.active_index = -1;
          } else {
            const matched_item = item2.value !== void 0 ? find_item_by_value(this.items, item2.value) : find_item_by_value(this.items, item2);
            this.selected_item = matched_item || null;
            this.active_index = matched_item ? this.filtered_items.findIndex((entry) => entry.id === matched_item.id) : -1;
          }
          if (!options.from_model) {
            const next_value = this.selected_item ? this.selected_item.value : "";
            this.set_model_value("value", next_value);
            this.set_model_value("selected_item", this.selected_item);
          }
          this.sync_input_to_selection();
          this.update_aria_active_descendant();
        }
        /**
         * Set open state for the dropdown.
         * @param {boolean} open - Whether the dropdown is open.
         * @param {Object} [options] - Optional settings.
         */
        set_open(open, options = {}) {
          this.open = !!open;
          if (!options.from_model) {
            this.set_model_value("open", this.open);
          }
          if (this.dropdown) {
            if (this.open) {
              this.dropdown.show();
            } else {
              this.dropdown.hide();
            }
          }
          if (this.input) {
            this.input.dom.attributes["aria-expanded"] = this.open ? "true" : "false";
          }
        }
        /**
         * Load items asynchronously using the configured loader.
         * @param {Object} [options] - Options passed to the loader.
         * @returns {Promise<Array>}
         */
        async load_items(options = {}) {
          if (!this.load_items_fn) return [];
          const loaded_items = await this.load_items_fn(options);
          this.set_items(loaded_items || []);
          return this.items;
        }
        /**
         * Get the selected value.
         * @returns {*}
         */
        get_value() {
          return this.selected_item ? this.selected_item.value : "";
        }
        /**
         * Set the selected value.
         * @param {*} value - Value to set.
         */
        set_value(value2) {
          this.set_selected_value(value2);
        }
        set_model_value(name, value2) {
          if (this.data && this.data.model && this.data.model[name] !== value2) {
            this.data.model[name] = value2;
          }
          if (this.view && this.view.data && this.view.data.model && this.view.data.model[name] !== value2) {
            this.view.data.model[name] = value2;
          }
        }
        update_aria_active_descendant() {
          if (!this.input) return;
          const active_item = this.selected_item;
          if (active_item && active_item.id) {
            this.input.dom.attributes["aria-activedescendant"] = active_item.id;
          } else {
            this.input.dom.attributes["aria-activedescendant"] = "";
          }
        }
        sync_input_to_selection() {
          if (!this.input) return;
          let next_value = "";
          if (this.selected_item) {
            next_value = this.selected_item.label;
          } else if (this.allow_custom_value) {
            next_value = this.filter_text || "";
          }
          if (this.input.view && this.input.view.data && this.input.view.data.model) {
            this.input.view.data.model.value = next_value;
          } else {
            this.input.dom.attributes.value = next_value;
            if (this.input.dom.el) {
              this.input.dom.el.value = next_value;
            }
          }
        }
        move_active_index(direction) {
          const count = this.filtered_items.length;
          if (!count) return;
          let next_index = this.active_index;
          if (next_index === -1) {
            next_index = direction > 0 ? 0 : count - 1;
          } else {
            next_index = next_index + direction;
            if (next_index < 0) next_index = count - 1;
            if (next_index >= count) next_index = 0;
          }
          this.active_index = next_index;
          if (this.list && this.list.set_active_index) {
            this.list.set_active_index(next_index, { from_model: true });
          }
          const active_item = this.filtered_items[next_index];
          if (active_item) {
            this.selected_item = active_item;
            this.sync_input_to_selection();
            this.update_aria_active_descendant();
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (this.input && this.input.dom && this.input.dom.el) {
              const input_el = this.input.dom.el;
              input_el.addEventListener("focus", () => {
                this.set_open(true);
              });
              input_el.addEventListener("click", () => {
                this.set_open(true);
              });
              input_el.addEventListener("input", () => {
                if (this.typeahead) {
                  const next_filter = input_el.value || "";
                  this.set_filter_text(next_filter);
                  this.set_open(true);
                }
              });
              input_el.addEventListener("keydown", (e_keydown) => {
                if (e_keydown.key === "ArrowDown") {
                  e_keydown.preventDefault();
                  this.set_open(true);
                  this.move_active_index(1);
                } else if (e_keydown.key === "ArrowUp") {
                  e_keydown.preventDefault();
                  this.set_open(true);
                  this.move_active_index(-1);
                } else if (e_keydown.key === "Enter") {
                  e_keydown.preventDefault();
                  if (this.selected_item) {
                    this.set_selected_item(this.selected_item);
                    this.raise("change", {
                      name: "selected_item",
                      value: this.selected_item
                    });
                  }
                  this.set_open(false);
                } else if (e_keydown.key === "Escape") {
                  e_keydown.preventDefault();
                  this.set_open(false);
                }
              });
            }
            if (this.list) {
              this.list.on("change", (e_change) => {
                if (e_change.name === "selected_item") {
                  this.set_selected_item(e_change.value);
                  this.raise("change", {
                    name: "selected_item",
                    value: this.selected_item
                  });
                  this.set_open(false);
                }
              });
            }
            if (this.auto_load && this.load_items_fn && !this.items.length) {
              this.load_items();
            }
          }
        }
      };
      Combo_Box.css = `
.combo-box {
    position: relative;
    display: inline-block;
    min-width: 160px;
}
.combo-box-input {
    width: 100%;
}
.combo-box-dropdown {
    position: absolute;
    left: 0;
    right: 0;
    top: 100%;
    background: #fff;
    border: 1px solid #ccc;
    z-index: 10;
    max-height: 220px;
    overflow-y: auto;
}
.combo-box-dropdown.hidden {
    display: none;
}
`;
      module.exports = Combo_Box;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/cluster.js
  var require_cluster = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/cluster.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var Cluster = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "cluster";
          super(spec);
          this.add_class("cluster");
          this.dom.tagName = "div";
          this.gap = Number.isFinite(Number(spec.gap)) ? Number(spec.gap) : 12;
          this.justify = spec.justify || "flex-start";
          this.align = spec.align || "center";
          this.apply_layout();
        }
        /**
         * Set cluster gap.
         * @param {number} gap - Gap in px.
         */
        set_gap(gap) {
          const next_gap = Number(gap);
          if (Number.isFinite(next_gap)) {
            this.gap = next_gap;
            this.apply_layout();
          }
        }
        /**
         * Set justify content value.
         * @param {string} justify - CSS justify-content value.
         */
        set_justify(justify) {
          if (justify) {
            this.justify = justify;
            this.apply_layout();
          }
        }
        /**
         * Set align items value.
         * @param {string} align - CSS align-items value.
         */
        set_align(align) {
          if (align) {
            this.align = align;
            this.apply_layout();
          }
        }
        apply_layout() {
          this.dom.attributes.style.display = "flex";
          this.dom.attributes.style.flexWrap = "wrap";
          this.dom.attributes.style.gap = `${this.gap}px`;
          this.dom.attributes.style.justifyContent = this.justify;
          this.dom.attributes.style.alignItems = this.align;
        }
      };
      module.exports = Cluster;
    }
  });

  // ../jsgui3-html/control_mixins/coverable.js
  var require_coverable = __commonJS({
    "../jsgui3-html/control_mixins/coverable.js"(exports, module) {
      var jsgui = require_html_core();
      var { prop, field, Control: Control2 } = jsgui;
      var coverable = (ctrl, opts) => {
        let select_toggle = false;
        let select_multi = false;
        if (!opts) {
        }
        if (opts) {
        }
        let ctrl_cover;
        ctrl.cover = (content) => {
          ctrl_cover = new Control2({
            context: ctrl.context,
            class: "cover"
          });
          let ctrl_cover_bg = new Control2({
            context: ctrl.context,
            class: "background"
          });
          let ctrl_cover_fg = new Control2({
            context: ctrl.context,
            class: "foreground"
          });
          content.remove();
          ctrl_cover.add(ctrl_cover_bg);
          ctrl_cover.add(ctrl_cover_fg);
          ctrl_cover_fg.add(content);
          ctrl.add(ctrl_cover);
          return ctrl_cover;
        };
        ctrl.uncover = () => {
          ctrl_cover.remove();
          ctrl_cover = null;
        };
        field(ctrl, "covered");
      };
      module.exports = coverable;
    }
  });

  // ../jsgui3-html/control_mixins/typed_data/date.js
  var require_date = __commonJS({
    "../jsgui3-html/control_mixins/typed_data/date.js"(exports, module) {
      var lang = require_lang();
      var is_defined = lang.is_defined;
      var date = (ctrl, spec) => {
        let _date, _year, _month, _day;
        let constructor = () => {
          Object.defineProperty(ctrl, `date`, {
            get() {
              return _date;
            },
            set(value2) {
              let old = _date;
              _date = value2;
              if (typeof document === "undefined") {
                ctrl._fields = ctrl._fields || {};
                ctrl._fields["date"] = value2;
              }
              ctrl.raise("change", {
                "name": "date",
                "old": old,
                //'new': _disabled,
                "value": _date
              });
            },
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(ctrl, `year`, {
            get() {
              return _year;
            },
            set(value2) {
              let old = _year;
              _year = value2;
              if (typeof document === "undefined") {
                ctrl._fields = ctrl._fields || {};
                ctrl._fields["year"] = value2;
              }
              ctrl.raise("change", {
                "name": "year",
                "old": old,
                //'new': _disabled,
                "value": _year
              });
            },
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(ctrl, `month`, {
            get() {
              return _month;
            },
            set(value2) {
              let old = _month;
              _month = value2;
              if (typeof document === "undefined") {
                ctrl._fields = ctrl._fields || {};
                ctrl._fields["month"] = value2;
              }
              ctrl.raise("change", {
                "name": "month",
                "old": old,
                //'new': _disabled,
                "value": _month
              });
            },
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(ctrl, `day`, {
            get() {
              return _day;
            },
            set(value2) {
              let old = _day;
              _day = value2;
              if (typeof document === "undefined") {
                ctrl._fields = ctrl._fields || {};
                ctrl._fields["day"] = value2;
              }
              ctrl.raise("change", {
                "name": "day",
                "old": old,
                //'new': _disabled,
                "value": _day
              });
            },
            enumerable: true,
            configurable: false
          });
          if (is_defined(spec.year) && is_defined(spec.month)) {
            ctrl.month = spec.month;
            ctrl.year = spec.year;
          } else {
            let now = /* @__PURE__ */ new Date();
            ctrl.month = now.getMonth();
            ctrl.year = now.getFullYear();
          }
          Object.assign(ctrl, {
            next_month: () => {
              if (ctrl.month === 11) {
                ctrl.month = 0;
                ctrl.year = ctrl.year + 1;
              } else {
                ctrl.month = ctrl.month + 1;
              }
              ctrl.refresh_month_view();
            },
            previous_month: () => {
              if (ctrl.month === 0) {
                ctrl.month = 11;
                ctrl.year = ctrl.year - 1;
              } else {
                ctrl.month = ctrl.month - 1;
              }
              ctrl.refresh_month_view();
            },
            next_year: () => {
              ctrl.year = ctrl.year + 1;
              ctrl.refresh_month_view();
            },
            previous_year: () => {
              ctrl.year = ctrl.year - 1;
              ctrl.refresh_month_view();
            }
          });
        };
        let activate = () => {
        };
        if (spec) {
          constructor();
        } else {
          activate();
        }
      };
      module.exports = date;
    }
  });

  // ../jsgui3-html/control_mixins/display.js
  var require_display = __commonJS({
    "../jsgui3-html/control_mixins/display.js"(exports, module) {
      var lang = require_lang();
      var { Evented_Class, tof, each } = lang;
      var Ctrl_Display_Mode_Category = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          if (spec.name) {
            this.name = spec.name;
          } else {
            throw "Ctrl_Display_Mode_Category requires a name property";
          }
        }
      };
      var Ctrl_Display_Modes_Categories = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          const map_categories = {}, arr_categories = [];
          if (spec.names) {
            const add_category = (name) => {
              if (typeof name !== "string" || name.length === 0) return;
              if (map_categories[name]) return;
              const cat = new Ctrl_Display_Mode_Category({ name });
              map_categories[name] = cat;
              arr_categories.push(cat);
            };
            if (tof(spec.names) === "array") {
              each(spec.names, (name) => add_category(name));
            } else if (tof(spec.names) === "string") {
              add_category(spec.names);
            } else if (tof(spec.names) === "object") {
              each(spec.names, (_value, key2) => add_category(key2));
            }
          }
          this.map = map_categories;
          this.arr = arr_categories;
        }
      };
      var Ctrl_Display_Modes = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          const arr_category_names = ["size", "layout", "colors", "interactivity"];
          const categories = new Ctrl_Display_Modes_Categories({ names: arr_category_names });
          Object.defineProperty(this, "categories", { get: () => categories });
          let _value;
          Object.defineProperty(this, "value", {
            get() {
              return _value;
            },
            set(value2) {
              const old = _value;
              _value = value2;
              this.raise("change", { name: "value", old, value: value2 });
            }
          });
        }
      };
      var Ctrl_Display = class extends Evented_Class {
        // so it can have on change events.
        constructor(spec = {}) {
          super(spec);
          let ctrl;
          if (spec.ctrl) ctrl = spec.ctrl;
          const modes = new Ctrl_Display_Modes({ ctrl });
          Object.defineProperty(this, "modes", {
            get() {
              return modes;
            },
            set(value2) {
              modes.value = value2;
            }
          });
        }
      };
      var display = (ctrl, opts = {}) => {
        if (ctrl.display) return ctrl.display;
        const ctrl_display = new Ctrl_Display({
          ctrl
        });
        Object.defineProperty(ctrl, "display", {
          get() {
            return ctrl_display;
          },
          set(value2) {
            ctrl_display.modes = value2;
          }
        });
        return ctrl_display;
      };
      module.exports = display;
    }
  });

  // ../jsgui3-html/control_mixins/display-modes.js
  var require_display_modes = __commonJS({
    "../jsgui3-html/control_mixins/display-modes.js"(exports, module) {
      var display_modes = (ctrl, opts = {}) => {
      };
      module.exports = display_modes;
    }
  });

  // ../jsgui3-html/control_mixins/fast-touch-click.js
  var require_fast_touch_click = __commonJS({
    "../jsgui3-html/control_mixins/fast-touch-click.js"(exports, module) {
      var fast_touch_click = (ctrl) => {
        let has_moved_away = false;
        ctrl.on("touchstart", (ets) => {
          ets.preventDefault();
        });
        ctrl.on("touchend", (ete) => {
          if (!has_moved_away) {
            ctrl.raise("click", ete);
          }
          has_moved_away = false;
        });
        ctrl.on("touchmove", (etm) => {
          has_moved_away = true;
        });
      };
      module.exports = fast_touch_click;
    }
  });

  // ../jsgui3-html/control_mixins/popup.js
  var require_popup = __commonJS({
    "../jsgui3-html/control_mixins/popup.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var context_ensure_popup_layer = (context2) => {
        let ctrl_document = context2.ctrl_document;
        let body = context2.map_controls["body_0"];
        if (!body.popup_layer) {
          body.popup_layer = new Control2({
            "context": context2,
            "__type_name": "popup_layer"
          });
          body.popup_layer.add_class("popup-layer");
          body.add(body.popup_layer);
        }
        return body.popup_layer;
      };
      var popup = (ctrl) => {
        let context2 = ctrl.context;
        ctrl.popup = () => {
          let popup_layer = context_ensure_popup_layer(context2);
          let parent, placeholder;
          setTimeout(() => {
            placeholder = new Control2({
              "context": context2,
              "__type_name": "placeholder"
            });
            parent = ctrl.parent;
            let absolute_container = new Control2({
              "context": context2
            });
            popup_layer.add(absolute_container);
            absolute_container.add(placeholder);
            parent.content.swap(ctrl, placeholder);
            let bcr = placeholder.dom.el.getBoundingClientRect();
            absolute_container.dom.attrs.style.position = "absolute";
            absolute_container.dom.attrs.style.left = bcr.left + "px";
            absolute_container.dom.attrs.style.top = bcr.top + "px";
            ctrl.remove_class("hidden");
          }, 0);
          const replace = () => {
            ctrl.add_class("hidden");
            parent.content.swap(placeholder, ctrl);
          };
          return replace;
        };
      };
      module.exports = popup;
    }
  });

  // ../jsgui3-html/control_mixins/drag_like_events.js
  var require_drag_like_events = __commonJS({
    "../jsgui3-html/control_mixins/drag_like_events.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var {
        each,
        tof
      } = require_lang();
      var drag_like_events = (ctrl, opts = {}) => {
        let {
          //condition
        } = opts;
        let start_action;
        if (!ctrl.__using_drag_like_events) {
          start_action = start_action || ["touchstart", "mousedown"];
          if (tof(start_action) === "string") start_action = [start_action];
          let pos_md, pos_mm, pos_mu, pos_md_within_ctrl;
          let ctrl_body = ctrl.context.body();
          let dragging = false;
          let drag_offset_distance = opts.start_distance || 6;
          let movement_offset;
          let item_start_pos;
          let half_item_width, item_width, initial_bcr;
          const el = ctrl.dom.el;
          let initial_ctrl_translate;
          const begin_drag = (pos) => {
            initial_bcr = ctrl.bcr();
            dragging = true;
            const old_bounds_handling_code = () => {
              if (bounds) {
                if (typeof bounds.bcr === "function") {
                  initial_bounds_bcr = bounds.bcr();
                  initial_bcr_offset_from_bounds = [
                    [initial_bcr[0][0] - initial_bounds_bcr[0][0], initial_bcr[0][1] - initial_bounds_bcr[0][1]],
                    [initial_bcr[1][0] - initial_bounds_bcr[1][0], initial_bcr[1][1] - initial_bounds_bcr[1][1]],
                    [initial_bcr[2][0] - initial_bounds_bcr[2][0], initial_bcr[2][1] - initial_bounds_bcr[2][1]]
                  ];
                }
              }
            };
            ctrl.raise("drag-like-action-start");
          };
          const move_drag = (pos) => {
            ctrl.raise("drag-like-action-move", {
              offset: movement_offset
            });
          };
          const body_mm = (e_mm) => {
            let touch_count = 0;
            if (e_mm.touches) touch_count = e_mm.touches.length;
            if (e_mm.buttons === 0 && touch_count === 0) {
              body_mu();
            } else {
              if (e_mm.touches) {
                pos_mm = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
              } else {
                pos_mm = [e_mm.pageX, e_mm.pageY];
              }
              if (touch_count === 0 || touch_count === 1) {
                if (e_mm.pageX || e_mm.touches) {
                  let pos_mm2;
                  if (e_mm.touches) {
                    pos_mm2 = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
                  } else {
                    pos_mm2 = [e_mm.pageX, e_mm.pageY];
                  }
                  if (pos_mm2[0] !== void 0 && pos_mm2[1] !== void 0) {
                    movement_offset = [pos_mm2[0] - pos_md[0], pos_mm2[1] - pos_md[1]];
                    if (!dragging) {
                      let abs_offset = [Math.abs(movement_offset[0]), Math.abs(movement_offset[1])];
                      let abs_offset_dist = Math.sqrt(Math.pow(abs_offset[0], 2) + Math.pow(abs_offset[1], 2));
                      if (abs_offset_dist >= drag_offset_distance) {
                        begin_drag(pos_mm2);
                      }
                    } else {
                      move_drag(pos_mm2);
                    }
                  }
                }
              }
            }
          };
          const end_drag = (e_mu) => {
            ctrl_body.off("mousemove", body_mm);
            ctrl_body.off("mouseup", body_mu);
            ctrl_body.off("touchmove", body_mm);
            ctrl_body.off("touchend", body_mu);
            if (dragging) {
              dragging = false;
              ctrl.raise("drag-like-action-end", {
                offset: movement_offset
              });
            }
          };
          const body_mu = (e_mu) => {
            end_drag(e_mu);
          };
          const h_md = (e_md) => {
            if (e_md.pageX) {
              pos_md_within_ctrl = [e_md.offsetX, e_md.offsetX];
            } else {
              pos_md_within_ctrl = [0, 0];
            }
            dragging = false;
            pos_md = [e_md.pageX || e_md.touches[0].pageX, e_md.pageY || e_md.touches[0].pageY];
            ctrl_body.on("mousemove", body_mm);
            ctrl_body.on("mouseup", body_mu);
            ctrl_body.on("touchmove", body_mm);
            ctrl_body.on("touchend", body_mu);
          };
          field(ctrl, "drag_like_events");
          ctrl.on("change", (e_change) => {
            let n = e_change.name, value2 = e_change.value;
            if (n === "drag_like_events") {
              if (value2 === true) {
                if (typeof document === "undefined") {
                } else {
                  let apply_start_handlers = (start_action2) => {
                    if (!ctrl.has_drag_like_md_handler) {
                      ctrl.has_drag_like_md_handler = true;
                      each(start_action2, (sa) => {
                        ctrl.on(sa, h_md);
                      });
                    }
                  };
                  ctrl.once_active(() => {
                    apply_start_handlers(start_action);
                  });
                }
              } else {
                if (typeof document === "undefined") {
                } else {
                  ((start_action2) => {
                    each(start_action2, (sa) => {
                      ctrl.off(sa, h_md);
                    });
                  })(start_action);
                  ctrl.has_drag_md_handler = false;
                }
              }
            }
          });
          ctrl.__using_drag_like_events = true;
        }
      };
      module.exports = drag_like_events;
    }
  });

  // ../jsgui3-html/control_mixins/resizable.js
  var require_resizable = __commonJS({
    "../jsgui3-html/control_mixins/resizable.js"(exports, module) {
      var Control2 = require_control();
      var drag_like_events = require_drag_like_events();
      var { tof } = require_lang();
      var { field } = require_oext();
      var resizable = (ctrl, options = { resize_mode: "br_handle" }) => {
        const opts = options || {};
        const ensure_isomorphic_mixin = () => {
          var _a, _b, _c;
          const mixins = (_c = (_b = (_a = ctrl.view) == null ? void 0 : _a.data) == null ? void 0 : _b.model) == null ? void 0 : _c.mixins;
          if (!mixins || typeof mixins.each !== "function" || typeof mixins.push !== "function") return;
          let has_resizable = false;
          mixins.each((mixin) => {
            if (mixin && mixin.name === "resizable") has_resizable = true;
          });
          if (has_resizable) return;
          const old_silent = mixins.silent;
          mixins.silent = true;
          mixins.push({ name: "resizable" });
          mixins.silent = old_silent;
        };
        ensure_isomorphic_mixin();
        field(ctrl, "resizable");
        ctrl.resizable = true;
        const extra_margin = opts.extra_margin !== void 0 ? opts.extra_margin : 2;
        const { bounds: bounds2 } = opts;
        const extent_bounds = opts.extent_bounds || opts.extent;
        const t_extent_bounds = tof(extent_bounds);
        let min_bound, max_bound;
        if (bounds2) {
          [min_bound, max_bound] = bounds2;
        }
        const { resize_mode } = opts;
        const start_action = ["touchstart", "mousedown"];
        let initial_size, initial_measured_pos_within_ctrl_bounds;
        if (resize_mode === "br_handle") {
          const ctrl_relative = ctrl.ctrl_relative || ctrl;
          if (!ctrl.ctrl_relative) {
            ctrl.ctrl_relative = ctrl_relative;
            if (ctrl.dom && ctrl.dom.attributes && ctrl.dom.attributes.style && !ctrl.dom.attributes.style.position) {
              ctrl.dom.attributes.style.position = "relative";
            }
          }
          const find_existing_resize_handle = () => {
            var _a;
            const arr = ((_a = ctrl_relative == null ? void 0 : ctrl_relative.content) == null ? void 0 : _a._arr) || [];
            for (let idx = 0; idx < arr.length; idx++) {
              const item2 = arr[idx];
              if (item2 && typeof item2.has_class === "function") {
                if (item2.has_class("resize-handle") && item2.has_class("bottom-right")) return item2;
              }
            }
            return void 0;
          };
          if (!ctrl.ctrl_br_resize_handle) {
            const found = find_existing_resize_handle();
            if (found) ctrl.ctrl_br_resize_handle = found;
          }
          if (ctrl.ctrl_br_resize_handle) {
          } else {
            const ctrl_br_resize_handle2 = new Control2({
              context: ctrl.context
            });
            ctrl_br_resize_handle2.add_class("bottom-right");
            ctrl_br_resize_handle2.add_class("resize-handle");
            ctrl_br_resize_handle2.add("\u25E2");
            ctrl_relative.add(ctrl_br_resize_handle2);
            if (typeof document !== "undefined" && ctrl_relative.dom && ctrl_relative.dom.el && ctrl_relative.__active) {
              ctrl_br_resize_handle2.pre_activate();
              if (ctrl_br_resize_handle2.dom && ctrl_br_resize_handle2.dom.el) {
                ctrl_br_resize_handle2.activate();
              }
            }
            ctrl.ctrl_br_resize_handle = ctrl_br_resize_handle2;
          }
          const ctrl_br_resize_handle = ctrl.ctrl_br_resize_handle;
          if (typeof document !== "undefined" && ctrl_br_resize_handle.context && typeof ctrl_br_resize_handle.context.body === "function") {
            drag_like_events(ctrl_br_resize_handle);
            ctrl_br_resize_handle.drag_like_events = true;
          }
          if (!ctrl_br_resize_handle.__has_resizable_handle_events) {
            ctrl_br_resize_handle.__has_resizable_handle_events = true;
            let css_transition;
            ctrl_br_resize_handle.on("drag-like-action-start", () => {
              initial_size = ctrl.bcr()[2];
              if (t_extent_bounds === "control") {
                const ctrl_bcr = ctrl.bcr();
                const extent_bounds_ctrl_bcr = extent_bounds.bcr();
                const pos_offset = [ctrl_bcr[0][0] - extent_bounds_ctrl_bcr[0][0], ctrl_bcr[0][1] - extent_bounds_ctrl_bcr[0][1]];
                const extent_bounds_ctrl_measured_size = extent_bounds_ctrl_bcr[2];
                const bounded_max_size = [extent_bounds_ctrl_measured_size[0] - pos_offset[0] - extra_margin, extent_bounds_ctrl_measured_size[1] - pos_offset[1] - extra_margin];
                max_bound = bounded_max_size;
              }
              ctrl.add_class("no-transitions");
              ctrl_br_resize_handle.add_class("resizing");
            });
            ctrl_br_resize_handle.on("drag-like-action-move", (e_drag_like_action_move) => {
              const { offset: offset2 } = e_drag_like_action_move;
              const new_size = [initial_size[0] + offset2[0], initial_size[1] + offset2[1]];
              if (min_bound) {
                if (new_size[0] < min_bound[0]) new_size[0] = min_bound[0];
                if (new_size[1] < min_bound[1]) new_size[1] = min_bound[1];
              }
              if (max_bound) {
                if (new_size[0] > max_bound[0]) new_size[0] = max_bound[0];
                if (new_size[1] > max_bound[1]) new_size[1] = max_bound[1];
              }
              ctrl.size = new_size;
            });
            ctrl_br_resize_handle.on("drag-like-action-end", (e_drag_like_action_end) => {
              ctrl_br_resize_handle.remove_class("resizing");
              ctrl.remove_class("no-transitions");
            });
          }
        }
      };
      module.exports = resizable;
    }
  });

  // ../jsgui3-html/control_mixins/deletable.js
  var require_deletable = __commonJS({
    "../jsgui3-html/control_mixins/deletable.js"(exports, module) {
      var deletable = (ctrl) => {
        ctrl.delete = () => {
          ctrl.remove();
          ctrl.raise("delete");
        };
      };
      module.exports = deletable;
    }
  });

  // ../jsgui3-html/control_mixins/selected-deletable.js
  var require_selected_deletable = __commonJS({
    "../jsgui3-html/control_mixins/selected-deletable.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var deletable = require_deletable();
      var selected_deletable = (ctrl) => {
        deletable(ctrl);
        let old_selected_deletable = ctrl.selected_deletable;
        let click_handler = (e) => {
        };
        let press_handler = (event) => {
          const keyName = event.key;
          if (keyName === "Delete") {
            ctrl.delete();
          }
        };
        ctrl.on("change", (e_change) => {
          let {
            name,
            value: value2
          } = e_change;
          if (name === "selected") {
            ctrl.once_active(() => {
              if (value2) {
                document.addEventListener("keydown", press_handler, false);
              } else {
                document.removeEventListener("keydown", press_handler, false);
              }
            });
          }
          ;
          return true;
        });
        if (true) {
          if (old_selected_deletable !== void 0) {
            ctrl.selected_deletable = old_selected_deletable;
          }
        }
      };
      module.exports = selected_deletable;
    }
  });

  // ../jsgui3-html/control_mixins/selected-resizable.js
  var require_selected_resizable = __commonJS({
    "../jsgui3-html/control_mixins/selected-resizable.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var selected_resizable = (ctrl, ctrl_handle) => {
        let old_selected_resizable = ctrl.old_selected_resizable;
        let click_handler = (e) => {
        };
        let press_handler = (event) => {
          const keyName = event.key;
          console.log("event", event);
          if (keyName === "Control") {
            return;
          }
          if (event.ctrlKey) {
          } else {
          }
        };
        ctrl.on("change", (e_change) => {
          let {
            name,
            value: value2
          } = e_change;
          if (name === "selected") {
            ctrl.once_active(() => {
              if (value2) {
                document.addEventListener("keypress", press_handler, false);
              } else {
                document.removeEventListener("keypress", press_handler, false);
              }
            });
          }
          ;
          return true;
        });
        if (true) {
          if (old_selectable !== void 0) {
            ctrl.selected_deletable = old_sselected_deletableelectable;
          }
        }
      };
      module.exports = selected_resizable;
    }
  });

  // ../jsgui3-html/control_mixins/selection-box-host.js
  var require_selection_box_host = __commonJS({
    "../jsgui3-html/control_mixins/selection-box-host.js"(exports, module) {
      var {
        prop,
        field
      } = require_oext();
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var coords_to_lt_wh = (coords_pair) => {
        let l2, t, r, b, w, h, min = Math.min, max = Math.max;
        l2 = min(coords_pair[0][0], coords_pair[1][0]);
        r = max(coords_pair[0][0], coords_pair[1][0]);
        t = min(coords_pair[0][1], coords_pair[1][1]);
        b = max(coords_pair[0][1], coords_pair[1][1]);
        w = r - l2;
        h = b - t;
        return [
          [l2, t],
          [w, h]
        ];
      };
      var selection_box_host = (ctrl) => {
        let click_handler = (e) => {
          if (ctrl.selectable && !ctrl.selection_scope) {
            var ctrl_key2 = e.ctrlKey;
            var meta_key = e.metaKey;
            if (ctrl_key2 || meta_key) {
              ctrl.action_select_toggle();
            } else {
              ctrl.action_select_only();
            }
          }
        };
        field(ctrl, "selection_box_host");
        ctrl.selection_box_host = true;
        let old_activate = ctrl.activate;
        ctrl.activate = function(spec) {
          if (old_activate) {
            old_activate.call(this, spec);
          }
          let selection_box;
          let md_pos, mm_pos, md_offset_within_ctrl, mm_offset_within_ctrl;
          let isf;
          let nsb = this.new_selection_box = (pos) => {
            this.add(selection_box = new Control2({
              context: this.context,
              css: {
                position: "absolute"
              },
              "class": "selection-box",
              pos
            }));
            selection_box.activate();
            prop(selection_box, "coords", (e_change) => {
              let lt_wh = coords_to_lt_wh(e_change[0]);
              [selection_box.pos, selection_box.size] = lt_wh;
            });
            return selection_box;
          };
          ctrl.drag_events((md) => {
            console.log("md", md);
            let main_boxes = ctrl.$(".main-box");
            let do_begin_selection_box = true;
            if (md.target.tagName.toLowerCase() === "span") {
              do_begin_selection_box = false;
            }
            if (do_begin_selection_box) {
              md_pos = md.pos;
              ctrl.find_selection_scope().deselect_all();
              let ctrl_pos = ctrl.bcr()[0];
              md_offset_within_ctrl = v_subtract(md.pos, ctrl_pos);
              md_offset_within_ctrl[1] -= window.scrollY;
              md_pos[1] -= window.scrollY;
              isf = new jsgui.Intersection_Finder({
                controls: main_boxes
              });
              isf.on("change", (e_change) => {
                if (e_change.name === "intersections") {
                  let [intersecting, newly_intersecting, previously_intersecting] = e_change.value;
                  each(newly_intersecting, (ctrl2) => {
                    let sel = ctrl2.closest((cmatch) => {
                      return cmatch.selectable === true;
                    });
                    if (sel) sel.selected = true;
                  });
                  each(previously_intersecting, (ctrl2) => {
                    let sel = ctrl2.closest((match) => match.selectable === true);
                    if (sel) sel.selected = false;
                  });
                }
              });
              let selection_box2 = nsb(md.pos);
              if (selection_box2) {
              }
            } else {
              return false;
            }
          }, (mm) => {
            if (selection_box) {
              mm_pos = mm.pos;
              mm_pos[1] -= window.scrollY;
              let ctrl_pos = ctrl.bcr()[0];
              mm_offset_within_ctrl = v_subtract(mm.pos, ctrl_pos);
              selection_box.coords = [md_offset_within_ctrl, mm_offset_within_ctrl];
              isf.coords = [md_pos, mm_pos];
            }
          }, (mu) => {
            selection_box.remove();
            isf = null;
          });
        };
      };
      module.exports = selection_box_host;
    }
  });

  // ../jsgui3-html/control_mixins/press-events.js
  var require_press_events = __commonJS({
    "../jsgui3-html/control_mixins/press-events.js"(exports, module) {
      var { get_truth_map_from_arr, each } = require_lang();
      var press_events = (ctrl, options = {}) => {
        ctrl.__mx = ctrl.__mx || {};
        ctrl.__mx.press_events = true;
        const press_event_names = ["press-start", "press-move", "press-end", "press-hold", "press-drag-start"];
        const map_press_event_names = get_truth_map_from_arr(press_event_names);
        const setup_isomorphic = () => {
          const old_silent = ctrl.view.data.model.mixins.silent;
          ctrl.view.data.model.mixins.silent = true;
          ctrl.view.data.model.mixins.push({
            name: "press-events"
          });
          ctrl.view.data.model.mixins.silent = old_silent;
        };
        setup_isomorphic();
        if (ctrl.dom.el) {
          ctrl.once_active(() => {
            const body = ctrl.context.body();
            const { css } = options;
            let handling_is_setup = false;
            let pos_start;
            let movement_offsets;
            let pos_move;
            let movement_offset;
            let timeout_hold;
            let drag_started = false;
            let el;
            const hold_movement_threshold = 4;
            let move_mag;
            const ms_short = 500;
            const ts = (e) => {
              if (e.touches.length === 1) {
                e.pos = [e.pageX = e.touches[0].pageX, e.pageY = e.touches[0].pageY];
                el = e.el = e.touches[0].target;
                return ps(e);
              }
            };
            const md = (e) => {
              let path = e.path || e.composedPath();
              el = e.el = path[0];
              return ps(e);
            };
            const mm = (e) => {
              e.pos = [e.pageX = e.pageX, e.pageY = e.pageY];
              return pm(e);
            };
            const tm = (e) => {
              e.pos = [e.pageX = e.touches[0].pageX, e.pageY = e.touches[0].pageY];
              return pm(e);
            };
            const pm = (e) => {
              pos_move = e.pos;
              e.movement_offset = movement_offset = [e.pos[0] - pos_start[0], e.pos[1] - pos_start[1]];
              movement_offsets.push(movement_offset);
              e.movement_offsets = movement_offsets;
              e.move_mag = move_mag = Math.sqrt(Math.pow(movement_offset[0], 2) + Math.pow(movement_offset[1], 2));
              e.ctrl = ctrl;
              ctrl.raise("press-move", e);
              if (move_mag >= 4 && !drag_started) {
                ctrl.raise("press-drag-start", e);
                drag_started = true;
              }
            };
            const pe = (e) => {
              e.movement_offsets = movement_offsets;
              e.move_mag = move_mag;
              e.ctrl = ctrl;
              e.el = el;
              if (timeout_hold) clearTimeout(timeout_hold);
              body.off({
                touchend: te,
                touchmove: tm,
                mouseup: mu,
                mousemove: mm
              });
              ctrl.raise("press-end", e);
            };
            const mu = (e) => {
              body.off({
                mouseup: mu,
                mousemove: mm
              });
              e.pos = [e.pageX, e.pageY];
              return pe(e);
            };
            const te = (e) => {
              body.off({
                touchend: te,
                touchmove: tm
              });
              e.pos = pos_move || pos_start;
              return pe(e);
            };
            const ps = (e) => {
              movement_offsets = [];
              move_mag = 0;
              drag_started = false;
              let is_touch_event = !!e.touches;
              e.is_touch_event = is_touch_event;
              pos_start = [e.pageX, e.pageY];
              if (is_touch_event) {
                body.on({
                  touchend: te,
                  touchmove: tm
                });
              } else {
                body.on({
                  mouseup: mu,
                  mousemove: mm
                });
              }
              e.ctrl = ctrl;
              ctrl.raise("press-start", e);
              timeout_hold = setTimeout(() => {
                if (move_mag <= hold_movement_threshold) {
                  ctrl.raise("press-hold", e);
                }
              }, ms_short);
            };
            const setup = () => {
              ctrl.on({
                "touchstart": ts,
                "mousedown": md
              });
              handling_is_setup = true;
            };
            const unsetup = () => {
              ctrl.off({
                "touchstart": ts,
                "mousedown": md
              });
              handling_is_setup = false;
            };
            const outer_setup = () => {
              ctrl.event_events = true;
              const relying_on_recognising_adding_of_event_listeners = () => {
                ctrl.on("add-event-listener", (e) => {
                  const { name } = e;
                  if (map_press_event_names[name]) {
                    if (!handling_is_setup) {
                      setup();
                    }
                  }
                });
                ctrl.on("remove-event-listener", (e) => {
                  const { name } = e;
                  if (map_press_event_names[name]) {
                    console.log("ctrl remove-event-listener", name);
                    const bnec = ctrl.bound_named_event_counts;
                    console.log("bound_named_event_counts bnec", bnec);
                    console.log("name", name);
                    let count_bound_press_events = 0;
                    each(bnec, (count, event_name) => {
                      if (map_press_event_names[event_name]) count_bound_press_events += count;
                    });
                    if (count_bound_press_events === 0) {
                      unsetup();
                    }
                  }
                });
              };
              const just_do_it = () => {
                if (!handling_is_setup) {
                  setup();
                }
              };
              just_do_it();
            };
            outer_setup();
          });
        }
        if (typeof window !== "undefined" && ctrl.dom && ctrl.dom.el) {
          ctrl.on("press-start", (e_ps) => {
            const outsideHandler = (e_pe) => {
              if (!ctrl.dom.el.contains(e_pe.target)) {
                ctrl.raise("press-outside", e_pe);
              }
              window.removeEventListener("mouseup", outsideHandler);
              window.removeEventListener("touchend", outsideHandler);
            };
            window.addEventListener("mouseup", outsideHandler);
            window.addEventListener("touchend", outsideHandler);
          });
        }
      };
      module.exports = press_events;
    }
  });

  // ../jsgui3-html/control_mixins/press-outside.js
  var require_press_outside = __commonJS({
    "../jsgui3-html/control_mixins/press-outside.js"(exports, module) {
      var press_events = require_press_events();
      var press_outside = (ctrl, options = {}) => {
        let once = options.one || options.once || false;
        console.log("press_outside");
        ctrl.__mx = ctrl.__mx || {};
        if (!ctrl.__mx || !ctrl.__mx.press_events) {
          press_events(ctrl);
        }
        ctrl.__mx.press_outside = true;
        const body = ctrl.context.body();
        if (!body.__mx || !body.__mx.press_events) {
          press_events(body);
        }
        ctrl.event_events = true;
        const body_press = (e) => {
          console.log("press_outside body press e", e);
          const { ctrl_target } = e;
          const match = ctrl_target === ctrl || ctrl_target.ancestor(ctrl);
          if (!match) {
            ctrl.raise("press-outside", e);
          }
        };
        const setup_body_press = () => {
          body.on("press-end", body_press);
        };
        const remove_body_press = () => {
          body.off("press-end", body_press);
        };
        ctrl.on("add-event-listener", (e) => {
          const { name } = e;
          if (name === "press-outside") {
            setup_body_press();
          }
        });
        ctrl.on("remove-event-listener", (e) => {
          const { name } = e;
          if (name === "press-outside") {
            remove_body_press();
          }
        });
      };
      module.exports = press_outside;
    }
  });

  // ../jsgui3-html/control_mixins/pressed-state.js
  var require_pressed_state = __commonJS({
    "../jsgui3-html/control_mixins/pressed-state.js"(exports, module) {
      var {
        field,
        prop
      } = require_oext();
      var press_events = require_press_events();
      var pressed_state = (ctrl, options = {}) => {
        ctrl.__mx = ctrl.__mx || {};
        if (!ctrl.__mx || !ctrl.__mx.press_events) {
          press_events(ctrl);
        }
        ctrl.__mx.pressed_state = true;
        const setup_isomorphic = () => {
          const old_silent = ctrl.view.data.model.mixins.silent;
          ctrl.view.data.model.mixins.silent = true;
          ctrl.view.data.model.mixins.push({
            name: "pressed-state"
          });
          ctrl.view.data.model.mixins.silent = old_silent;
        };
        setup_isomorphic();
        field(ctrl.view.data.model, "state");
        ctrl.on("press-start", () => {
          ctrl.view.data.model.state = "pressed";
        });
        ctrl.on("press-end", () => {
          ctrl.view.data.model.state = "not-pressed";
        });
        ctrl.view.data.model.on("change", (e) => {
          const { name, value: value2 } = e;
          if (name === "state") {
            if (value2 === "pressed") ctrl.add_class("pressed");
            else ctrl.remove_class("pressed");
          }
        });
      };
      module.exports = pressed_state;
    }
  });

  // ../jsgui3-html/control_mixins/mx.js
  var require_mx = __commonJS({
    "../jsgui3-html/control_mixins/mx.js"(exports, module) {
      var mx = {
        coverable: require_coverable(),
        date: require_date(),
        display: require_display(),
        display_modes: require_display_modes(),
        fast_touch_click: require_fast_touch_click(),
        input_api: require_input_api(),
        input_base: require_input_base(),
        input_validation: require_input_validation(),
        model_data_view_compositional_representation: require_model_data_view_compositional_representation(),
        popup: require_popup(),
        resizable: require_resizable(),
        selectable: require_selectable(),
        selected_deletable: require_selected_deletable(),
        selected_resizable: require_selected_resizable(),
        selection_box_host: require_selection_box_host(),
        dragable: require_dragable(),
        drag_like_events: require_drag_like_events(),
        press_events: require_press_events(),
        press_outside: require_press_outside(),
        pressed_state: require_pressed_state(),
        theme: require_theme(),
        theme_params: require_theme_params(),
        themeable: require_themeable()
      };
      module.exports = mx;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Dropdown_Menu.js
  var require_Dropdown_Menu = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Dropdown_Menu.js"(exports, module) {
      var jsgui = require_html_core();
      var { each, tof, is_array, is_arr_of_strs } = jsgui;
      var Control2 = jsgui.Control;
      var { field, prop } = require_oext();
      var { press_events, pressed_state, selectable } = require_mx();
      var { themeable } = require_themeable();
      var { apply_token_map, apply_radius_tokens } = require_token_maps();
      var Dropdown_Menu = class extends Control2 {
        /**
         * Create a Dropdown Menu.
         * @param {Object} spec - Control specification
         * @param {string[]} [spec.options] - Array of option strings
         * @param {string} [spec.variant] - Theme variant name
         * @param {Object} [spec.params] - Theme parameters override
         */
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "dropdown_menu";
          super(spec);
          const params = themeable(this, "dropdown_menu", spec);
          apply_token_map(this, "input", params);
          apply_radius_tokens(this, params);
          this.add_class("dropdown-menu");
          field(this.view.data.model, "state");
          field(this.view.data.model, "options");
          this.view.data.model.on("change", (e_change) => {
            const { name, value: value2 } = e_change;
            if (name === "state") {
              if (value2 === "open") {
                this.remove_class("closed");
                this.add_class("open");
              } else if (value2 === "closed") {
                this.remove_class("open");
                this.add_class("closed");
              }
            } else {
            }
          });
          this.view.data.model.state = "closed";
          if (spec.options) {
            this.view.data.model.options = spec.options;
          }
          if (!spec.abstract && !spec.el) {
            this.compose_dropdown_menu();
          }
        }
        compose_dropdown_menu() {
          const { context: context2 } = this;
          const ctrl_closed_top = new Control2({ context: context2 });
          ctrl_closed_top.add_class("closed-top");
          const ctrl_closed_top_item_itself = new Control2({ context: context2 });
          ctrl_closed_top_item_itself.add_class("item-itself");
          ctrl_closed_top.add(ctrl_closed_top_item_itself);
          const ctrl_dropdown_icon = new Control2({ context: context2 });
          ctrl_dropdown_icon.add_class("dropdown-icon");
          ctrl_dropdown_icon.add("\u25BC");
          ctrl_closed_top.add(ctrl_dropdown_icon);
          this.add(ctrl_closed_top);
          const ctrl_open_items = new Control2({ context: context2 });
          ctrl_open_items.add_class("open-items");
          this.add(ctrl_open_items);
          const dm_options = this.view.data.model.options;
          if (is_array(dm_options)) {
            if (is_arr_of_strs(dm_options)) {
              each(dm_options, (str_option) => {
                const ctrl_option = new Control2({
                  context: context2
                });
                ctrl_option.add_class("item");
                ctrl_option.add(str_option);
                ctrl_open_items.add(ctrl_option);
              });
            }
          }
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.ctrl_dropdown_icon = ctrl_dropdown_icon;
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const { ctrl_dropdown_icon } = this;
            pressed_state(ctrl_dropdown_icon);
            ctrl_dropdown_icon.on("click", (e_click) => {
              if (this.view.data.model.state === "closed") {
                this.view.data.model.state = "open";
              } else {
                this.view.data.model.state = "closed";
              }
            });
          }
        }
      };
      Dropdown_Menu.css = `
.dropdown-menu {
    height: 64px;
    width: 384px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
}

.dropdown-menu .closed-top {
    height: 56px;
    width: 376px;
    background-color: #EEEEEE;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
    display: flex;
    flex-direction: row;
}

.dropdown-menu .closed-top .item-itself {
    height: 53px;
    width: 320px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
}

.dropdown-menu .closed-top .dropdown-icon {
    height: 53px;
    width: 53px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    margin-left: 2px;
    font-size: 53px;
    line-height: 53px;
    color: #888888;
}

.dropdown-menu .closed-top .dropdown-icon.pressed {
    background-color: #F0F0F0;
}

.dropdown-menu .open-items {
    width: 376px;
    height: 414px;
    background-color: #EEEEEE;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
}

.dropdown-menu.closed .open-items {
    display: none;
}

.dropdown-menu .open-items .item {
    width: 373px;
    height: 64px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    text-indent: 12px;
    font-size: 52px;
    line-height: 56px;
}

.dropdown-menu .open-items .item:not(:first-child) {
    margin-top: 2px;
}



`;
      if (__require.main === module) {
        const ddm = new Dropdown_Menu();
        console.log(ddm.all_html_render());
      } else {
      }
      module.exports = Dropdown_Menu;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/drawer.js
  var require_drawer = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/drawer.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var Drawer = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "drawer";
          super(spec);
          this.add_class("drawer");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.position = spec.position === "right" ? "right" : "left";
          this.breakpoint = is_defined(spec.breakpoint) ? Number(spec.breakpoint) : 960;
          this.is_open = !!spec.open;
          this.overlay_mode = spec.overlay_mode !== false;
          this.show_close_button = spec.show_close_button !== false;
          this.set_open(this.is_open);
          if (!spec.el) {
            this.compose_drawer(spec);
          }
          this.bind_model();
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            if (e_change.name === "open") {
              this.is_open = !!e_change.value;
              this.apply_state();
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Open the drawer.
         */
        open() {
          this.set_open(true);
          this.raise("open");
        }
        /**
         * Close the drawer.
         */
        close() {
          this.set_open(false);
          this.raise("close");
        }
        /**
         * Toggle the drawer.
         */
        toggle() {
          this.set_open(!this.is_open);
          this.raise("toggle", { open: this.is_open });
        }
        /**
         * Set open state.
         * @param {boolean} is_open - Open state.
         */
        set_open(is_open) {
          this.is_open = !!is_open;
          this.set_model_value("open", this.is_open);
          this.apply_state();
        }
        /**
         * Get open state.
         * @returns {boolean}
         */
        get_open() {
          return !!this.is_open;
        }
        compose_drawer(spec = {}) {
          const { context: context2 } = this;
          const overlay_ctrl = new Control2({ context: context2, tag_name: "div" });
          overlay_ctrl.add_class("drawer-overlay");
          const panel_ctrl = new Control2({ context: context2, tag_name: "aside" });
          panel_ctrl.add_class("drawer-panel");
          panel_ctrl.add_class(`drawer-panel-${this.position}`);
          const header_ctrl = new Control2({ context: context2, tag_name: "div" });
          header_ctrl.add_class("drawer-header");
          if (this.show_close_button) {
            const close_button = new Control2({ context: context2, tag_name: "button" });
            close_button.dom.attributes.type = "button";
            close_button.add_class("drawer-close");
            close_button.add("Close");
            header_ctrl.add(close_button);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.close_button = close_button;
          }
          const body_ctrl = new Control2({ context: context2, tag_name: "div" });
          body_ctrl.add_class("drawer-body");
          if (is_defined(spec.content)) {
            body_ctrl.add(spec.content);
          }
          panel_ctrl.add(header_ctrl);
          panel_ctrl.add(body_ctrl);
          this.add(overlay_ctrl);
          this.add(panel_ctrl);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.overlay = overlay_ctrl;
          this._ctrl_fields.panel = panel_ctrl;
          this._ctrl_fields.body = body_ctrl;
          this.apply_state();
        }
        apply_state() {
          if (this.is_open) {
            this.add_class("is-open");
          } else {
            this.remove_class("is-open");
          }
        }
        update_responsive_state() {
          if (typeof window === "undefined") return;
          const is_overlay = this.overlay_mode && window.innerWidth < this.breakpoint;
          if (is_overlay) {
            this.remove_class("drawer-docked");
            this.add_class("drawer-overlay-mode");
          } else {
            this.add_class("drawer-docked");
            this.remove_class("drawer-overlay-mode");
          }
        }
        trap_focus(e_key) {
          if (!this.is_open || !this._ctrl_fields || !this._ctrl_fields.panel) return;
          const panel_el = this._ctrl_fields.panel.dom.el;
          if (!panel_el) return;
          const focusable = panel_el.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
          );
          if (!focusable.length) return;
          const first = focusable[0];
          const last = focusable[focusable.length - 1];
          const is_shift = e_key.shiftKey;
          if (document.activeElement === first && is_shift) {
            e_key.preventDefault();
            last.focus();
          } else if (document.activeElement === last && !is_shift) {
            e_key.preventDefault();
            first.focus();
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el || typeof document === "undefined") return;
            const overlay_ctrl = this._ctrl_fields && this._ctrl_fields.overlay;
            const close_button = this._ctrl_fields && this._ctrl_fields.close_button;
            if (overlay_ctrl && overlay_ctrl.dom.el) {
              overlay_ctrl.add_dom_event_listener("click", () => {
                if (this.is_open) this.close();
              });
            }
            if (close_button && close_button.dom.el) {
              close_button.add_dom_event_listener("click", () => this.close());
            }
            this.add_dom_event_listener("keydown", (e_key) => {
              const key2 = e_key.key || e_key.keyCode;
              if (key2 === "Escape" || key2 === 27) {
                if (this.is_open) this.close();
              }
              if (key2 === "Tab" || key2 === 9) {
                this.trap_focus(e_key);
              }
            });
            if (typeof window !== "undefined") {
              this.update_responsive_state();
              window.addEventListener("resize", () => this.update_responsive_state());
            }
          }
        }
      };
      Drawer.css = `
.drawer {
    position: relative;
}
.drawer-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.3);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
}
.drawer-panel {
    position: fixed;
    top: 0;
    bottom: 0;
    width: 280px;
    background: #fff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.16);
    transform: translateX(-100%);
    transition: transform 0.2s ease;
    display: flex;
    flex-direction: column;
}
.drawer-panel-right {
    right: 0;
    left: auto;
    transform: translateX(100%);
}
.drawer.is-open .drawer-panel {
    transform: translateX(0);
}
.drawer.is-open .drawer-overlay {
    opacity: 1;
    pointer-events: auto;
}
.drawer-header {
    padding: 12px;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: flex-end;
}
.drawer-body {
    padding: 12px;
    overflow: auto;
}
.drawer-close {
    border: 1px solid #ccc;
    background: #fff;
    padding: 6px 10px;
    cursor: pointer;
}
.drawer.drawer-docked .drawer-overlay {
    display: none;
}
.drawer.drawer-docked .drawer-panel {
    position: static;
    transform: translateX(0);
    box-shadow: none;
    width: 240px;
}
`;
      module.exports = Drawer;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/4-data/data_table.js
  var require_data_table = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/4-data/data_table.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var normalize_columns = (columns) => {
        if (!Array.isArray(columns)) return [];
        return columns.map((column, index) => {
          if (typeof column === "string") {
            return {
              key: column,
              label: column,
              sortable: true
            };
          }
          if (column && typeof column === "object") {
            const key2 = is_defined(column.key) ? column.key : index;
            return {
              key: key2,
              label: is_defined(column.label) ? column.label : String(key2),
              sortable: column.sortable !== false,
              accessor: column.accessor,
              render: column.render
            };
          }
          return {
            key: index,
            label: String(column),
            sortable: true
          };
        });
      };
      var get_cell_value = (row, column, column_index) => {
        if (column && typeof column.accessor === "function") {
          return column.accessor(row);
        }
        if (Array.isArray(row)) {
          const index = is_defined(column.index) ? column.index : column_index;
          return row[index];
        }
        if (row && typeof row === "object") {
          const key2 = is_defined(column.key) ? column.key : column_index;
          return row[key2];
        }
        return void 0;
      };
      var compare_values = (left, right) => {
        if (left === right) return 0;
        if (!is_defined(left)) return 1;
        if (!is_defined(right)) return -1;
        if (typeof left === "number" && typeof right === "number") {
          return left - right;
        }
        return String(left).localeCompare(String(right));
      };
      var Data_Table = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "data_table";
          super(spec);
          this.add_class("data-table");
          this.dom.tagName = "table";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.set_columns(spec.columns || []);
          this.set_rows(spec.rows || []);
          this.set_sort_state(spec.sort_state || null);
          this.set_filters(spec.filters || null);
          this.set_page(is_defined(spec.page) ? spec.page : 1);
          this.set_page_size(spec.page_size || null);
          if (!spec.el) {
            this.compose_table();
          }
          this.bind_model();
        }
        compose_table() {
          const { context: context2 } = this;
          const head_ctrl = new Control2({ context: context2, tag_name: "thead" });
          const body_ctrl = new Control2({ context: context2, tag_name: "tbody" });
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.head = head_ctrl;
          this._ctrl_fields.body = body_ctrl;
          this.add(head_ctrl);
          this.add(body_ctrl);
          this.render_table();
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            const name = e_change.name;
            const value2 = e_change.value;
            if (name === "columns" || name === "rows" || name === "sort_state" || name === "filters" || name === "page" || name === "page_size") {
              if (name === "columns") {
                this.columns = normalize_columns(value2);
                if (this.model && typeof this.model.set === "function") {
                  this.model.set("columns", this.columns, true);
                }
              } else if (name === "rows") {
                this.rows = Array.isArray(value2) ? value2 : [];
              } else if (name === "sort_state") {
                this.sort_state = value2 ? { ...value2 } : null;
              } else if (name === "filters") {
                this.filters = value2 ? { ...value2 } : null;
              } else if (name === "page") {
                this.page = Number(value2) || 1;
              } else if (name === "page_size") {
                this.page_size = value2 ? Number(value2) : null;
              }
              this.render_table();
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set table rows.
         * @param {Array} rows - Rows to set.
         */
        set_rows(rows) {
          const row_list = Array.isArray(rows) ? rows.slice() : [];
          this.set_model_value("rows", row_list);
          this.rows = row_list;
        }
        /**
         * Set table columns.
         * @param {Array} columns - Columns to set.
         */
        set_columns(columns) {
          const normalized = normalize_columns(columns);
          this.set_model_value("columns", normalized);
          this.columns = normalized;
        }
        /**
         * Set sort state.
         * @param {Object|null} sort_state - Sort state object.
         */
        set_sort_state(sort_state) {
          const next_sort_state = sort_state ? { ...sort_state } : null;
          this.set_model_value("sort_state", next_sort_state);
          this.sort_state = next_sort_state;
        }
        /**
         * Set filters.
         * @param {Object|null} filters - Filters to set.
         */
        set_filters(filters) {
          const next_filters = filters ? { ...filters } : null;
          this.set_model_value("filters", next_filters);
          this.filters = next_filters;
        }
        /**
         * Set current page.
         * @param {number} page - Page number.
         */
        set_page(page) {
          const next_page = Number(page) || 1;
          this.set_model_value("page", next_page);
          this.page = next_page;
        }
        /**
         * Set page size.
         * @param {number|null} page_size - Page size.
         */
        set_page_size(page_size) {
          const next_page_size = page_size ? Number(page_size) : null;
          this.set_model_value("page_size", next_page_size);
          this.page_size = next_page_size;
        }
        /**
         * Get visible rows after sort/filter/paging.
         * @returns {Array}
         */
        get_visible_rows() {
          return this.visible_rows || [];
        }
        /**
         * Filter rows based on filters.
         * @param {Array} rows - Rows to filter.
         * @returns {Array}
         */
        get_filtered_rows(rows) {
          if (!this.filters) return rows;
          return rows.filter((row) => {
            return Object.keys(this.filters).every((key2) => {
              const filter_value = this.filters[key2];
              if (typeof filter_value === "function") {
                return filter_value(row);
              }
              if (!is_defined(filter_value) || filter_value === "") return true;
              const cell_value = row && typeof row === "object" ? row[key2] : void 0;
              return String(cell_value || "").includes(String(filter_value));
            });
          });
        }
        /**
         * Sort rows based on sort state.
         * @param {Array} rows - Rows to sort.
         * @returns {Array}
         */
        get_sorted_rows(rows) {
          if (!this.sort_state || !is_defined(this.sort_state.key)) return rows;
          const sort_key = this.sort_state.key;
          const direction = this.sort_state.direction === "desc" ? "desc" : "asc";
          const column_index = this.columns.findIndex((column2) => String(column2.key) === String(sort_key));
          if (column_index < 0) return rows;
          const column = this.columns[column_index];
          const sorted = rows.slice().sort((left, right) => {
            const left_value = get_cell_value(left, column, column_index);
            const right_value = get_cell_value(right, column, column_index);
            const cmp = compare_values(left_value, right_value);
            return direction === "desc" ? -cmp : cmp;
          });
          return sorted;
        }
        /**
         * Paginate rows based on page settings.
         * @param {Array} rows - Rows to page.
         * @returns {Array}
         */
        get_paged_rows(rows) {
          if (!this.page_size) return rows;
          const page = Math.max(1, this.page || 1);
          const start_index = (page - 1) * this.page_size;
          return rows.slice(start_index, start_index + this.page_size);
        }
        render_table() {
          const head_ctrl = this._ctrl_fields && this._ctrl_fields.head;
          const body_ctrl = this._ctrl_fields && this._ctrl_fields.body;
          if (!head_ctrl || !body_ctrl) return;
          const columns = this.columns || [];
          const rows = this.rows || [];
          const sort_key = this.sort_state && this.sort_state.key;
          const sort_direction = this.sort_state && this.sort_state.direction === "desc" ? "descending" : "ascending";
          head_ctrl.clear();
          const header_row = new Control2({ context: this.context, tag_name: "tr" });
          columns.forEach((column) => {
            const th_ctrl = new Control2({ context: this.context, tag_name: "th" });
            th_ctrl.add_class("data-table-header");
            th_ctrl.dom.attributes["data-column-key"] = String(column.key);
            th_ctrl.dom.attributes.scope = "col";
            th_ctrl.add(column.label || String(column.key));
            if (column.sortable !== false) {
              th_ctrl.add_class("is-sortable");
              th_ctrl.dom.attributes.tabindex = "0";
              if (is_defined(sort_key) && String(sort_key) === String(column.key)) {
                th_ctrl.dom.attributes["aria-sort"] = sort_direction;
              } else {
                th_ctrl.dom.attributes["aria-sort"] = "none";
              }
            }
            header_row.add(th_ctrl);
          });
          head_ctrl.add(header_row);
          body_ctrl.clear();
          const filtered_rows = this.get_filtered_rows(rows);
          const sorted_rows = this.get_sorted_rows(filtered_rows);
          const visible_rows = this.get_paged_rows(sorted_rows);
          this.visible_rows = visible_rows;
          visible_rows.forEach((row, row_index) => {
            const tr_ctrl = new Control2({ context: this.context, tag_name: "tr" });
            tr_ctrl.add_class("data-table-row");
            tr_ctrl.dom.attributes["data-row-index"] = String(row_index);
            columns.forEach((column, column_index) => {
              const td_ctrl = new Control2({ context: this.context, tag_name: "td" });
              td_ctrl.add_class("data-table-cell");
              const cell_value = get_cell_value(row, column, column_index);
              if (typeof column.render === "function") {
                const rendered = column.render(cell_value, row);
                if (rendered instanceof Control2) {
                  td_ctrl.add(rendered);
                } else if (is_defined(rendered)) {
                  td_ctrl.add(String(rendered));
                }
              } else if (is_defined(cell_value)) {
                td_ctrl.add(String(cell_value));
              }
              tr_ctrl.add(td_ctrl);
            });
            body_ctrl.add(tr_ctrl);
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            const find_row_el = (target) => {
              let node = target;
              while (node && node.getAttribute) {
                if (node.getAttribute("data-row-index") !== null) return node;
                node = node.parentNode;
              }
              return null;
            };
            const find_header_el = (target) => {
              let node = target;
              while (node && node.getAttribute) {
                if (node.getAttribute("data-column-key") !== null) return node;
                node = node.parentNode;
              }
              return null;
            };
            this.add_dom_event_listener("click", (e_click) => {
              const header_el = find_header_el(e_click.target);
              if (header_el) {
                const column_key = header_el.getAttribute("data-column-key");
                const column = (this.columns || []).find((col) => String(col.key) === String(column_key));
                if (column && column.sortable !== false) {
                  const direction = this.sort_state && String(this.sort_state.key) === String(column.key) && this.sort_state.direction === "asc" ? "desc" : "asc";
                  this.set_sort_state({ key: column.key, direction });
                  this.raise("sort_change", { sort_state: this.sort_state });
                }
                return;
              }
              const row_el = find_row_el(e_click.target);
              if (row_el) {
                const row_index = parseInt(row_el.getAttribute("data-row-index"), 10);
                if (!Number.isNaN(row_index)) {
                  const row_data = this.visible_rows && this.visible_rows[row_index];
                  this.raise("row_click", { row_index, row_data });
                }
              }
            });
            this.add_dom_event_listener("keydown", (e_key) => {
              const header_el = find_header_el(e_key.target);
              if (!header_el) return;
              const key2 = e_key.key || e_key.keyCode;
              if (key2 !== "Enter" && key2 !== " " && key2 !== 13 && key2 !== 32) return;
              e_key.preventDefault();
              const column_key = header_el.getAttribute("data-column-key");
              const column = (this.columns || []).find((col) => String(col.key) === String(column_key));
              if (column && column.sortable !== false) {
                const direction = this.sort_state && String(this.sort_state.key) === String(column.key) && this.sort_state.direction === "asc" ? "desc" : "asc";
                this.set_sort_state({ key: column.key, direction });
                this.raise("sort_change", { sort_state: this.sort_state });
              }
            });
          }
        }
      };
      Data_Table.css = `
.data-table {
    width: 100%;
    border-collapse: collapse;
}
.data-table-header {
    text-align: left;
    font-weight: 600;
    padding: 6px 8px;
    border-bottom: 1px solid #ddd;
}
.data-table-header.is-sortable {
    cursor: pointer;
}
.data-table-row {
    border-bottom: 1px solid #eee;
}
.data-table-cell {
    padding: 6px 8px;
}
`;
      module.exports = Data_Table;
    }
  });

  // ../jsgui3-html/controls/connected/data-grid.js
  var require_data_grid = __commonJS({
    "../jsgui3-html/controls/connected/data-grid.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var Data_Table = require_data_table();
      var normalize_columns = (columns) => {
        if (!Array.isArray(columns)) return [];
        return columns.map((column) => column);
      };
      var Data_Grid = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "data_grid";
          super(spec);
          this.add_class("data-grid");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.set_columns(spec.columns || []);
          this.set_data_source(spec.data_source || spec.rows || []);
          this.set_sort_state(spec.sort_state || null);
          this.set_filters(spec.filters || null);
          this.set_page(is_defined(spec.page) ? spec.page : 1);
          this.set_page_size(spec.page_size || null);
          this.set_selection(spec.selection || null);
          if (!spec.el) {
            this.compose_grid();
          }
          this.bind_model();
          this.refresh_rows();
        }
        compose_grid() {
          const { context: context2 } = this;
          const table2 = new Data_Table({
            context: context2,
            columns: this.columns,
            rows: []
          });
          table2.add_class("data-grid-table");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.table = table2;
          this.table = table2;
          this.add(table2);
          table2.on("row_click", (e_row) => {
            this.set_selection({
              row_index: e_row.row_index,
              row_data: e_row.row_data
            });
            this.raise("selection_change", { selection: this.selection });
          });
          table2.on("sort_change", (e_sort) => {
            if (e_sort && e_sort.sort_state) {
              this.set_sort_state(e_sort.sort_state);
            }
          });
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            const name = e_change.name;
            const value2 = e_change.value;
            if (name === "columns") {
              this.columns = normalize_columns(value2);
              if (this.table) this.table.set_columns(this.columns);
              return;
            }
            if (name === "sort_state") {
              this.sort_state = value2 ? { ...value2 } : null;
              if (this.table) this.table.set_sort_state(this.sort_state);
              this.refresh_rows();
              return;
            }
            if (name === "filters") {
              this.filters = value2 ? { ...value2 } : null;
              if (this.table) this.table.set_filters(this.filters);
              this.refresh_rows();
              return;
            }
            if (name === "page") {
              this.page = Number(value2) || 1;
              if (this.table) this.table.set_page(this.page);
              this.refresh_rows();
              return;
            }
            if (name === "page_size") {
              this.page_size = value2 ? Number(value2) : null;
              if (this.table) this.table.set_page_size(this.page_size);
              this.refresh_rows();
              return;
            }
            if (name === "data_source") {
              this.data_source = value2;
              this.refresh_rows();
              return;
            }
            if (name === "selection") {
              this.selection = value2;
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set data source.
         * @param {*} data_source - Source of rows.
         */
        set_data_source(data_source) {
          this.set_model_value("data_source", data_source);
          this.data_source = data_source;
        }
        /**
         * Set columns.
         * @param {Array} columns - Column definitions.
         */
        set_columns(columns) {
          const normalized = normalize_columns(columns);
          this.set_model_value("columns", normalized);
          this.columns = normalized;
          if (this.table) this.table.set_columns(normalized);
        }
        /**
         * Set sort state.
         * @param {Object|null} sort_state - Sort state.
         */
        set_sort_state(sort_state) {
          const next_sort_state = sort_state ? { ...sort_state } : null;
          this.set_model_value("sort_state", next_sort_state);
          this.sort_state = next_sort_state;
          if (this.table) this.table.set_sort_state(next_sort_state);
        }
        /**
         * Set filters.
         * @param {Object|null} filters - Filters to apply.
         */
        set_filters(filters) {
          const next_filters = filters ? { ...filters } : null;
          this.set_model_value("filters", next_filters);
          this.filters = next_filters;
          if (this.table) this.table.set_filters(next_filters);
        }
        /**
         * Set page.
         * @param {number} page - Page number.
         */
        set_page(page) {
          const next_page = Number(page) || 1;
          this.set_model_value("page", next_page);
          this.page = next_page;
          if (this.table) this.table.set_page(next_page);
        }
        /**
         * Set page size.
         * @param {number|null} page_size - Page size.
         */
        set_page_size(page_size) {
          const next_page_size = page_size ? Number(page_size) : null;
          this.set_model_value("page_size", next_page_size);
          this.page_size = next_page_size;
          if (this.table) this.table.set_page_size(next_page_size);
        }
        /**
         * Set selection.
         * @param {*} selection - Selection object.
         */
        set_selection(selection) {
          this.set_model_value("selection", selection);
          this.selection = selection;
        }
        /**
         * Get selection.
         * @returns {*}
         */
        get_selection() {
          return this.selection;
        }
        /**
         * Refresh rows from the data source.
         */
        refresh_rows() {
          const data_source = this.data_source;
          const params = {
            columns: this.columns,
            sort_state: this.sort_state,
            filters: this.filters,
            page: this.page,
            page_size: this.page_size
          };
          let rows = [];
          if (Array.isArray(data_source)) {
            rows = data_source;
          } else if (typeof data_source === "function") {
            rows = data_source(params);
          } else if (data_source && typeof data_source.get_rows === "function") {
            rows = data_source.get_rows(params);
          } else if (data_source && Array.isArray(data_source.rows)) {
            rows = data_source.rows;
          }
          if (rows && typeof rows.then === "function") {
            const request_id = (this._request_id || 0) + 1;
            this._request_id = request_id;
            rows.then((result) => {
              if (this._request_id !== request_id) return;
              const resolved_rows = Array.isArray(result) ? result : [];
              if (this.table) this.table.set_rows(resolved_rows);
            });
          } else {
            const resolved_rows = Array.isArray(rows) ? rows : [];
            if (this.table) this.table.set_rows(resolved_rows);
          }
        }
      };
      Data_Grid.css = `
.data-grid {
    width: 100%;
}
`;
      module.exports = Data_Grid;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/text-item.js
  var require_text_item = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/text-item.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var textNode = require_text_node();
      var fields = [
        ["value", String, ""]
      ];
      var Text_Item = class extends Control2 {
        // is an Input element.
        //  type of either text or password.
        // could possibly specify some of the starting field values in this part.
        constructor(spec) {
          super(spec, fields);
          this.__type_name = "text_item";
          this.add_class("item");
          this.add(new textNode({
            text: this.value,
            context: this.context
          }));
        }
      };
      module.exports = Text_Item;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Indicator.js
  var require_Indicator = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Indicator.js"(exports, module) {
      var jsgui = require_html_core();
      var {
        Control: Control2,
        parse_mount,
        parse,
        field
      } = jsgui;
      var Indicator = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "indicator";
          super(spec);
          const {
            context: context2
          } = this;
          this.add_class("indicator");
          if (!spec.el) {
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
          }
        }
      };
      module.exports = Indicator;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Status_Indicator.js
  var require_Status_Indicator = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Status_Indicator.js"(exports, module) {
      var Indicator = require_Indicator();
      var Status_Indicator = class extends Indicator {
        constructor(spec) {
          super(spec);
          this.on("change", (e) => {
            const { name, value: value2 } = e;
            console.log("status indicator change", name, value2);
          });
          this.data.on("change", (e) => {
            const { name, value: value2 } = e;
            console.log("status indicator .data change", name, value2);
          });
          this.data.model.on("change", (e) => {
            const { name, value: value2 } = e;
            console.log("status indicator .data.model change", name, value2);
          });
        }
        // bind this to a data value?
        //   simple function, could deal with lower level stuff where necessary.
      };
      Status_Indicator.css = `
.indicator {
    display: inline-block;
    width: 1em;
    height: 1em;
    border-radius: 50%;
    background-color: var(--status-indicator-color, gray);
}       
.indicator.on {
    background-color: green;
}       
.indicator.off {
    background-color: red;
}
.indicator.yes {
    background-color: blue;
}
.indicator.no {
    background-color: orange;
}   
.indicator.unknown {
    background-color: gray;
}   
`;
      module.exports = Status_Indicator;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Validation_Status_Indicator.js
  var require_Validation_Status_Indicator = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Validation_Status_Indicator.js"(exports, module) {
      var Status_Indicator = require_Status_Indicator();
      var Control_Validation = require_Control_Validation();
      var Validation_Status_Indicator = class extends Status_Indicator {
        // Likely will need some client-side recoherence with whatever model(s).
        // vsi.data.model.value being the status value itself?
        // vsi.data.model.validation.state perhaps?????
        //   
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "validation_status_indicator";
          super(spec);
          this.add_class("validation-status");
          const { context: context2 } = this;
          const create_control_validation_but_maybe_we_dont_need_it = () => {
            const o_validation = { context: context2 };
            if (spec.validation) {
              if (spec.validation.data) {
                if (spec.validation.data.model) {
                  o_validation.data = {
                    model: spec.validation.data.model
                  };
                }
              }
            }
            this.validation = new Control_Validation(o_validation);
            this.validation.state.on("change", (e) => {
              const { name, old, value: value2 } = e;
              if (name === "valid") {
                if (value2 === true) {
                  this.remove_class("is-not-valid");
                  this.add_class("is-valid");
                } else if (value2 === false) {
                  this.remove_class("is-valid");
                  this.add_class("is-not-valid");
                }
              }
            });
          };
          create_control_validation_but_maybe_we_dont_need_it();
          if (this.data && this.data.model) {
            try {
              this.data.model.set("validation", this.validation, true);
            } catch (e) {
              this.data.model.validation = this.validation;
            }
          }
          this.data.on("change", (e) => {
            console.log("V_S_I change e:", e);
            const { name, old, value: value2 } = e;
            if (name === "model") {
              console.log("vsi data model change e", e);
            }
          });
          if (this.data && this.data.model && this.data.model.validation && this.data.model.validation.state && this.data.model.validation.state.on) {
            this.data.model.validation.state.on("change", (e) => {
              console.log("Validation_Status_Indicator .data.model.validation.state change e:", e);
            });
          }
        }
        activate() {
          const log_some_things = () => {
            console.log("Validation_Status_Indicator activate");
            console.log("this.validation", this.validation);
            console.log("this.validation.state", this.validation.state);
            console.log("this.validation.data.model", this.validation.data.model);
            console.log("this.data.model", this.data.model);
            console.log("this.data.model.value", this.data.model.value);
          };
        }
        // And activation????
        //   Would nice to have less needing to be done in activate functions.
      };
      Validation_Status_Indicator.css = `
    .validation-status.indicator {
        width: 24px;
        height: 24px;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
        border: 1px solid #333333;
        border-radius: 3px;
    }
    .validation-status.indicator.is-valid {
        background-color: '#66DD66'
    }
    .validation-status.indicator.is-not-valid {
        background-color: '#DD6666'
    }
`;
      module.exports = Validation_Status_Indicator;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Text_Field.js
  var require_Text_Field = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/Text_Field.js"(exports, module) {
      var jsgui = require_html_core();
      var Text_Input = require_Text_Input();
      var Text_Item = require_text_item();
      var { Control: Control2, Control_Data, Control_View, Data_Object, Data_Value: Data_Value2, Data_Model } = jsgui;
      var { field } = require_lang();
      var Data_Model_View_Model_Control = require_Data_Model_View_Model_Control();
      var Validation_Status_Indicator = require_Validation_Status_Indicator();
      var { model_data_view_compositional_representation } = require_mx();
      var fields = [
        ["text", String],
        ["name", String],
        //['value', String],
        ["type", String],
        ["editable", Boolean, true],
        ["show_text", Boolean, true]
      ];
      var Text_Field = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        //  and can have other fields possibly.
        constructor(spec) {
          super(spec, fields);
          this.editable = true;
          this.__type_name = "text_field";
          this.add_class("text-field");
          if (spec.placeholder) this.placeholder = spec.placeholder;
          if (spec.label !== void 0 && spec.text === void 0) {
            this.text = spec.label;
          }
          if (spec.value !== void 0) {
            try {
              this.set("value", spec.value, true);
            } catch (e) {
              this.value = spec.value;
            }
            if (this.data && this.data.model && typeof this.data.model.set === "function") {
              this.data.model.set("value", spec.value, true);
            } else if (this.data && this.data.model) {
              this.data.model.value = spec.value;
            }
          }
          const { context: context2 } = this;
          const data_model_change_handler = (e) => {
            console.log("Text_Field data_model_change_handler e", e);
            const { name, old, value: value2 } = e;
            if (name === "value") {
              this.view.data.model.value = value2;
            }
          };
          this.data.model.on("change", data_model_change_handler);
          this.data.on("change", (e) => {
            const { name, value: value2, old } = e;
            console.log("Text_Field data change e:", e);
            if (name === "model") {
              if (old instanceof Data_Model) {
                old.off("change", data_model_change_handler);
              }
              value2.on("change", data_model_change_handler);
            }
          });
          const view_data_model_change_handler = (e) => {
            const { name, old, value: value2 } = e;
            if (name === "value") {
              this.data.model.value = value2;
              if (this.text_input) {
                this.text_input.data.model.value = value2;
              }
            }
          };
          this.view.data.model.on("change", view_data_model_change_handler);
          this.view.data.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (name === "model") {
              if (old instanceof Data_Model) {
                old.off("change", view_data_model_change_handler);
              }
              value2.on("change", view_data_model_change_handler);
            }
          });
          const old_setup_data_and_view = () => {
            this.data = new Control_Data({ context: context2 });
            if (spec.data && spec.data.model) {
              this.data.model = spec.data.model;
            } else {
              this.data.model = new Data_Value2({ context: context2 });
            }
            this.view = new Control_View({ context: context2 });
            if (spec.view && spec.view.data.model) {
              this.view.data.model = spec.view.data.model;
            } else {
              this.view.data.model = new Data_Value2({ context: context2 });
            }
            this.view.data.model.on("change", (e) => {
              const { name, value: value2, old } = e;
              if (name === "value") {
                if (value2 !== old) {
                  this.data.model.value = value2;
                  this.text_input.data.model.value = value2;
                }
              }
            });
          };
          if (!spec.el) {
            this.compose_text_field();
          }
        }
        setup_inner_control_events() {
          const { text_input } = this;
          this.view.data.model.on("change", (e) => {
            const { name, old, value: value2 } = e;
            if (name === "value") {
              text_input.data.model.value = value2;
            }
          });
          text_input.data.model.on("change", (e) => {
            const { name, old, value: value2 } = e;
            if (name === "value") {
              this.view.data.model.value = value2;
            }
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const { dom, text_input } = this;
            this.setup_inner_control_events();
          }
        }
        compose_text_field() {
          const old_composition_code = () => {
            var left = new jsgui.div({
              "context": this.context
            });
            left.add_class("left");
            var right = new jsgui.div({
              "context": this.context
            });
            right.add_class("right");
            this.add(left);
            this.add(right);
            var clearall = new jsgui.div({
              "context": this.context
            });
            clearall.add_class("clearall");
            this.add(clearall);
            if (this.show_text) {
              var label = new jsgui.label({
                "context": this.context
              });
              label.add(this.text);
              left.add(label);
            }
            const _ctrl_fields = this._ctrl_fields = this._ctrl_fields || {};
            if (this.editable) {
              let o_spec = {
                "context": this.context,
                "value": this.value
              };
              if (this.placeholder) o_spec.placeholder = this.placeholder;
              var text_input = new Text_Input(o_spec);
              var tiid = text_input._id();
              text_input.dom.attributes.id = tiid;
              text_input.dom.attributes.name = this.name;
              label.dom.attributes.for = tiid;
              text_input.dom.attributes.type = this.type;
              right.add(text_input);
              _ctrl_fields.text_input = text_input;
              this.text_input = this.text_input = text_input;
            } else {
              var text_item = new Text_Item({
                "context": this.context,
                "value": this.value
              });
              right.add(text_item);
              _ctrl_fields.text_item = text_item;
              this.text_item = text_item;
            }
          };
          const using_compositional_model = () => {
            this.view.ui.compositional.model = [
              // (string, function || constructor) handling needed for the composition system.
              // (string, function || constructor, object)
              ["left_part", Control2, { class: "left", comp: [["label", jsgui.label]] }],
              ["right_part", Control2, { class: "right", comp: [["text_input", Text_Input, { "value": this.value }]] }]
            ];
            const label = this._ctrl_fields.left_part.content._arr[0];
            const text_input = this._ctrl_fields.right_part.content._arr[0];
            if (this.text) {
              label.add(this.text);
            }
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.label = label;
            this._ctrl_fields.text_input = text_input;
            this.label = label;
            this.text_input = text_input;
          };
          using_compositional_model();
        }
      };
      module.exports = Text_Field;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/file-upload.js
  var require_file_upload = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/file-upload.js"(exports, module) {
      var jsgui = require_html_core();
      var Text_Field = require_Text_Field();
      var Button = require_button();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var File_Upload = class extends Control2 {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          var autosubmit = spec.autosubmit || false;
          var mode = "medium";
          if (spec.mode) mode = spec.mode;
          if (mode == "icon" || mode == "mini" || mode == "compact") autosubmit = true;
          this.__type_name = "file_upload";
          var req = this.context.req;
          var frm = new jsgui.form({
            "context": this.context
          });
          this.action = spec.action || "/upload/";
          var da = this.dom.attrs;
          da.action = this.action;
          da.method = "POST";
          da.enctype = "multipart/form-data";
          this.add(frm);
          var input_file = new jsgui.input({
            //'type': 'file',
            "context": this.context
          });
          input_file.set("dom.attributes.type", "file");
          input_file.set("dom.attributes.name", "file");
          frm.add(input_file);
          if (mode === "normal" || mode === "large") {
            var btn = new Button({
              "context": this.context
            });
            var bda = btn.dom.attrs;
            bda.type = "submit";
            bda.value = "submit";
            bda.class = "upload";
            btn.add("Upload");
            frm.add(btn);
          }
          var ctrl_fields = {
            "input_file": input_file._id(),
            "form": frm._id()
          };
        }
        "activate"() {
          super.activate();
          console.log("activate File_Upload");
          var mode = this.mode;
          var autosubmit = this.autosubmit;
          var input_file = this.input_file;
          var form = this.form;
          if (autosubmit) {
            input_file.add_event_listener("change", function(e_change) {
              console.log("e_change", e_change);
              form.dom.el.submit();
            });
          }
        }
      };
      module.exports = File_Upload;
    }
  });

  // ../jsgui3-html/control_mixins/field_status.js
  var require_field_status = __commonJS({
    "../jsgui3-html/control_mixins/field_status.js"(exports, module) {
      var jsgui = require_html_core();
      var { is_defined } = jsgui;
      var STATUS_TOKENS = ["error", "warn", "info", "success"];
      var get_status_class = (prefix, status) => status ? `${prefix}-${status}` : "";
      var apply_field_status = (ctrl, spec = {}) => {
        const prefix = spec.prefix || "field-status";
        ctrl.field_status = "";
        ctrl.attach_field_aria = (input_ctrl, message_ctrl, status) => {
          if (!input_ctrl || !input_ctrl.dom || !input_ctrl.dom.attributes) return;
          if (message_ctrl && message_ctrl.dom && message_ctrl.dom.attributes) {
            if (!message_ctrl.dom.attributes.id) {
              message_ctrl.dom.attributes.id = message_ctrl.__id;
            }
            input_ctrl.dom.attributes["aria-describedby"] = message_ctrl.dom.attributes.id;
          }
          if (status === "error") {
            input_ctrl.dom.attributes["aria-invalid"] = "true";
          } else {
            input_ctrl.dom.attributes["aria-invalid"] = "false";
          }
        };
        ctrl.set_field_status = (status, detail = {}) => {
          if (ctrl.field_status) {
            ctrl.remove_class(get_status_class(prefix, ctrl.field_status));
          }
          const next_status = is_defined(status) ? String(status) : "";
          ctrl.field_status = next_status;
          if (next_status) {
            ctrl.add_class(get_status_class(prefix, next_status));
          }
          if (detail.message_ctrl) {
            if (detail.message_ctrl.set_status) {
              detail.message_ctrl.set_status(next_status);
            }
            if (is_defined(detail.message) && detail.message_ctrl.set_message) {
              detail.message_ctrl.set_message(detail.message);
            }
          }
          if (detail.badge_ctrl) {
            if (detail.badge_ctrl.set_status) {
              detail.badge_ctrl.set_status(next_status);
            }
            if (is_defined(detail.badge_text) && detail.badge_ctrl.set_text) {
              detail.badge_ctrl.set_text(detail.badge_text);
            }
          }
          if (detail.input_ctrl) {
            ctrl.attach_field_aria(detail.input_ctrl, detail.message_ctrl, next_status);
          }
        };
        ctrl.clear_field_status = (detail) => {
          ctrl.set_field_status("", detail || {});
        };
        return ctrl;
      };
      module.exports = {
        STATUS_TOKENS,
        apply_field_status,
        get_status_class
      };
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/inline_validation_message.js
  var require_inline_validation_message = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/inline_validation_message.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var get_status_class = (status) => status ? `inline-validation-message-${status}` : "";
      var status_icons = {
        error: "\u2717",
        // Heavy ballot X
        warn: "\u26A0",
        // Warning sign
        info: "\u2139",
        // Information source
        success: "\u2713"
        // Check mark
      };
      var Inline_Validation_Message = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "inline_validation_message";
          super(spec);
          this.add_class("inline-validation-message");
          this.dom.tagName = "span";
          this.dom.attributes.role = "status";
          this.dom.attributes["aria-live"] = "polite";
          this.dom.attributes["aria-atomic"] = "true";
          this.show_icon = spec.show_icon !== false;
          this.status = is_defined(spec.status) ? String(spec.status) : "";
          if (this.status) {
            this.add_class(get_status_class(this.status));
          }
          this.message = is_defined(spec.message) ? String(spec.message) : "";
          if (!spec.el) {
            this._compose();
          }
        }
        /**
         * Compose the message structure with icon.
         * @private
         */
        _compose() {
          const { context: context2 } = this;
          this._icon_ctrl = new Control2({
            context: context2,
            tag_name: "span"
          });
          this._icon_ctrl.add_class("inline-validation-icon");
          this._icon_ctrl.dom.attributes["aria-hidden"] = "true";
          this.add(this._icon_ctrl);
          this._text_ctrl = new Control2({
            context: context2,
            tag_name: "span"
          });
          this._text_ctrl.add_class("inline-validation-text");
          this.add(this._text_ctrl);
          this._update_icon();
          if (this.message) {
            this._text_ctrl.add(this.message);
          }
        }
        /**
         * Update the icon based on status.
         * @private
         */
        _update_icon() {
          if (!this._icon_ctrl) return;
          this._icon_ctrl.clear();
          if (this.show_icon && this.status && status_icons[this.status]) {
            this._icon_ctrl.add(status_icons[this.status]);
            this._icon_ctrl.show();
          } else {
            this._icon_ctrl.hide();
          }
        }
        /**
         * Set the validation message text.
         * @param {string} message - The message to set.
         * @param {string} [status] - Optional status to set at the same time.
         */
        set_message(message, status) {
          this.message = is_defined(message) ? String(message) : "";
          if (this._text_ctrl) {
            this._text_ctrl.clear();
            if (this.message) {
              this._text_ctrl.add(this.message);
            }
          } else {
            this.clear();
            this._compose();
          }
          if (is_defined(status)) {
            this.set_status(status);
          }
        }
        /**
         * Get the validation message text.
         * @returns {string}
         */
        get_message() {
          return this.message || "";
        }
        /**
         * Set the validation status.
         * @param {string} status - The status to set.
         */
        set_status(status) {
          if (this.status) {
            this.remove_class(get_status_class(this.status));
          }
          this.status = is_defined(status) ? String(status) : "";
          if (this.status) {
            this.add_class(get_status_class(this.status));
          }
          this._update_icon();
        }
        /**
         * Clear the message and status.
         */
        clear_validation() {
          this.set_message("");
          this.set_status("");
        }
        /**
         * Set error state.
         * @param {string} message - Error message.
         */
        set_error(message) {
          this.set_message(message, "error");
        }
        /**
         * Set success state.
         * @param {string} [message] - Optional success message.
         */
        set_success(message) {
          this.set_message(message || "", "success");
        }
        /**
         * Set warning state.
         * @param {string} message - Warning message.
         */
        set_warning(message) {
          this.set_message(message, "warn");
        }
        /**
         * Set info state.
         * @param {string} message - Info message.
         */
        set_info(message) {
          this.set_message(message, "info");
        }
      };
      Inline_Validation_Message.css = `
.inline-validation-message {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 0.85em;
    color: #444;
    min-height: 1.2em;
}

.inline-validation-icon {
    flex-shrink: 0;
    font-weight: bold;
}

.inline-validation-text {
    flex: 1;
}

.inline-validation-message-error {
    color: #b71c1c;
}

.inline-validation-message-error .inline-validation-icon {
    color: #d32f2f;
}

.inline-validation-message-warn {
    color: #e65100;
}

.inline-validation-message-warn .inline-validation-icon {
    color: #ff9800;
}

.inline-validation-message-info {
    color: #0d47a1;
}

.inline-validation-message-info .inline-validation-icon {
    color: #1976d2;
}

.inline-validation-message-success {
    color: #1b5e20;
}

.inline-validation-message-success .inline-validation-icon {
    color: #388e3c;
}
`;
      module.exports = Inline_Validation_Message;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/textarea.js
  var require_textarea = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/textarea.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var apply_input_mask = require_input_mask();
      var { apply_full_input_api } = require_input_api();
      var Textarea = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "textarea";
          super(spec);
          this.add_class("textarea");
          this.dom.tagName = "textarea";
          this.enhance_only = !!spec.enhance_only && !!spec.el;
          this.autosize = !!spec.autosize;
          this.autosize_line_height = is_defined(spec.autosize_line_height) ? Number(spec.autosize_line_height) : 20;
          apply_input_mask(this, spec);
          apply_full_input_api(this, {
            disabled: spec.disabled,
            readonly: spec.readonly,
            required: spec.required
          });
          if (is_defined(spec.placeholder)) {
            this.dom.attributes.placeholder = String(spec.placeholder);
          }
          if (is_defined(spec.rows)) {
            this.dom.attributes.rows = String(spec.rows);
          }
          if (is_defined(spec.cols)) {
            this.dom.attributes.cols = String(spec.cols);
          }
          if (spec.disabled) {
            this.dom.attributes.disabled = "disabled";
          }
          if (spec.readonly) {
            this.dom.attributes.readonly = "readonly";
          }
          const has_spec_value = is_defined(spec.value);
          const dom_value = this.enhance_only && spec.el ? String(spec.el.value || "") : "";
          const value2 = has_spec_value ? String(spec.value) : dom_value;
          this.value = this.apply_input_mask_value ? this.apply_input_mask_value(value2) : value2;
          if (!spec.el && value2) {
            this.add(this.value);
          }
        }
        /**
         * Set the textarea value.
         * @param {*} value - The value to set.
         */
        set_value(value2) {
          const value_str = is_defined(value2) ? String(value2) : "";
          const masked_value = this.apply_input_mask_value ? this.apply_input_mask_value(value_str) : value_str;
          this.value = masked_value;
          if (!this.dom.el) {
            this.clear();
            if (masked_value) {
              this.add(masked_value);
            }
          } else {
            this.dom.el.value = masked_value;
            if (this.autosize) {
              this.adjust_autosize();
            }
          }
        }
        /**
         * Get the textarea value.
         * @returns {string}
         */
        get_value() {
          return this.value || "";
        }
        /**
         * Focus the textarea element.
         */
        focus() {
          if (this.dom.el) {
            this.dom.el.focus();
          }
        }
        /**
         * Select the textarea content.
         */
        select() {
          if (this.dom.el) {
            this.dom.el.select();
          }
        }
        /**
         * Adjust textarea height for autosize mode.
         */
        adjust_autosize() {
          if (!this.dom.el) return;
          this.dom.el.style.height = "auto";
          const scroll_height = this.dom.el.scrollHeight || 0;
          if (scroll_height > 0) {
            this.dom.el.style.height = `${scroll_height}px`;
          } else {
            const rows = Number(this.dom.attributes.rows) || 2;
            const fallback_height = rows * (this.autosize_line_height || 20);
            this.dom.el.style.height = `${fallback_height}px`;
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            const sync_value = () => {
              const masked_value = this.apply_input_mask_value ? this.apply_input_mask_value(this.dom.el.value) : this.dom.el.value;
              if (this.dom.el.value !== masked_value) {
                this.dom.el.value = masked_value;
              }
              this.value = masked_value;
              if (this.autosize) {
                this.adjust_autosize();
              }
            };
            this.add_dom_event_listener("input", sync_value);
            this.add_dom_event_listener("change", sync_value);
            sync_value();
            if (this.autosize) {
              this.adjust_autosize();
            }
          }
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap("textarea", Textarea, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Textarea;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/form_container.js
  var require_form_container = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/form_container.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2, Data_Object } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var apply_field_status = require_field_status().apply_field_status;
      var Inline_Validation_Message = require_inline_validation_message();
      var Badge = require_badge();
      var Text_Input = require_Text_Input();
      var Textarea = require_textarea();
      var normalize_fields = (fields) => Array.isArray(fields) ? fields.slice() : [];
      var get_field_label = (field) => {
        if (is_defined(field.label)) return String(field.label);
        if (is_defined(field.name)) return String(field.name);
        return "Field";
      };
      var get_field_name = (field, index) => {
        if (is_defined(field.name)) return String(field.name);
        return `field_${index}`;
      };
      var Form_Container = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "form_container";
          super(spec);
          this.add_class("form-container");
          this.dom.tagName = "form";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          const { context: context2 } = this;
          this.values = spec.values instanceof Data_Object ? spec.values : new Data_Object({ context: context2 });
          this.validation = spec.validation instanceof Data_Object ? spec.validation : new Data_Object({ context: context2 });
          this.errors = spec.errors instanceof Data_Object ? spec.errors : new Data_Object({ context: context2 });
          this.model.set("values", this.values);
          this.model.set("validation", this.validation);
          this.model.set("errors", this.errors);
          this.fields = normalize_fields(spec.fields);
          this.show_status_badge = spec.show_status_badge !== false;
          if (!spec.el) {
            this.compose_form();
          }
          this.bind_model();
        }
        bind_model() {
          if (!this.values || typeof this.values.on !== "function") return;
          this.values.on("change", (e_change) => {
            const field_name = e_change.name;
            const field_ctrl = this.field_controls && this.field_controls[field_name];
            if (!field_ctrl) return;
            this.apply_field_value(field_ctrl, e_change.value);
          });
        }
        /**
         * Set field value in model and control.
         * @param {string} field_name - Field name.
         * @param {*} value - Value to set.
         */
        set_value(field_name, value2) {
          if (!field_name) return;
          if (this.values && typeof this.values.set === "function") {
            this.values.set(field_name, value2);
          }
          const field_ctrl = this.field_controls && this.field_controls[field_name];
          if (field_ctrl) {
            this.apply_field_value(field_ctrl, value2);
          }
        }
        /**
         * Get field value.
         * @param {string} field_name - Field name.
         * @returns {*}
         */
        get_value(field_name) {
          const field_ctrl = this.field_controls && this.field_controls[field_name];
          if (!field_ctrl) return void 0;
          return this.read_field_value(field_ctrl);
        }
        /**
         * Get form values.
         * @returns {Object}
         */
        get_values() {
          const values = {};
          Object.keys(this.field_controls || {}).forEach((field_name) => {
            values[field_name] = this.get_value(field_name);
          });
          return values;
        }
        /**
         * Set form values.
         * @param {Object} values - Values to set.
         */
        set_values(values) {
          if (!values || typeof values !== "object") return;
          Object.keys(values).forEach((field_name) => {
            this.set_value(field_name, values[field_name]);
          });
        }
        /**
         * Validate all fields.
         * @returns {Object} Validation result.
         */
        validate() {
          const result = {
            valid: true,
            errors: {}
          };
          this.fields.forEach((field, index) => {
            const field_name = get_field_name(field, index);
            const field_ctrl = this.field_controls[field_name];
            if (!field_ctrl) return;
            const value2 = this.read_field_value(field_ctrl);
            const errors = [];
            const validators = [];
            if (field.required) {
              validators.push((val) => {
                if (field.type === "checkbox") {
                  return val ? true : "This field is required.";
                }
                if (is_defined(val) && String(val).trim() !== "") return true;
                return "This field is required.";
              });
            }
            if (typeof field.validator === "function") {
              validators.push(field.validator);
            }
            if (Array.isArray(field.validators)) {
              field.validators.forEach((validator) => {
                if (typeof validator === "function") validators.push(validator);
              });
            }
            validators.forEach((validator) => {
              const validation = validator(value2, this.get_values());
              if (validation === true) return;
              if (validation === false) {
                errors.push("Invalid value.");
                return;
              }
              if (typeof validation === "string") {
                errors.push(validation);
                return;
              }
              if (validation && typeof validation === "object") {
                if (validation.valid === false) {
                  errors.push(validation.message || "Invalid value.");
                }
              }
            });
            if (errors.length) {
              result.valid = false;
              result.errors[field_name] = errors[0];
              this.validation.set(field_name, { valid: false, status: "error" });
              this.errors.set(field_name, errors[0]);
              this.update_field_status(field_ctrl, "error", errors[0]);
            } else {
              this.validation.set(field_name, { valid: true, status: "success" });
              this.errors.set(field_name, "");
              this.update_field_status(field_ctrl, "success", "");
            }
          });
          return result;
        }
        /**
         * Submit the form.
         * @returns {Object}
         */
        submit() {
          const validation = this.validate();
          if (validation.valid) {
            this.raise("submit", { values: this.get_values() });
          } else {
            this.raise("invalid", { errors: validation.errors });
          }
          return validation;
        }
        compose_form() {
          const { context: context2 } = this;
          this.field_controls = {};
          this.fields.forEach((field, index) => {
            const field_name = get_field_name(field, index);
            const field_label = get_field_label(field);
            const field_ctrl = new Control2({ context: context2, tag_name: "div" });
            field_ctrl.add_class("form-container-field");
            field_ctrl.dom.attributes["data-field-name"] = field_name;
            apply_field_status(field_ctrl);
            const label_ctrl = new Control2({ context: context2, tag_name: "label" });
            label_ctrl.add_class("form-container-label");
            label_ctrl.dom.attributes["data-field-name"] = field_name;
            label_ctrl.add(field_label);
            const input_ctrl = this.create_input_control(field, context2);
            input_ctrl.add_class("form-container-input");
            input_ctrl.dom.attributes["data-field-name"] = field_name;
            input_ctrl.dom.attributes.name = field_name;
            if (field.required) {
              input_ctrl.dom.attributes.required = "required";
              input_ctrl.dom.attributes["aria-required"] = "true";
            }
            const message_ctrl = new Inline_Validation_Message({
              context: context2,
              message: "",
              status: ""
            });
            message_ctrl.add_class("form-container-message");
            let badge_ctrl = null;
            if (this.show_status_badge) {
              badge_ctrl = new Badge({
                context: context2,
                text: "",
                status: ""
              });
              badge_ctrl.add_class("form-container-badge");
            }
            field_ctrl.add(label_ctrl);
            field_ctrl.add(input_ctrl);
            if (badge_ctrl) field_ctrl.add(badge_ctrl);
            field_ctrl.add(message_ctrl);
            const initial_value = is_defined(field.value) ? field.value : field.initial_value;
            if (is_defined(initial_value)) {
              this.apply_field_value({ input_ctrl, field }, initial_value);
              this.values.set(field_name, initial_value);
            }
            this.update_field_status(
              { field_ctrl, input_ctrl, message_ctrl, badge_ctrl, field },
              "",
              ""
            );
            this.field_controls[field_name] = {
              field_ctrl,
              input_ctrl,
              message_ctrl,
              badge_ctrl,
              field
            };
            this.add(field_ctrl);
          });
        }
        create_input_control(field, context2) {
          if (field.input_control) {
            return field.input_control;
          }
          const type = field.type || "text";
          if (type === "textarea") {
            return new Textarea({
              context: context2,
              placeholder: field.placeholder,
              autosize: field.autosize,
              mask_type: field.mask_type,
              mask_pattern: field.mask_pattern
            });
          }
          if (type === "checkbox") {
            const checkbox = new Control2({ context: context2, tag_name: "input" });
            checkbox.dom.attributes.type = "checkbox";
            return checkbox;
          }
          const input = new Text_Input({
            context: context2,
            placeholder: field.placeholder,
            mask_type: field.mask_type,
            mask_pattern: field.mask_pattern
          });
          input.dom.attributes.type = type;
          return input;
        }
        read_field_value(field_ctrl) {
          const input_ctrl = field_ctrl.input_ctrl || field_ctrl;
          const field_def = field_ctrl.field || {};
          if (!input_ctrl) return void 0;
          if (typeof input_ctrl.get_value === "function") {
            return input_ctrl.get_value();
          }
          if (input_ctrl.dom && input_ctrl.dom.el) {
            if (field_def.type === "checkbox") return !!input_ctrl.dom.el.checked;
            return input_ctrl.dom.el.value;
          }
          if (this.values && typeof this.values.get === "function") {
            return this.values.get(field_def.name);
          }
          return void 0;
        }
        apply_field_value(field_ctrl, value2) {
          const input_ctrl = field_ctrl.input_ctrl || field_ctrl;
          const field_def = field_ctrl.field || {};
          if (!input_ctrl) return;
          if (typeof input_ctrl.set_value === "function") {
            input_ctrl.set_value(value2);
            return;
          }
          if (input_ctrl.dom && input_ctrl.dom.el) {
            if (field_def.type === "checkbox") {
              input_ctrl.dom.el.checked = !!value2;
            } else {
              input_ctrl.dom.el.value = is_defined(value2) ? value2 : "";
            }
          } else if (input_ctrl.dom && input_ctrl.dom.attributes) {
            if (field_def.type === "checkbox") {
              if (value2) {
                input_ctrl.dom.attributes.checked = "checked";
              } else {
                delete input_ctrl.dom.attributes.checked;
              }
            } else {
              input_ctrl.dom.attributes.value = is_defined(value2) ? value2 : "";
            }
          }
        }
        update_field_status(field_ctrl, status, message) {
          const { field_ctrl: wrapper, input_ctrl, message_ctrl, badge_ctrl, field } = field_ctrl;
          const badge_text = status ? status.toUpperCase() : "";
          if (wrapper && wrapper.set_field_status) {
            wrapper.set_field_status(status, {
              input_ctrl,
              message_ctrl,
              badge_ctrl,
              message,
              badge_text
            });
          }
          if (field && field.status_badge_text && badge_ctrl && badge_ctrl.set_text) {
            badge_ctrl.set_text(field.status_badge_text);
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            const handle_event = (e_event) => {
              const target = e_event.target;
              if (!target || !target.getAttribute) return;
              const field_name = target.getAttribute("data-field-name") || target.name;
              if (!field_name) return;
              const field_ctrl = this.field_controls && this.field_controls[field_name];
              if (!field_ctrl) return;
              const value2 = this.read_field_value(field_ctrl);
              if (this.values && typeof this.values.set === "function") {
                this.values.set(field_name, value2);
              }
            };
            this.add_dom_event_listener("input", handle_event);
            this.add_dom_event_listener("change", handle_event);
            this.add_dom_event_listener("submit", (e_submit) => {
              e_submit.preventDefault();
              this.submit();
            });
          }
        }
      };
      Form_Container.css = `
.form-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.form-container-field {
    display: grid;
    grid-template-columns: 160px 1fr auto;
    gap: 8px;
    align-items: center;
}
.form-container-label {
    font-weight: 600;
}
.form-container-input {
    min-width: 0;
}
.form-container-message {
    grid-column: 2 / -1;
}
.form-container-badge {
    justify-self: end;
}
.field-status-error .form-container-input {
    border-color: #b71c1c;
}
.field-status-error .form-container-message {
    color: #b71c1c;
}
.field-status-success .form-container-input {
    border-color: #1b5e20;
}
`;
      module.exports = Form_Container;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/form_field.js
  var require_form_field = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/form_field.js"(exports, module) {
      var Control2 = require_control();
      var Text_Input = require_Text_Input();
      var Validation_Status_Indicator = require_Validation_Status_Indicator();
      var Form_Field = class extends Control2 {
        constructor(options = {}) {
          super(options);
          const { context: context2 } = options;
          this.config = {
            label: options.label || "",
            name: options.name || "",
            type: options.type || "text",
            // text, email, password, checkbox, select, textarea
            placeholder: options.placeholder || "",
            required: options.required || false,
            input_control: options.input_control || null,
            // Custom input control
            validator: options.validator || null
          };
          this.add_class("form-field");
          if (this.config.label) {
            this.label_container = new Control2({ context: context2, tag_name: "div" });
            this.label_container.add_class("form-field-label-container");
            this.label = new Control2({ context: context2, tag_name: "label" });
            this.label.add_class("form-field-label");
            this.label.add(this.config.label);
            if (this.config.required) {
              this.required_indicator = new Control2({ context: context2, tag_name: "span" });
              this.required_indicator.add_class("required-indicator");
              this.required_indicator.add(" *");
              this.label.add(this.required_indicator);
            }
            this.label_container.add(this.label);
            this.add(this.label_container);
          }
          this.input_container = new Control2({ context: context2, tag_name: "div" });
          this.input_container.add_class("form-field-input-container");
          if (this.config.input_control) {
            this.input = this.config.input_control;
          } else {
            this.input = this._create_input_control(context2);
          }
          this.input_container.add(this.input);
          this.validation_indicator = new Validation_Status_Indicator({ context: context2 });
          this.validation_indicator.add_class("form-field-validation");
          this.input_container.add(this.validation_indicator);
          this.add(this.input_container);
          this.error_message = new Control2({ context: context2, tag_name: "div" });
          this.error_message.add_class("form-field-error");
          this.add(this.error_message);
        }
        _create_input_control(context2) {
          const { type, placeholder, name } = this.config;
          switch (type) {
            case "text":
            case "email":
            case "password":
            case "number":
            case "url":
            case "tel":
              const input = new Text_Input({ context: context2 });
              input.dom.attributes.type = type;
              input.dom.attributes.name = name;
              if (placeholder) input.dom.attributes.placeholder = placeholder;
              return input;
            case "textarea":
              const textarea = new Control2({ context: context2, tag_name: "textarea" });
              textarea.dom.attributes.name = name;
              if (placeholder) textarea.dom.attributes.placeholder = placeholder;
              textarea.add_class("form-textarea");
              return textarea;
            case "checkbox":
              const checkbox = new Control2({ context: context2, tag_name: "input" });
              checkbox.dom.attributes.type = "checkbox";
              checkbox.dom.attributes.name = name;
              checkbox.add_class("form-checkbox");
              return checkbox;
            case "select":
              const select = new Control2({ context: context2, tag_name: "select" });
              select.dom.attributes.name = name;
              select.add_class("form-select");
              return select;
            default:
              return new Text_Input({ context: context2 });
          }
        }
        /**
         * Set the field value
         */
        set_value(value2) {
          const { type } = this.config;
          if (type === "checkbox") {
            this.input.dom.el.checked = !!value2;
          } else if (type === "select") {
            this.input.dom.el.value = value2;
          } else {
            this.input.dom.el.value = value2 || "";
          }
        }
        /**
         * Get the field value
         */
        get_value() {
          const { type } = this.config;
          if (type === "checkbox") {
            return this.input.dom.el.checked;
          } else {
            return this.input.dom.el.value;
          }
        }
        /**
         * Set validation state
         */
        set_validation(is_valid, error_message = "") {
          if (is_valid) {
            this.validation_indicator.set_status("valid");
            this.error_message.content.clear();
            this.remove_class("has-error");
          } else {
            this.validation_indicator.set_status("invalid");
            this.error_message.content.clear();
            this.error_message.add(error_message);
            this.add_class("has-error");
          }
        }
        /**
         * Clear validation state
         */
        clear_validation() {
          this.validation_indicator.set_status("neutral");
          this.error_message.content.clear();
          this.remove_class("has-error");
        }
        /**
         * Enable/disable the field
         */
        set_enabled(enabled) {
          this.input.dom.el.disabled = !enabled;
          if (enabled) {
            this.remove_class("disabled");
          } else {
            this.add_class("disabled");
          }
        }
      };
      module.exports = Form_Field;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/grid_gap.js
  var require_grid_gap = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/grid_gap.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var Grid_Gap = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "grid_gap";
          super(spec);
          this.add_class("grid-gap");
          this.dom.tagName = "div";
          this.columns = spec.columns || "repeat(auto-fit, minmax(160px, 1fr))";
          this.gap = Number.isFinite(Number(spec.gap)) ? Number(spec.gap) : 12;
          this.apply_layout();
        }
        /**
         * Set grid columns.
         * @param {string} columns - CSS grid-template-columns value.
         */
        set_columns(columns) {
          if (columns) {
            this.columns = columns;
            this.apply_layout();
          }
        }
        /**
         * Set grid gap.
         * @param {number} gap - Gap in px.
         */
        set_gap(gap) {
          const next_gap = Number(gap);
          if (Number.isFinite(next_gap)) {
            this.gap = next_gap;
            this.apply_layout();
          }
        }
        apply_layout() {
          this.dom.attributes.style.display = "grid";
          this.dom.attributes.style.gridTemplateColumns = this.columns;
          this.dom.attributes.style.gap = `${this.gap}px`;
        }
      };
      module.exports = Grid_Gap;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/horizontal-menu.js
  var require_horizontal_menu = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/horizontal-menu.js"(exports, module) {
      var jsgui = require_html_core();
      var Menu_Node = require_menu_node();
      var keyboard_navigation = require_keyboard_navigation();
      var {
        apply_label,
        apply_role
      } = require_a11y();
      var { themeable } = require_themeable();
      var { apply_token_map } = require_token_maps();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var Horizontal_Menu = class extends Control2 {
        // could have a title field.
        //'fields': {
        //	'title': String
        //}
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "horizontal_menu";
          const params = themeable(this, "horizontal_menu", spec);
          apply_token_map(this, "menu", params);
          this.dom.attrs.class = "horizontal menu";
          this.aria_label = spec.aria_label;
          apply_role(this, "menubar");
          if (this.aria_label !== void 0) {
            apply_label(this, this.aria_label);
          }
          if (!spec.abstract && !spec.el) {
            var obj2 = spec.value;
            var tobj = tof(obj2);
            if (tobj == "object") {
              each(obj2, (v, key2) => {
                var menu_node = make(Menu_Node({
                  "text": key2,
                  "value": v,
                  "menu": this
                }));
                this.add(menu_node);
              });
            }
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            const get_menu_nodes = () => {
              const nodes = [];
              this.content.each((ctrl) => {
                if (ctrl && ctrl.__type_name === "menu_node") nodes.push(ctrl);
              });
              return nodes;
            };
            const get_menu_items = () => get_menu_nodes().map((node) => node.main_control || node);
            const set_active_index = (next_index) => {
              const menu_nodes = get_menu_nodes();
              if (!menu_nodes.length) return;
              const clamped = Math.max(0, Math.min(next_index, menu_nodes.length - 1));
              this.active_index = clamped;
              const menu_items = get_menu_items();
              menu_items.forEach((item2, idx) => {
                if (item2 && item2.dom) {
                  item2.dom.attributes = item2.dom.attributes || {};
                  item2.dom.attributes.tabindex = idx === clamped ? "0" : "-1";
                }
              });
            };
            set_active_index(0);
            keyboard_navigation(this, {
              orientation: "horizontal",
              roving_tabindex: true,
              focus_item: true,
              get_items: () => get_menu_items(),
              get_active_index: () => this.active_index,
              set_active_index,
              on_activate: () => {
                const menu_nodes = get_menu_nodes();
                const active_node = menu_nodes[this.active_index];
                if (active_node && active_node.open) active_node.open();
              },
              on_down: () => {
                const menu_nodes = get_menu_nodes();
                const active_node = menu_nodes[this.active_index];
                if (active_node && active_node.open) active_node.open();
              }
            });
            var last_clicked;
            this.content.each((v, i) => {
              v.on("click", (e_click) => {
                var v_state = v.state;
                v.open();
                v.one_mousedown_anywhere(function(e_mousedown) {
                  if (!e_mousedown.within_this) {
                    v.close();
                  } else {
                  }
                });
              });
              v.on("mouseup", function(e_mouseup) {
              });
            });
          }
        }
        "close_all"() {
          console.log("menu close_all");
          this.content.each((v, i) => {
            v.close_all();
          });
        }
      };
      module.exports = Horizontal_Menu;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/4-data/data-item.js
  var require_data_item = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/4-data/data-item.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var fields = [
        ["value", Object]
      ];
      var Data_Item = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        // this.__type_name = 'text_item';
        constructor(spec) {
          super(spec, fields);
          this.__type_name = "data_item";
          this.add_class("data-item");
          let context2 = this.context;
          this.add(new jsgui.textNode({
            text: this.value + "",
            context: this.context
          }));
        }
      };
      module.exports = Data_Item;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/4-data/data-row.js
  var require_data_row = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/4-data/data-row.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var Data_Item = require_data_item();
      var Data_Row = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        constructor(spec) {
          super(spec);
          this.add_class("data-row");
          let context2 = this.context;
          let items = this.items = [];
          if (spec.items) {
            each(spec.items, (item2) => {
              items.push(this.add(new Data_Item({
                "context": context2,
                "value": item2
              })));
            });
          }
        }
      };
      module.exports = Data_Row;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/date-picker.js
  var require_date_picker = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/date-picker.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2, Control_Data, Control_View, Data_Object } = jsgui;
      var { field } = require_oext();
      var { apply_full_input_api } = require_input_api();
      var ISO_DATE_RE = /^\d{4}-\d{2}-\d{2}$/;
      var pad_2 = (value2) => String(value2).padStart(2, "0");
      var to_iso_date = (date) => {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return "";
        const year = date.getFullYear();
        const month = pad_2(date.getMonth() + 1);
        const day = pad_2(date.getDate());
        return `${year}-${month}-${day}`;
      };
      var parse_iso_date = (value2) => {
        if (!value2 || typeof value2 !== "string") return null;
        if (!ISO_DATE_RE.test(value2)) return null;
        const [year, month, day] = value2.split("-").map((part) => parseInt(part, 10));
        if (!year || !month || !day) return null;
        return new Date(year, month - 1, day);
      };
      var clamp_iso_value = (value2, min_value, max_value) => {
        if (!value2) return "";
        let next_value = value2;
        if (min_value && next_value < min_value) next_value = min_value;
        if (max_value && next_value > max_value) next_value = max_value;
        return next_value;
      };
      var add_days = (date, day_delta) => {
        const next = new Date(date.getFullYear(), date.getMonth(), date.getDate() + day_delta);
        return next;
      };
      var add_months = (date, month_delta) => {
        const year = date.getFullYear();
        const month = date.getMonth() + month_delta;
        const day = date.getDate();
        const first_of_target = new Date(year, month, 1);
        const last_day = new Date(first_of_target.getFullYear(), first_of_target.getMonth() + 1, 0).getDate();
        const safe_day = Math.min(day, last_day);
        return new Date(first_of_target.getFullYear(), first_of_target.getMonth(), safe_day);
      };
      var Date_Picker = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "date_picker";
          super(spec);
          this.add_class("date-picker");
          this.dom.tagName = "input";
          this.dom.attributes.type = "date";
          this.enhance_only = !!spec.enhance_only && !!spec.el;
          this.locale = spec.locale || "";
          this.week_start = spec.week_start !== void 0 ? Number(spec.week_start) : 0;
          this.min_value = spec.min ? this.format_date(spec.min, { format: "iso" }) : "";
          this.max_value = spec.max ? this.format_date(spec.max, { format: "iso" }) : "";
          if (this.enhance_only && spec.el) {
            const dom_locale = spec.el.getAttribute("lang");
            const dom_week_start = spec.el.getAttribute("data-week-start");
            const dom_min = spec.el.getAttribute("min");
            const dom_max = spec.el.getAttribute("max");
            if (!spec.locale && dom_locale) {
              this.locale = dom_locale;
            }
            if (spec.week_start === void 0 && dom_week_start !== null && dom_week_start !== "") {
              const parsed_week_start = Number(dom_week_start);
              if (!Number.isNaN(parsed_week_start)) {
                this.week_start = parsed_week_start;
              }
            }
            if (!spec.min && dom_min) {
              this.min_value = dom_min;
            }
            if (!spec.max && dom_max) {
              this.max_value = dom_max;
            }
          }
          if (this.locale) {
            this.dom.attributes.lang = this.locale;
          }
          if (this.week_start !== void 0) {
            this.dom.attributes["data-week-start"] = String(this.week_start);
          }
          if (this.min_value) {
            this.dom.attributes.min = this.min_value;
          }
          if (this.max_value) {
            this.dom.attributes.max = this.max_value;
          }
          apply_full_input_api(this, {
            disabled: spec.disabled,
            readonly: spec.readonly,
            required: spec.required
          });
          this.construct_synchronised_data_and_view_models(spec);
          if (spec.value !== void 0) {
            this.set_value(spec.value, { from_model: true });
          } else if (this.enhance_only && spec.el && spec.el.value) {
            const dom_value = spec.el.value;
            this.set_model_value("value", dom_value);
            this.set_value(dom_value, { from_model: true });
          }
        }
        construct_synchronised_data_and_view_models(spec) {
          const { context: context2 } = this;
          this.data = new Control_Data({ context: context2 });
          if (spec.data && spec.data.model) {
            this.data.model = spec.data.model;
          } else {
            this.data.model = new Data_Object({ context: context2 });
          }
          field(this.data.model, "value");
          field(this.data.model, "min");
          field(this.data.model, "max");
          field(this.data.model, "locale");
          field(this.data.model, "week_start");
          this.view = new Control_View({ context: context2 });
          if (spec.view && spec.view.data && spec.view.data.model) {
            this.view.data.model = spec.view.data.model;
          } else {
            this.view.data.model = new Data_Object({ context: context2 });
          }
          field(this.view.data.model, "value");
          field(this.view.data.model, "min");
          field(this.view.data.model, "max");
          field(this.view.data.model, "locale");
          field(this.view.data.model, "week_start");
          this.data.model.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (value2 === old) return;
            if (name === "value") {
              this.view.data.model.value = value2;
              this.set_value(value2, { from_model: true });
            } else if (name === "min") {
              this.view.data.model.min = value2;
              this.set_min(value2, { from_model: true });
            } else if (name === "max") {
              this.view.data.model.max = value2;
              this.set_max(value2, { from_model: true });
            } else if (name === "locale") {
              this.view.data.model.locale = value2;
              this.set_locale(value2, { from_model: true });
            } else if (name === "week_start") {
              this.view.data.model.week_start = value2;
              this.set_week_start(value2, { from_model: true });
            }
          });
          this.view.data.model.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (value2 === old) return;
            if (name === "value") {
              this.data.model.value = value2;
              this.set_value(value2, { from_model: true });
            } else if (name === "min") {
              this.data.model.min = value2;
              this.set_min(value2, { from_model: true });
            } else if (name === "max") {
              this.data.model.max = value2;
              this.set_max(value2, { from_model: true });
            } else if (name === "locale") {
              this.data.model.locale = value2;
              this.set_locale(value2, { from_model: true });
            } else if (name === "week_start") {
              this.data.model.week_start = value2;
              this.set_week_start(value2, { from_model: true });
            }
          });
        }
        /**
         * Format a date value as ISO or locale string.
         * @param {Date|string} value - Date to format.
         * @param {Object} [options] - Options for formatting.
         * @returns {string}
         */
        format_date(value2, options = {}) {
          const format = options.format || "iso";
          let date_value = value2;
          if (typeof value2 === "string") {
            date_value = parse_iso_date(value2);
          }
          if (!(date_value instanceof Date)) return "";
          if (format === "locale" && typeof Intl !== "undefined") {
            const locale = options.locale || this.locale || void 0;
            try {
              return new Intl.DateTimeFormat(locale).format(date_value);
            } catch (e) {
              return to_iso_date(date_value);
            }
          }
          return to_iso_date(date_value);
        }
        /**
         * Parse a date value into a Date object.
         * @param {Date|string} value - Value to parse.
         * @returns {Date|null}
         */
        parse_date(value2) {
          if (value2 instanceof Date) return value2;
          return parse_iso_date(value2);
        }
        /**
         * Set the picker value.
         * @param {Date|string} value - Value to set.
         * @param {Object} [options] - Optional settings.
         */
        set_value(value2, options = {}) {
          const iso_value = this.format_date(value2, { format: "iso" });
          const clamped_value = clamp_iso_value(iso_value, this.min_value, this.max_value);
          if (!options.from_model) {
            this.set_model_value("value", clamped_value);
          }
          if (this.dom.el) {
            this.dom.el.value = clamped_value;
          }
          this.dom.attributes.value = clamped_value;
        }
        /**
         * Get the picker value.
         * @returns {string}
         */
        get_value() {
          if (this.data && this.data.model && this.data.model.value) {
            return this.data.model.value;
          }
          return this.dom.attributes.value || "";
        }
        /**
         * Set minimum value.
         * @param {Date|string} value - Minimum value.
         * @param {Object} [options] - Optional settings.
         */
        set_min(value2, options = {}) {
          this.min_value = value2 ? this.format_date(value2, { format: "iso" }) : "";
          this.dom.attributes.min = this.min_value;
          if (!options.from_model) {
            this.set_model_value("min", this.min_value);
          }
        }
        /**
         * Set maximum value.
         * @param {Date|string} value - Maximum value.
         * @param {Object} [options] - Optional settings.
         */
        set_max(value2, options = {}) {
          this.max_value = value2 ? this.format_date(value2, { format: "iso" }) : "";
          this.dom.attributes.max = this.max_value;
          if (!options.from_model) {
            this.set_model_value("max", this.max_value);
          }
        }
        /**
         * Set locale for formatting.
         * @param {string} locale - Locale string.
         * @param {Object} [options] - Optional settings.
         */
        set_locale(locale, options = {}) {
          this.locale = locale || "";
          if (this.locale) {
            this.dom.attributes.lang = this.locale;
          }
          if (!options.from_model) {
            this.set_model_value("locale", this.locale);
          }
        }
        /**
         * Set week start index.
         * @param {number} week_start - Week start index.
         * @param {Object} [options] - Optional settings.
         */
        set_week_start(week_start, options = {}) {
          this.week_start = week_start !== void 0 ? Number(week_start) : 0;
          this.dom.attributes["data-week-start"] = String(this.week_start);
          if (!options.from_model) {
            this.set_model_value("week_start", this.week_start);
          }
        }
        set_model_value(name, value2) {
          if (this.data && this.data.model && this.data.model[name] !== value2) {
            this.data.model[name] = value2;
          }
          if (this.view && this.view.data && this.view.data.model && this.view.data.model[name] !== value2) {
            this.view.data.model[name] = value2;
          }
        }
        handle_keydown(e_keydown) {
          const key2 = e_keydown.key;
          if (!key2) return;
          const current_value = this.dom.el ? this.dom.el.value : this.get_value();
          let base_date = this.parse_date(current_value);
          if (!base_date) {
            if (this.min_value) {
              base_date = this.parse_date(this.min_value);
            } else {
              base_date = /* @__PURE__ */ new Date();
            }
          }
          if (!base_date) return;
          let next_date = null;
          if (key2 === "ArrowUp") {
            next_date = add_days(base_date, 1);
          } else if (key2 === "ArrowDown") {
            next_date = add_days(base_date, -1);
          } else if (key2 === "PageUp") {
            next_date = add_months(base_date, -1);
          } else if (key2 === "PageDown") {
            next_date = add_months(base_date, 1);
          } else if (key2 === "Home" && this.min_value) {
            next_date = this.parse_date(this.min_value);
          } else if (key2 === "End" && this.max_value) {
            next_date = this.parse_date(this.max_value);
          }
          if (next_date) {
            e_keydown.preventDefault();
            this.set_value(next_date);
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const { dom } = this;
            const sync_value = () => {
              if (dom.el) {
                this.view.data.model.value = dom.el.value;
              }
            };
            this.add_dom_event_listener("change", sync_value);
            this.add_dom_event_listener("keypress", sync_value);
            this.add_dom_event_listener("keyup", sync_value);
            this.add_dom_event_listener("keydown", (e_keydown) => {
              this.handle_keydown(e_keydown);
              sync_value();
            });
            sync_value();
          }
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="date"]', Date_Picker, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Date_Picker;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/Select_Options.js
  var require_Select_Options = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/Select_Options.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2, Control_Data, Control_View, Data_Object, each } = jsgui;
      var { field } = require_oext();
      var {
        normalize_items,
        find_item_by_value,
        filter_items
      } = require_item_utils();
      var {
        apply_focus_ring,
        apply_label
      } = require_a11y();
      var { apply_full_input_api } = require_input_api();
      var Select_Options = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "select_options";
          spec.tag_name = "select";
          super(spec);
          this.add_class("select-options");
          this.enhance_only = !!spec.enhance_only && !!spec.el;
          const { context: context2 } = this;
          this.items = [];
          this.filtered_items = [];
          this.filter_text = "";
          this.selected_item = null;
          this.load_items_fn = typeof spec.load_items === "function" ? spec.load_items : null;
          this.auto_load = spec.auto_load !== false;
          this.item_id_prefix = `${this._id()}-option`;
          this.aria_label = spec.aria_label;
          this.construct_synchronised_data_and_view_models(spec, context2);
          apply_full_input_api(this, {
            disabled: spec.disabled,
            readonly: spec.readonly,
            required: spec.required,
            get_value: () => {
              if (this.data && this.data.model && this.data.model.value !== void 0) {
                return this.data.model.value;
              }
              return this.selected_item ? this.selected_item.value : "";
            },
            set_value: (value2) => {
              this.set_selected_value(value2);
            }
          });
          if (spec.items || spec.options) {
            this.set_items(spec.items || spec.options, { from_model: true });
          }
          if (spec.filter_text !== void 0) {
            this.set_filter_text(spec.filter_text, { from_model: true });
          }
          if (spec.value !== void 0) {
            this.set_selected_value(spec.value, { from_model: true });
          }
          if (spec.selected_item !== void 0) {
            this.set_selected_item(spec.selected_item, { from_model: true });
          }
          apply_focus_ring(this);
          if (this.aria_label !== void 0) {
            apply_label(this, this.aria_label);
          }
          if (!spec.el) {
            this.compose();
          }
        }
        construct_synchronised_data_and_view_models(spec, context2) {
          this.data = new Control_Data({ context: context2 });
          if (spec.data && spec.data.model) {
            this.data.model = spec.data.model;
          } else {
            this.data.model = new Data_Object({ context: context2 });
          }
          field(this.data.model, "value");
          field(this.data.model, "items");
          field(this.data.model, "filter_text");
          field(this.data.model, "selected_item");
          this.view = new Control_View({ context: context2 });
          if (spec.view && spec.view.data && spec.view.data.model) {
            this.view.data.model = spec.view.data.model;
          } else {
            this.view.data.model = new Data_Object({ context: context2 });
          }
          field(this.view.data.model, "value");
          field(this.view.data.model, "items");
          field(this.view.data.model, "filter_text");
          field(this.view.data.model, "selected_item");
          this.data.model.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (value2 === old) return;
            if (name === "value") {
              this.view.data.model.value = value2;
              this.set_selected_value(value2, { from_model: true });
            } else if (name === "items") {
              this.view.data.model.items = value2;
              this.set_items(value2, { from_model: true });
            } else if (name === "filter_text") {
              this.view.data.model.filter_text = value2;
              this.set_filter_text(value2, { from_model: true });
            } else if (name === "selected_item") {
              this.view.data.model.selected_item = value2;
              this.set_selected_item(value2, { from_model: true });
            }
          });
          this.view.data.model.on("change", (e) => {
            const { name, value: value2, old } = e;
            if (value2 === old) return;
            if (name === "value") {
              this.data.model.value = value2;
              this.set_selected_value(value2, { from_model: true });
            } else if (name === "items") {
              this.data.model.items = value2;
              this.set_items(value2, { from_model: true });
            } else if (name === "filter_text") {
              this.data.model.filter_text = value2;
              this.set_filter_text(value2, { from_model: true });
            } else if (name === "selected_item") {
              this.data.model.selected_item = value2;
              this.set_selected_item(value2, { from_model: true });
            }
          });
        }
        /**
         * Set items for the select options control.
         * @param {Array} items - Items to set.
         * @param {Object} [options] - Optional settings.
         */
        set_items(items, options = {}) {
          this.items = normalize_items(items, { id_prefix: this.item_id_prefix });
          this.filtered_items = filter_items(this.items, this.filter_text);
          if (!options.from_model) {
            this.set_model_value("items", items);
          }
          this.compose();
        }
        /**
         * Set the filter text for typeahead filtering.
         * @param {string} filter_text - Filter text.
         * @param {Object} [options] - Optional settings.
         */
        set_filter_text(filter_text, options = {}) {
          this.filter_text = filter_text || "";
          this.filtered_items = filter_items(this.items, this.filter_text);
          if (!options.from_model) {
            this.set_model_value("filter_text", this.filter_text);
          }
          this.compose();
        }
        /**
         * Set the selected item by value.
         * @param {*} value - Selected value.
         * @param {Object} [options] - Optional settings.
         */
        set_selected_value(value2, options = {}) {
          const matched_item = find_item_by_value(this.items, value2);
          if (matched_item) {
            this.selected_item = matched_item;
          } else {
            this.selected_item = null;
          }
          if (!options.from_model) {
            this.set_model_value("value", value2);
            this.set_model_value("selected_item", this.selected_item);
          }
          if (this.dom.el) {
            this.dom.el.value = value2;
          }
          this.update_aria_active_descendant();
          this.apply_option_selection();
        }
        /**
         * Set the selected item directly.
         * @param {Object} item - Selected item.
         * @param {Object} [options] - Optional settings.
         */
        set_selected_item(item2, options = {}) {
          if (!item2) {
            this.selected_item = null;
          } else {
            const matched_item = item2.value !== void 0 ? find_item_by_value(this.items, item2.value) : find_item_by_value(this.items, item2);
            this.selected_item = matched_item || null;
          }
          if (!options.from_model) {
            const next_value = this.selected_item ? this.selected_item.value : "";
            this.set_model_value("value", next_value);
            this.set_model_value("selected_item", this.selected_item);
          }
          this.update_aria_active_descendant();
          this.apply_option_selection();
        }
        /**
         * Load items asynchronously using the configured loader.
         * @param {Object} [options] - Options passed to the loader.
         * @returns {Promise<Array>} - Loaded items.
         */
        async load_items(options = {}) {
          if (!this.load_items_fn) return [];
          const loaded_items = await this.load_items_fn(options);
          this.set_items(loaded_items || []);
          return this.items;
        }
        set_model_value(name, value2) {
          if (this.data && this.data.model && this.data.model[name] !== value2) {
            this.data.model[name] = value2;
          }
          if (this.view && this.view.data && this.view.data.model && this.view.data.model[name] !== value2) {
            this.view.data.model[name] = value2;
          }
        }
        update_aria_active_descendant() {
          const active_item = this.selected_item;
          if (active_item && active_item.id) {
            this.dom.attributes["aria-activedescendant"] = active_item.id;
            if (this.dom.el && typeof this.dom.el.setAttribute === "function") {
              this.dom.el.setAttribute("aria-activedescendant", active_item.id);
            }
          } else {
            this.dom.attributes["aria-activedescendant"] = "";
            if (this.dom.el && typeof this.dom.el.removeAttribute === "function") {
              this.dom.el.removeAttribute("aria-activedescendant");
            }
          }
        }
        apply_option_selection() {
          if (!this.content || !this.content.each) return;
          this.content.each((ctrl_option) => {
            const option_id = ctrl_option.dom && ctrl_option.dom.attributes && ctrl_option.dom.attributes.id;
            const is_selected = !!(this.selected_item && option_id === this.selected_item.id);
            ctrl_option.dom.attributes["aria-selected"] = is_selected ? "true" : "false";
          });
        }
        compose() {
          if (this.enhance_only && this.dom.el) {
            this.dom.attributes.role = this.dom.attributes.role || "listbox";
            if (typeof this.dom.el.setAttribute === "function") {
              this.dom.el.setAttribute("role", this.dom.attributes.role);
            }
            this.update_aria_active_descendant();
            return;
          }
          this.clear();
          this.dom.attributes.role = "listbox";
          const { context: context2 } = this;
          each(this.filtered_items, (item2) => {
            const ctrl_option = new jsgui.option({
              context: context2
            });
            ctrl_option.dom.attributes.value = item2.value;
            ctrl_option.dom.attributes.id = item2.id;
            ctrl_option.dom.attributes["aria-selected"] = item2 === this.selected_item ? "true" : "false";
            if (item2.disabled) {
              ctrl_option.dom.attributes.disabled = "disabled";
            }
            ctrl_option.add(item2.label);
            this.add(ctrl_option);
          });
          if (this.selected_item) {
            this.dom.attributes.value = this.selected_item.value;
          }
          this.update_aria_active_descendant();
        }
        _load_items_from_dom() {
          if (!this.dom.el || !this.dom.el.options) return;
          const dom_items = [];
          const options = this.dom.el.options;
          for (let i = 0; i < options.length; i += 1) {
            const option = options[i];
            dom_items.push({
              value: option.value,
              label: option.text,
              disabled: option.disabled,
              id: option.id || `${this.item_id_prefix}-${i}`
            });
          }
          this.items = normalize_items(dom_items, { id_prefix: this.item_id_prefix });
          this.filtered_items = filter_items(this.items, this.filter_text);
          if (this.dom.el) {
            this.set_selected_value(this.dom.el.value);
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (this.dom.el) {
              if (this.enhance_only && !this.items.length) {
                this._load_items_from_dom();
              }
              this.add_dom_event_listener("change", () => {
                const next_value = this.dom.el.value;
                this.set_selected_value(next_value);
                this.raise("change", {
                  name: "selected_item",
                  value: this.selected_item
                });
              });
            }
            if (this.auto_load && this.load_items_fn && !this.items.length) {
              this.load_items();
            }
          }
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap("select", Select_Options, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Select_Options;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/dropdown-list.js
  var require_dropdown_list = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/dropdown-list.js"(exports, module) {
      var Select_Options = require_Select_Options();
      var Dropdown_List = class extends Select_Options {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "dropdown_list";
          super(spec);
          this.add_class("dropdown-list");
        }
      };
      module.exports = Dropdown_List;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/email_input.js
  var require_email_input = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/email_input.js"(exports, module) {
      var Text_Input = require_Text_Input();
      var Email_Input = class extends Text_Input {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "email_input";
          super(spec);
          this.add_class("email-input");
          this.dom.attributes.type = "email";
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="email"]', Email_Input, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Email_Input;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/panel.js
  var require_panel = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/panel.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var def = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var { resizable } = require_mx();
      var { themeable } = require_themeable();
      var { apply_token_map } = require_token_maps();
      var parse_px = (value2) => {
        if (typeof value2 === "number") return value2;
        if (typeof value2 === "string") {
          const parsed = parseFloat(value2);
          return Number.isNaN(parsed) ? 0 : parsed;
        }
        return 0;
      };
      var get_parent_size = (ctrl) => {
        const parent = ctrl && ctrl.parent;
        if (!parent) return [0, 0];
        if (Array.isArray(parent.size) && parent.size.length === 2) {
          return parent.size;
        }
        const style = parent.dom && parent.dom.attributes && parent.dom.attributes.style;
        if (style) {
          const width = parse_px(style.width);
          const height2 = parse_px(style.height);
          if (width || height2) return [width, height2];
        }
        if (parent.dom && parent.dom.el && typeof parent.dom.el.getBoundingClientRect === "function") {
          const rect = parent.dom.el.getBoundingClientRect();
          return [rect.width, rect.height];
        }
        return [0, 0];
      };
      var Panel = class extends Control2 {
        /**
         * Create a new Panel.
         * 
         * @param {Object} spec - Panel specification
         * @param {string} [spec.name] - Panel name/identifier
         * @param {string} [spec.title] - Panel title (creates header)
         * @param {string} [spec.variant] - Variant preset: default, card, elevated, flush, well, glass, outline, hero
         * @param {Object} [spec.params] - Theme params
         * @param {string} [spec.params.padding] - Padding: none, small, medium, large, xlarge
         * @param {string} [spec.params.shadow] - Shadow: none, small, medium, large, inset
         * @param {string} [spec.params.radius] - Border radius: none, small, medium, large, full
         * @param {boolean} [spec.params.border] - Whether to show border
         * @param {boolean} [spec.params.header] - Whether to show header (if title provided)
         * @param {boolean} [spec.params.collapsible] - Whether panel can be collapsed
         * @param {*} [spec.content] - Initial content to add
         * @param {boolean} [spec.resizable] - Whether panel is resizable
         * @param {Array} [spec.min_size] - Minimum size [width, height]
         * @param {Array} [spec.max_size] - Maximum size [width, height]
         */
        constructor(spec, add, make) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "panel";
          super(spec);
          this.add_class("panel");
          const params = themeable(this, "panel", spec);
          apply_token_map(this, "panel", params);
          if (params.border) {
            this.add_class("bordered");
          }
          this.resizable_enabled = !!spec.resizable;
          this.min_size = spec.min_size || null;
          this.max_size = spec.max_size || null;
          this.resize_bounds = spec.resize_bounds || spec.extent_bounds || null;
          this.pending_dock_edge = spec.dock || spec.docked || null;
          this._collapsible = params.collapsible || false;
          this._collapsed = false;
          if (def(spec.name)) {
            this.name = spec.name;
          }
          if (def(spec.title)) {
            this.title = spec.title;
          }
          if (!spec.abstract && !spec.el) {
            this._compose(params, spec);
          }
        }
        /**
         * Compose panel structure based on theme params.
         * @param {Object} params - Resolved theme params
         * @param {Object} spec - Original spec
         */
        _compose(params, spec) {
          const { context: context2 } = this;
          let n = this.name;
          if (def(n)) {
            let f = this._fields = this._fields || {};
            f.name = n;
          }
          const show_header = params.header !== false && def(this.title);
          if (show_header) {
            const header = new Control2({
              context: context2,
              class: "panel-header"
            });
            const title_ctrl = new Control2({
              context: context2,
              class: "panel-title"
            });
            title_ctrl.add(this.title);
            header.add(title_ctrl);
            if (this._collapsible) {
              const toggle = new Control2({
                context: context2,
                tag_name: "button",
                class: "panel-collapse-toggle"
              });
              toggle.add("\u25BC");
              header.add(toggle);
            }
            this.add(header);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.header = header;
            this._ctrl_fields.title = title_ctrl;
          }
          const content_container = new Control2({
            context: context2,
            class: "panel-content"
          });
          this.add(content_container);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.content = content_container;
          this.content_container = content_container;
          if (def(spec.content)) {
            content_container.add(spec.content);
          }
        }
        /**
         * Add content to the panel.
         * If a content container exists, adds to it instead of directly.
         * @param {*} content - Content to add
         */
        add_content(content) {
          if (this.content_container) {
            this.content_container.add(content);
          } else {
            this.add(content);
          }
        }
        /**
         * Toggle collapsed state.
         */
        toggle_collapsed() {
          this._collapsed = !this._collapsed;
          if (this._collapsed) {
            this.add_class("collapsed");
          } else {
            this.remove_class("collapsed");
          }
        }
        /**
         * Set collapsed state.
         * @param {boolean} collapsed - Whether panel should be collapsed
         */
        set_collapsed(collapsed) {
          this._collapsed = !!collapsed;
          if (this._collapsed) {
            this.add_class("collapsed");
          } else {
            this.remove_class("collapsed");
          }
        }
        /**
         * Dock the panel to a parent edge.
         * @param {string} edge - Dock edge: left, right, top, bottom
         * @param {Object} [options] - Optional settings
         * @param {Array} [options.size] - Override size [width, height]
         */
        dock_to(edge, options = {}) {
          const parent_size = get_parent_size(this);
          const [parent_width, parent_height] = parent_size;
          if (!parent_width || !parent_height) return;
          const dock_edge = edge || "left";
          if (!this._pre_dock_state) {
            this._pre_dock_state = {
              pos: this.pos,
              size: this.size
            };
          }
          let next_pos = [0, 0];
          let next_size = [parent_width, parent_height];
          if (dock_edge === "left") {
            next_size = options.size || [Math.round(parent_width / 2), parent_height];
            next_pos = [0, 0];
          } else if (dock_edge === "right") {
            next_size = options.size || [Math.round(parent_width / 2), parent_height];
            next_pos = [parent_width - next_size[0], 0];
          } else if (dock_edge === "top") {
            next_size = options.size || [parent_width, Math.round(parent_height / 2)];
            next_pos = [0, 0];
          } else if (dock_edge === "bottom") {
            next_size = options.size || [parent_width, Math.round(parent_height / 2)];
            next_pos = [0, parent_height - next_size[1]];
          }
          this.dom.attributes.style.position = "absolute";
          this.pos = next_pos;
          this.size = next_size;
          this.docked_edge = dock_edge;
        }
        /**
         * Undock the panel and restore previous size/position.
         */
        undock() {
          if (!this._pre_dock_state) return;
          if (this._pre_dock_state.pos) this.pos = this._pre_dock_state.pos;
          if (this._pre_dock_state.size) this.size = this._pre_dock_state.size;
          this._pre_dock_state = null;
          this.docked_edge = null;
        }
        activate() {
          var _a, _b;
          if (!this.__active) {
            super.activate();
            if (this.resizable_enabled) {
              resizable(this, {
                resize_mode: "br_handle",
                bounds: [this.min_size, this.max_size],
                extent_bounds: this.resize_bounds || this.parent
              });
            }
            if (this.pending_dock_edge) {
              this.dock_to(this.pending_dock_edge);
              this.pending_dock_edge = null;
            }
            if (this._collapsible && this._ctrl_fields && this._ctrl_fields.header) {
              const toggle = (_b = (_a = this._ctrl_fields.header.dom) == null ? void 0 : _a.el) == null ? void 0 : _b.querySelector(".panel-collapse-toggle");
              if (toggle) {
                toggle.addEventListener("click", () => this.toggle_collapsed());
              }
            }
          }
        }
      };
      module.exports = Panel;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/title-bar.js
  var require_title_bar = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/title-bar.js"(exports, module) {
      var jsgui = require_html_core();
      var { stringify, each, tof, def, Control: Control2 } = jsgui;
      var fields = [
        ["text", String]
      ];
      var Title_Bar = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "title_bar";
          super(spec, fields);
          if (!spec.el) {
            this.add_class("title-bar title bar");
            var span = new jsgui.span({
              "context": this.context,
              "text": this.text
            });
            this.add(span);
          }
        }
      };
      module.exports = Title_Bar;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/toggle-button.js
  var require_toggle_button = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/toggle-button.js"(exports, module) {
      var jsgui = require_html_core();
      var { stringify, each, tof, def, Control: Control2 } = jsgui;
      var { prop, field } = require_oext();
      var Toggle_Button = class extends Control2 {
        constructor(spec, add, make) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "toggle_button";
          super(spec);
          this.add_class("toggle-button");
          field(this, "states", spec.states || "");
          field(this, "state", spec.state || "");
          if (!spec.abstract && !spec.el) {
            const _compose = () => {
              var span_state = this.span_state = new jsgui.span({ "context": this.context, text: this.state });
              this.add(span_state);
            };
            const compose = () => jsgui.parse_mount(`<span name='span_state'>${this.state}</span>`, this, jsgui.controls);
            compose();
          }
          this.on("change", (e_change) => {
            if (this.span_state) this.span_state.text = e_change.value;
          });
          if (typeof document === "undefined") {
            this.dom.attributes["data-jsgui-ctrl-fields"] = stringify({
              "span_state": this.span_state._id()
            }).replace(/"/g, "'");
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            this.on("click", (e_click) => {
              var state = this.state;
              var states = this.states;
              var i_current_state;
              if (tof(states) === "array") {
                each(states, (i_state, i) => {
                  if (i_state === state) {
                    i_current_state = i;
                  }
                });
                var i_next_state = i_current_state + 1;
                if (i_next_state === states.length) i_next_state = 0;
                var str_next_state = states[i_next_state];
                this.raise("toggle", {
                  "state": str_next_state
                });
                this.state = str_next_state;
              } else {
                throw "stop";
              }
            });
          }
        }
      };
      module.exports = Toggle_Button;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/plus-minus-toggle-button.js
  var require_plus_minus_toggle_button = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/plus-minus-toggle-button.js"(exports, module) {
      var jsgui = require_html_core();
      var Toggle_Button = require_toggle_button();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var Plus_Minus_Toggle_Button = class extends Toggle_Button {
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          spec.__type_name = "plus_minus_toggle_button";
          spec.states = ["+", "-"];
          spec.state = spec.state || "-";
          super(spec);
          let state = this.state = spec.state;
        }
      };
      module.exports = Plus_Minus_Toggle_Button;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/tree-node.js
  var require_tree_node = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/tree-node.js"(exports, module) {
      var jsgui = require_html_core();
      var Plus_Minus_Toggle_Button = require_plus_minus_toggle_button();
      var Vertical_Expander = require_vertical_expander();
      var mx_selectable = require_selectable();
      var { apply_label } = require_a11y();
      var { field } = require_oext();
      var { each, def, Control: Control2 } = jsgui;
      var Tree_Node = class _Tree_Node extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "tree_node";
          if (!def(spec.expandable)) spec.expandable = true;
          super(spec);
          this.node_class = spec.node_class || _Tree_Node;
          this.expandable = spec.expandable;
          this.load_children = typeof spec.load_children === "function" ? spec.load_children : typeof spec.children_loader === "function" ? spec.children_loader : null;
          this.has_loaded_children = Array.isArray(spec.nodes) && spec.nodes.length > 0;
          this.loading = false;
          this.multi_select = !!spec.multi_select;
          this.drag_reparent = !!spec.drag_reparent;
          this.selectable = spec.selectable !== false;
          mx_selectable(this, null, {
            multi: this.multi_select,
            toggle: !!spec.select_toggle
          });
          if (this.selectable) {
            this.selectable = true;
          }
          field(this, "depth");
          field(this, "state", "open");
          this.state = spec.state === "closed" ? "closed" : "open";
          if (def(spec.depth)) this.depth = spec.depth;
          if (spec.text) {
            this.text = spec.text;
          } else if (spec.name) {
            this.text = spec.name;
          }
          if (!spec.el) {
            this.compose_tree_node(spec);
          }
          if (this.inner_control) {
            this.inner_control.content.on("change", () => {
              this.update_toggle_visibility();
            });
          }
        }
        compose_tree_node(spec) {
          const my = (p) => {
            p.context = this.context;
            return p;
          };
          const top_line = this.add(new Control2(my({
            "class": "top-line"
          })));
          this.top_line = top_line;
          if (def(this.depth)) {
            for (let c2 = 0; c2 < this.depth; c2++) {
              const depth_block = new Control2(my({
                "class": "depth-block"
              }));
              top_line.add(depth_block);
            }
          }
          let plus_minus;
          const spec_state = this.state === "closed" ? "+" : "-";
          top_line.add(plus_minus = new Plus_Minus_Toggle_Button(my({
            state: spec_state
          })));
          this.toggle_button = plus_minus;
          this.update_toggle_aria();
          const main_box = top_line.add(new Control2(my({
            "class": "main-box"
          })));
          main_box.add(new jsgui.span(my({
            text: this.text,
            "class": "text"
          })));
          let expander;
          if (this.expandable) {
            expander = this.add(new Vertical_Expander(my({})));
            expander.add(this.inner_control = new Control2(my({
              "class": "inner"
            })));
            this.expander = expander;
            if (spec.nodes) {
              for (let node of spec.nodes) {
                const node_spec = Object.assign({}, node, {
                  context: this.context,
                  depth: (this.depth || 0) + 1,
                  multi_select: this.multi_select,
                  selectable: this.selectable,
                  drag_reparent: this.drag_reparent,
                  node_class: this.node_class
                });
                const Node_Class = this.node_class;
                const tn = node instanceof Control2 ? node : new Node_Class(node_spec);
                this.inner_control.add(tn);
              }
              expander.state = this.state = "open";
            } else {
              expander.state = this.state = "closed";
            }
          }
          this._ctrl_fields = Object.assign(this._ctrl_fields || {}, {
            toggle_button: plus_minus,
            top_line,
            main_box
          });
          if (expander) {
            this._ctrl_fields.inner_control = this.inner_control;
            this._ctrl_fields.expander = expander;
          }
          this.dom.attributes.id = this._id();
          this.dom.attributes.role = "treeitem";
          this.update_aria_state();
          this.update_toggle_visibility();
        }
        update_toggle_visibility() {
          if (!this.toggle_button) return;
          const has_children = this.has_children() || this.load_children;
          if (has_children) {
            this.toggle_button.show();
          } else {
            this.toggle_button.hide();
          }
        }
        update_aria_state() {
          const aria_level = (this.depth || 0) + 1;
          this.dom.attributes["aria-level"] = String(aria_level);
          if (this.expandable) {
            this.dom.attributes["aria-expanded"] = this.state === "open" ? "true" : "false";
          }
          if (this.selected !== void 0) {
            this.dom.attributes["aria-selected"] = this.selected ? "true" : "false";
          }
          this.update_toggle_aria();
        }
        update_toggle_aria() {
          if (!this.toggle_button || !this.toggle_button.dom) return;
          const label_text = this.state === "open" ? "Collapse" : "Expand";
          apply_label(this.toggle_button, label_text, { force: true });
        }
        /**
         * Check if the node has child nodes.
         * @returns {boolean}
         */
        has_children() {
          return !!(this.inner_control && this.inner_control.content && this.inner_control.content._arr.length);
        }
        /**
         * Get child tree nodes.
         * @returns {Array}
         */
        get_child_nodes() {
          if (!this.inner_control || !this.inner_control.content) return [];
          const res2 = [];
          this.inner_control.content.each((ctrl) => {
            if (ctrl instanceof _Tree_Node) res2.push(ctrl);
          });
          return res2;
        }
        /**
         * Get the parent tree node.
         * @returns {Tree_Node|null}
         */
        get_parent_node() {
          return this.closest((ctrl) => ctrl instanceof _Tree_Node);
        }
        is_open() {
          return this.state === "open";
        }
        /**
         * Open the node and load children if needed.
         */
        open() {
          if (!this.expandable || !this.expander) return;
          this.expander.open();
          this.state = "open";
          if (this.toggle_button) this.toggle_button.state = "-";
          this.update_aria_state();
          this.ensure_children_loaded();
        }
        /**
         * Close the node.
         */
        close() {
          if (!this.expandable || !this.expander) return;
          this.expander.close();
          this.state = "closed";
          if (this.toggle_button) this.toggle_button.state = "+";
          this.update_aria_state();
        }
        /**
         * Toggle open/closed state.
         */
        toggle() {
          if (this.is_open()) {
            this.close();
          } else {
            this.open();
          }
        }
        /**
         * Update the node depth and refresh indentation.
         * @param {number} next_depth - New depth.
         */
        update_depth(next_depth) {
          this.depth = next_depth;
          if (this.top_line) {
            const to_remove = [];
            this.top_line.content.each((ctrl) => {
              if (ctrl.has_class && ctrl.has_class("depth-block")) {
                to_remove.push(ctrl);
              }
            });
            to_remove.forEach((ctrl) => ctrl.remove());
            for (let c2 = 0; c2 < next_depth; c2++) {
              const depth_block = new Control2({
                context: this.context,
                class: "depth-block"
              });
              this.top_line.content.insert(depth_block, c2);
              depth_block.parent = this.top_line;
            }
          }
          const children = this.get_child_nodes();
          children.forEach((child) => child.update_depth(next_depth + 1));
          this.update_aria_state();
        }
        /**
         * Load children asynchronously when configured.
         * @returns {Promise<void>}
         */
        async ensure_children_loaded() {
          if (this.has_loaded_children || !this.load_children || !this.inner_control) return;
          this.set_loading_state(true);
          try {
            const result = await this.load_children(this);
            const nodes = Array.isArray(result) ? result : [];
            nodes.forEach((node) => {
              const node_spec = Object.assign({}, node, {
                context: this.context,
                depth: (this.depth || 0) + 1,
                multi_select: this.multi_select,
                selectable: this.selectable,
                drag_reparent: this.drag_reparent,
                node_class: this.node_class
              });
              const Node_Class = this.node_class;
              const tn = node instanceof Control2 ? node : new Node_Class(node_spec);
              this.inner_control.add(tn);
            });
            this.has_loaded_children = true;
            this.update_toggle_visibility();
          } catch (error2) {
            this.raise("load-error", { error: error2 });
          } finally {
            this.set_loading_state(false);
          }
        }
        set_loading_state(is_loading) {
          this.loading = !!is_loading;
          if (this.loading) {
            this.add_class("loading");
            this.dom.attributes["aria-busy"] = "true";
          } else {
            this.remove_class("loading");
            this.dom.attributes["aria-busy"] = "false";
          }
        }
        attach_drag_reparent_events() {
          if (!this.drag_reparent || !this.dom.el) return;
          this.dom.attributes.draggable = "true";
          this.add_dom_event_listener("dragstart", (e_drag) => {
            if (e_drag && e_drag.dataTransfer) {
              e_drag.dataTransfer.setData("text/plain", this._id());
            }
            const tree = this.get_tree();
            if (tree) {
              tree.drag_node = this;
            }
          });
          this.add_dom_event_listener("dragover", (e_drag) => {
            e_drag.preventDefault();
            this.add_class("drag-over");
          });
          this.add_dom_event_listener("dragleave", () => {
            this.remove_class("drag-over");
          });
          this.add_dom_event_listener("drop", (e_drop) => {
            e_drop.preventDefault();
            this.remove_class("drag-over");
            const tree = this.get_tree();
            if (tree && tree.drag_node) {
              tree.reparent_node(tree.drag_node, this);
            }
          });
        }
        get_tree() {
          return this.closest((ctrl) => ctrl && (ctrl.__type_name === "tree" || ctrl.__type_name === "file_tree"));
        }
        activate() {
          if (!this.__active) {
            super.activate();
            this.rec_desc_ensure_ctrl_el_refs();
            if (this.toggle_button) {
              this.toggle_button.on("toggle", (e_toggle) => {
                const state = e_toggle.state;
                if (state === "-") {
                  this.open();
                  this.raise("expand");
                  this.raise("open");
                } else {
                  this.close();
                  this.raise("contract");
                  this.raise("close");
                }
              });
            }
            this.on("change", (e_change) => {
              if (e_change.name === "selected") {
                this.dom.attributes["aria-selected"] = e_change.value ? "true" : "false";
              }
            });
            this.update_aria_state();
            this.attach_drag_reparent_events();
          }
        }
      };
      module.exports = Tree_Node;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/tree.js
  var require_tree = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/tree.js"(exports, module) {
      var jsgui = require_html_core();
      var { stringify, each, tof, def, Control: Control2 } = jsgui;
      var Panel = require_panel();
      var Title_Bar = require_title_bar();
      var Tree_Node = require_tree_node();
      var keyboard_navigation = require_keyboard_navigation();
      var {
        apply_focus_ring,
        apply_label,
        apply_role
      } = require_a11y();
      var { prop, field } = require_oext();
      var Tree = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "tree";
          super(spec);
          this.add_class("tree");
          this.multi_select = !!spec.multi_select;
          this.selectable = spec.selectable !== false;
          this.drag_reparent = !!spec.drag_reparent;
          this.node_class = spec.node_class || Tree_Node;
          this.active_node = null;
          this.aria_label = spec.aria_label || spec.title;
          field(this, "title");
          this.title = spec.title;
          if (!spec.el) {
            this.compose_tree(spec);
          }
          this.on("change", (e_change) => {
            if (e_change.name === "title") {
              this.title_bar.text = e_change.value;
            }
            ;
          });
          if (this.aria_label !== void 0) {
            apply_label(this, this.aria_label);
          }
        }
        compose_tree(spec) {
          if (this.title !== void 0) {
            this.add(this.title_bar = new Title_Bar({
              context: this.context,
              text: this.title
            }));
          }
          this.add(this.main = new Panel({
            context: this.context
          }));
          if (spec.nodes) {
            for (let node of spec.nodes) {
              const node_spec = Object.assign({}, node, {
                context: this.context,
                depth: 0,
                multi_select: this.multi_select,
                selectable: this.selectable,
                drag_reparent: this.drag_reparent,
                node_class: this.node_class
              });
              const Node_Class = this.node_class;
              const tn = node instanceof Control2 ? node : new Node_Class(node_spec);
              this.main.add(tn);
            }
          }
          this._ctrl_fields = Object.assign(this._ctrl_fields || {}, {
            //'title_bar': this.title_bar,
            "main": this.main
          });
          if (this.title_bar) {
            this._ctrl_fields.title_bar = this.title_bar;
          }
        }
        clear() {
          this.main.clear();
        }
        activate() {
          super.activate();
          if (!this.selection_scope) {
            this.selection_scope = this.context.new_selection_scope(this);
          }
          apply_role(this, "tree", { force: true });
          this.dom.attributes.tabindex = "0";
          if (this.multi_select) {
            this.dom.attributes["aria-multiselectable"] = "true";
          }
          apply_focus_ring(this);
          this.ensure_active_node();
          keyboard_navigation(this, {
            orientation: "vertical",
            get_items: () => this.get_visible_nodes(),
            get_active_index: () => this.get_visible_nodes().indexOf(this.active_node),
            set_active_index: (index) => {
              const nodes = this.get_visible_nodes();
              if (nodes[index]) {
                this.set_active_node(nodes[index]);
              }
            },
            on_left: () => {
              const active_node = this.active_node;
              if (!active_node) return;
              if (active_node.is_open && active_node.is_open()) {
                active_node.close();
              } else {
                const parent_node = active_node.get_parent_node();
                if (parent_node) {
                  this.set_active_node(parent_node);
                }
              }
            },
            on_right: () => {
              const active_node = this.active_node;
              if (active_node && active_node.expandable) {
                if (!active_node.is_open()) {
                  active_node.open();
                } else {
                  const children = active_node.get_child_nodes();
                  if (children.length) {
                    this.set_active_node(children[0]);
                  }
                }
              }
            },
            on_home: () => {
              const nodes = this.get_visible_nodes();
              if (nodes.length) this.set_active_node(nodes[0], { select: false });
            },
            on_end: () => {
              const nodes = this.get_visible_nodes();
              if (nodes.length) this.set_active_node(nodes[nodes.length - 1], { select: false });
            },
            on_activate: () => {
              const active_node = this.active_node;
              if (!active_node) return;
              if (active_node.action_select_only) {
                active_node.action_select_only();
              } else {
                active_node.selected = true;
              }
            }
          });
        }
        ensure_active_node() {
          if (this.active_node) return;
          const nodes = this.get_visible_nodes();
          if (nodes.length) {
            this.set_active_node(nodes[0], { select: false });
          }
        }
        /**
         * Get visible tree nodes in depth-first order.
         * @returns {Array}
         */
        get_visible_nodes() {
          const res2 = [];
          const traverse = (node) => {
            res2.push(node);
            if (node.is_open && node.is_open()) {
              const children = node.get_child_nodes ? node.get_child_nodes() : [];
              children.forEach((child) => traverse(child));
            }
          };
          if (this.main && this.main.content) {
            this.main.content.each((ctrl) => {
              if (ctrl instanceof Tree_Node) {
                traverse(ctrl);
              }
            });
          }
          return res2;
        }
        /**
         * Set the active node and update ARIA state.
         * @param {Control} node - Node to activate.
         * @param {Object} [options] - Optional settings.
         */
        set_active_node(node, options = {}) {
          if (!node) return;
          this.active_node = node;
          const node_id = node.dom && node.dom.attributes && node.dom.attributes.id;
          if (node_id) {
            this.dom.attributes["aria-activedescendant"] = node_id;
          }
          if (options.select !== false) {
            if (this.selection_scope && typeof this.selection_scope.select_only === "function") {
              this.selection_scope.select_only(node);
            } else {
              node.selected = true;
            }
          }
        }
        move_active_node(direction) {
          const nodes = this.get_visible_nodes();
          if (!nodes.length) return;
          let current_index = nodes.indexOf(this.active_node);
          if (current_index === -1) current_index = 0;
          let next_index = current_index + direction;
          if (next_index < 0) next_index = 0;
          if (next_index >= nodes.length) next_index = nodes.length - 1;
          this.set_active_node(nodes[next_index]);
        }
        handle_keydown(e_keydown) {
          if (!this._keyboard_nav_state || !this._keyboard_nav_state.handle_keydown) return;
          this._keyboard_nav_state.handle_keydown(e_keydown);
        }
        /**
         * Reparent a node to a new parent.
         * @param {Control} node - Node to move.
         * @param {Control} target_node - New parent node.
         * @returns {boolean}
         */
        reparent_node(node, target_node) {
          if (!node || !target_node) return false;
          if (node === target_node) return false;
          if (!target_node.expandable || !target_node.inner_control) return false;
          if (node.is_ancestor_of && node.is_ancestor_of(target_node.dom && target_node.dom.el)) return false;
          const old_parent = node.get_parent_node ? node.get_parent_node() : null;
          node.remove();
          target_node.inner_control.add(node);
          target_node.open();
          if (node.update_depth) {
            node.update_depth(target_node.depth + 1);
          }
          this.raise("reparent", {
            node,
            old_parent,
            new_parent: target_node
          });
          return true;
        }
      };
      module.exports = Tree;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/file-tree-node.js
  var require_file_tree_node = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/file-tree-node.js"(exports, module) {
      var Tree_Node = require_tree_node();
      var File_Tree_Node = class extends Tree_Node {
        constructor(spec = {}) {
          if (spec.file || spec.entry) {
            const file_entry = spec.file || spec.entry;
            if (file_entry.name) {
              spec.text = file_entry.name;
            }
            if (file_entry.path) {
              spec.path = file_entry.path;
            }
            if (file_entry.is_directory !== void 0) {
              spec.expandable = !!file_entry.is_directory;
            }
            if (file_entry.type === "directory") {
              spec.expandable = true;
            }
          }
          spec.__type_name = "file_tree_node";
          if (spec.expandable === void 0) {
            spec.expandable = false;
          }
          super(spec);
          this.add_class("file");
          if (this.expandable) {
            this.add_class("directory");
          }
          if (spec.path) {
            this.path = spec.path;
          }
        }
      };
      module.exports = File_Tree_Node;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/file-tree.js
  var require_file_tree = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/file-tree.js"(exports, module) {
      var Tree = require_tree();
      var File_Tree_Node = require_file_tree_node();
      var File_Tree = class extends Tree {
        constructor(spec = {}) {
          const fs_resource = spec.fs || spec.fs_resource || null;
          const root_path = spec.root_path || spec.path || "";
          const load_children = typeof spec.load_children === "function" ? spec.load_children : fs_resource ? async (node) => {
            if (fs_resource.list) {
              return fs_resource.list(node.path || root_path);
            }
            if (fs_resource.get) {
              return fs_resource.get(node.path || root_path);
            }
            return [];
          } : null;
          if (!spec.nodes && load_children) {
            spec.nodes = [{
              text: root_path || "Root",
              path: root_path,
              expandable: true,
              load_children
            }];
          }
          spec.__type_name = "file_tree";
          spec.node_class = File_Tree_Node;
          super(spec);
          this.add_class("file tree file-tree");
          this.fs_resource = fs_resource;
          this.root_path = root_path;
          this.load_children = load_children;
        }
      };
      module.exports = File_Tree;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/item-selector.js
  var require_item_selector = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/item-selector.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var def = jsgui.is_defined;
      var Item_View = require_item();
      var List = require_list();
      var mx_popup = require_popup();
      var Item_Selector = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "item_selector";
          super(spec);
          this.add_class("item-selector");
          if (spec.items) {
            this.items = spec.items;
          } else {
            this.items = [];
          }
          if (spec.loop) this.loop = spec.loop;
          if (def(spec.item_index)) {
            this.item_index = spec.item_index;
          } else {
            if (!def(this.item_index)) {
              this.item_index = 0;
            }
          }
          if (!spec.el) {
            this.compose_item_selector();
            this.finish_item_selector();
          }
        }
        finish_item_selector() {
          this.item_list.on("change", (e_change) => {
            if (e_change.name === "selection") {
              let selected_index = e_change.value;
              this.item_index = selected_index;
              this.current_item_view.item = this.items[selected_index];
              this.raise("change", {
                "name": "value",
                "value": this.items[selected_index],
                "index": selected_index
              });
              this.value = this.items[selected_index];
              setTimeout(() => {
                this.item_list.hide();
              }, 120);
            }
          });
        }
        compose_item_selector() {
          let current_item_view = this.current_item_view = new Item_View({
            context: this.context,
            item: this.items[this.item_index]
          });
          this.add(current_item_view);
          let item_list = this.item_list = new List({
            context: this.context,
            items: this.items
          });
          item_list.hide();
          item_list.add_class("item-selector");
          mx_popup(item_list);
          this.add(item_list);
          this._fields = this._fields || {};
          this._fields.item_index = this.item_index;
          this._fields.items = this.items;
          if (this.loop) this._fields.loop = this.loop;
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.current_item_view = current_item_view;
          this._ctrl_fields.item_list = item_list;
        }
        previous(raise_event = true) {
          let o_change;
          if (this.item_index > 0) {
            this.item_index--;
            this.current_item_view.item = this.items[this.item_index];
            if (raise_event) {
              o_change = {
                value: this.items[this.item_index],
                index: this.item_index,
                size: -1
              };
            }
          } else {
            if (this.loop) {
              this.item_index = this.items.length - 1;
              this.current_item_view.item = this.items[this.item_index];
              if (raise_event) {
                this.raise("loop", -1);
                o_change = {
                  value: this.items[this.item_index],
                  loop: -1,
                  index: this.item_index,
                  size: -1
                };
              }
            }
          }
          if (o_change) {
            if (this.item_index === 0) {
              o_change.first = true;
            }
            if (this.item_index === this.items.length - 1) {
              o_change.last = true;
            }
            this.raise("change", o_change);
          }
        }
        next(raise_event = true) {
          let old_index = this.item_index;
          let old = this.items[this.item_index];
          let o_change;
          if (this.item_index < this.items.length - 1) {
            this.item_index++;
            this.current_item_view.item = this.items[this.item_index];
            if (raise_event) {
              o_change = {
                value: this.items[this.item_index],
                index: this.item_index,
                size: 1
              };
            }
          } else {
            if (this.loop) {
              this.item_index = 0;
              this.current_item_view.item = this.items[this.item_index];
              if (raise_event) {
                this.raise("loop", 1);
                o_change = {
                  value: this.items[this.item_index],
                  loop: 1,
                  index: this.item_index,
                  size: 1
                };
              }
            }
          }
          if (o_change) {
            if (this.item_index === 0) {
              o_change.first = true;
            }
            if (this.item_index === this.items.length - 1) {
              o_change.last = true;
            }
            this.raise("change", o_change);
          }
        }
        activate() {
          let ctrl = this;
          if (!this.__active) {
            super.activate();
            let item_list = this.item_list;
            mx_popup(item_list);
            let has_moved_away = false;
            let t = false;
            this.on("touchstart", (ets) => {
              t = true;
              item_list.popup();
              ets.preventDefault();
            });
            this.on("touchend", (ete) => {
              if (!has_moved_away) {
              }
              has_moved_away = false;
              item_list.hide();
            });
            this.on("touchmove", (etm) => {
              has_moved_away = true;
            });
            this.on("click", (ec) => {
              if (!t) {
                let replace = item_list.popup();
                let body = this.context.map_controls["body_0"];
                let body_click_handler = (e_click) => {
                  let target_ctrl = this.context.map_controls[e_click.target.getAttribute("data-jsgui-id")];
                  let anc = target_ctrl.ancestor(item_list);
                  if (anc) {
                  } else {
                    body.off("click", body_click_handler);
                    replace();
                  }
                };
                setTimeout(() => {
                  body.on("click", body_click_handler);
                }, 0);
              }
            });
            this.finish_item_selector();
          }
        }
      };
      module.exports = Item_Selector;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/2-misc/left-right-arrows-selector.js
  var require_left_right_arrows_selector = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/2-misc/left-right-arrows-selector.js"(exports, module) {
      var jsgui = require_html_core();
      var Control2 = jsgui.Control;
      var def = jsgui.is_defined;
      var Arrow_Button = require_arrow_button();
      var Item_Selector = require_item_selector();
      var Left_Right_Arrows_Selector = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "left_right_arrows_selector";
          super(spec);
          this.add_class("left-right");
          this.add_class("arrows-selector");
          if (spec.items) {
            this.items = spec.items;
          }
          if (def(spec.item_index)) {
            this.item_index = spec.item_index;
          }
          if (def(spec.loop)) {
            this.loop = spec.loop;
          }
          if (!spec.el) {
            this.compose_lras();
          }
        }
        compose_lras() {
          let context2 = this.context;
          let left_arrow = new Arrow_Button({
            context: context2,
            direction: "left"
          });
          let is_spec = {
            context: context2
          };
          if (this.items) is_spec.items = this.items;
          if (this.item_index) is_spec.item_index = this.item_index;
          if (this.loop) is_spec.loop = this.loop;
          let item_selector = new Item_Selector(is_spec);
          let right_arrow = new Arrow_Button({
            context: context2,
            direction: "right"
          });
          this.add(left_arrow);
          this.add(item_selector);
          this.add(right_arrow);
          this._fields = this._fields || {};
          if (this.items) this._fields.items = this.items;
          if (def(this.item_index)) this._fields.item_index = this.item_index;
          if (def(this.loop)) this._fields.loop = this.loop;
          this._ctrl_fields = {
            left_arrow,
            item_selector,
            right_arrow
          };
        }
        previous(raise_event = true) {
          this.item_selector.previous(raise_event);
        }
        next(raise_event = true) {
          this.item_selector.next(raise_event);
        }
        activate() {
          if (!this.__active) {
            super.activate();
            let { left_arrow, item_selector, right_arrow } = this;
            left_arrow.on("click", (e_click) => {
              this.previous();
            });
            item_selector.on("change", (e_change) => {
              if (!this.loop) {
                if (e_change.first) {
                  left_arrow.disabled = true;
                } else {
                  left_arrow.disabled = false;
                }
                if (e_change.last) {
                  right_arrow.disabled = true;
                } else {
                  right_arrow.disabled = false;
                }
              }
              this.raise("change", e_change);
            });
            right_arrow.on("click", (e_click) => {
              this.next();
            });
            if (this.loop) {
              item_selector.on("loop", (loop_direction) => {
                this.raise("loop", loop_direction);
              });
            }
          }
        }
      };
      module.exports = Left_Right_Arrows_Selector;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/line-chart.js
  var require_line_chart = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/line-chart.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var extend = jsgui.extend;
      var Control2 = jsgui.Control;
      var Collection = jsgui.Collection;
      var Line_Chart = class extends Control2 {
        constructor(spec) {
          super(spec);
          this.__type_name = "line_chart";
          if (!spec.abstract && !spec.el) {
            this.add_class("line-chart no-select");
            var vert_margin = 10;
            var left_margin = 80;
            var right_margin = 24;
            var axis_thickness = 2;
            var x_major_notch_spacing = spec.x_major_notch_spacing || spec.major_notch_spacing || 50;
            var y_major_notch_spacing = spec.y_major_notch_spacing || spec.major_notch_spacing || 50;
            var x_minor_notch_spacing = spec.x_minor_notch_spacing || spec.major_minor_spacing || 10;
            var y_minor_notch_spacing = spec.y_minor_notch_spacing || spec.major_minor_spacing || 10;
            var suppress_0_axes_labels = true;
            this.set({
              "vert_margin": vert_margin,
              "left_margin": left_margin,
              "right_margin": right_margin,
              "axis_thickness": axis_thickness,
              "x_major_notch_spacing": x_major_notch_spacing,
              "y_major_notch_spacing": y_major_notch_spacing,
              "x_minor_notch_spacing": x_minor_notch_spacing,
              "y_minor_notch_spacing": y_minor_notch_spacing,
              "suppress_0_axes_labels": suppress_0_axes_labels
            });
            this.add_full_axes();
          }
          var num_days = this.get("num_days");
          if (typeof window == "undefined") {
            extend(this._fields = this._fields || {}, {
              "vert_margin": vert_margin,
              "left_margin": left_margin,
              "right_margin": right_margin,
              "axis_thickness": axis_thickness,
              "x_major_notch_spacing": x_major_notch_spacing,
              "y_major_notch_spacing": y_major_notch_spacing,
              "x_minor_notch_spacing": x_minor_notch_spacing,
              "y_minor_notch_spacing": y_minor_notch_spacing,
              "suppress_0_axes_labels": suppress_0_axes_labels,
              "range": this.get("range").value(),
              "x_origin": this.get("x_origin").value(),
              "y_origin": this.get("y_origin").value()
            });
          }
        }
        "add_full_axes"() {
          var vert_margin = this.get("vert_margin");
          var left_margin = this.get("left_margin");
          var right_margin = this.get("right_margin");
          var axis_thickness = this.get("axis_thickness");
          var x_major_notch_spacing = this.get("x_major_notch_spacing");
          var y_major_notch_spacing = this.get("y_major_notch_spacing");
          var x_minor_notch_spacing = this.get("x_minor_notch_spacing");
          var y_minor_notch_spacing = this.get("y_minor_notch_spacing");
          var suppress_0_axes_labels = this.get("suppress_0_axes_labels");
          var size = this.get("size").value();
          var w = size[0][0];
          var h = size[1][0];
          var range = this.get("range").value();
          console.log("range", range);
          var y_axis_x, x_axis_y;
          var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
          var x_range = x_max - x_min, y_range = y_max - y_min;
          var y_axis_is_at_origin = x_min <= 0 && x_max >= 0;
          var x_axis_is_at_origin = y_min <= 0 && y_max >= 0;
          var x_axis_left = left_margin;
          var x_axis_right = w - right_margin;
          var y_axis_top = vert_margin;
          var y_axis_bottom = h - vert_margin;
          var x_chart_distance = x_axis_right - x_axis_left;
          var y_chart_distance = y_axis_bottom - y_axis_top;
          var x_axis_length = w - left_margin - right_margin;
          var y_axis_length = h - 2 * vert_margin;
          var x_scale = x_range / x_axis_length;
          var y_scale = y_range / y_axis_length;
          var x_origin, y_origin;
          var values_from_pixel_location = function(px_loc) {
            var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
            var res2 = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
            return res2;
          };
          var pixel_location_from_values = function(values) {
            var res2 = [Math.round(origin[0] + values[0] * 1 / x_scale), Math.round(origin[1] + values[1] * -1 / y_scale)];
            return res2;
          };
          var x_location_from_value = function(x_value) {
            return Math.round(x_origin + x_value * 1 / x_scale);
          };
          var y_location_from_value = function(y_value) {
            return Math.round(y_origin + y_value * -1 / y_scale);
          };
          var svg = new Control2({
            "context": this.context,
            "tag_name": "svg"
          });
          svg.set("dom.attributes", {
            "width": w,
            "height": h,
            "viewPort": "0 0 " + w + " " + h,
            "version": "1.1",
            "xmlns": "http://www.w3.org/2000/svg"
          });
          this.add(svg);
          this.set("svg", svg);
          if (y_axis_is_at_origin) {
            var prop_through = -1 * x_min / x_range;
            var distance_through = x_chart_distance * prop_through;
            x_origin = x_axis_left + distance_through;
            y_axis_x = x_origin;
          } else {
            throw "stop";
          }
          if (x_axis_is_at_origin) {
            var prop_through = -1 * y_min / y_range;
            var distance_through = y_chart_distance * prop_through;
            y_origin = y_axis_bottom - distance_through;
            x_axis_y = y_origin;
          } else {
            throw "stop";
          }
          this.x_origin = x_origin;
          this.y_origin = y_origin;
          var y_axis_top = vert_margin;
          var y_axis_bottom = h - vert_margin;
          var add_y_axis_line = function() {
            var y_axis = new Control2({
              "context": this.context,
              "tag_name": "line"
            });
            y_axis.set("dom.attributes", {
              "width": 10,
              "height": h,
              "x1": y_axis_x,
              "y1": y_axis_top,
              "x2": y_axis_x,
              "y2": y_axis_bottom,
              "stroke": "#000000",
              "stroke-width": 2
            });
            svg.add(y_axis);
          };
          var add_x_axis_line = function() {
            var x_axis = new Control2({
              "context": this.context,
              "tag_name": "line"
            });
            x_axis.set("dom.attributes", {
              "width": 10,
              "height": h,
              "x1": x_axis_left,
              "y1": x_axis_y,
              "x2": x_axis_right,
              "y2": x_axis_y,
              "stroke": "#000000",
              "stroke-width": 2
            });
            svg.add(x_axis);
          };
          var add_x_notch_group = function(spacing, height2) {
            var num_notches_left_of_origin = Math.floor(x_min * -1 / spacing);
            var num_notches_right_of_origin = Math.floor(x_max / spacing);
            var first_notch_x_value = num_notches_left_of_origin * spacing * -1;
            var notch_x_value = first_notch_x_value;
            while (notch_x_value <= x_max) {
              var x_notch = new Control2({
                "context": this.context,
                "tag_name": "line"
              });
              var x_location = x_location_from_value(notch_x_value);
              x_notch.set("dom.attributes", {
                "width": 2,
                "height": height2,
                "x1": x_location,
                "y1": y_origin,
                "x2": x_location,
                "y2": y_origin + height2,
                "stroke": "#AAAAAA",
                "stroke-width": 2
                //'xmlns': 'http://www.w3.org/2000/svg',
                //'version': '1.1'
              });
              svg.add(x_notch);
              notch_x_value += spacing;
            }
          };
          var add_x_label_group = function(spacing) {
            var num_notches_left_of_origin = Math.floor(x_min * -1 / spacing);
            var num_notches_right_of_origin = Math.floor(x_max / spacing);
            var first_notch_x_value = num_notches_left_of_origin * spacing * -1;
            var notch_x_value = first_notch_x_value;
            while (notch_x_value <= x_max) {
              if (!(suppress_0_axes_labels && notch_x_value === 0)) {
                var x_location = x_location_from_value(notch_x_value);
                var x_notch_label = new Control2({
                  "context": this.context,
                  "tag_name": "text"
                });
                x_notch_label.set("dom.attributes", {
                  "x": x_location - 4,
                  "y": y_origin + 28,
                  "font-family": "Verdana",
                  "font-size": 14
                });
                x_notch_label.add(notch_x_value + "");
                svg.add(x_notch_label);
              }
              notch_x_value += spacing;
            }
          };
          var add_y_label_group = function(spacing) {
            var num_notches_below_origin = Math.floor(y_min * -1 / spacing);
            var num_notches_above_origin = Math.floor(y_max / spacing);
            var first_notch_y_value = num_notches_below_origin * spacing * -1;
            var notch_y_value = first_notch_y_value;
            while (notch_y_value <= y_max) {
              if (!(suppress_0_axes_labels && notch_y_value === 0)) {
                var y_notch = new Control2({
                  "context": this.context,
                  "tag_name": "line"
                });
                var y_location = y_location_from_value(notch_y_value);
                var y_notch_label = new Control2({
                  "context": this.context,
                  "tag_name": "text"
                });
                y_notch_label.set("dom.attributes", {
                  "x": x_origin - 48,
                  "y": y_location + 6,
                  "font-family": "Verdana",
                  "font-size": 14
                });
                y_notch_label.add(notch_y_value + "");
                svg.add(y_notch_label);
              }
              notch_y_value += spacing;
            }
          };
          var add_y_notch_group = function(spacing, length) {
            var num_notches_below_origin = Math.floor(y_min * -1 / spacing);
            var num_notches_above_origin = Math.floor(y_max / spacing);
            var first_notch_y_value = num_notches_below_origin * spacing * -1;
            var notch_y_value = first_notch_y_value;
            while (notch_y_value <= y_max) {
              var y_notch = new Control2({
                "context": this.context,
                "tag_name": "line"
              });
              var y_location = y_location_from_value(notch_y_value);
              y_notch.set("dom.attributes", {
                "width": length,
                "height": 2,
                "x1": x_origin - length,
                "y1": y_location,
                "x2": x_origin,
                "y2": y_location,
                "stroke": "#AAAAAA",
                "stroke-width": 2
                //'xmlns': 'http://www.w3.org/2000/svg',
                //'version': '1.1'
              });
              svg.add(y_notch);
              notch_y_value += spacing;
            }
          };
          var add_x_axis_major_notches = function() {
            add_x_notch_group(x_major_notch_spacing, 20);
          };
          var add_x_axis_minor_notches = function() {
            add_x_notch_group(x_minor_notch_spacing, 10);
          };
          var add_origin_label = function() {
            var origin_label = new Control2({
              "context": this.context,
              "tag_name": "text"
            });
            origin_label.set("dom.attributes", {
              "x": x_origin - 14,
              "y": y_origin + 14,
              "font-family": "Verdana",
              "font-size": 14
              //,
              //'xmlns': 'http://www.w3.org/2000/svg',
              //'version': '1.1'
            });
            origin_label.add("0");
            svg.add(origin_label);
          };
          var add_y_axis_major_notches = function() {
            add_y_notch_group(y_major_notch_spacing, 20);
          };
          var add_y_axis_minor_notches = function() {
            console.log("x_minor_notch_spacing", y_minor_notch_spacing);
            add_y_notch_group(y_minor_notch_spacing, 10);
          };
          var add_major_x_axis_labels = function() {
            add_x_label_group(x_major_notch_spacing);
          };
          var add_major_y_axis_labels = function() {
            add_y_label_group(y_major_notch_spacing);
          };
          var add_major_axes_labels = function() {
            add_major_x_axis_labels();
            add_major_y_axis_labels();
          };
          add_x_axis_minor_notches();
          add_x_axis_major_notches();
          add_y_axis_minor_notches();
          add_y_axis_major_notches();
          add_x_axis_line();
          add_y_axis_line();
          add_major_axes_labels();
          add_origin_label();
        }
        "render_axes"() {
        }
        "values_from_pixel_location"(px_loc) {
          var el = this.dom.el;
          var w = el.clientWidth;
          var h = el.clientHeight;
          var x_origin = this.x_origin;
          var y_origin = this.y_origin;
          var vert_margin = this.vert_margin;
          var left_margin = this.left_margin;
          var right_margin = this.right_margin;
          var x_axis_length = w - left_margin - right_margin;
          var y_axis_length = h - 2 * vert_margin;
          var range = this.range;
          var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
          var x_range = x_max - x_min, y_range = y_max - y_min;
          var x_scale = x_range / x_axis_length;
          var y_scale = y_range / y_axis_length;
          var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
          var res2 = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
          return res2;
        }
        "pixel_location_from_values"(values) {
          var el = this.dom.el;
          var w, h;
          if (el) {
            w = el.clientWidth;
            h = el.clientHeight;
          } else {
            var size = this.size();
            w = size._[0][0];
            h = size._[1][0];
          }
          var x_origin = this.x_origin;
          var y_origin = this.y_origin;
          var vert_margin = this.vert_margin;
          var left_margin = this.left_margin;
          var right_margin = this.right_margin;
          var x_axis_length = w - left_margin - right_margin;
          var y_axis_length = h - 2 * vert_margin;
          var range = this.range;
          var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
          var x_range = x_max - x_min, y_range = y_max - y_min;
          var x_scale = x_range / x_axis_length;
          var y_scale = y_range / y_axis_length;
          var res2 = [Math.round(x_origin + values[0] * 1 / x_scale), Math.round(y_origin + values[1] * -1 / y_scale)];
          return res2;
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            var that2 = this;
            var el = this.dom.el;
            var w = el.clientWidth;
            var h = el.clientHeight;
            var size = [w, h];
            var vert_margin = this.vert_margin;
            var left_margin = this.left_margin;
            var right_margin = this.right_margin;
            var axis_thickness = this.axis_thickness;
            var x_major_notch_spacing = this.x_major_notch_spacing;
            var y_major_notch_spacing = this.y_major_notch_spacing;
            var x_minor_notch_spacing = this.x_minor_notch_spacing;
            var y_minor_notch_spacing = this.y_minor_notch_spacing;
            var suppress_0_axes_labels = this.suppress_0_axes_labels;
            var x_origin = this.x_origin;
            var y_origin = this.y_origin;
            var range = this.range;
            var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
            var y_axis_is_at_origin = x_min <= 0 && x_max >= 0;
            var x_axis_is_at_origin = y_min <= 0 && y_max >= 0;
            var x_axis_left = left_margin;
            var x_axis_right = w - right_margin;
            var y_axis_top = vert_margin;
            var y_axis_bottom = h - vert_margin;
            var x_axis_length = w - left_margin - right_margin;
            var y_axis_length = h - 2 * vert_margin;
            var x_range = x_max - x_min, y_range = y_max - y_min;
            var x_scale = x_range / x_axis_length;
            var y_scale = y_range / y_axis_length;
            var log_values = function() {
              console.log("x_range", x_range);
              console.log("y_range", y_range);
              console.log("x_scale", x_scale);
              console.log("y_scale", y_scale);
              console.log("left_margin", left_margin);
              console.log("right_margin", right_margin);
              console.log("range", range);
              console.log("tof range", tof(range));
            };
            var context2 = this.context;
            var values_from_pixel_location = function(px_loc) {
              var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
              var res2 = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
              return res2;
            };
            var pixel_location_from_values = function(values) {
              var res2 = [Math.round(origin[0] + values[0] * 1 / x_scale), Math.round(origin[1] + values[1] * -1 / y_scale)];
              return res2;
            };
            var x_location_from_value = function(x_value) {
              return Math.round(x_origin + x_value * 1 / x_scale);
            };
            var y_location_from_value = function(y_value) {
              return Math.round(y_origin + y_value * -1 / y_scale);
            };
            var findPos = function(obj2) {
              var curleft = curtop = 0;
              if (obj2.offsetParent) {
                do {
                  curleft += obj2.offsetLeft;
                  curtop += obj2.offsetTop;
                } while (obj2 = obj2.offsetParent);
              }
              return [curleft, curtop];
            };
            this.add_event_listener("mousemove", function(e_mousemove) {
              var pos = findPos(el);
              var click_x, click_y;
              if (e_mousemove.pageX || e_mousemove.pageY) {
                click_x = e_mousemove.pageX;
                click_y = e_mousemove.pageY;
              }
              var click_pos = [click_x, click_y];
              var pos_within_this = jsgui.v_subtract(click_pos, pos);
              var values = values_from_pixel_location(pos_within_this);
              e_mousemove.chart_position = values;
            });
            this.add_event_listener("click", function(e_click) {
              var pos = findPos(el);
              var click_x, click_y;
              if (e_click.pageX || e_click.pageY) {
                click_x = e_click.pageX;
                click_y = e_click.pageY;
              }
              var click_pos = [click_x, click_y];
              var pos_within_this = jsgui.v_subtract(click_pos, pos);
              var values = values_from_pixel_location(pos_within_this);
              e_click.chart_position = values;
            });
          }
        }
      };
      module.exports = Line_Chart;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/1-advanced/login.js
  var require_login = __commonJS({
    "../jsgui3-html/controls/organised/0-core/1-advanced/login.js"(exports, module) {
      var jsgui = require_html_core();
      var Text_Field = require_Text_Field();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var Login = class extends Control2 {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.add_class("login-control");
          var req = this.context.req;
          console.log("--- Within Login Control ---");
          var headers = req.headers;
          console.log("headers " + stringify(headers));
          var auth = this.context.auth;
          console.log("auth " + stringify(auth));
          if (auth && auth.verified) {
            var div_logged_in = new jsgui.div({
              "context": this.context
            });
            var span_logged_in = new jsgui.span({
              "context": this.context
            });
            span_logged_in.add("Logged in as: " + auth.username);
            div_logged_in.add(span_logged_in);
            var frm = new jsgui.form({
              "context": this.context
            });
            frm.dom.attrs.set({
              "action": "/logout/?returnurl=%2F",
              "method": "POST"
            });
            div_logged_in.add(frm);
            var btn = new jsgui.button({
              "context": this.context
            });
            btn.dom.attrs.set({
              "type": "submit",
              "value": "submit",
              "class": "logout"
            });
            btn.add("Logout");
            frm.add(btn);
            this.add(div_logged_in);
          } else {
            var frm = new jsgui.form({
              "context": this.context
            });
            frm.dom.attrs.set({
              "action": "/logout/?returnurl=%2F",
              "method": "POST"
            });
            this.add(frm);
            var tf_username = new Text_Field({
              "text": "Username",
              "name": "username",
              "value": "",
              "type": "text",
              "context": this.context
            });
            frm.add(tf_username);
            var tf_password = new Text_Field({
              // a name field as well?
              //  a name for the form
              "text": "Password",
              "name": "password",
              "value": "",
              "type": "password",
              "context": this.context
            });
            frm.add(tf_password);
            var btn = new jsgui.button({
              "context": this.context
            });
            btn.dom.attrs.set({
              "type": "submit",
              "value": "submit",
              "class": "login"
            });
            btn.add("Login");
            frm.add(btn);
          }
        }
      };
      module.exports = Login;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/meter.js
  var require_meter = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/meter.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var normalize_number_value = (value2) => {
        if (!is_defined(value2)) return void 0;
        const numeric = Number(value2);
        if (Number.isFinite(numeric)) return numeric;
        return void 0;
      };
      var Meter = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "meter";
          super(spec);
          this.add_class("meter");
          this.dom.tagName = "meter";
          if (is_defined(spec.min)) this.set_min(spec.min);
          if (is_defined(spec.max)) this.set_max(spec.max);
          if (is_defined(spec.low)) this.set_low(spec.low);
          if (is_defined(spec.high)) this.set_high(spec.high);
          if (is_defined(spec.optimum)) this.set_optimum(spec.optimum);
          if (is_defined(spec.value)) this.set_value(spec.value);
        }
        /**
         * Set the meter value.
         * @param {*} value - The value to set.
         */
        set_value(value2) {
          const numeric = normalize_number_value(value2);
          if (!is_defined(numeric)) {
            this.value = void 0;
            this.dom.attributes.value = "";
            if (this.dom.el) {
              this.dom.el.removeAttribute("value");
            }
            return;
          }
          const min_value = is_defined(this.min) ? this.min : 0;
          const max_value = is_defined(this.max) ? this.max : numeric;
          const clamped = Math.min(Math.max(numeric, min_value), max_value);
          this.value = clamped;
          this.dom.attributes.value = String(clamped);
          if (this.dom.el) {
            this.dom.el.value = clamped;
          }
        }
        /**
         * Get the meter value.
         * @returns {*}
         */
        get_value() {
          return this.value;
        }
        /**
         * Set the meter min value.
         * @param {*} min_value - The min value to set.
         */
        set_min(min_value) {
          const numeric = normalize_number_value(min_value);
          if (!is_defined(numeric)) return;
          this.min = numeric;
          this.dom.attributes.min = String(numeric);
          if (this.dom.el) {
            this.dom.el.min = numeric;
          }
        }
        /**
         * Set the meter max value.
         * @param {*} max_value - The max value to set.
         */
        set_max(max_value) {
          const numeric = normalize_number_value(max_value);
          if (!is_defined(numeric)) return;
          this.max = numeric;
          this.dom.attributes.max = String(numeric);
          if (this.dom.el) {
            this.dom.el.max = numeric;
          }
        }
        /**
         * Set the meter low value.
         * @param {*} low_value - The low value to set.
         */
        set_low(low_value) {
          const numeric = normalize_number_value(low_value);
          if (!is_defined(numeric)) return;
          this.low = numeric;
          this.dom.attributes.low = String(numeric);
          if (this.dom.el) {
            this.dom.el.low = numeric;
          }
        }
        /**
         * Set the meter high value.
         * @param {*} high_value - The high value to set.
         */
        set_high(high_value) {
          const numeric = normalize_number_value(high_value);
          if (!is_defined(numeric)) return;
          this.high = numeric;
          this.dom.attributes.high = String(numeric);
          if (this.dom.el) {
            this.dom.el.high = numeric;
          }
        }
        /**
         * Set the meter optimum value.
         * @param {*} optimum_value - The optimum value to set.
         */
        set_optimum(optimum_value) {
          const numeric = normalize_number_value(optimum_value);
          if (!is_defined(numeric)) return;
          this.optimum = numeric;
          this.dom.attributes.optimum = String(numeric);
          if (this.dom.el) {
            this.dom.el.optimum = numeric;
          }
        }
      };
      module.exports = Meter;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/modal.js
  var require_modal = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/modal.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var def = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Modal = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "modal";
          super(spec);
          this.add_class("modal");
        }
      };
      module.exports = Modal;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/tile-slide.js
  var require_tile_slide = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/tile-slide.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var fnl = require_fnl();
      var prom_or_cb = fnl.prom_or_cb;
      var Tile_Slider = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = "tile_slider";
          super(spec);
          if (!spec.el) {
            this.compose_tile_slider();
          }
        }
        compose_tile_slider() {
          const context2 = this.context;
          let above = new Control2({
            "context": context2
          });
          above.add_class("above");
          this.add(above);
          let left = new Control2({
            "context": context2
          });
          left.add_class("left");
          this.add(left);
          let right = new Control2({
            "context": context2
          });
          right.add_class("right");
          this.add(right);
          let below = new Control2({
            "context": context2
          });
          below.add_class("below");
          this.add(below);
          let central = new Control2({
            "context": context2
          });
          central.add_class("central");
          this.add(central);
          this.above = above;
          this.left_ctrl = left;
          this.central = central;
          this.right = right;
          this.below = below;
          this._ctrl_fields = {
            "above": above,
            "left": left,
            "central": central,
            "right": right,
            "below": below
          };
          this._fields = {
            "size": this.size
          };
        }
        // Need repositioning after sliding.
        // So the central slide is now the current one.
        //  Could be worth keeping these cached?
        //  For the moment, just want 1 further in each direction.
        // Just the sliding.
        // previous, next
        // previous_major
        // next_major
        //  used for changing years
        // previous_year = previous_major
        // prev2
        // Transitions of the non-framed version would be cool.
        // move_previous
        // does the slide to the left / right
        //  rearrange / arrange things so that the next operation is ready.
        slide_to_left() {
          return prom_or_cb((resolve, reject) => {
            let ms = 333;
            let s = ms / 1e3;
            this.central.dom.attributes.style.transition = "transform " + s + "s";
            this.central.dom.attributes.style.transform = "translate(" + -1 * this.size[0] + "px, 0px)";
            this.right.dom.attributes.style.transition = "transform " + s + "s";
            this.right.dom.attributes.style.transform = "translate(" + -1 * this.size[0] + "px, 0px)";
            this.right.one("transitionend", (e_end) => {
              resolve();
            });
          }, callback);
        }
        slide_to_right(callback2) {
          return prom_or_cb((resolve, reject) => {
            this.central.dom.attributes.style.transition = "transform 0.33s";
            this.central.dom.attributes.style.transform = "translate(" + this.size[0] + "px, 0px)";
            this.left_ctrl.dom.attributes.style.transition = "transform 0.33s";
            this.left_ctrl.dom.attributes.style.transform = "translate(" + this.size[0] + "px, 0px)";
            this.left_ctrl.one("transitionend", (e_end) => {
              resolve();
            });
          }, callback2);
        }
        activate() {
          if (!this.__active) {
            super.activate();
            setTimeout(async () => {
              await this.slide_to_right();
              console.log("awaited slide to right");
            }, 2e3);
          }
        }
      };
      var Tile_Slide = function(Ctrl, fn_prev_spec, fn_next_spec, adjacencies = {
        left: -1,
        right: 1
      }) {
        class Tile_Sliding_Ctrl extends Tile_Slider {
          constructor(spec) {
            let slider_spec = {
              context: spec.context,
              size: spec.size
            };
            super(slider_spec);
            if (spec.size) {
              slider_spec.size = spec.size;
              this.size = spec.size;
            }
            this.spec = spec;
            if (!spec.el) {
              this.compose_tile_sliding_ctrl();
            }
            if (spec.size) {
            }
          }
          compose_tile_sliding_ctrl() {
            let prev_spec = fn_prev_spec(this.spec);
            let next_spec = fn_next_spec(this.spec);
            if (this.spec.size) {
              this.central.size = this.spec.size;
              this.dom.attributes.style.overflow = "hidden";
              this.dom.attributes.style.position = "relative";
              this.left_ctrl.dom.attributes.style.position = "absolute";
              this.left_ctrl.dom.attributes.style.left = -1 * this.spec.size[0] + "px";
              this.right.dom.attributes.style.position = "absolute";
              this.right.dom.attributes.style.left = this.spec.size[0] + "px";
              this.left_ctrl.size = this.spec.size;
              this.right.size = this.spec.size;
            }
            if (adjacencies.left === -1) {
              let left_ctrl_prev = new Ctrl(prev_spec);
              this.left_ctrl.add(left_ctrl_prev);
            }
            let ctrl = new Ctrl(this.spec);
            this.central.add(ctrl);
            if (adjacencies.right === 1) {
              let left_ctrl_prev = new Ctrl(next_spec);
              this.right.add(left_ctrl_prev);
              if (next_spec.size) {
              }
            }
          }
        }
        return Tile_Sliding_Ctrl;
      };
      Tile_Slider.wrap = Tile_Slide;
      module.exports = Tile_Slider;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/month-view.js
  var require_month_view = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/month-view.js"(exports, module) {
      var jsgui = require_html_core();
      var clone = jsgui.clone;
      var each = jsgui.each;
      var is_defined = jsgui.is_defined;
      var Grid = require_grid();
      var Tile_Slider = require_tile_slide();
      var days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
      var bgc_disabled = "#DDDDDD";
      var bgc_enabled = "inherit";
      var mx_date = require_date();
      var Month_View = class extends Grid {
        constructor(spec) {
          spec.grid_size = [7, 7];
          spec.size = spec.size || [360, 200];
          spec.__type_name = "month_view";
          super(spec);
          mx_date(this, spec);
          if (!spec.el) {
            this.compose_month_view();
          }
          this.context.new_selection_scope(this);
        }
        activate() {
          super.activate();
          let cells = this.$("grid_cell");
          each(cells, (cell) => {
            cell.on("change", (e_change) => {
              if (e_change.name === "selected" && e_change.value && is_defined(cell.value)) {
                this.day = cell.value;
              }
            });
          });
        }
        compose_month_view() {
          this.refresh_month_view();
          this.add_class("month-view");
          let days_row = this._arr_rows[0];
          days_row.add_class("days");
          days_row.add_class("header");
          each(days_row.content._arr, (cell, i) => {
            if (cell.span) {
              cell.span.add(days[i]);
            }
          });
          let cell_pos = [0, 1], ctrl_row = this._arr_rows[cell_pos[1]];
          let advance_cell = () => {
            if (cell_pos[0] === ctrl_row.content._arr.length - 1) {
              if (cell_pos[1] < this._arr_rows.length - 1) {
                cell_pos[0] = 0;
                cell_pos[1]++;
                ctrl_row = this._arr_rows[cell_pos[1]];
              } else return false;
            } else {
              cell_pos[0]++;
            }
            return true;
          };
          let d = new Date(this.year, this.month, 1);
          let got_day = d.getDay() - 1;
          if (got_day < 0) got_day = 6;
          while (cell_pos[0] < got_day) {
            let cell = ctrl_row.content._arr[cell_pos[0]++];
            cell.selectable = false;
            cell.select_unique = true;
            cell.background.color = bgc_disabled;
          }
          let did_advance = true;
          while (did_advance) {
            let cell = ctrl_row.content._arr[cell_pos[0]];
            cell.selectable = true;
            cell.select_unique = true;
            cell.value = d.getDate();
            cell._fields = cell._fields || {};
            cell._fields.value = cell.value;
            d.setDate(d.getDate() + 1);
            did_advance = advance_cell() && d.getDate() !== 1;
          }
          while (cell_pos[0] <= 6) {
            let cell = ctrl_row.content._arr[cell_pos[0]++];
            cell.selectable = false;
            cell.select_unique = true;
            cell.background.color = bgc_disabled;
          }
          if (cell_pos[1] < 6) {
            cell_pos = [0, 6];
            ctrl_row = this._arr_rows[cell_pos[1]];
            while (cell_pos[0] <= 6) {
              let cell = ctrl_row.content._arr[cell_pos[0]++];
              cell.selectable = false;
              cell.select_unique = true;
              cell.background.color = bgc_disabled;
            }
          }
        }
        refresh_month_view() {
          let d = new Date(this.year, this.month, 1), m = d.getMonth();
          let got_day = d.getDay() - 1;
          if (got_day < 0) got_day = 6;
          let day = this.day;
          this.each_cell((cell, cell_pos) => {
            let [x, y] = cell_pos;
            if (y > 0) {
              if (y === 1) {
                if (x < got_day) {
                  cell.background.color = bgc_disabled;
                  cell.selectable = false;
                  if (cell.deselect) cell.deselect();
                  cell.value = null;
                  cell.iterate_this_and_subcontrols((ctrl) => {
                    if (ctrl.dom.tagName === "span") ctrl.text = "";
                  });
                } else {
                  cell.background.color = bgc_enabled;
                  cell.selectable = true;
                  cell.span.add(d.getDate() + "");
                  d.setDate(d.getDate() + 1);
                }
              } else {
                let dm = d.getMonth();
                if (dm === m) {
                  cell.background.color = bgc_enabled;
                  cell.selectable = true;
                  cell.span.add(d.getDate() + "");
                  d.setDate(d.getDate() + 1);
                } else {
                  cell.background.color = bgc_disabled;
                  cell.selectable = false;
                  if (cell.deselect) cell.deselect();
                  cell.value = null;
                }
              }
            }
          });
        }
      };
      Month_View.Tiled = Tile_Slider.wrap(Month_View, (spec) => {
        spec = clone(spec);
        if (!is_defined(spec.month)) {
          let now = /* @__PURE__ */ new Date();
          spec.month = now.getMonth();
          spec.year = now.getFullYear();
        }
        spec.month = spec.month - 1;
        if (spec.month < 0) {
          spec.month = 11;
          spec.year = spec.year - 1;
        }
        return spec;
      }, (spec) => {
        spec = clone(spec);
        if (!is_defined(spec.month)) {
          let now = /* @__PURE__ */ new Date();
          spec.month = now.getMonth();
          spec.year = now.getFullYear();
        }
        spec.month = spec.month + 1;
        if (spec.month > 11) {
          spec.month = 0;
          spec.year = spec.year + 1;
        }
        return spec;
      });
      module.exports = Month_View;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/master_detail.js
  var require_master_detail = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/master_detail.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var normalize_items = (items) => {
        if (!Array.isArray(items)) return [];
        return items.map((item2, index) => {
          if (item2 && typeof item2 === "object") {
            const id = is_defined(item2.id) ? item2.id : index;
            const label = is_defined(item2.label) ? item2.label : String(id);
            return { ...item2, id, label };
          }
          return { id: index, label: String(item2), value: item2 };
        });
      };
      var Master_Detail = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "master_detail";
          super(spec);
          this.add_class("master-detail");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.detail_renderer = spec.detail_renderer;
          this.master_renderer = spec.master_renderer;
          this.set_items(spec.items || []);
          this.set_selected_id(is_defined(spec.selected_id) ? spec.selected_id : null);
          if (!spec.el) {
            this.compose_master_detail();
          }
          this.bind_model();
        }
        compose_master_detail() {
          const { context: context2 } = this;
          const master_ctrl = new Control2({ context: context2, tag_name: "div" });
          master_ctrl.add_class("master-detail-master");
          const detail_ctrl = new Control2({ context: context2, tag_name: "div" });
          detail_ctrl.add_class("master-detail-detail");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.master = master_ctrl;
          this._ctrl_fields.detail = detail_ctrl;
          this.add(master_ctrl);
          this.add(detail_ctrl);
          this.render_master();
          this.render_detail();
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            if (e_change.name === "items") {
              this.items = normalize_items(e_change.value);
              this.ensure_selected_id();
              this.render_master();
              this.render_detail();
            }
            if (e_change.name === "selected_id") {
              this.selected_id = e_change.value;
              this.render_master();
              this.render_detail();
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set master items.
         * @param {Array} items - Items to set.
         */
        set_items(items) {
          const normalized = normalize_items(items);
          this.set_model_value("items", normalized);
          this.items = normalized;
          this.ensure_selected_id();
        }
        /**
         * Set selected id.
         * @param {*} selected_id - Selected item id.
         */
        set_selected_id(selected_id) {
          this.set_model_value("selected_id", selected_id);
          this.selected_id = selected_id;
        }
        /**
         * Get selected id.
         * @returns {*}
         */
        get_selected_id() {
          return this.selected_id;
        }
        /**
         * Get selected item.
         * @returns {Object|null}
         */
        get_selected_item() {
          const items = this.items || [];
          const selected_id = this.selected_id;
          const item2 = items.find((entry) => String(entry.id) === String(selected_id));
          return item2 || null;
        }
        ensure_selected_id() {
          const items = this.items || [];
          if (!items.length) {
            this.selected_id = null;
            return;
          }
          const current = this.get_selected_item();
          if (!current) {
            this.selected_id = items[0].id;
            this.set_model_value("selected_id", this.selected_id);
          }
        }
        render_master() {
          const master_ctrl = this._ctrl_fields && this._ctrl_fields.master;
          if (!master_ctrl) return;
          master_ctrl.clear();
          const items = this.items || [];
          const selected_id = this.selected_id;
          items.forEach((item2, index) => {
            const item_ctrl = new Control2({ context: this.context, tag_name: "button" });
            item_ctrl.dom.attributes.type = "button";
            item_ctrl.add_class("master-detail-item");
            item_ctrl.dom.attributes["data-item-id"] = String(item2.id);
            const is_selected = String(item2.id) === String(selected_id);
            if (is_selected) item_ctrl.add_class("is-selected");
            item_ctrl.dom.attributes["aria-selected"] = is_selected ? "true" : "false";
            if (typeof this.master_renderer === "function") {
              const rendered = this.master_renderer(item2, index);
              if (rendered instanceof Control2) {
                item_ctrl.add(rendered);
              } else if (is_defined(rendered)) {
                item_ctrl.add(String(rendered));
              }
            } else {
              item_ctrl.add(item2.label);
            }
            master_ctrl.add(item_ctrl);
          });
        }
        render_detail() {
          const detail_ctrl = this._ctrl_fields && this._ctrl_fields.detail;
          if (!detail_ctrl) return;
          detail_ctrl.clear();
          const item2 = this.get_selected_item();
          if (!item2) return;
          if (typeof this.detail_renderer === "function") {
            const rendered = this.detail_renderer(item2);
            if (rendered instanceof Control2) {
              detail_ctrl.add(rendered);
            } else if (is_defined(rendered)) {
              detail_ctrl.add(String(rendered));
            }
            return;
          }
          const detail_text = is_defined(item2.detail) ? item2.detail : item2.label;
          if (is_defined(detail_text)) detail_ctrl.add(String(detail_text));
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const master_ctrl = this._ctrl_fields && this._ctrl_fields.master;
            if (!master_ctrl || !master_ctrl.dom.el) return;
            const find_item_el = (target) => {
              let node = target;
              while (node && node.getAttribute) {
                if (node.getAttribute("data-item-id") !== null) return node;
                node = node.parentNode;
              }
              return null;
            };
            master_ctrl.add_dom_event_listener("click", (e_click) => {
              const item_el = find_item_el(e_click.target);
              if (!item_el) return;
              const item_id = item_el.getAttribute("data-item-id");
              if (!is_defined(item_id)) return;
              this.set_selected_id(item_id);
              this.raise("selection_change", { selected_id: item_id });
            });
            master_ctrl.add_dom_event_listener("keydown", (e_key) => {
              const item_el = find_item_el(e_key.target);
              if (!item_el) return;
              const key2 = e_key.key || e_key.keyCode;
              if (key2 !== "Enter" && key2 !== " " && key2 !== 13 && key2 !== 32) return;
              e_key.preventDefault();
              const item_id = item_el.getAttribute("data-item-id");
              if (!is_defined(item_id)) return;
              this.set_selected_id(item_id);
              this.raise("selection_change", { selected_id: item_id });
            });
          }
        }
      };
      Master_Detail.css = `
.master-detail {
    display: grid;
    grid-template-columns: minmax(180px, 240px) 1fr;
    gap: 16px;
    align-items: start;
}
.master-detail-master {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.master-detail-item {
    text-align: left;
    padding: 8px 10px;
    border: 1px solid #ddd;
    border-radius: 6px;
    background: #fff;
    cursor: pointer;
}
.master-detail-item.is-selected {
    border-color: #888;
    background: #f5f5f5;
}
.master-detail-detail {
    padding: 12px;
    border: 1px solid #eee;
    border-radius: 8px;
    background: #fafafa;
    min-height: 120px;
}
`;
      module.exports = Master_Detail;
    }
  });

  // ../jsgui3-html/controls/matrix/VirtualMatrix.js
  var require_VirtualMatrix = __commonJS({
    "../jsgui3-html/controls/matrix/VirtualMatrix.js"(exports, module) {
      "use strict";
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var StringControl = jsgui.String_Control;
      function text(ctx, value2) {
        return new StringControl({ context: ctx, text: String(value2 != null ? value2 : "") });
      }
      function makeEl(ctx, tagName, className = null, attrs = null) {
        const el = new Control2({ context: ctx, tagName, __type_name: tagName });
        if (className) el.add_class(className);
        if (attrs) {
          for (const [key2, value2] of Object.entries(attrs)) {
            if (value2 === void 0) continue;
            el.dom.attributes[key2] = String(value2);
          }
        }
        return el;
      }
      function normalizeInt(value2, fallback) {
        const n = Number(value2);
        if (!Number.isFinite(n)) return fallback;
        return Math.trunc(n);
      }
      var VirtualMatrixControl = class extends Control2 {
        constructor(spec = {}) {
          super({
            ...spec,
            tagName: spec.tagName || "div",
            __type_name: spec.__type_name || "virtual_matrix_control"
          });
          this.testId = spec.testId || null;
          this.viewportTestId = spec.viewportTestId || "vm-viewport";
          this.cornerLabel = spec.cornerLabel || "";
          this.rowKeys = Array.isArray(spec.rowKeys) ? spec.rowKeys : [];
          this.rowLabels = Array.isArray(spec.rowLabels) ? spec.rowLabels : [];
          this.rowTitles = Array.isArray(spec.rowTitles) ? spec.rowTitles : this.rowLabels;
          this.rowAttrs = Array.isArray(spec.rowAttrs) ? spec.rowAttrs : [];
          this.colKeys = Array.isArray(spec.colKeys) ? spec.colKeys : [];
          this.colLabels = Array.isArray(spec.colLabels) ? spec.colLabels : [];
          this.colTitles = Array.isArray(spec.colTitles) ? spec.colTitles : this.colLabels;
          this.colAttrs = Array.isArray(spec.colAttrs) ? spec.colAttrs : [];
          this.specialCells = Array.isArray(spec.specialCells) ? spec.specialCells : [];
          const cellLink = spec.cellLink && typeof spec.cellLink === "object" ? spec.cellLink : {};
          this.cellLink = {
            path: typeof cellLink.path === "string" ? cellLink.path : "/cell",
            rowParam: typeof cellLink.rowParam === "string" ? cellLink.rowParam : "row",
            colParam: typeof cellLink.colParam === "string" ? cellLink.colParam : "col",
            params: cellLink.params && typeof cellLink.params === "object" ? cellLink.params : null
          };
          const layout = spec.layout && typeof spec.layout === "object" ? spec.layout : {};
          this.layout = {
            cellW: Math.max(16, normalizeInt(layout.cellW, 44)),
            cellH: Math.max(16, normalizeInt(layout.cellH, 26)),
            rowHeaderW: Math.max(80, normalizeInt(layout.rowHeaderW, 220)),
            colHeaderH: Math.max(40, normalizeInt(layout.colHeaderH, 120)),
            bufferRows: Math.max(0, normalizeInt(layout.bufferRows, 4)),
            bufferCols: Math.max(0, normalizeInt(layout.bufferCols, 4))
          };
          if (!spec.el) {
            this.compose();
          }
        }
        compose() {
          const ctx = this.context;
          const root = makeEl(ctx, "div", "virtual-matrix", {
            ...this.testId ? { "data-testid": this.testId } : null,
            "data-cell-w": this.layout.cellW,
            "data-cell-h": this.layout.cellH,
            "data-row-header-w": this.layout.rowHeaderW,
            "data-col-header-h": this.layout.colHeaderH,
            "data-buffer-rows": this.layout.bufferRows,
            "data-buffer-cols": this.layout.bufferCols,
            "data-vm-ready": "0",
            "data-render-seq": "0"
          });
          const viewport = makeEl(ctx, "div", "vm-viewport", {
            "data-testid": this.viewportTestId
          });
          const corner = makeEl(ctx, "div", "vm-corner");
          if (this.cornerLabel) {
            corner.add(text(ctx, this.cornerLabel));
          }
          const spacer = makeEl(ctx, "div", "vm-spacer");
          const colHeaders = makeEl(ctx, "div", "vm-col-headers");
          const rowHeaders = makeEl(ctx, "div", "vm-row-headers");
          const cellsLayer = makeEl(ctx, "div", "vm-cells");
          viewport.add(corner);
          viewport.add(spacer);
          viewport.add(colHeaders);
          viewport.add(rowHeaders);
          viewport.add(cellsLayer);
          root.add(viewport);
          const payload = {
            cornerLabel: this.cornerLabel,
            rowKeys: this.rowKeys,
            rowLabels: this.rowLabels,
            rowTitles: this.rowTitles,
            rowAttrs: this.rowAttrs,
            colKeys: this.colKeys,
            colLabels: this.colLabels,
            colTitles: this.colTitles,
            colAttrs: this.colAttrs,
            specialCells: this.specialCells,
            cellLink: this.cellLink
          };
          const dataScript = makeEl(ctx, "script", null, {
            type: "application/json",
            "data-vm-role": "data"
          });
          dataScript.add(text(ctx, JSON.stringify(payload)));
          root.add(dataScript);
          const initScript = makeEl(ctx, "script", null, { "data-vm-role": "init" });
          initScript.add(text(ctx, this._getInitScript()));
          root.add(initScript);
          this.add(root);
        }
        _getInitScript() {
          return `
(() => {
  const clamp = (n, min, max) => (n < min ? min : (n > max ? max : n));
  const ensureInit = () => {
    if (window.__VMATRIX_INIT__) return;
    window.__VMATRIX_INIT__ = true;

    const parseJson = (scriptEl) => {
      if (!scriptEl) return null;
      try { return JSON.parse(scriptEl.textContent || 'null'); } catch { return null; }
    };

    const buildHrefFor = (cellLink) => {
      const safe = (cellLink && typeof cellLink === 'object') ? cellLink : null;
      const path = (safe && safe.path) ? String(safe.path) : '/cell';
      const rowParam = (safe && safe.rowParam) ? String(safe.rowParam) : 'row';
      const colParam = (safe && safe.colParam) ? String(safe.colParam) : 'col';

      const extra = (safe && safe.params && typeof safe.params === 'object') ? safe.params : null;
      const baseParams = new URLSearchParams();
      if (extra) {
        for (const k of Object.keys(extra)) {
          const v = extra[k];
          if (v === undefined || v === null || v === '') continue;
          baseParams.set(String(k), String(v));
        }
      }

      const baseQuery = baseParams.toString();
      const basePrefix = baseQuery ? (baseQuery + '&') : '';

      const enc = encodeURIComponent;
      const rp = enc(rowParam);
      const cp = enc(colParam);

      return (rowKey, colKey) => {
        return path + '?' + basePrefix + rp + '=' + enc(String(rowKey)) + '&' + cp + '=' + enc(String(colKey));
      };
    };

    const initOne = (root) => {
      if (!root || root.getAttribute('data-vm-init') === '1') return;
      root.setAttribute('data-vm-init', '1');

      const dataEl = root.querySelector('script[data-vm-role="data"][type="application/json"]');
      const payload = parseJson(dataEl);
      if (!payload) return;

      const rowKeys = Array.isArray(payload.rowKeys) ? payload.rowKeys : [];
      const rowLabels = Array.isArray(payload.rowLabels) ? payload.rowLabels : [];
      const rowTitles = Array.isArray(payload.rowTitles) ? payload.rowTitles : rowLabels;
      const rowAttrs = Array.isArray(payload.rowAttrs) ? payload.rowAttrs : [];
      const colKeys = Array.isArray(payload.colKeys) ? payload.colKeys : [];
      const colLabels = Array.isArray(payload.colLabels) ? payload.colLabels : [];
      const colTitles = Array.isArray(payload.colTitles) ? payload.colTitles : colLabels;
      const colAttrs = Array.isArray(payload.colAttrs) ? payload.colAttrs : [];
      const specialCells = Array.isArray(payload.specialCells) ? payload.specialCells : [];

      const buildHref = buildHrefFor(payload.cellLink);

      const cellW = Number(root.getAttribute('data-cell-w')) || 44;
      const cellH = Number(root.getAttribute('data-cell-h')) || 26;
      const rowHeaderW = Number(root.getAttribute('data-row-header-w')) || 220;
      const colHeaderH = Number(root.getAttribute('data-col-header-h')) || 120;
      const bufferRows = Number(root.getAttribute('data-buffer-rows')) || 4;
      const bufferCols = Number(root.getAttribute('data-buffer-cols')) || 4;

      const viewport = root.querySelector('.vm-viewport');
      const corner = root.querySelector('.vm-corner');
      const spacer = root.querySelector('.vm-spacer');
      const colLayer = root.querySelector('.vm-col-headers');
      const rowLayer = root.querySelector('.vm-row-headers');
      const cellLayer = root.querySelector('.vm-cells');

      if (!viewport || !spacer || !colLayer || !rowLayer || !cellLayer) return;

      const specialByKey = new Map();
      for (const cell of specialCells) {
        if (!cell) continue;
        const rk = cell.rowKey;
        const ck = cell.colKey;
        specialByKey.set(String(rk) + '|' + String(ck), cell);
      }

      const totalRows = rowKeys.length;
      const totalCols = colKeys.length;

      spacer.style.position = 'relative';
      spacer.style.width = String(rowHeaderW + (totalCols * cellW)) + 'px';
      spacer.style.height = String(colHeaderH + (totalRows * cellH)) + 'px';

      viewport.style.position = 'relative';

      if (corner) {
        corner.style.position = 'absolute';
        corner.style.left = '0px';
        corner.style.top = '0px';
        corner.style.width = String(rowHeaderW) + 'px';
        corner.style.height = String(colHeaderH) + 'px';
        corner.style.display = 'flex';
        corner.style.alignItems = 'flex-end';
        corner.style.padding = '8px 10px';
        corner.style.fontWeight = '600';
        corner.style.fontSize = '12px';
        corner.style.color = 'rgba(212,165,116,0.95)';
        corner.style.background = '#120e0b';
        corner.style.borderRight = '1px solid rgba(74,54,40,1)';
        corner.style.borderBottom = '1px solid rgba(74,54,40,1)';
        corner.style.zIndex = '4';
      }

      colLayer.style.position = 'absolute';
  colLayer.style.left = String(rowHeaderW) + 'px';
  colLayer.style.top = '0px';
  colLayer.style.height = String(colHeaderH) + 'px';
      colLayer.style.zIndex = '3';

      rowLayer.style.position = 'absolute';
  rowLayer.style.left = '0px';
  rowLayer.style.top = String(colHeaderH) + 'px';
  rowLayer.style.width = String(rowHeaderW) + 'px';
      rowLayer.style.zIndex = '2';

      cellLayer.style.position = 'absolute';
      cellLayer.style.left = String(rowHeaderW) + 'px';
      cellLayer.style.top = String(colHeaderH) + 'px';

      let raf = 0;
      let renderSeq = 0;
      let lastWindowKey = null;

      const clearLayer = (el) => {
        while (el.firstChild) el.removeChild(el.firstChild);
      };

      const render = () => {
        raf = 0;

        const scrollTop = viewport.scrollTop || 0;
        const scrollLeft = viewport.scrollLeft || 0;

        colLayer.style.transform = 'translateX(' + String(scrollLeft) + 'px)';
        rowLayer.style.transform = 'translateY(' + String(scrollTop) + 'px)';
        if (corner) corner.style.transform = 'translate(' + String(scrollLeft) + 'px, ' + String(scrollTop) + 'px)';

        const vpW = viewport.clientWidth || 0;
        const vpH = viewport.clientHeight || 0;

        const approxFirstRow = Math.floor(scrollTop / cellH);
        const approxFirstCol = Math.floor(scrollLeft / cellW);

        const visibleRows = Math.ceil((vpH || 1) / cellH);
        const visibleCols = Math.ceil((vpW || 1) / cellW);

        const firstRow = clamp(approxFirstRow - bufferRows, 0, Math.max(0, totalRows - 1));
        const firstCol = clamp(approxFirstCol - bufferCols, 0, Math.max(0, totalCols - 1));
        const lastRow = clamp(approxFirstRow + visibleRows + bufferRows, 0, Math.max(0, totalRows - 1));
        const lastCol = clamp(approxFirstCol + visibleCols + bufferCols, 0, Math.max(0, totalCols - 1));

        const windowKey = String(firstRow) + ':' + String(lastRow) + ':' + String(firstCol) + ':' + String(lastCol);
        if (lastWindowKey === windowKey && root.getAttribute('data-vm-ready') === '1') {
          return;
        }

        lastWindowKey = windowKey;
        renderSeq += 1;

        clearLayer(colLayer);
        clearLayer(rowLayer);
        clearLayer(cellLayer);

        for (let c = firstCol; c <= lastCol; c += 1) {
          const col = document.createElement('div');
          col.className = 'vm-col-header';
          col.style.position = 'absolute';
          col.style.left = String(c * cellW) + 'px';
          col.style.top = '0px';
          col.style.width = String(cellW) + 'px';
          col.style.height = String(colHeaderH) + 'px';

          const attrs = colAttrs[c];
          if (attrs && typeof attrs === 'object') {
            for (const k of Object.keys(attrs)) {
              col.setAttribute(k, String(attrs[k]));
            }
          }

          const inner = document.createElement('div');
          inner.className = 'vm-col-header-inner';
          const labelSpan = document.createElement('span');
          labelSpan.className = 'vm-col-label';
          labelSpan.textContent = String(colLabels[c] ?? '');
          const title = String(colTitles[c] ?? colLabels[c] ?? '');
          if (title) labelSpan.setAttribute('title', title);

          inner.appendChild(labelSpan);
          col.appendChild(inner);
          colLayer.appendChild(col);
        }

        for (let r = firstRow; r <= lastRow; r += 1) {
          const row = document.createElement('div');
          row.className = 'vm-row-header';
          row.style.position = 'absolute';
          row.style.left = '0px';
          row.style.top = String(r * cellH) + 'px';
          row.style.width = String(rowHeaderW) + 'px';
          row.style.height = String(cellH) + 'px';
          row.setAttribute('title', String(rowTitles[r] ?? rowLabels[r] ?? ''));
          row.textContent = String(rowLabels[r] ?? '');

          const rAttrs = rowAttrs[r];
          if (rAttrs && typeof rAttrs === 'object') {
            for (const k of Object.keys(rAttrs)) {
              row.setAttribute(k, String(rAttrs[k]));
            }
          }
          rowLayer.appendChild(row);
        }

        let cellCount = 0;
        for (let r = firstRow; r <= lastRow; r += 1) {
          const rk = rowKeys[r];
          for (let c = firstCol; c <= lastCol; c += 1) {
            const ck = colKeys[c];
            const special = specialByKey.get(String(rk) + '|' + String(ck)) || null;
            const state = (special && special.state) ? String(special.state) : 'unchecked';
            const cls = (special && special.className) ? String(special.className) : 'cell--none';
            const title = (special && special.title) ? String(special.title) : '';
            const glyph = (special && special.glyph) ? String(special.glyph) : '';
            const ageLabel = (special && special.ageLabel) ? String(special.ageLabel) : '';

            const el = document.createElement('div');
            el.className = 'vm-cell cell ' + cls;
            el.style.position = 'absolute';
            el.style.left = String(c * cellW) + 'px';
            el.style.top = String(r * cellH) + 'px';
            el.style.width = String(cellW) + 'px';
            el.style.height = String(cellH) + 'px';
            el.setAttribute('data-state', state);
            if (title) el.setAttribute('title', title);

            const a = document.createElement('a');
            a.className = 'cell-link';
            a.setAttribute('href', buildHref(rk, ck));
            if (glyph) a.appendChild(document.createTextNode(glyph));
            if (ageLabel) {
              const sub = document.createElement('span');
              sub.className = 'cell-age';
              sub.textContent = ageLabel;
              a.appendChild(sub);
            }
            el.appendChild(a);
            cellLayer.appendChild(el);
            cellCount += 1;
          }
        }
        root.setAttribute('data-vm-ready', '1');
      };

      const scheduleRender = () => {
        if (raf) return;
        raf = window.requestAnimationFrame(render);
      };

      try { viewport.addEventListener('scroll', scheduleRender, { passive: true }); } catch { viewport.addEventListener('scroll', scheduleRender); }
      if (typeof ResizeObserver === 'function') {
        try { const ro = new ResizeObserver(() => scheduleRender()); ro.observe(viewport); } catch {}
      }
      window.addEventListener('resize', scheduleRender);
      scheduleRender();
    };

    const initAll = () => {
      const roots = document.querySelectorAll('.virtual-matrix');
      for (const root of roots) initOne(root);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initAll);
    } else {
      initAll();
    }
  };
  ensureInit();
})();`;
        }
      };
      module.exports = VirtualMatrixControl;
    }
  });

  // ../jsgui3-html/controls/matrix/Matrix.js
  var require_Matrix = __commonJS({
    "../jsgui3-html/controls/matrix/Matrix.js"(exports, module) {
      "use strict";
      var jsgui = require_html_core();
      var { Data_Object } = require_lang();
      var { Control: Control2 } = jsgui;
      var StringControl = jsgui.String_Control;
      function text(ctx, value2) {
        return new StringControl({ context: ctx, text: String(value2 != null ? value2 : "") });
      }
      function makeEl(ctx, tagName, className = null, attrs = null) {
        const el = new Control2({ context: ctx, tagName, __type_name: tagName });
        if (className) el.add_class(className);
        if (attrs) {
          for (const [key2, value2] of Object.entries(attrs)) {
            if (value2 === void 0) continue;
            el.dom.attributes[key2] = String(value2);
          }
        }
        return el;
      }
      function truncateLabel(label, maxLen) {
        const s = String(label != null ? label : "");
        const limit = Number.isFinite(maxLen) ? Math.max(0, Math.trunc(maxLen)) : 0;
        if (!limit || s.length <= limit) return { display: s, truncated: false };
        if (limit <= 1) return { display: "\u2026", truncated: true };
        return { display: s.slice(0, limit - 1) + "\u2026", truncated: true };
      }
      var Matrix = class extends Control2 {
        /**
         * @param {Object} spec - Configuration
         * @param {Array} spec.rows - Row data array
         * @param {Array} spec.cols - Column data array
         * @param {Map|Object} [spec.cells] - Sparse cell data map (key: "rowKey|colKey")
         * @param {Function} [spec.getCellData] - (row, col, rowIndex, colIndex) => CellData
         * @param {Function} [spec.getRowKey] - (row, index) => key
         * @param {Function} [spec.getRowLabel] - (row, index) => label
         * @param {Function} [spec.getRowTitle] - (row, index) => title
         * @param {Function} [spec.getColKey] - (col, index) => key
         * @param {Function} [spec.getColLabel] - (col, index) => label
         * @param {Function} [spec.getColTitle] - (col, index) => title
         * @param {Object} [spec.header] - Header options
         * @param {string} [spec.header.mode] - 'angle' or 'vertical'
         * @param {boolean} [spec.virtual] - Force virtual mode
         * @param {number} [spec.virtualThreshold] - Cell count for auto-virtual (default: 50000)
         */
        constructor(spec = {}) {
          super({
            ...spec,
            tagName: spec.tagName || "div",
            __type_name: spec.__type_name || "matrix"
          });
          this.add_class("matrix-control");
          this.data.model = new Data_Object({
            rows: spec.rows || [],
            cols: spec.cols || [],
            cells: spec.cells instanceof Map ? spec.cells : new Map(Object.entries(spec.cells || {}))
          });
          this.view.data.model = new Data_Object({
            row_count: 0,
            col_count: 0,
            cell_count: 0,
            render_mode: "table"
          });
          this.getRowKey = spec.getRowKey || ((row, i) => i);
          this.getRowLabel = spec.getRowLabel || ((row) => String(row != null ? row : ""));
          this.getRowTitle = spec.getRowTitle || this.getRowLabel;
          this.getColKey = spec.getColKey || ((col, i) => i);
          this.getColLabel = spec.getColLabel || ((col) => String(col != null ? col : ""));
          this.getColTitle = spec.getColTitle || this.getColLabel;
          this.getCellData = spec.getCellData || this._defaultGetCellData.bind(this);
          const header = spec.header || {};
          this.headerMode = header.mode === "vertical" ? "vertical" : "angle";
          this.headerAngleDeg = Number.isFinite(header.angleDeg) ? Math.max(0, Math.min(90, header.angleDeg)) : 45;
          this.headerTruncateAt = Number.isFinite(header.truncateAt) ? Math.max(0, header.truncateAt) : 18;
          this.cornerLabel = spec.cornerLabel || "";
          this.forceVirtual = !!spec.virtual;
          this.virtualThreshold = Number.isFinite(spec.virtualThreshold) ? spec.virtualThreshold : 5e4;
          this._setupComputedProperties();
          if (!spec.el) {
            this.compose();
          }
        }
        _defaultGetCellData(row, col, rowIndex, colIndex) {
          const rowKey = this.getRowKey(row, rowIndex);
          const colKey = this.getColKey(col, colIndex);
          const key2 = `${rowKey}|${colKey}`;
          const data = this.data.model.cells.get(key2);
          if (!data) return null;
          if (typeof data === "object" && (data.glyph || data.className || data.state)) return data;
          return { glyph: String(data), value: data };
        }
        _setupComputedProperties() {
          this.computed(
            this.data.model,
            ["rows"],
            (rows) => (rows || []).length,
            { propertyName: "row_count", target: this.view.data.model }
          );
          this.computed(
            this.data.model,
            ["cols"],
            (cols) => (cols || []).length,
            { propertyName: "col_count", target: this.view.data.model }
          );
          this.computed(
            this.view.data.model,
            ["row_count", "col_count"],
            (r, c2) => r * c2,
            { propertyName: "cell_count", target: this.view.data.model }
          );
          this.computed(this.view.data.model, ["cell_count"], (count) => {
            if (this.forceVirtual) return "virtual";
            return count > this.virtualThreshold ? "virtual" : "table";
          }, { propertyName: "render_mode", target: this.view.data.model });
        }
        compose() {
          const ctx = this.context;
          const renderMode = this.view.data.model.render_mode;
          const wrap = makeEl(ctx, "div", "matrix-wrap");
          if (renderMode === "virtual") {
            wrap.add(this._composeVirtual());
          } else {
            wrap.add(this._composeTable());
          }
          this.add(wrap);
        }
        _composeTable() {
          const ctx = this.context;
          const { rows, cols } = this.data.model;
          const table2 = makeEl(ctx, "table", "matrix");
          const thead = makeEl(ctx, "thead");
          const trh = makeEl(ctx, "tr", "matrix-header-row");
          trh.add(makeEl(ctx, "th", "matrix-th matrix-th-corner", { "aria-label": "Corner" }).add(text(ctx, this.cornerLabel)));
          for (let ci = 0; ci < cols.length; ci++) {
            const col = cols[ci];
            const display = truncateLabel(this.getColLabel(col, ci), this.headerTruncateAt).display;
            const th = makeEl(ctx, "th", `matrix-th matrix-th-col matrix-th-col--${this.headerMode}`, {
              "data-col-key": this.getColKey(col, ci),
              title: this.getColTitle(col, ci)
            });
            const inner = makeEl(
              ctx,
              "div",
              "matrix-th-col-inner",
              this.headerMode === "angle" ? { style: `--matrix-angle: ${this.headerAngleDeg}deg;` } : null
            );
            inner.add(makeEl(ctx, "span", "matrix-th-col-label").add(text(ctx, display)));
            th.add(inner);
            trh.add(th);
          }
          thead.add(trh);
          table2.add(thead);
          const tbody = makeEl(ctx, "tbody");
          for (let ri = 0; ri < rows.length; ri++) {
            const row = rows[ri];
            const rowKey = this.getRowKey(row, ri);
            const tr = makeEl(ctx, "tr", "matrix-row");
            const th = makeEl(ctx, "th", "matrix-th matrix-th-row", {
              "data-row-key": rowKey,
              title: this.getRowTitle(row, ri)
            });
            th.add(text(ctx, this.getRowLabel(row, ri)));
            tr.add(th);
            for (let ci = 0; ci < cols.length; ci++) {
              const col = cols[ci];
              const colKey = this.getColKey(col, ci);
              const cellData = this.getCellData(row, col, ri, ci);
              const td = makeEl(ctx, "td", "matrix-td");
              td.dom.attributes["data-row-key"] = String(rowKey);
              td.dom.attributes["data-col-key"] = String(colKey);
              this._renderDefaultCell(td, cellData);
              tr.add(td);
            }
            tbody.add(tr);
          }
          table2.add(tbody);
          return table2;
        }
        _renderDefaultCell(td, cellData) {
          if (!cellData) {
            td.add_class("matrix-td--empty");
            return;
          }
          if (cellData.className) td.add_class(cellData.className);
          if (cellData.state) td.add_class(`cell--${cellData.state}`);
          if (cellData.title) td.dom.attributes.title = cellData.title;
          if (cellData.attrs) {
            for (const [k, v] of Object.entries(cellData.attrs)) {
              td.dom.attributes[k] = String(v);
            }
          }
          const ctx = this.context;
          const display = cellData.glyph || cellData.text || (cellData.value !== void 0 ? String(cellData.value) : "");
          if (cellData.href) {
            const a = makeEl(ctx, "a", "matrix-cell-link", { href: cellData.href, target: cellData.target || "_self" });
            a.add(text(ctx, display));
            td.add(a);
          } else {
            td.add(text(ctx, display));
          }
        }
        _composeVirtual() {
          const VirtualMatrix = require_VirtualMatrix();
          const ctx = this.context;
          const { rows, cols } = this.data.model;
          const rowKeys = [];
          const rowLabels = [];
          const rowTitles = [];
          const colKeys = [];
          const colLabels = [];
          const colTitles = [];
          for (let i = 0; i < rows.length; i++) {
            rowKeys.push(this.getRowKey(rows[i], i));
            rowLabels.push(this.getRowLabel(rows[i], i));
            rowTitles.push(this.getRowTitle(rows[i], i));
          }
          for (let i = 0; i < cols.length; i++) {
            colKeys.push(this.getColKey(cols[i], i));
            colLabels.push(this.getColLabel(cols[i], i));
            colTitles.push(this.getColTitle(cols[i], i));
          }
          const specialCells = [];
          const extractCellData = (value2, key2) => {
            const [rk, ck] = key2.split("|");
            if (value2) {
              const cell = typeof value2 === "object" ? value2 : { glyph: String(value2) };
              specialCells.push({
                rowKey: rk,
                colKey: ck,
                state: cell.state,
                className: cell.className,
                glyph: cell.glyph,
                title: cell.title,
                href: cell.href
              });
            }
          };
          if (this.data.model.cells instanceof Map) {
            this.data.model.cells.forEach(extractCellData);
          }
          return new VirtualMatrix({
            context: ctx,
            cornerLabel: this.cornerLabel,
            rowKeys,
            rowLabels,
            rowTitles,
            colKeys,
            colLabels,
            colTitles,
            specialCells,
            // Pass through layout options if provided in spec (need to add to constructor or assume defaults)
            // For now use defaults or robust ones
            layout: {
              cellW: 44,
              cellH: 26,
              rowHeaderW: 220,
              colHeaderH: 120
            }
          });
        }
        /**
         * Set cell data (updates sparse map)
         */
        set_cell(rowKey, colKey, value2) {
          const key2 = `${rowKey}|${colKey}`;
          const cells = new Map(this.data.model.cells);
          cells.set(key2, value2);
          this.data.model.cells = cells;
        }
      };
      Matrix.css = `
.matrix-control { font-family: system-ui, sans-serif; font-size: 14px; }
.matrix-wrap { overflow: auto; border: 1px solid #ccc; background: #fff; }
table.matrix { border-collapse: collapse; width: 100%; }
.matrix-th { background: #f8f9fa; color: #333; font-weight: 600; padding: 8px; border: 1px solid #dee2e6; text-align: left; }
.matrix-th-corner { position: sticky; left: 0; top: 0; z-index: 3; }
.matrix-th-row { position: sticky; left: 0; z-index: 1; min-width: 120px; }
.matrix-th-col { padding: 0; vertical-align: bottom; height: 100px; width: 40px; }
.matrix-th-col-inner { position: relative; height: 100px; width: 40px; }
.matrix-th-col--angle .matrix-th-col-label { position: absolute; left: 6px; bottom: 6px; transform-origin: left bottom; transform: rotate(calc(-1 * var(--matrix-angle, 45deg))); white-space: nowrap; font-size: 11px; }
.matrix-td { border: 1px solid #dee2e6; padding: 4px; text-align: center; width: 40px; height: 26px; font-family: monospace; }
.matrix-td:hover { outline: 2px solid #3b82f6; outline-offset: -2px; }
.matrix-cell-link { text-decoration: none; color: inherit; display: block; width: 100%; height: 100%; }
`;
      module.exports = Matrix;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/radio-button.js
  var require_radio_button = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/radio-button.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var { apply_full_input_api } = require_input_api();
      var group = jsgui.group;
      var Radio_Button = class extends Control2 {
        // panel name?
        // could have a title field.
        // Items field could be an array.
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          spec = spec || {};
          super(spec);
          this.__type_name = "radio_button";
          this.add_class("radio-button");
          var context2 = this.context;
          if (spec.group_name) this.group_name = spec.group_name;
          if (spec.text) this.text = spec.text;
          if (spec.label) this.text = spec.label;
          const enhance_only = !!spec.enhance_only && !!spec.el;
          const has_checked = is_defined(spec.checked);
          const initial_checked = has_checked ? !!spec.checked : enhance_only ? !!spec.el.checked : false;
          this.checked = initial_checked;
          this.enhance_only = enhance_only;
          if (enhance_only) {
            this._native_radio_el = spec.el;
            this._input_base_el = spec.el;
            if (!this.group_name && spec.el.name) {
              this.group_name = spec.el.name;
            }
            if (spec.el.value !== void 0) {
              this.value = spec.el.value;
            }
          }
          if (!spec.abstract && !spec.el) {
            var name = this.group_name;
            var html_radio = new Control2({
              context: context2
            });
            {
              const { dom } = html_radio;
              dom.tagName = "input";
              const { attributes } = dom;
              attributes.type = "radio";
              attributes.name = name;
              attributes.id = html_radio._id();
              attributes["aria-checked"] = initial_checked ? "true" : "false";
              if (initial_checked) {
                attributes.checked = "checked";
              }
            }
            var html_label = new Control2({
              "context": context2
            });
            html_label.dom.tagName = "label";
            var text_value = this.text + "";
            if (is_defined(text_value)) {
              html_label.add(text_value);
            }
            html_label.dom.attributes.for = html_radio._id();
            this.add(html_radio);
            this.add(html_label);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.radio = html_radio;
            this._ctrl_fields.label = html_label;
            this.radio = html_radio;
            this.label = html_label;
            this._input_base_el = html_radio;
          }
          apply_full_input_api(this, {
            value_mode: "checked"
          });
        }
        /**
         * Set the checked state.
         * @param {boolean} checked - The checked state.
         */
        set_checked(checked) {
          const next_checked = !!checked;
          this.checked = next_checked;
          this._fields = this._fields || {};
          this._fields.checked = next_checked;
          const html_radio = this.radio || this._ctrl_fields && this._ctrl_fields.radio;
          const native_radio = this._native_radio_el || (html_radio && html_radio.dom ? html_radio.dom.el : null);
          if (html_radio) {
            html_radio.dom.attributes["aria-checked"] = next_checked ? "true" : "false";
            if (next_checked) {
              html_radio.dom.attributes.checked = "checked";
            } else {
              html_radio.dom.attributes.checked = "";
            }
            if (html_radio.dom.el) {
              html_radio.dom.el.checked = next_checked;
            }
          } else if (native_radio) {
            if (typeof native_radio.setAttribute === "function") {
              native_radio.setAttribute("aria-checked", next_checked ? "true" : "false");
              if (next_checked) {
                native_radio.setAttribute("checked", "checked");
              } else {
                native_radio.removeAttribute("checked");
              }
            }
            native_radio.checked = next_checked;
          }
        }
        /**
         * Get the checked state.
         * @returns {boolean}
         */
        get_checked() {
          return !!this.checked;
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            super.activate();
            var radio = this.radio || this._ctrl_fields && this._ctrl_fields.radio;
            var el_radio = radio && radio.dom ? radio.dom.el : null;
            if (!el_radio) {
              el_radio = this._native_radio_el || this.dom && this.dom.el;
            }
            if (!el_radio) return;
            var label = this.label;
            const handle_change = () => {
              const checked = !!el_radio.checked;
              this.set_checked(checked);
              this.raise("change", {
                name: "checked",
                value: checked
              });
            };
            if (radio) {
              radio.on("change", handle_change);
            } else {
              this.add_dom_event_listener("change", handle_change);
            }
          }
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="radio"]', Radio_Button, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Radio_Button;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/radio-button-group.js
  var require_radio_button_group = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/radio-button-group.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var Radio_Button = require_radio_button();
      var Radio_Button_Group = class extends Control2 {
        // panel name?
        // Should not need to give a group name...
        //'fields': {
        //    'items': Array
        //},
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "radio_button_group";
          this.add_class("radio-button-group");
          var context2 = this.context;
          if (!spec.abstract && !spec.el) {
            var id = this._id();
            var items = this.get("items").value();
            each(items, (v, i) => {
              var radio_button = new Radio_Button({
                "context": context2,
                "name": id,
                "text": v,
                "value": v
              });
              this.add(radio_button);
            });
          }
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            var that2 = this;
            super.activate();
            var ctrl_checked;
            this.content.each(function(ctrl, i) {
              ctrl.on("change", false, function(e_change) {
                ctrl_checked = ctrl;
                that2.raise("change", {
                  "checked": ctrl_checked
                });
              });
            });
          }
        }
      };
      module.exports = Radio_Button_Group;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/tabbed-panel.js
  var require_tabbed_panel = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/tabbed-panel.js"(exports, module) {
      var jsgui = require_html_core();
      var Control2 = jsgui.Control;
      var mx_selectable = require_selectable();
      var { each, is_array, tof } = jsgui;
      var Panel = require_panel();
      var List = require_list();
      var Radio_Button_Group = require_radio_button_group();
      var Radio_Button = require_radio_button();
      var keyboard_navigation = require_keyboard_navigation();
      var {
        apply_focus_ring,
        apply_label,
        apply_role,
        ensure_sr_text
      } = require_a11y();
      var { themeable } = require_themeable();
      var { apply_token_map } = require_token_maps();
      var Tab = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "tab";
          super(spec);
          let _group_name;
          Object.defineProperty(this, "group_name", {
            get() {
              return _group_name;
            },
            set(value2) {
              let old = _group_name;
              _group_name = value2;
              this.raise("change", { "name": "group_name", "old": old, "value": value2 });
            }
          });
          _group_name = spec.group_name;
          let _name;
          Object.defineProperty(this, "name", {
            get() {
              return _name;
            },
            set(value2) {
              let old = _name;
              _name = value2;
              this.raise("change", { "name": "name", "old": old, "value": value2 });
            }
          });
          _name = spec.name;
          this.add_class("tab");
          mx_selectable(this);
          this.selectable = true;
          if (!spec.el) {
            this.construct_tab();
          }
        }
        construct_tab() {
          const { context: context2 } = this;
          const radio_button = new Radio_Button({
            context: context2,
            group_name: this.group_name,
            text: this.name
          });
          this.add(radio_button);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.radio_button = radio_button;
          (this._fields = this._fields || {}).name = this.name;
        }
      };
      Tab.css = `
.tab { }
`;
      var Tab_Group = class extends List {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "tab_group";
          super(spec);
          this.add_class("tab-group");
          this.tab_names = spec.tab_names || spec.tabs;
          if (!spec.el) {
            this.compose_tab_group();
          }
        }
        compose_tab_group() {
          each(this.tab_names, (tab_name) => {
            this.add(new Tab({
              context: this.context,
              name: tab_name,
              group_name: this.__id
            }));
          });
        }
      };
      Tab_Group.css = `
.tab-group {
    display: flex;
    column-gap: 6px;
}
`;
      var Tabbed_Panel = class extends Panel {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "tabbed_panel";
          super(spec);
          const params = themeable(this, "tabbed_panel", spec);
          apply_token_map(this, "tab", params);
          this.add_class("tab-container");
          this.tabs = spec.tabs;
          this.tab_bar = spec.tab_bar || {};
          this.aria_label = spec.aria_label;
          if (!spec.el) {
            this.compose_tabbed_panel(spec.tabs, this.tab_bar);
          }
        }
        compose_tabbed_panel(tabs_def, tab_bar = {}) {
          const { context: context2 } = this;
          this.tab_pages = [];
          const tabs = tabs_def || this.tabs || [];
          const tab_bar_position = tab_bar.position || "top";
          const tab_variant = tab_bar.variant || null;
          const max_tabs = Number.isFinite(Number(tab_bar.max_tabs)) ? Number(tab_bar.max_tabs) : null;
          const use_overflow = !!tab_bar.overflow && Number.isFinite(max_tabs) && tabs.length > max_tabs;
          apply_role(this, "tablist", { force: true });
          this.dom.attributes["aria-orientation"] = tab_bar_position === "left" || tab_bar_position === "right" ? "vertical" : "horizontal";
          if (this.aria_label !== void 0) {
            apply_label(this, this.aria_label);
          }
          this.remove_class("tabbed-panel-vertical");
          this.remove_class("tabbed-panel-right");
          this.remove_class("tabbed-panel-bottom");
          if (tab_bar_position === "left" || tab_bar_position === "right") {
            this.add_class("tabbed-panel-vertical");
            if (tab_bar_position === "right") {
              this.add_class("tabbed-panel-right");
            }
          }
          if (tab_bar_position === "bottom") {
            this.add_class("tabbed-panel-bottom");
          }
          const tab_inputs = [];
          const tab_labels = [];
          const tab_pages = [];
          const add_tab = (name, group_name2, is_checked, tab_index, tab_def) => {
            var html_radio = new Control2({ context: context2 });
            {
              const { dom } = html_radio;
              dom.tagName = "input";
              const { attributes } = dom;
              attributes.type = "radio";
              attributes.name = group_name2;
              if (is_checked) attributes.checked = "checked";
            }
            html_radio.add_class("tab-input");
            this.add(html_radio);
            html_radio.dom.attributes.id = html_radio.__id;
            html_radio.dom.attributes["data-tab-index"] = String(tab_index);
            const label = new jsgui.controls.label({ context: context2 });
            const tab_id = `${this._id()}-tab-${tab_index}`;
            const panel_id = `${this._id()}-panel-${tab_index}`;
            label.dom.attributes.for = html_radio.dom.attributes.id;
            label.add_class("tab-label");
            label.dom.attributes["data-tab-index"] = String(tab_index);
            label.dom.attributes.role = "tab";
            label.dom.attributes.id = tab_id;
            label.dom.attributes.tabindex = is_checked ? "0" : "-1";
            label.dom.attributes["aria-selected"] = is_checked ? "true" : "false";
            label.dom.attributes["aria-controls"] = panel_id;
            if (tab_variant === "icon" && tab_def && tab_def.icon) {
              const icon_span = new Control2({ context: context2, tag_name: "span" });
              icon_span.add_class("tab-icon");
              icon_span.add(String(tab_def.icon));
              label.add(icon_span);
              if (name) {
                const label_span = new Control2({ context: context2, tag_name: "span" });
                label_span.add_class("tab-text");
                label_span.add(name);
                label.add(label_span);
              } else {
                const fallback_text = `Tab ${tab_index + 1}`;
                ensure_sr_text(label, fallback_text);
              }
            } else {
              label.add(name);
            }
            apply_focus_ring(label);
            this.add(label);
            const tab_page = new Control2({ context: context2 });
            tab_page.add_class("tab-page");
            tab_page.dom.attributes["data-tab-index"] = String(tab_index);
            tab_page.dom.attributes.role = "tabpanel";
            tab_page.dom.attributes.id = panel_id;
            tab_page.dom.attributes["aria-labelledby"] = tab_id;
            tab_page.dom.attributes["aria-hidden"] = is_checked ? "false" : "true";
            tab_page.dom.attributes.tabindex = "0";
            this.tab_pages.push(tab_page);
            this.add(tab_page);
            return {
              tab_page,
              input_ctrl: html_radio,
              label_ctrl: label
            };
          };
          const group_name = this._id();
          const normalize_tab_def = (tab, idx_tab) => {
            const t = tof(tab);
            if (t === "string") return { label_text: tab, content: void 0 };
            if (t === "array") {
              return { label_text: tab[0], content: tab[1] };
            }
            if (tab instanceof Control2) {
              const label_text = tab.title || tab.name || tab.text || tab.__type_name || "Tab " + (idx_tab + 1);
              return { label_text, content: tab };
            }
            if (t === "object") {
              const label_text = tab.title || tab.name || tab.text || "Tab " + (idx_tab + 1);
              const content = tab.content;
              return { label_text, content };
            }
            return { label_text: String(tab), content: void 0 };
          };
          each(tabs, (tab, idx_tab) => {
            const is_checked = idx_tab === 0;
            const normalized = normalize_tab_def(tab, idx_tab);
            const label_text = typeof normalized.label_text === "undefined" ? "" : normalized.label_text;
            const tab_parts = add_tab(label_text, group_name, is_checked, idx_tab, tab);
            if (typeof normalized.content !== "undefined") {
              tab_parts.tab_page.add(normalized.content);
            }
            tab_inputs.push(tab_parts.input_ctrl);
            tab_labels.push(tab_parts.label_ctrl);
            tab_pages.push(tab_parts.tab_page);
            if (use_overflow && idx_tab >= max_tabs) {
              tab_parts.label_ctrl.add_class("tab-label-hidden");
            }
          });
          if (use_overflow) {
            const overflow_select = new Control2({ context: context2 });
            overflow_select.dom.tagName = "select";
            overflow_select.add_class("tab-overflow-select");
            overflow_select.dom.attributes["aria-label"] = "More tabs";
            for (let index = max_tabs; index < tabs.length; index += 1) {
              const normalized = normalize_tab_def(tabs[index], index);
              const option_ctrl = new Control2({ context: context2 });
              option_ctrl.dom.tagName = "option";
              option_ctrl.dom.attributes.value = String(index);
              option_ctrl.add(normalized.label_text || `Tab ${index + 1}`);
              overflow_select.add(option_ctrl);
            }
            this.add(overflow_select);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.overflow_select = overflow_select;
          }
          const ctrl_break = new Control2({ context: context2 });
          ctrl_break.add_class("break");
          this.add(ctrl_break);
          this._tab_controls = {
            tab_inputs,
            tab_labels,
            tab_pages
          };
        }
        /**
         * Set the active tab by index.
         * @param {number} index - Tab index to activate.
         * @param {Object} [options] - Optional settings.
         */
        set_active_tab_index(index, options = {}) {
          const tab_controls = this._tab_controls || {};
          const tab_inputs = tab_controls.tab_inputs;
          const tab_labels = tab_controls.tab_labels;
          const tab_pages = tab_controls.tab_pages;
          if (!Array.isArray(tab_inputs) || !Array.isArray(tab_labels) || !Array.isArray(tab_pages)) return;
          if (!tab_inputs.length) return;
          const clamped = Math.max(0, Math.min(index, tab_inputs.length - 1));
          this.active_index = clamped;
          tab_inputs.forEach((input_ctrl, idx) => {
            const is_checked = idx === clamped;
            if (is_checked) {
              input_ctrl.dom.attributes.checked = "checked";
            } else if (input_ctrl.dom.attributes.checked) {
              delete input_ctrl.dom.attributes.checked;
            }
            if (input_ctrl.dom.el) {
              input_ctrl.dom.el.checked = is_checked;
            }
          });
          tab_labels.forEach((label_ctrl, idx) => {
            const is_selected = idx === clamped;
            label_ctrl.dom.attributes["aria-selected"] = is_selected ? "true" : "false";
            label_ctrl.dom.attributes.tabindex = is_selected ? "0" : "-1";
            if (options.focus && is_selected && label_ctrl.dom.el) {
              label_ctrl.dom.el.focus();
            }
          });
          tab_pages.forEach((page_ctrl, idx) => {
            const is_active = idx === clamped;
            const aria_hidden = is_active ? "false" : "true";
            page_ctrl.dom.attributes["aria-hidden"] = aria_hidden;
            if (page_ctrl.dom.el) {
              page_ctrl.dom.el.setAttribute("aria-hidden", aria_hidden);
            }
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const overflow_select = this._ctrl_fields && this._ctrl_fields.overflow_select;
            const tab_controls = this._tab_controls || {};
            const tab_inputs = tab_controls.tab_inputs;
            const tab_labels = tab_controls.tab_labels;
            const tab_pages = tab_controls.tab_pages;
            if (Array.isArray(tab_inputs) && tab_inputs.length) {
              const initial_index = tab_inputs.findIndex((input_ctrl) => {
                const attrs_checked = input_ctrl.dom.attributes.checked;
                const dom_checked = input_ctrl.dom.el && input_ctrl.dom.el.checked;
                return attrs_checked || dom_checked;
              });
              this.set_active_tab_index(initial_index >= 0 ? initial_index : 0);
              tab_inputs.forEach((input_ctrl, idx) => {
                if (input_ctrl.dom.el) {
                  input_ctrl.dom.el.addEventListener("change", () => {
                    this.set_active_tab_index(idx);
                  });
                }
              });
            }
            if (overflow_select && overflow_select.dom.el && Array.isArray(tab_inputs)) {
              overflow_select.add_dom_event_listener("change", () => {
                const selected = overflow_select.dom.el.value;
                const selected_index = Number(selected);
                if (!Number.isFinite(selected_index)) return;
                this.set_active_tab_index(selected_index, { focus: true });
              });
            }
            if (Array.isArray(tab_labels) && tab_labels.length) {
              const orientation = this.dom.attributes["aria-orientation"] === "vertical" ? "vertical" : "horizontal";
              keyboard_navigation(this, {
                orientation,
                roving_tabindex: true,
                focus_item: true,
                get_items: () => tab_labels,
                get_active_index: () => this.active_index || 0,
                set_active_index: (index, options_set = {}) => {
                  this.set_active_tab_index(index, { focus: !!options_set.from_keyboard });
                },
                on_activate: () => {
                  this.set_active_tab_index(this.active_index || 0, { focus: true });
                }
              });
            }
          }
        }
      };
      Tabbed_Panel.css = `
.tab-container {
    display: flex;
    flex-wrap: wrap;
    flex-direction: row; /* Change to 'row' for top or bottom tabs */
    width: 300px; /* Adjust width as needed */
    position: relative;
    height: 300px;
}
.tabbed-panel-vertical {
    flex-direction: column;
    align-items: flex-start;
}
.tabbed-panel-right {
    align-items: flex-end;
}
.tabbed-panel-bottom {
    flex-direction: column-reverse;
}
.break {
    flex-basis: 100%;
    height: 0;
}
.tab-input {
    display: none;
}
.tab-label {
    height: 22px;
    background-color: #ccc;
    padding: 4px;
    margin: 2px;
    cursor: pointer;
}
.tab-label-hidden {
    display: none;
}
.tab-icon {
    margin-right: 6px;
}
.tab-overflow-select {
    margin: 2px;
    padding: 4px;
}
.tab-input:checked + .tab-label {
    background-color: #DDFFDD;
}
.tab-input:checked + .tab-label + .tab-page {
    display: block;
}
.tab-page {
    display: none;
    


    /*
    order: 100;
    left: 4px;
    right: 4px;
    top: 32px;
    */


    /* height: calc(100% - 32px); */

    height: 300px;
    width: 300px;
    background-color: #FFFFFF;
    border: 1px solid #CCCCCC;
}
`;
      module.exports = Tabbed_Panel;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/app/multi-layout-mode.js
  var require_multi_layout_mode = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/app/multi-layout-mode.js"(exports, module) {
      var jsgui = require_html_core();
      var Panel = require_panel();
      var Tabbed_Panel = require_tabbed_panel();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var Multi_Layout_Mode = class extends Control2 {
        // could have a title field.
        //'fields': {
        //	'title': String
        //},
        // maybe add before make would be better. add will probably be used more.
        constructor(spec) {
          spec.__type_name = spec.__type_name || "multi_layout_mode";
          super(spec);
          this.layout_mode = spec.layout_mode;
          var make = this.context.make;
          var context2 = this.context;
          this.add_class("multi-layout-mode");
          if (!spec.el) {
            this.compose_mlm();
          }
          this._features = this._features || [];
        }
        "compose_mlm"() {
          var layout_mode = this.layout_mode;
          let context2 = this.context;
          if (layout_mode) {
            this.add_class(layout_mode);
          }
          var panel_title = new Panel({
            "context": context2,
            "name": "title",
            "class": "title"
          });
          var panel_navigation = new Panel({
            "context": context2,
            "name": "navigation",
            "class": "navigation"
          });
          var panel_main = new Panel({
            "context": context2,
            "name": "main",
            "class": "main"
          });
          var panel_misc = new Panel({
            "context": context2,
            "name": "misc",
            "class": "misc"
          });
          if (layout_mode == "fluid-fixed") {
            var panel_top = new Panel({
              "context": context2,
              "name": "top"
            });
            panel_top.add_class("top");
            var panel_left_wrapper = new Panel({
              "context": context2,
              "name": "left-wrapper"
            });
            panel_left_wrapper.add_class("left-wrapper");
            var panel_left = new Panel({
              "context": context2,
              "name": "left"
            });
            panel_left.add_class("left");
            var panel_right = new Panel({
              "context": context2,
              "name": "right"
            });
            panel_right.add_class("right");
            var panel_bottom = new Panel({
              "context": context2,
              "name": "bottom"
            });
            panel_bottom.add_class("bottom");
            this.add(panel_top);
            this.add(panel_left_wrapper);
            panel_left_wrapper.add(panel_left);
            this.add(panel_right);
            this.add(panel_bottom);
            panel_top.add(panel_title);
            panel_bottom.add(panel_navigation);
            panel_left.add(panel_main);
            panel_right.add(panel_misc);
          } else if (layout_mode === "tools-at-top") {
            this.add(panel_title);
            this.add(panel_navigation);
            var main_column = new Control2({
              "context": context2,
              "class": "main-column"
            });
            this.add(main_column);
            main_column.add(panel_misc);
            main_column.add(panel_main);
          } else {
            this.add(panel_title);
            this.add(panel_navigation);
            this.add(panel_main);
            this.add(panel_misc);
          }
          this.title = panel_title;
          this.nav = this.navigation = panel_navigation;
          this.main = panel_main;
          this.misc = panel_misc;
          this._ctrl_fields = this._ctrl_fields || {};
          Object.assign(this._ctrl_fields, {
            "title": panel_title,
            "nav": panel_navigation,
            "main": panel_main,
            "misc": panel_misc
          });
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
          }
        }
        //,
        // Takes on the menu of the maximized window (for the moment).
        //  Could have its own menu possibly
        //'menu': function(menu_spec) {
        //}
      };
      module.exports = Multi_Layout_Mode;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/number_input.js
  var require_number_input = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/number_input.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { apply_full_input_api } = require_input_api();
      var normalize_number_value = (value2) => {
        if (!is_defined(value2)) return "";
        if (value2 === "") return "";
        const numeric = Number(value2);
        if (Number.isFinite(numeric)) return numeric;
        return value2;
      };
      var set_attr_if_defined = (dom_attributes, name, value2) => {
        if (is_defined(value2)) {
          dom_attributes[name] = String(value2);
        }
      };
      var Number_Input = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "number_input";
          super(spec);
          this.add_class("number-input");
          this.dom.tagName = "input";
          this.dom.attributes.type = "number";
          this.enhance_only = !!spec.enhance_only && !!spec.el;
          set_attr_if_defined(this.dom.attributes, "min", spec.min);
          set_attr_if_defined(this.dom.attributes, "max", spec.max);
          set_attr_if_defined(this.dom.attributes, "step", spec.step);
          set_attr_if_defined(this.dom.attributes, "inputmode", spec.inputmode);
          apply_full_input_api(this, {
            disabled: spec.disabled,
            readonly: spec.readonly,
            required: spec.required
          });
          if (is_defined(spec.value)) {
            this.set_value(spec.value);
          } else if (this.enhance_only && spec.el && is_defined(spec.el.value)) {
            this.set_value(spec.el.value);
          }
        }
        /**
         * Set the number input value.
         * @param {*} value - The value to set.
         */
        set_value(value2) {
          const normalized = normalize_number_value(value2);
          const value_str = normalized === "" ? "" : String(normalized);
          this.value = normalized;
          this.dom.attributes.value = value_str;
          if (this.dom.el) {
            this.dom.el.value = value_str;
          }
        }
        /**
         * Get the number input value.
         * @returns {*}
         */
        get_value() {
          return this.value;
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            const sync_value = () => {
              this.set_value(this.dom.el.value);
            };
            this.add_dom_event_listener("input", sync_value);
            this.add_dom_event_listener("change", sync_value);
            sync_value();
          }
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="number"]', Number_Input, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Number_Input;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/number_stepper.js
  var require_number_stepper = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/number_stepper.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Number_Input = require_number_input();
      var normalize_number_value = (value2) => {
        if (!is_defined(value2)) return "";
        if (value2 === "") return "";
        const numeric = Number(value2);
        if (Number.isFinite(numeric)) return numeric;
        return "";
      };
      var Number_Stepper = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "number_stepper";
          super(spec);
          this.add_class("number-stepper");
          this.dom.tagName = "div";
          this.min = is_defined(spec.min) ? Number(spec.min) : void 0;
          this.max = is_defined(spec.max) ? Number(spec.max) : void 0;
          this.step = is_defined(spec.step) ? Number(spec.step) : 1;
          this.value = normalize_number_value(spec.value);
          if (!spec.el) {
            this.compose_number_stepper();
          }
        }
        compose_number_stepper() {
          const { context: context2 } = this;
          const input_ctrl = new Number_Input({
            context: context2,
            value: this.value,
            min: this.min,
            max: this.max,
            step: this.step
          });
          input_ctrl.add_class("number-stepper-input");
          const increment_ctrl = new Control2({ context: context2, tag_name: "button" });
          increment_ctrl.dom.attributes.type = "button";
          increment_ctrl.add_class("number-stepper-button");
          increment_ctrl.add_class("number-stepper-increment");
          increment_ctrl.add("+");
          const decrement_ctrl = new Control2({ context: context2, tag_name: "button" });
          decrement_ctrl.dom.attributes.type = "button";
          decrement_ctrl.add_class("number-stepper-button");
          decrement_ctrl.add_class("number-stepper-decrement");
          decrement_ctrl.add("-");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.input = input_ctrl;
          this._ctrl_fields.increment = increment_ctrl;
          this._ctrl_fields.decrement = decrement_ctrl;
          this.add(decrement_ctrl);
          this.add(input_ctrl);
          this.add(increment_ctrl);
        }
        clamp_value(value2) {
          const numeric = normalize_number_value(value2);
          if (numeric === "") return "";
          let next_value = numeric;
          if (is_defined(this.min)) next_value = Math.max(next_value, this.min);
          if (is_defined(this.max)) next_value = Math.min(next_value, this.max);
          return next_value;
        }
        /**
         * Set the stepper value.
         * @param {*} value - The value to set.
         */
        set_value(value2) {
          const clamped = this.clamp_value(value2);
          this.value = clamped;
          const input_ctrl = this._ctrl_fields && this._ctrl_fields.input;
          if (input_ctrl) {
            input_ctrl.set_value(clamped);
          }
        }
        /**
         * Get the stepper value.
         * @returns {*}
         */
        get_value() {
          return this.value;
        }
        /**
         * Step the value up.
         */
        step_up() {
          const current = normalize_number_value(this.value);
          const next_value = current === "" ? this.step : Number(current) + this.step;
          this.set_value(next_value);
          this.raise("change", { name: "value", value: this.value });
        }
        /**
         * Step the value down.
         */
        step_down() {
          const current = normalize_number_value(this.value);
          const next_value = current === "" ? -this.step : Number(current) - this.step;
          this.set_value(next_value);
          this.raise("change", { name: "value", value: this.value });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const input_ctrl = this._ctrl_fields && this._ctrl_fields.input;
            const increment_ctrl = this._ctrl_fields && this._ctrl_fields.increment;
            const decrement_ctrl = this._ctrl_fields && this._ctrl_fields.decrement;
            if (input_ctrl && input_ctrl.dom.el) {
              input_ctrl.add_dom_event_listener("input", () => {
                this.set_value(input_ctrl.dom.el.value);
                this.raise("change", { name: "value", value: this.value });
              });
            }
            if (increment_ctrl) {
              increment_ctrl.on("click", () => this.step_up());
            }
            if (decrement_ctrl) {
              decrement_ctrl.on("click", () => this.step_down());
            }
          }
        }
      };
      Number_Stepper.css = `
.number-stepper {
    display: inline-flex;
    align-items: center;
    gap: 4px;
}
.number-stepper-button {
    width: 28px;
    height: 28px;
    border: 1px solid #ccc;
    background: #fff;
    cursor: pointer;
}
.number-stepper-input {
    width: 80px;
}
`;
      module.exports = Number_Stepper;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/0-viewer/array.js
  var require_array = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/0-viewer/array.js"(exports, module) {
      var jsgui = require_html_core();
      var factory = require_factory();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var Array_Viewer = class extends Control2 {
        //  though in this case the selection behaviour is a bit more complicated.
        // need drag behaviour to be easy too.
        //  however, should implement it with most in jsgui html if possible.
        //'behaviour': ['selectable']
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.add_class("array-viewer");
          this.__type_name = "array_viewer";
          if (!this.factory) this.factory = factory;
          var req = this._context.req;
          if (is_defined(spec.value)) {
            this.set("value", spec.value);
          }
          var that2 = this;
          if (!spec.el) {
            var ctrlOpen = new Control2({
              "context": this._context
            });
            ctrlOpen.set("dom.attributes.class", "array-open");
            ctrlOpen.content.add("[");
            var ctrlInner = new Control2({
              "context": this._context
            });
            ctrlInner.set("dom.attributes.class", "array-inner");
            var ctrlClose = new Control2({
              "context": this._context
            });
            ctrlClose.set("dom.attributes.class", "array-close");
            ctrlClose.content.add("]");
            this.add(ctrlOpen);
            this.add(ctrlInner);
            this.add(ctrlClose);
            this.set("inner", ctrlInner);
            this.refresh_internal();
          }
          this.add_event_listener("change", function(e) {
            var fieldName = e[0];
            var fieldValue = e[1];
            that2.refresh_internal();
          });
        }
        "refresh_internal"() {
          var inner = this.get("inner");
          var value2 = this.get("value");
          var first = true;
          var context2 = this._context;
          var that2 = this;
          each(value2, function(i, v) {
            var comma_space;
            if (!first) {
              comma_space = new jsgui.span({
                "context": that2._context
              });
              comma_space.content.push(", ");
              inner.add(comma_space);
            }
            var ctrl = that2.factory(v, context2);
            inner.add(ctrl);
            first = false;
          });
        }
        "activate"() {
          super.activate();
          var content = this.content;
          var ctrl_open = this.set("open", content.get(0));
          var ctrl_close = this.set("close", content.get(2));
          var hover_class = "bg-light-yellow";
          var group_open_close = jsgui.group_hover_class([ctrl_open, ctrl_close], hover_class);
          var that2 = this;
          group_open_close.selectable(this);
          var ctrl_inner = content.get(1);
          var prev_comma_space;
          ctrl_inner.content.each(function(i, v) {
            var is_comma_space = i % 2;
            if (is_comma_space) {
              prev_comma_space = v;
            } else {
              if (prev_comma_space) {
                prev_comma_space.selectable(v);
              }
            }
          });
        }
      };
      module.exports = Array_Viewer;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/0-viewer/string.js
  var require_string = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/0-viewer/string.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var extend = jsgui.extend;
      var String_Viewer = class extends Control2 {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.add_class("string-viewer");
          this.__type_name = "string_viewer";
          var that2 = this;
          var el = spec.el;
          console.log("string viewer init el", el);
          if (is_defined(spec.value)) {
            this.set("value", spec.value);
          }
          var mode = spec.mode = spec.mode || "json";
          if (!el) {
            if (mode == "json") {
              var span_open = new jsgui.span({
                "context": this._context
              });
              span_open.add('"');
              this.add(span_open);
            }
            var span = new jsgui.span({
              "context": this._context
            });
            span.set("dom.attributes.class", "single-line");
            this.add(span);
            this.set("span", span);
            span.add(spec.text);
            if (mode == "json") {
              var span_close = new jsgui.span({
                "context": this._context
              });
              span_close.add('"');
              this.add(span_close);
            }
            if (typeof document === "undefined") {
              extend(this._fields = this._fields || {}, {
                "mode": mode
              });
            }
          }
        }
        "refresh_internal"() {
          var value2 = this.get("value");
          var span = this.get("span");
          var span_content = span.content;
          var tval = tof(value2);
          var context2 = this._context;
          var content = this.content;
          if (tval == "data_value") {
            span_content.clear();
            span_content.push(typeof value2.value === "function" ? value2.value() : value2.value);
          }
        }
        "activate"() {
          super.activate();
          var that2 = this;
          var content = this.content;
          var mode = this.get("mode");
          console.log("mode", mode);
          console.log("mode " + mode);
          if (mode == "json") {
            var hover_class = "bg-light-yellow";
            var ctrl_open = this.set("open", content.get(0));
            console.log("ctrl_open", ctrl_open);
            var span = this.set("span", content.get(1));
            console.log("span", span);
            var value2 = span.dom.el.innerHTML;
            jsgui.hover_class(span, hover_class);
            var ctrl_close = this.set("close", content.get(2));
            var group_open_close = jsgui.group_hover_class([ctrl_open, ctrl_close], hover_class);
            group_open_close.click(function(e) {
              var ctrl_key2 = e.ctrlKey;
              if (ctrl_key2) {
                that2.action_select_toggle();
              } else {
                that2.action_select_only();
              }
            });
            span.selectable();
          }
          if (mode == "tabular") {
            var span = this.get("span");
            var value2 = span.dom.el.innerHTML;
          }
          this.set("value", value2);
        }
      };
      module.exports = String_Viewer;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/0-viewer/number.js
  var require_number = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/0-viewer/number.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Number_Viewer = class extends Control2 {
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.add_class("number-viewer");
          this.__type_name = "number_viewer";
          var span = new jsgui.span({
            "context": this.context
          });
          if (is_defined(spec.value)) {
            this.set("value", spec.value);
          }
          this.add(span);
          this.set("span", span);
          this.refresh_internal();
        }
        "refresh_internal"() {
          var value2 = this.get("value");
          var span = this.get("span");
          var span_content = span.content;
          var tval = tof(value2);
          var context2 = this._context;
          var content = this.content;
          if (tval == "data_value") {
            span_content.clear();
            span_content.push(typeof value2.value === "function" ? value2.value() : value2.value);
          }
          if (tval == "number") {
            span_content.clear();
            span_content.push(value2);
          }
        }
        "activate"() {
          super.activate();
          var that2 = this;
          var hover_class = "bg-light-yellow";
          var span = this.get("span");
          var span_content = span.content;
          var content_val = span_content.get(0).value();
          var num = JSON.parse(content_val);
          that2.set("value", num);
          that2.selectable();
          jsgui.hover_class(that2, hover_class);
        }
      };
      module.exports = Number_Viewer;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/0-viewer/factory.js
  var require_factory = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/0-viewer/factory.js"(exports, module) {
      var jsgui = require_html_core();
      var Object_Viewer = require_object();
      var Array_Viewer = require_array();
      var String_Viewer = require_string();
      var Number_Viewer = require_number();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var create = function(obj2, context2) {
        var tobj = tof(obj2);
        if (tobj == "object") {
          var res2 = new Object_Viewer({
            "context": context2,
            "value": obj2
          });
          return res2;
        }
        if (tobj == "array") {
          var res2 = new Array_Viewer({
            "context": context2,
            "value": obj2
          });
          return res2;
        }
        if (tobj == "string") {
          var res2 = new String_Viewer({
            "context": context2,
            "value": obj2
          });
          return res2;
        }
        if (tobj == "number") {
          var res2 = new Number_Viewer({
            "context": context2,
            "value": obj2
          });
          return res2;
        }
        if (tobj == "data_value") {
          const val = typeof obj2.value === "function" ? obj2.value() : obj2.value;
          return create(val, context2);
        }
      };
      module.exports = create;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/0-viewer/object-kvp.js
  var require_object_kvp = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/0-viewer/object-kvp.js"(exports, module) {
      var jsgui = require_html_core();
      var factory = require_factory();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Object_KVP_Viewer = class extends Control2 {
        constructor(spec) {
          super(spec);
          this.add_class("object-kvp-viewer");
          this.__type_name = "object_kvp_viewer";
          var that2 = this;
          if (is_defined(spec.key)) {
            this.set("key", spec.key);
          }
          ;
          var val;
          if (is_defined(spec.value)) {
            val = spec.value;
            this.set("value", spec.value);
          }
          ;
          var mode = this.mode;
          if (!spec.mode) {
            spec.mode = "json";
          }
          if (!mode) {
            mode = spec.mode;
            this.mode = mode;
          }
          this.add_class(mode);
          if (!spec.el) {
            if (mode == "json") {
            }
            var ctrl_string_key = new that2.String({
              "context": this._context,
              "text": spec.key,
              "mode": mode
            });
            var ctrl_value_container = new Control2({
              "context": this.context
            });
            ctrl_value_container.add_class("object-kvp-value-viewer");
            var ctrl_value2;
            if (is_defined(val)) {
              var t_val = tof(val);
              if (t_val == "string") {
                ctrl_value2 = new that2.String({
                  "context": this.context,
                  "value": val
                });
              }
              if (t_val == "number") {
                ctrl_value2 = new that2.Number({
                  "context": this.context,
                  "value": val
                });
              }
              if (ctrl_value2) {
                ctrl_value_container.add(ctrl_value2);
              }
            }
            var ctrlClose = new Control2({
              "context": this.context
            });
            ctrlClose.add_class("object-close");
            ctrlClose.content.add("}");
            this.ctrl_key = ctrl_string_key;
            this.ctrl_value = ctrl_value2;
            this.add(ctrl_string_key);
            if (mode == "json") {
              var span_key_colon_space = new jsgui.span({
                "context": this.context
              });
              span_key_colon_space.content.add(": ");
              this.add(span_key_colon_space);
            }
            this.add(ctrl_value_container);
          }
        }
        // Maybe don't use this?
        //  Maybe don't need it.
        "refresh_internal"() {
          var key2 = this.key;
          var value2 = this.value;
          var content = this.content;
          var key_content = ctrl_key.span;
          if (key2) {
            key_content.add(key2);
            var vcon = ctrl_value.content;
            vcon.clear();
            var ctrl_viewer = this.factory(value2, this.context);
            vcon.push(ctrl_viewer);
          }
        }
        "activate"(el) {
          var mode = this.mode;
          var hover_class = "bg-light-yellow";
          super.activate(el);
          var el = el || this.dom.el;
          var cns = el.childNodes;
          var content = this.content;
          var clength = content.length;
          var ctrl_key2, ctrl_value2, ctrl_comma;
          if (mode === "json") {
            if (clength === 3 || clength === 4) {
              var content_key = content.get(0);
              ctrl_key2 = this.ctrl_key = content_key;
              ctrl_value2 = this.ctrl_value = content.get(2);
            }
            if (clength == 4) {
              ctrl_comma = this.ctrl_comma = content.get(4);
            }
          } else {
            ctrl_key2 = this.ctrl_key;
            ctrl_value2 = this.ctrl_value;
          }
          if (clength > 4) {
            throw "stop";
          }
          console.log("ctrl_key", ctrl_key2);
          var key_content = ctrl_key2.content;
          var value_value = ctrl_value2.value;
          console.log("value_value", value_value);
          var ctrl_key_open_quote, ctrl_key_content, ctrl_key_close_quote, ctrl_key_colon_space;
          if (key_content.length === 4) {
            ctrl_key_open_quote = key_content.get(0);
            ctrl_key_content = key_content.get(1);
            ctrl_key_close_quote = key_content.get(2);
            ctrl_key_colon_space = key_content.get(3);
            var group_key_quotes = jsgui.group_hover_class([ctrl_key_open_quote, ctrl_key_close_quote], hover_class);
            var that2 = this;
            group_key_quotes.click_to_select(this);
            jsgui.hover_class(ctrl_key_content, hover_class);
            ctrl_key_content.click_to_select();
            ctrl_key_colon_space.click_to_select(this);
          }
        }
      };
      module.exports = Object_KVP_Viewer;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/0-viewer/object.js
  var require_object = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/0-viewer/object.js"(exports, module) {
      var jsgui = require_html_core();
      var Object_KVP_Viewer = require_object_kvp();
      var factory = require_factory();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Object_Viewer = class extends Control2 {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          if (!this.factory) this.factory = factory;
          this.add_class("object-viewer");
          this.__type_name = "object_viewer";
          var req = this.context.req;
          if (is_defined(spec.value)) {
            this.value = spec.value;
          }
          if (!spec.el) {
            var ctrlOpen = new Control2({
              "context": this.context
            });
            ctrlOpen.add_class("object-open");
            ctrlOpen.content.add("{");
            var ctrlOpenID = ctrlOpen._id();
            var ctrlInner = new Control2({
              "context": this.context
            });
            ctrlInner.add_class("object-inner");
            var ctrlClose = new Control2({
              "context": this.context
            });
            ctrlClose.add_class("object-close");
            ctrlClose.content.add("}");
            var ctrlCloseID = ctrlClose._id();
            this.add(ctrlOpen);
            this.add(ctrlInner);
            this.add(ctrlClose);
            this.inner = ctrlInner;
            var ctrl_fields = {
              "open": ctrlOpenID,
              "close": ctrlCloseID,
              "inner": ctrlInner._id()
            };
            this.dom.attributes = this.dom.attributes || {};
            this.dom.attributes["data-jsgui-ctrl-fields"] = stringify(ctrl_fields).replace(/"/g, "'");
            this.refresh_internal();
          }
          var that2 = this;
        }
        "refresh_internal"() {
          var value2 = this.value;
          var inner = this.inner;
          inner.clear();
          var context2 = this._context;
          var that2 = this;
          var first = true;
          var prev_kvp;
          each(value2, function(v, i) {
            if (!first) {
              var comma = new jsgui.span({
                "context": context2
              });
              comma.content.push(",");
              prev_kvp.content.push(comma);
            }
            var kvp_viewer = new Object_KVP_Viewer({
              "context": context2,
              "key": i,
              "value": v
            });
            var cInternal = that2.factory(v, context2);
            inner.add(kvp_viewer);
            first = false;
            prev_kvp = kvp_viewer;
          });
        }
        // Could put this in control or enhanced control?
        "activate"() {
          super.activate();
          var ctrl_open = this.open;
          var ctrl_close = this.close;
          var ctrl_inner = this.inner;
          var hover_class = "bg-light-yellow";
          var group_open_close = jsgui.group_hover_class([ctrl_open, ctrl_close], hover_class);
          var that2 = this;
          group_open_close.selectable(this);
          var prev_comma;
          ctrl_inner.content.each(function(ctrl_kvp, i) {
            var ckvp = ctrl_kvp.content;
            if (prev_comma) {
              prev_comma.click(function(e) {
                ctrl_kvp.action_select_only();
              });
            }
            if (ckvp.length() == 3) {
              var comma = ckvp.get(2);
              prev_comma = comma;
            }
          });
          this.on("change", function(e_change) {
            that2.refresh_internal();
          });
          console.log("this._bound_events", this._bound_events);
        }
      };
      module.exports = Object_Viewer;
    }
  });

  // ../jsgui3-html/controls/_core.js
  var require_core = __commonJS({
    "../jsgui3-html/controls/_core.js"(exports, module) {
      module.exports = require_html_core();
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/array.js
  var require_array2 = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/array.js"(exports, module) {
      var jsgui = require_html_core();
      var Array_Viewer = require_array();
      var factory = require_factory2();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Array_Editor = class extends Array_Viewer {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.factory = factory;
          this.add_class("array-editor");
          this.__type_name = "array_editor";
        }
        "refresh_internal"() {
          super.refresh_internal();
        }
      };
      module.exports = Array_Editor;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/string.js
  var require_string2 = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/string.js"(exports, module) {
      var jsgui = require_html_core();
      var String_Viewer = require_string();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var String_Editor = class extends String_Viewer {
        // Bit of a problem with this...
        //  Input does not work when it keeps the same size as the text.
        //  Input needs to be at least slightly bigger than the text.
        //  So, I'm thinking that a new version could be made,
        //   where it displays the text in a span, but there is a hidden input, with focus, being edited.
        // Another possibility is to use contenteditable, but to restrict what gets allowed (maybe not so easy)
        //  Could use blur keyup paste events
        //   have it replace anything in the HTML that's a tag / formatting with plain text.
        //  That seems like a decent way of doing it. Would then be able to expand the size of the contenteditable
        //   to the size of its content? I think that happens anyway...
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        // I think persisting the values in the editor, and having them actually do something, like run a CMS,
        // will be very helpful.
        constructor(spec) {
          super(spec);
          var make = this.make;
          var that2 = this;
          this.add_class("string-editor");
          this.__type_name = "string_editor";
          var that2 = this;
        }
        "refresh_internal"() {
          super.refresh_internal();
        }
        "_edit"() {
          var input = this.get("input");
          if (!input) {
            var content = this.content;
            var span = this.get("span");
            var el = this.dom.el;
            var span_bcr = span.dom.el.getBoundingClientRect();
            var this_bcr = el.getBoundingClientRect();
            var span_x_offset = span_bcr.left - this_bcr.left;
            var w = span_bcr.width;
            var value2 = this.get("value");
            input = new jsgui.input({
              "context": this._context
            });
            input.set("dom.attributes.value", value2);
            var font_size = span.style("font-size");
            var font = span.style("font");
            input.style({
              "position": "absolute",
              "margin-left": span_x_offset + "px",
              "width": w + "px",
              "outline": "0",
              //'background-color': 'transparent',
              "border": "0px solid",
              //'font-size': font_size
              "font": font
            });
            content.insert(input, 0);
            var iel = input.dom.el;
            var spanel = span.dom.el;
            iel.focus();
            var sync_size = function(e) {
              console.log("e", e);
              requestAnimationFrame(function() {
                var scrollWidth = iel.scrollWidth;
                console.log("scrollWidth", scrollWidth);
                input.style({
                  "width": scrollWidth + "px"
                });
              });
            };
            input.on("keypress", function(e_keydown) {
              sync_size();
            });
            console.log("has inserted input.");
            this.set("editing", true);
          }
        }
        "activate"() {
          this._super();
          var that2 = this;
          var span = this.get("span");
          span.on("blur", function(e_blur) {
            console.log("e_blur", e_blur);
          });
          var selected_on_mousedown;
          this.on("mousedown", function(e_down) {
            console.log("mousedown");
            var span_selected = this.get("span.selected");
            console.log("md span_selected", span_selected);
            selected_on_mousedown = span_selected;
          });
          this.on("click", function(e_click) {
            var selected = that2.get("selected");
            var editing = that2.get("editing");
            if (selected & !editing) {
              console.log("selected and not editing");
            }
            var span_selected = this.get("span.selected");
            console.log("span_selected", span_selected);
            span.dom.el.setAttribute("contenteditable", true);
          });
          var elSpan = span.dom.el;
          span.on("keyup", function(e_keyup) {
            console.log("span keyup");
            var cns = elSpan.childNodes;
            console.log("cns.length " + cns.length);
            if (cns.length > 1) {
              for (var i = 0; i < cns.length; i++) {
                var cn = cns[i];
                if (cn.nodeType == 3) {
                } else {
                  elSpan.removeChild(cn);
                  i--;
                }
              }
            }
          });
        }
      };
      module.exports = String_Editor;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/2-misc/up-down-arrow-buttons.js
  var require_up_down_arrow_buttons = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/2-misc/up-down-arrow-buttons.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var Button = require_button();
      var Up_Down_Arrow_Buttons = class extends Control2 {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.add_class("up-down-arrow-buttons");
          this.__type_name = "up_down_arrow_buttons";
          var btn_up = new Button({
            "context": this.context,
            "text": "up"
          });
          var btn_down = new Button({
            "context": this.context,
            "text": "down"
          });
          this.add(btn_up);
          this.add(btn_down);
          this.set("btn_up", btn_up);
          this.set("btn_down", btn_down);
          this.btn_up = btn_up;
          this.btn_down = btn_down;
          var that2 = this;
        }
        "activate"() {
          super.activate();
          var that2 = this;
          var btn_up = this.btn_up || this.get("btn_up");
          var btn_down = this.btn_down || this.get("btn_down");
          var that2 = this;
          btn_up.on("click", function(e_click) {
            that2.raise("up");
          });
          btn_down.on("click", function(e_click) {
            that2.raise("down");
          });
        }
      };
      module.exports = Up_Down_Arrow_Buttons;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/number.js
  var require_number2 = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/number.js"(exports, module) {
      var jsgui = require_html_core();
      var Number_Viewer = require_number();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Up_Down_Arrow_Buttons = require_up_down_arrow_buttons();
      var Number_Editor = class extends Number_Viewer {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.add_class("number-editor");
          this.__type_name = "number_editor";
          var udab = new Up_Down_Arrow_Buttons({
            "context": this.context
          });
          this.add(udab);
          this.set("up_down_arrow_buttons", udab);
        }
        "activate"() {
          super.activate();
          var udab = this.get("up_down_arrow_buttons");
          var that2 = this;
          udab.on("up", function() {
            var val = that2.get("value");
            that2.set("value", val + 1);
          });
          udab.on("down", function() {
            var val = that2.get("value");
            that2.set("value", val - 1);
          });
        }
      };
      module.exports = Number_Editor;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/factory.js
  var require_factory2 = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/factory.js"(exports, module) {
      var jsgui = require_html_core();
      var Object_Editor = require_object2();
      var Array_Editor = require_array2();
      var String_Editor = require_string2();
      var Number_Editor = require_number2();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var group = jsgui.group;
      var create = function(obj2, context2) {
        var tobj = tof(obj2);
        if (tobj == "object") {
          var res2 = new Object_Editor({
            "context": context2,
            "value": obj2
          });
          return res2;
        }
        if (tobj == "array") {
          var res2 = new Array_Editor({
            "context": context2,
            "value": obj2
          });
          return res2;
        }
        if (tobj == "string") {
          var res2 = new String_Editor({
            "context": context2,
            "value": obj2
          });
          return res2;
        }
        if (tobj == "number") {
          var res2 = new Number_Editor({
            "context": context2,
            "value": obj2
          });
          return res2;
        }
        if (tobj == "data_value") {
          var val = obj2.value();
          var tval = tof(val);
          if (tval == "string") {
            var res2 = new String_Editor({
              "context": context2,
              "value": obj2
            });
          }
          if (tval == "array") {
            var res2 = new Array_Editor({
              "context": context2,
              "value": obj2
            });
          }
          return res2;
        }
      };
      module.exports = create;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/object-kvp.js
  var require_object_kvp2 = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/object-kvp.js"(exports, module) {
      var jsgui = require_core();
      var Object_KVP_Viewer = require_object_kvp();
      var factory = require_factory2();
      var String_Editor = require_string2();
      var Number_Editor = require_number2();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Object_KVP_Editor = class extends Object_KVP_Viewer {
        constructor(spec) {
          super(spec);
          this.factory = factory;
          this.String = String_Editor;
          this.Number = Number_Editor;
          this.add_class("object-kvp-editor");
          this.add_class(this.mode);
          this.__type_name = "object_kvp_editor";
        }
        "refresh_internal"() {
          super.refresh_internal();
        }
        "activate"() {
          super.activate();
        }
      };
      module.exports = Object_KVP_Editor;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/object.js
  var require_object2 = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/object.js"(exports, module) {
      var jsgui = require_html_core();
      var Object_Viewer = require_object();
      var Object_KVP_Editor = require_object_kvp2();
      var factory = require_factory2();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Text_Input = require_Text_Input();
      var Textarea = require_textarea();
      var Number_Input = require_number_input();
      var Array_Editor = require_array2();
      var Object_Editor = class _Object_Editor extends Object_Viewer {
        // Maybe should put this into a form, so that it does a form post.
        //  That could possibly be disabled.
        constructor(spec) {
          super(spec);
          var make = this.make;
          this.factory = factory;
          this.Object_KVP = Object_KVP_Editor;
          this.add_class("object-editor");
          this.__type_name = "object_editor";
          this.schema = spec.schema || null;
          this.allow_add = spec.allow_add !== false;
          this.allow_remove = spec.allow_remove !== false;
          this.show_key_editor = spec.show_key_editor !== false;
          this.collapsed_keys = Array.isArray(spec.collapsed_keys) ? spec.collapsed_keys.slice() : [];
        }
        "refresh_internal"() {
          const value2 = this.value || {};
          const inner = this.inner;
          if (!inner) return;
          inner.clear();
          const schema = this.schema || {};
          const schema_keys = Array.isArray(schema.fields) ? schema.fields.map((field) => String(field.name)) : schema.properties ? Object.keys(schema.properties) : [];
          const value_keys = Object.keys(value2 || {});
          const keys = schema_keys.concat(value_keys.filter((key2) => !schema_keys.includes(key2)));
          keys.forEach((key2, index) => {
            const field_schema = this.get_schema_for_key(key2, index, schema);
            const row_ctrl = new Control2({ context: this.context, tag_name: "div" });
            row_ctrl.add_class("object-editor-row");
            row_ctrl.dom.attributes["data-key"] = key2;
            const key_ctrl = this.create_key_control(key2, field_schema);
            row_ctrl.add(key_ctrl);
            const value_ctrl = this.create_value_control(key2, value2[key2], field_schema);
            row_ctrl.add(value_ctrl.wrapper);
            if (this.allow_remove) {
              const remove_ctrl = new Control2({ context: this.context, tag_name: "button" });
              remove_ctrl.add_class("object-editor-remove");
              remove_ctrl.dom.attributes.type = "button";
              remove_ctrl.dom.attributes["data-role"] = "remove-key";
              remove_ctrl.dom.attributes["data-key"] = key2;
              remove_ctrl.add("Remove");
              row_ctrl.add(remove_ctrl);
            }
            inner.add(row_ctrl);
          });
          if (this.allow_add) {
            const add_ctrl = new Control2({ context: this.context, tag_name: "button" });
            add_ctrl.add_class("object-editor-add");
            add_ctrl.dom.attributes.type = "button";
            add_ctrl.dom.attributes["data-role"] = "add-key";
            add_ctrl.add("Add field");
            inner.add(add_ctrl);
          }
        }
        /**
         * Set editor value.
         * @param {Object} value - Object value.
         */
        set_value(value2) {
          this.value = value2 || {};
          this.refresh_internal();
        }
        /**
         * Get editor value.
         * @returns {Object}
         */
        get_value() {
          return this.value || {};
        }
        /**
         * Toggle collapse for a key.
         * @param {string} key - Key to toggle.
         */
        toggle_key(key2) {
          const key_str = String(key2);
          const index = this.collapsed_keys.indexOf(key_str);
          if (index >= 0) {
            this.collapsed_keys.splice(index, 1);
          } else {
            this.collapsed_keys.push(key_str);
          }
          this.refresh_internal();
        }
        /**
         * Add a key/value pair.
         * @param {string} key - Key to add.
         * @param {*} value - Value to set.
         * @returns {boolean}
         */
        add_key(key2, value2) {
          const key_str = String(key2 || "");
          if (!key_str) return false;
          if (is_defined(this.value[key_str])) return false;
          this.value[key_str] = is_defined(value2) ? value2 : "";
          this.refresh_internal();
          return true;
        }
        /**
         * Remove a key/value pair.
         * @param {string} key - Key to remove.
         * @returns {boolean}
         */
        remove_key(key2) {
          const key_str = String(key2 || "");
          if (!is_defined(this.value[key_str])) return false;
          delete this.value[key_str];
          this.refresh_internal();
          return true;
        }
        get_schema_for_key(key2, index, schema) {
          if (Array.isArray(schema.fields)) {
            const field = schema.fields.find((field_def) => String(field_def.name) === String(key2));
            if (field) return field;
          }
          if (schema.properties && schema.properties[key2]) {
            return schema.properties[key2];
          }
          return {
            name: key2,
            type: typeof (this.value || {})[key2]
          };
        }
        create_key_control(key2, field_schema) {
          const key_ctrl = new Control2({ context: this.context, tag_name: "input" });
          key_ctrl.add_class("object-editor-key");
          key_ctrl.dom.attributes.type = "text";
          key_ctrl.dom.attributes.value = String(key2);
          key_ctrl.dom.attributes["data-role"] = "key-input";
          key_ctrl.dom.attributes["data-key"] = key2;
          if (!this.show_key_editor || field_schema && field_schema.readonly) {
            key_ctrl.dom.attributes.readonly = "readonly";
          }
          return key_ctrl;
        }
        create_value_control(key2, value2, field_schema) {
          const wrapper = new Control2({ context: this.context, tag_name: "div" });
          wrapper.add_class("object-editor-value");
          wrapper.dom.attributes["data-key"] = key2;
          const type = field_schema && field_schema.type ? field_schema.type : typeof value2;
          if (type === "object" && value2 && !Array.isArray(value2)) {
            const toggle_ctrl = new Control2({ context: this.context, tag_name: "button" });
            toggle_ctrl.add_class("object-editor-toggle");
            toggle_ctrl.dom.attributes.type = "button";
            toggle_ctrl.dom.attributes["data-role"] = "toggle-node";
            toggle_ctrl.dom.attributes["data-key"] = key2;
            const is_collapsed = this.collapsed_keys.includes(String(key2));
            toggle_ctrl.dom.attributes["aria-expanded"] = is_collapsed ? "false" : "true";
            toggle_ctrl.add(is_collapsed ? "Expand" : "Collapse");
            wrapper.add(toggle_ctrl);
            const child_ctrl = new _Object_Editor({
              context: this.context,
              value: value2 || {},
              schema: field_schema && field_schema.schema,
              allow_add: this.allow_add,
              allow_remove: this.allow_remove,
              show_key_editor: this.show_key_editor,
              collapsed_keys: []
            });
            child_ctrl.add_class("object-editor-children");
            if (is_collapsed) {
              child_ctrl.dom.attributes.style.display = "none";
            }
            wrapper.add(child_ctrl);
            return { wrapper, input_ctrl: null };
          }
          if (type === "array" || Array.isArray(value2)) {
            const toggle_ctrl = new Control2({ context: this.context, tag_name: "button" });
            toggle_ctrl.add_class("object-editor-toggle");
            toggle_ctrl.dom.attributes.type = "button";
            toggle_ctrl.dom.attributes["data-role"] = "toggle-node";
            toggle_ctrl.dom.attributes["data-key"] = key2;
            const is_collapsed = this.collapsed_keys.includes(String(key2));
            toggle_ctrl.dom.attributes["aria-expanded"] = is_collapsed ? "false" : "true";
            toggle_ctrl.add(is_collapsed ? "Expand" : "Collapse");
            wrapper.add(toggle_ctrl);
            const child_ctrl = new Array_Editor({
              context: this.context,
              value: value2 || []
            });
            child_ctrl.add_class("object-editor-children");
            if (is_collapsed) {
              child_ctrl.dom.attributes.style.display = "none";
            }
            wrapper.add(child_ctrl);
            return { wrapper, input_ctrl: null };
          }
          let input_ctrl;
          if (type === "number") {
            input_ctrl = new Number_Input({ context: this.context, value: value2 });
          } else if (type === "boolean") {
            input_ctrl = new Control2({ context: this.context, tag_name: "input" });
            input_ctrl.dom.attributes.type = "checkbox";
            if (value2) {
              input_ctrl.dom.attributes.checked = "checked";
            }
          } else if (field_schema && field_schema.multiline) {
            input_ctrl = new Textarea({ context: this.context, value: value2 });
          } else {
            input_ctrl = new Text_Input({ context: this.context, value: value2 });
          }
          input_ctrl.add_class("object-editor-value-input");
          input_ctrl.dom.attributes["data-role"] = "value-input";
          input_ctrl.dom.attributes["data-key"] = key2;
          wrapper.add(input_ctrl);
          return { wrapper, input_ctrl };
        }
        activate() {
          if (!this.__active) {
            Control2.prototype.activate.call(this);
            const inner = this.inner;
            if (!inner || !inner.dom.el) return;
            inner.add_dom_event_listener("click", (e_click) => {
              const target = e_click.target;
              if (!target || !target.getAttribute) return;
              const role = target.getAttribute("data-role");
              const key2 = target.getAttribute("data-key");
              if (role === "remove-key" && key2) {
                this.remove_key(key2);
              }
              if (role === "add-key") {
                let index = 1;
                let new_key = `field_${index}`;
                while (is_defined(this.value[new_key])) {
                  index += 1;
                  new_key = `field_${index}`;
                }
                this.add_key(new_key, "");
              }
              if (role === "toggle-node" && key2) {
                this.toggle_key(key2);
              }
            });
            inner.add_dom_event_listener("change", (e_change) => {
              const target = e_change.target;
              if (!target || !target.getAttribute) return;
              const role = target.getAttribute("data-role");
              const key2 = target.getAttribute("data-key");
              if (!key2) return;
              if (role === "key-input") {
                const new_key = target.value.trim();
                if (!new_key || new_key === key2) return;
                if (is_defined(this.value[new_key])) return;
                this.value[new_key] = this.value[key2];
                delete this.value[key2];
                this.refresh_internal();
              }
              if (role === "value-input") {
                if (target.type === "checkbox") {
                  this.value[key2] = !!target.checked;
                } else if (target.type === "number") {
                  this.value[key2] = Number(target.value);
                } else {
                  this.value[key2] = target.value;
                }
              }
            });
          }
        }
      };
      Object_Editor.css = `
.object-editor-row {
    display: grid;
    grid-template-columns: minmax(120px, 180px) 1fr auto;
    gap: 8px;
    align-items: center;
    padding: 4px 0;
}
.object-editor-key {
    padding: 4px 6px;
}
.object-editor-value {
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.object-editor-value-input {
    padding: 4px 6px;
}
.object-editor-toggle {
    align-self: flex-start;
    border: 1px solid #ccc;
    background: #fff;
    padding: 4px 6px;
    cursor: pointer;
}
.object-editor-children {
    margin-left: 12px;
    padding-left: 8px;
    border-left: 1px dashed #ddd;
}
.object-editor-add,
.object-editor-remove {
    border: 1px solid #ccc;
    background: #fff;
    padding: 4px 6px;
    cursor: pointer;
}
`;
      module.exports = Object_Editor;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/pagination.js
  var require_pagination = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/pagination.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Pagination = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "pagination";
          super(spec);
          this.add_class("pagination");
          this.dom.tagName = "nav";
          this.dom.attributes["aria-label"] = "Pagination";
          this.page = is_defined(spec.page) ? Number(spec.page) : 1;
          this.page_count = is_defined(spec.page_count) ? Number(spec.page_count) : 1;
          this.page_size = is_defined(spec.page_size) ? Number(spec.page_size) : void 0;
          if (!spec.el) {
            this.compose_pagination();
          }
        }
        compose_pagination() {
          const { context: context2 } = this;
          const list_ctrl = new Control2({ context: context2 });
          list_ctrl.dom.tagName = "ul";
          list_ctrl.add_class("pagination-list");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.list = list_ctrl;
          this.add(list_ctrl);
          this.render_pages();
        }
        render_pages() {
          const list_ctrl = this._ctrl_fields && this._ctrl_fields.list;
          if (!list_ctrl) return;
          list_ctrl.clear();
          const total_pages = Math.max(1, this.page_count || 1);
          const current_page = Math.min(Math.max(1, this.page || 1), total_pages);
          this.page = current_page;
          const add_button = (label, page, disabled, is_current) => {
            const li_ctrl = new Control2({ context: this.context });
            li_ctrl.dom.tagName = "li";
            li_ctrl.add_class("pagination-item");
            const button_ctrl = new Control2({ context: this.context });
            button_ctrl.dom.tagName = "button";
            button_ctrl.dom.attributes.type = "button";
            button_ctrl.dom.attributes["data-page"] = String(page);
            button_ctrl.add_class("pagination-button");
            if (disabled) {
              button_ctrl.dom.attributes.disabled = "disabled";
            }
            if (is_current) {
              button_ctrl.dom.attributes["aria-current"] = "page";
              button_ctrl.add_class("is-current");
            }
            button_ctrl.add(String(label));
            li_ctrl.add(button_ctrl);
            list_ctrl.add(li_ctrl);
          };
          add_button("Prev", current_page - 1, current_page <= 1, false);
          for (let i = 1; i <= total_pages; i += 1) {
            add_button(i, i, false, i === current_page);
          }
          add_button("Next", current_page + 1, current_page >= total_pages, false);
        }
        /**
         * Set the current page.
         * @param {number} page - The page number to set.
         */
        set_page(page) {
          const next_page = Number(page);
          if (!Number.isFinite(next_page)) return;
          this.page = next_page;
          this.render_pages();
          this.raise("page_change", { page: this.page, page_count: this.page_count });
        }
        /**
         * Set the total page count.
         * @param {number} page_count - The page count to set.
         */
        set_page_count(page_count) {
          const next_count = Number(page_count);
          if (!Number.isFinite(next_count)) return;
          this.page_count = Math.max(1, next_count);
          this.render_pages();
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const list_ctrl = this._ctrl_fields && this._ctrl_fields.list;
            if (!list_ctrl || !list_ctrl.dom.el) return;
            list_ctrl.add_dom_event_listener("click", (e_click) => {
              const target = e_click.target;
              if (!target || !target.getAttribute) return;
              const page_str = target.getAttribute("data-page");
              if (!is_defined(page_str)) return;
              const next_page = Number(page_str);
              if (!Number.isFinite(next_page)) return;
              if (target.getAttribute("disabled")) return;
              this.set_page(next_page);
            });
          }
        }
      };
      Pagination.css = `
.pagination-list {
    list-style: none;
    display: flex;
    gap: 6px;
    padding: 0;
    margin: 0;
}
.pagination-button {
    border: 1px solid #ccc;
    background: #fff;
    padding: 4px 8px;
    cursor: pointer;
}
.pagination-button.is-current {
    background: #222;
    color: #fff;
    border-color: #222;
}
`;
      module.exports = Pagination;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/property_editor.js
  var require_property_editor = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/property_editor.js"(exports, module) {
      var Panel = require_panel();
      var Control2 = require_control();
      var Text_Input = require_Text_Input();
      var Checkbox = require_checkbox();
      var Property_Editor = class extends Panel {
        constructor(options = {}) {
          super(options);
          this.add_class("property-editor");
          const { context: context2 } = this;
          this.header = new Control2({ context: context2, tag_name: "div" });
          this.header.add_class("property-editor-header");
          this.header_title = new Control2({ context: context2, tag_name: "h3" });
          this.header_title.add("Properties");
          this.header.add(this.header_title);
          this.add(this.header);
          this.properties_container = new Control2({ context: context2, tag_name: "div" });
          this.properties_container.add_class("property-editor-properties");
          this.add(this.properties_container);
          this.no_selection_message = new Control2({ context: context2, tag_name: "div" });
          this.no_selection_message.add_class("property-editor-no-selection");
          this.no_selection_message.add("Select a field to edit its properties");
          this.properties_container.add(this.no_selection_message);
          this.current_item = null;
          this.property_fields = {};
        }
        /**
         * Load properties for an item
         */
        load_item(item2, on_change) {
          this.current_item = item2;
          this.on_change = on_change;
          this.property_fields = {};
          this.properties_container.content.clear();
          if (!item2) {
            this.properties_container.add(this.no_selection_message);
            return;
          }
          const { context: context2 } = this;
          const properties = item2.properties || {};
          this._add_property_group(context2, "Field Type", properties.type || "text", null, true);
          this._add_property_group(context2, "Label", properties.label || "", (value2) => {
            properties.label = value2;
            if (this.on_change) this.on_change();
          });
          this._add_property_group(context2, "Name/ID", properties.name || "", (value2) => {
            properties.name = value2;
            if (this.on_change) this.on_change();
          });
          if (["text", "email", "password", "number", "url", "tel", "textarea"].includes(properties.type)) {
            this._add_property_group(context2, "Placeholder", properties.placeholder || "", (value2) => {
              properties.placeholder = value2;
              if (this.on_change) this.on_change();
            });
          }
          this._add_property_checkbox(context2, "Required", properties.required || false, (checked) => {
            properties.required = checked;
            if (this.on_change) this.on_change();
          });
          if (properties.type === "select") {
            this._add_property_group(
              context2,
              "Options (comma-separated)",
              (properties.options || []).join(", "),
              (value2) => {
                properties.options = value2.split(",").map((s) => s.trim()).filter((s) => s);
                if (this.on_change) this.on_change();
              }
            );
          }
          this._add_property_group(context2, "Width (%)", properties.width || "100", (value2) => {
            properties.width = value2;
            if (this.on_change) this.on_change();
          });
          const delete_btn = new Control2({ context: context2, tag_name: "button" });
          delete_btn.add_class("property-editor-delete-btn");
          delete_btn.add("Delete Field");
          delete_btn.on("click", () => {
            if (this.on_delete) this.on_delete(item2);
          });
          this.properties_container.add(delete_btn);
        }
        _add_property_group(context2, label, value2, on_change, read_only = false) {
          const group = new Control2({ context: context2, tag_name: "div" });
          group.add_class("property-group");
          const label_el = new Control2({ context: context2, tag_name: "label" });
          label_el.add_class("property-label");
          label_el.add(label);
          group.add(label_el);
          const input = new Text_Input({ context: context2 });
          input.add_class("property-input");
          input.dom.el.value = value2;
          if (read_only) input.dom.el.disabled = true;
          if (on_change && !read_only) {
            input.on("input", () => {
              on_change(input.dom.el.value);
            });
          }
          group.add(input);
          this.properties_container.add(group);
          this.property_fields[label] = input;
          return group;
        }
        _add_property_checkbox(context2, label, checked, on_change) {
          const group = new Control2({ context: context2, tag_name: "div" });
          group.add_class("property-group");
          group.add_class("property-group-checkbox");
          const checkbox = new Checkbox({ context: context2 });
          checkbox.add_class("property-checkbox");
          checkbox.dom.el.checked = checked;
          if (on_change) {
            checkbox.on("change", () => {
              on_change(checkbox.dom.el.checked);
            });
          }
          const label_el = new Control2({ context: context2, tag_name: "label" });
          label_el.add_class("property-label");
          label_el.add(label);
          group.add(checkbox);
          group.add(label_el);
          this.properties_container.add(group);
          this.property_fields[label] = checkbox;
          return group;
        }
        /**
         * Set the delete callback
         */
        set_on_delete(callback2) {
          this.on_delete = callback2;
        }
      };
      module.exports = Property_Editor;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/0-viewer/Property_Viewer.js
  var require_Property_Viewer = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/0-viewer/Property_Viewer.js"(exports, module) {
      var jsgui = require_html_core();
      var { each, tof } = jsgui;
      var Control2 = jsgui.Control;
      var { field, prop } = require_oext();
      var Property_Viewer = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "property_viewer";
          super(spec);
          this.add_class("property-viewer");
          field(this.view.data.model, "data");
          field(this.view.data.model, "schema");
          if (spec.data) this.view.data.model.data = spec.data;
          if (spec.schema) this.view.data.model.schema = spec.schema;
          this.view.data.model.on("change", (e) => {
            if (e.name === "data" || e.name === "schema") {
              this.refresh_view();
            }
          });
          if (!spec.abstract && !spec.el) {
            this.compose_viewer();
          }
        }
        compose_viewer() {
          this.add_class("property-viewer");
          this.refresh_view();
        }
        set_data(data) {
          this.view.data.model.data = data;
        }
        refresh_view() {
          this.content.clear();
          const { context: context2 } = this;
          const data = this.view.data.model.data || {};
          const schema = this.view.data.model.schema || {};
          const keys = Object.keys(schema).length > 0 ? Object.keys(schema) : Object.keys(data);
          each(keys, (key2) => {
            const field_schema = schema[key2] || {};
            const value2 = data[key2];
            const label_text = field_schema.label || key2;
            const type = field_schema.type || "string";
            const row = new Control2({ context: context2 });
            row.add_class("property-row");
            const label = new Control2({ context: context2 });
            label.add_class("property-label");
            label.add(label_text);
            row.add(label);
            const value_container = new Control2({ context: context2 });
            value_container.add_class("property-value");
            this.render_value(value_container, value2, type, field_schema);
            row.add(value_container);
            this.add(row);
          });
        }
        render_value(container, value2, type, schema) {
          const { context: context2 } = this;
          if (value2 === void 0 || value2 === null) {
            container.add("-");
            return;
          }
          if (type === "badge") {
            const badge = new Control2({ context: context2 });
            badge.add_class("property-value--badge");
            if (schema.badgeClass) badge.add_class(schema.badgeClass);
            badge.add(String(value2));
            container.add(badge);
          } else if (type === "status") {
            const status_wrapper = new Control2({ context: context2 });
            status_wrapper.add_class("property-value--status-wrapper");
            const dot = new Control2({ context: context2 });
            dot.add_class("status-dot");
            const status_map = schema.statusMap || { active: "green", inactive: "red" };
            const color = status_map[value2] || "gray";
            dot.add_class(`status-${color}`);
            status_wrapper.add(dot);
            const text = new Control2({ context: context2 });
            text.add(String(value2));
            status_wrapper.add(text);
            container.add(status_wrapper);
          } else if (type === "link") {
            const link = new Control2({ context: context2, tag_name: "a" });
            link.add_class("property-value--link");
            link.dom.attributes.href = value2;
            link.add(String(value2));
            container.add(link);
          } else if (type === "code") {
            const code = new Control2({ context: context2, tag_name: "code" });
            code.add_class("property-value--code");
            code.add(String(value2));
            container.add(code);
          } else if (type === "date") {
            let date_str = value2;
            try {
              if (value2 instanceof Date) {
                date_str = value2.toLocaleString();
              } else {
                date_str = new Date(value2).toLocaleString();
              }
            } catch (e) {
            }
            container.add(date_str);
          } else {
            container.add(String(value2));
          }
        }
      };
      Property_Viewer.css = `
.property-viewer {
    display: flex;
    flex-direction: column;
    font-family: 'Segoe UI', sans-serif;
    font-size: 14px;
    width: 100%;
}

.property-row {
    display: flex;
    flex-direction: row;
    padding: 6px 0;
    border-bottom: 1px solid #eee;
}

.property-row:last-child {
    border-bottom: none;
}

.property-label {
    width: 140px;
    color: #666;
    font-weight: 500;
    padding-right: 12px;
    flex-shrink: 0;
}

.property-value {
    color: #222;
    flex-grow: 1;
    word-break: break-word;
}

.property-value--badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    background-color: #e0e0e0;
    font-size: 12px;
    font-weight: 600;
    color: #444;
}

.property-value--badge.type-badge {
    background-color: #e3f2fd;
    color: #1565c0;
}

.property-value--status-wrapper {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: #ccc;
    display: inline-block;
}

.status-green { background-color: #4caf50; }
.status-yellow { background-color: #ffc107; }
.status-red { background-color: #f44336; }
.status-gray { background-color: #9e9e9e; }

.property-value--link {
    color: #0366d6;
    text-decoration: none;
}
.property-value--link:hover {
    text-decoration: underline;
}

.property-value--code {
    font-family: Consolas, monospace;
    background-color: #f6f8fa;
    padding: 2px 4px;
    border-radius: 3px;
    font-size: 13px;
}
`;
      module.exports = Property_Viewer;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/progress_bar.js
  var require_progress_bar = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/progress_bar.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var normalize_number_value = (value2) => {
        if (!is_defined(value2)) return void 0;
        const numeric = Number(value2);
        if (Number.isFinite(numeric)) return numeric;
        return void 0;
      };
      var Progress_Bar = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "progress_bar";
          super(spec);
          this.add_class("progress-bar");
          this.dom.tagName = "progress";
          if (is_defined(spec.max)) {
            this.set_max(spec.max);
          }
          if (is_defined(spec.value)) {
            this.set_value(spec.value);
          }
        }
        /**
         * Set the progress value.
         * @param {*} value - The value to set.
         */
        set_value(value2) {
          const numeric = normalize_number_value(value2);
          if (!is_defined(numeric)) {
            this.value = void 0;
            this.dom.attributes.value = "";
            if (this.dom.el) {
              this.dom.el.removeAttribute("value");
            }
            return;
          }
          const max_value = is_defined(this.max) ? this.max : void 0;
          const clamped = is_defined(max_value) ? Math.max(0, Math.min(numeric, max_value)) : Math.max(0, numeric);
          this.value = clamped;
          const value_str = String(clamped);
          this.dom.attributes.value = value_str;
          if (this.dom.el) {
            this.dom.el.value = clamped;
          }
        }
        /**
         * Get the progress value.
         * @returns {*}
         */
        get_value() {
          return this.value;
        }
        /**
         * Set the progress max value.
         * @param {*} max_value - The max value to set.
         */
        set_max(max_value) {
          const numeric = normalize_number_value(max_value);
          if (!is_defined(numeric)) {
            this.max = void 0;
            this.dom.attributes.max = "";
            if (this.dom.el) {
              this.dom.el.removeAttribute("max");
            }
            return;
          }
          this.max = numeric;
          this.dom.attributes.max = String(numeric);
          if (this.dom.el) {
            this.dom.el.max = numeric;
          }
        }
        /**
         * Get the progress max value.
         * @returns {*}
         */
        get_max() {
          return this.max;
        }
      };
      module.exports = Progress_Bar;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/1-advanced/popup-menu-button.js
  var require_popup_menu_button = __commonJS({
    "../jsgui3-html/controls/organised/0-core/1-advanced/popup-menu-button.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Button = require_button();
      var Item = require_item();
      var Collection = jsgui.Collection;
      var Data_Value2 = jsgui.Data_Value;
      var Popup_Menu_Button = class extends Button {
        // panel name?
        // could have a title field.
        //'fields': {
        //    'name': String
        //}
        // maybe add before make would be better. add will probably be used more.
        constructor(spec, add, make) {
          spec.no_compose = true;
          spec["class"] = "popup-menu-button";
          super(spec);
          this.__type_name = "popup_menu_button";
          var context2 = this.context;
          var setup_mixins = function() {
            this.mixin(
              ["open_closed", "closed"],
              ["item_container"]
            );
          };
          this.states = ["closed", "open"];
          this.state = new Data_Value2("closed");
          this.i_state = 0;
          var active_fields = this.active_fields = {};
          active_fields.states = this.states;
          active_fields.state = this.state;
          active_fields.i_state = this.i_state;
          var compose = () => {
            this.text = spec.text || spec.label || "";
            var root_menu_item = new Item({
              "context": context2,
              "item": this.text
            });
            root_menu_item.add_class("popup-menu");
            this.add(root_menu_item);
            root_menu_item.inner.add_class("popup-menu");
            this.root_menu_item = root_menu_item;
            if (spec.items) {
              let items = this.items = new Collection(spec.items);
              each(items, (item2) => {
                var menu_item = new Item({
                  "context": context2,
                  "item": item2
                });
                menu_item.add_class("popup-menu");
                root_menu_item.inner.add(menu_item);
              });
            }
            ;
            var ctrl_fields = {
              "root_menu_item": root_menu_item._id()
            };
            this.dom.attrs["data-jsgui-fields"] = stringify(active_fields).replace(/"/g, "'");
            this.dom.attrs["data-jsgui-ctrl-fields"] = stringify(ctrl_fields).replace(/"/g, "'");
          };
          if (!spec.abstract && !spec.el) {
            compose();
          }
          if (spec.el) {
            compose();
          }
        }
        //'resizable': function() {
        //},
        "activate"() {
          if (!this.__active) {
            super.activate();
            var root_menu_item = this.root_menu_item;
            this.state.on("change", (e_change) => {
              var val = e_change.value;
              if (val === "open") {
                root_menu_item.inner.pop_into_body();
                this.one_mousedown_elsewhere((e_mousedown_elsewhere) => {
                  console.log("e_mousedown_elsewhere", e_mousedown_elsewhere);
                  setTimeout(function() {
                    this.i_state = 0;
                    this.state.set("closed");
                  }, 300);
                });
              }
              ;
              root_menu_item.state.set(val);
            });
            root_menu_item.on("click", (e_click) => {
              var new_i_state = that.i_state + 1;
              if (new_i_state === that.states.length) {
                new_i_state = 0;
              }
              this.i_state = new_i_state;
              this.state.set(that.states[new_i_state]);
            });
            root_menu_item.inner.content.each((inner_menu_item) => {
              inner_menu_item.on("click", (e_click) => {
                root_menu_item.state.set("closed");
                this.i_state = 0;
              });
            });
          }
        }
      };
      module.exports = Popup_Menu_Button;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/pop_over.js
  var require_pop_over = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/pop_over.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Pop_Over = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "pop_over";
          super(spec);
          this.add_class("pop-over");
          this.dom.tagName = "div";
          this.dom.attributes.role = "dialog";
          this.dom.attributes["aria-hidden"] = "true";
          this.dom.attributes.id = this._id();
          this.placement = is_defined(spec.placement) ? String(spec.placement) : "bottom";
          this.target = spec.target;
          if (this.placement) {
            this.add_class(`pop-over-${this.placement}`);
          }
          if (!spec.el) {
            this.set_content(spec.content || spec.message || spec.text || "");
          }
        }
        /**
         * Set pop-over content.
         * @param {*} content - The content to set.
         */
        set_content(content) {
          this.clear();
          if (content instanceof Control2) {
            this.add(content);
          } else if (is_defined(content) && content !== "") {
            this.add(String(content));
          }
        }
        /**
         * Show the pop-over.
         */
        show() {
          this.add_class("is-visible");
          this.dom.attributes["aria-hidden"] = "false";
          if (this.dom.el) {
            this.dom.el.setAttribute("aria-hidden", "false");
          }
          this.update_target_state(true);
        }
        /**
         * Hide the pop-over.
         */
        hide() {
          this.remove_class("is-visible");
          this.dom.attributes["aria-hidden"] = "true";
          if (this.dom.el) {
            this.dom.el.setAttribute("aria-hidden", "true");
          }
          this.update_target_state(false);
        }
        /**
         * Toggle pop-over visibility.
         */
        toggle() {
          if (this.has_class("is-visible")) {
            this.hide();
          } else {
            this.show();
          }
        }
        update_target_state(is_open) {
          if (!this.target) return;
          const target_el = this.get_target_el();
          if (target_el) {
            target_el.setAttribute("aria-expanded", is_open ? "true" : "false");
            target_el.setAttribute("aria-controls", this._id());
          }
        }
        get_target_el() {
          if (!this.target) return void 0;
          if (typeof document === "undefined") return void 0;
          if (typeof this.target === "string") {
            return document.querySelector(this.target);
          }
          if (this.target.dom && this.target.dom.el) {
            return this.target.dom.el;
          }
          if (this.context && typeof this.context.get_ctrl_el === "function") {
            return this.context.get_ctrl_el(this.target);
          }
          return void 0;
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (typeof document === "undefined") return;
            const target_el = this.get_target_el();
            if (!target_el) return;
            target_el.addEventListener("click", (e_click) => {
              e_click.preventDefault();
              this.toggle();
            });
            document.addEventListener("click", (e_click) => {
              if (!this.dom.el) return;
              if (!this.has_class("is-visible")) return;
              const target = e_click.target;
              if (target === target_el || target_el.contains(target)) return;
              if (this.dom.el.contains(target)) return;
              this.hide();
            });
          }
        }
      };
      Pop_Over.css = `
.pop-over {
    position: absolute;
    min-width: 160px;
    padding: 8px 10px;
    border-radius: 6px;
    background: #fff;
    border: 1px solid #ddd;
    box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
}
.pop-over.is-visible {
    opacity: 1;
    pointer-events: auto;
}
`;
      module.exports = Pop_Over;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/reorderable_list.js
  var require_reorderable_list = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/reorderable_list.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var normalize_items = (items) => Array.isArray(items) ? items.slice() : [];
      var Reorderable_List = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "reorderable_list";
          super(spec);
          this.add_class("reorderable-list");
          this.dom.tagName = "ul";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.item_renderer = spec.item_renderer;
          this.set_items(spec.items || []);
          if (!spec.el) {
            this.render_items();
          }
          this.bind_model();
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            if (e_change.name === "items") {
              this.items = Array.isArray(e_change.value) ? e_change.value : [];
              this.render_items();
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set the list items.
         * @param {Array} items - Items to set.
         */
        set_items(items) {
          const list_items = normalize_items(items);
          this.set_model_value("items", list_items);
          this.items = list_items;
        }
        /**
         * Get the list items.
         * @returns {Array}
         */
        get_items() {
          return this.items || [];
        }
        /**
         * Move an item from one index to another.
         * @param {number} from_index - Starting index.
         * @param {number} to_index - Destination index.
         */
        move_item(from_index, to_index) {
          const items = this.get_items();
          if (!items.length) return;
          if (from_index === to_index) return;
          if (from_index < 0 || from_index >= items.length) return;
          const next_items = items.slice();
          const [moved_item] = next_items.splice(from_index, 1);
          const insert_index = Math.max(0, Math.min(to_index, next_items.length));
          next_items.splice(insert_index, 0, moved_item);
          this.set_items(next_items);
          this.raise("reorder", {
            from_index,
            to_index: insert_index,
            items: next_items
          });
          this.focus_item(insert_index);
        }
        focus_item(index) {
          if (!this.dom.el) return;
          const item_el = this.dom.el.querySelector(`[data-index="${index}"]`);
          if (item_el && typeof item_el.focus === "function") {
            item_el.focus();
          }
        }
        render_items() {
          this.clear();
          const items = this.get_items();
          items.forEach((item2, index) => {
            const item_ctrl = new Control2({ context: this.context, tag_name: "li" });
            item_ctrl.add_class("reorderable-list-item");
            item_ctrl.dom.attributes["data-index"] = String(index);
            item_ctrl.dom.attributes.draggable = "true";
            item_ctrl.dom.attributes.tabindex = "0";
            if (typeof this.item_renderer === "function") {
              const rendered = this.item_renderer(item2, index);
              if (rendered instanceof Control2) {
                item_ctrl.add(rendered);
              } else if (is_defined(rendered)) {
                item_ctrl.add(String(rendered));
              }
            } else if (is_defined(item2)) {
              item_ctrl.add(String(item2));
            }
            this.add(item_ctrl);
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            const find_item_el = (target) => {
              let node = target;
              while (node && node.getAttribute) {
                if (node.getAttribute("data-index") !== null) return node;
                node = node.parentNode;
              }
              return null;
            };
            let drag_index = null;
            this.add_dom_event_listener("dragstart", (e_drag) => {
              const item_el = find_item_el(e_drag.target);
              if (!item_el) return;
              drag_index = parseInt(item_el.getAttribute("data-index"), 10);
              item_el.classList.add("is-dragging");
              if (e_drag.dataTransfer) {
                e_drag.dataTransfer.effectAllowed = "move";
                e_drag.dataTransfer.setData("text/plain", String(drag_index));
              }
            });
            this.add_dom_event_listener("dragover", (e_drag) => {
              const item_el = find_item_el(e_drag.target);
              if (!item_el) return;
              e_drag.preventDefault();
              item_el.classList.add("is-drag-over");
            });
            this.add_dom_event_listener("dragleave", (e_drag) => {
              const item_el = find_item_el(e_drag.target);
              if (!item_el) return;
              item_el.classList.remove("is-drag-over");
            });
            this.add_dom_event_listener("drop", (e_drop) => {
              e_drop.preventDefault();
              const item_el = find_item_el(e_drop.target);
              if (!item_el) return;
              const drop_index = parseInt(item_el.getAttribute("data-index"), 10);
              const from_index = drag_index;
              drag_index = null;
              if (Number.isNaN(from_index) || Number.isNaN(drop_index)) return;
              item_el.classList.remove("is-drag-over");
              this.move_item(from_index, drop_index);
            });
            this.add_dom_event_listener("dragend", () => {
              drag_index = null;
              if (!this.dom.el) return;
              const dragging_el = this.dom.el.querySelector(".reorderable-list-item.is-dragging");
              if (dragging_el) dragging_el.classList.remove("is-dragging");
              const over_els = this.dom.el.querySelectorAll(".reorderable-list-item.is-drag-over");
              over_els.forEach((el) => el.classList.remove("is-drag-over"));
            });
            this.add_dom_event_listener("keydown", (e_key) => {
              const item_el = find_item_el(e_key.target);
              if (!item_el) return;
              const key2 = e_key.key || e_key.keyCode;
              const move_up = (key2 === "ArrowUp" || key2 === 38) && (e_key.ctrlKey || e_key.altKey);
              const move_down = (key2 === "ArrowDown" || key2 === 40) && (e_key.ctrlKey || e_key.altKey);
              if (!move_up && !move_down) return;
              e_key.preventDefault();
              const index = parseInt(item_el.getAttribute("data-index"), 10);
              if (Number.isNaN(index)) return;
              const next_index = move_up ? index - 1 : index + 1;
              this.move_item(index, next_index);
            });
          }
        }
      };
      Reorderable_List.css = `
.reorderable-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.reorderable-list-item {
    padding: 8px 10px;
    border: 1px solid #ddd;
    border-radius: 6px;
    background: #fff;
    cursor: grab;
}
.reorderable-list-item.is-dragging {
    opacity: 0.5;
}
.reorderable-list-item.is-drag-over {
    border-color: #999;
    background: #f5f5f5;
}
`;
      module.exports = Reorderable_List;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/0-viewer/Resource_Viewer.js
  var require_Resource_Viewer = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/0-viewer/Resource_Viewer.js"(exports, module) {
      var jsgui = require_html_core();
      var { each, tof } = jsgui;
      var Control2 = jsgui.Control;
      var { field, prop } = require_oext();
      var Property_Viewer = require_Property_Viewer();
      var Resource_Viewer = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "resource_viewer";
          super(spec);
          this.add_class("resource-viewer");
          field(this.view.data.model, "resource");
          field(this.view.data.model, "expanded");
          if (spec.resource) {
            this.view.data.model.resource = spec.resource;
          }
          if (spec.expandable !== void 0) {
            this.expandable = spec.expandable;
          } else {
            this.expandable = true;
          }
          if (spec.onAction) {
            this.on("action", spec.onAction);
          }
          this.view.data.model.expanded = false;
          this.view.data.model.on("change", (e) => {
            if (e.name === "resource") {
              this.refresh_view();
            }
            if (e.name === "expanded") {
              this.toggle_details_view(e.value);
            }
          });
          if (!spec.abstract && !spec.el) {
            this.compose_viewer();
          }
        }
        compose_viewer() {
          this.refresh_view();
        }
        refresh_view() {
          this.content.clear();
          const { context: context2 } = this;
          const resource = this.view.data.model.resource || {};
          const header = new Control2({ context: context2 });
          header.add_class("resource-header");
          if (this.expandable) {
            header.add_class("expandable");
            header.on("click", () => {
              this.view.data.model.expanded = !this.view.data.model.expanded;
            });
          }
          if (resource.icon) {
            const icon = new Control2({ context: context2 });
            icon.add_class("resource-icon");
            icon.add(resource.icon);
            header.add(icon);
          }
          const name = new Control2({ context: context2 });
          name.add_class("resource-name");
          name.add(resource.name || "Resource");
          header.add(name);
          if (resource.type) {
            const badge = new Control2({ context: context2 });
            badge.add_class("resource-badge");
            badge.add(resource.type);
            header.add(badge);
          }
          if (resource.status) {
            const status = new Control2({ context: context2 });
            status.add_class("resource-status");
            const status_color = this.get_status_color(resource.status);
            status.add_class(`status-${status_color}`);
            header.add(status);
          }
          this.add(header);
          if (resource.description) {
            const desc = new Control2({ context: context2 });
            desc.add_class("resource-description");
            desc.add(resource.description);
            this.add(desc);
          }
          if (this.expandable && resource.properties) {
            const details = new Control2({ context: context2 });
            details.add_class("resource-details");
            const props_viewer = new Property_Viewer({
              context: context2,
              data: resource.properties,
              schema: resource.properties.schema
              // If schema is embedded or passed separately
            });
            details.add(props_viewer);
            this.ctrl_details = details;
            this.add(details);
            if (!this.view.data.model.expanded) {
              details.add_class("hidden");
            }
          }
          if (resource.actions && Array.isArray(resource.actions)) {
            const actions_bar = new Control2({ context: context2 });
            actions_bar.add_class("resource-actions");
            each(resource.actions, (action) => {
              const btn = new Control2({ context: context2, tag_name: "button" });
              btn.add_class("resource-action-btn");
              btn.add(action.label || action.name);
              btn.on("click", (e) => {
                e.stopPropagation();
                this.raise("action", { action: action.name, resource });
              });
              actions_bar.add(btn);
            });
            this.add(actions_bar);
          }
        }
        toggle_details_view(expanded) {
          if (this.ctrl_details) {
            if (expanded) {
              this.ctrl_details.remove_class("hidden");
              this.add_class("expanded");
            } else {
              this.ctrl_details.add_class("hidden");
              this.remove_class("expanded");
            }
          }
        }
        get_status_color(status) {
          const map = {
            active: "green",
            online: "green",
            running: "green",
            paused: "yellow",
            warning: "yellow",
            stopped: "red",
            error: "red",
            offline: "gray"
          };
          return map[status] || "gray";
        }
      };
      Resource_Viewer.css = `
.resource-viewer {
    display: flex;
    flex-direction: column;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    overflow: hidden;
    margin-bottom: 8px;
    font-family: 'Segoe UI', sans-serif;
}

.resource-header {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    background-color: #f9fafb;
    border-bottom: 1px solid transparent;
    transition: background-color 0.2s;
}

.resource-header.expandable {
    cursor: pointer;
}
.resource-header.expandable:hover {
    background-color: #f3f4f6;
}

.resource-viewer.expanded .resource-header {
    border-bottom-color: #e5e7eb;
}

.resource-icon {
    font-size: 20px;
    margin-right: 12px;
}

.resource-name {
    font-size: 16px;
    font-weight: 600;
    color: #111827;
    margin-right: 12px;
}

.resource-badge {
    background-color: #e5e7eb;
    color: #374151;
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: auto; /* Push status to right */
    letter-spacing: 0.5px;
}

.resource-status {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-left: 12px;
}
.status-green { background-color: #10b981; }
.status-yellow { background-color: #f59e0b; }
.status-red { background-color: #ef4444; }
.status-gray { background-color: #9ca3af; }

.resource-description {
    padding: 0 16px 12px 48px; /* Indent under name */
    background-color: #f9fafb;
    color: #6b7280;
    font-size: 13px;
    margin-top: -8px; /* Pull up closer to header */
}

.resource-details {
    padding: 16px;
    background-color: #fff;
}

.resource-details.hidden {
    display: none;
}

.resource-actions {
    padding: 12px 16px;
    background-color: #f9fafb;
    border-top: 1px solid #e5e7eb;
    display: flex;
    gap: 8px;
}

.resource-action-btn {
    padding: 6px 12px;
    background-color: #fff;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    font-size: 13px;
    font-weight: 500;
    color: #374151;
    cursor: pointer;
    transition: all 0.1s;
}

.resource-action-btn:hover {
    background-color: #f3f4f6;
    border-color: #9ca3af;
}

`;
      module.exports = Resource_Viewer;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/rich_text_toolbar.js
  var require_rich_text_toolbar = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/rich_text_toolbar.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var DEFAULT_BUTTONS = [
        { command: "bold", label: "<strong>B</strong>", title: "Bold (Ctrl+B)" },
        { command: "italic", label: "<em>I</em>", title: "Italic (Ctrl+I)" },
        { command: "underline", label: "<u>U</u>", title: "Underline (Ctrl+U)" },
        { command: "strikeThrough", label: "<s>S</s>", title: "Strikethrough" },
        { type: "separator" },
        { command: "formatBlock", value: "<h2>", label: "H2", title: "Heading 2" },
        { command: "formatBlock", value: "<blockquote>", label: "\u275D", title: "Block quote" },
        { type: "separator" },
        { command: "insertUnorderedList", label: "\u2022 List", title: "Bullet List" },
        { command: "insertOrderedList", label: "1. List", title: "Numbered List" },
        { type: "separator" },
        { command: "createLink", label: "\u{1F517}", title: "Insert Link" },
        { command: "unlink", label: "\u{1F517}\u2717", title: "Remove Link" },
        { type: "separator" },
        { command: "removeFormat", label: "\u2717", title: "Clear Formatting" }
      ];
      var Rich_Text_Toolbar = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "rich_text_toolbar";
          super(spec);
          this.add_class("rte-toolbar");
          this.dom.tagName = "div";
          this.buttons = Array.isArray(spec.buttons) ? spec.buttons : DEFAULT_BUTTONS;
          if (!spec.el) {
            this.compose_toolbar();
          }
        }
        compose_toolbar() {
          const { context: context2 } = this;
          this.button_controls = [];
          this.buttons.forEach((button_def) => {
            if (button_def.type === "separator") {
              const sep = new Control2({ context: context2, tag_name: "span" });
              sep.add_class("rte-toolbar-separator");
              this.add(sep);
              return;
            }
            const button = new Control2({ context: context2, tag_name: "button" });
            button.add_class("rte-toolbar-button");
            button.dom.attributes.type = "button";
            button.dom.attributes.title = button_def.title || "";
            button.dom.attributes["data-command"] = button_def.command;
            if (button_def.value) {
              button.dom.attributes["data-value"] = button_def.value;
            }
            if (button_def.label) {
              button.dom.innerHTML = button_def.label;
            }
            if (typeof button_def.handler === "function") {
              button.custom_handler = button_def.handler;
            }
            this.button_controls.push(button);
            this.add(button);
          });
        }
      };
      Rich_Text_Toolbar.DEFAULT_BUTTONS = DEFAULT_BUTTONS;
      module.exports = Rich_Text_Toolbar;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/Rich_Text_Editor.js
  var require_Rich_Text_Editor = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/Rich_Text_Editor.js"(exports, module) {
      var Control2 = require_control();
      var Rich_Text_Toolbar = require_rich_text_toolbar();
      var Textarea = require_textarea();
      var is_defined = (value2) => value2 !== void 0 && value2 !== null;
      var escape_html = (value2) => String(value2 || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      var decode_html = (value2) => String(value2 || "").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&amp;/g, "&");
      var normalize_markdown_url = (value2) => {
        const cleaned = String(value2 || "").trim();
        if (!cleaned || /^\s*javascript:/i.test(cleaned)) return "";
        return cleaned.replace(/"/g, "%22");
      };
      var apply_inline_markdown = (value2) => {
        let text = value2;
        text = text.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
        text = text.replace(/`(.+?)`/g, "<code>$1</code>");
        text = text.replace(/\*(.+?)\*/g, "<em>$1</em>");
        text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, label, url) => {
          const safe_url = normalize_markdown_url(url);
          if (!safe_url) return label;
          return `<a href="${safe_url}" target="_blank" rel="noopener noreferrer">${label}</a>`;
        });
        return text;
      };
      var Rich_Text_Editor = class extends Control2 {
        constructor(options = {}) {
          options.__type_name = options.__type_name || "rich_text_editor";
          super(options);
          const { context: context2 } = this;
          this.add_class("rich-text-editor");
          this.config = {
            placeholder: options.placeholder || "Start typing...",
            initial_html: options.initial_html || "",
            initial_markdown: options.initial_markdown || "",
            min_height: options.min_height || "200px",
            max_height: options.max_height || "500px",
            toolbar_position: options.toolbar_position || "top",
            on_change: options.on_change || null,
            read_only: options.read_only || false,
            toolbar_buttons: options.toolbar_buttons || null,
            allow_markdown: !!options.allow_markdown,
            markdown_mode: !!options.markdown_mode,
            markdown_placeholder: options.markdown_placeholder || "Write markdown..."
          };
          if (this.config.allow_markdown && this.config.initial_markdown && !this.config.initial_html) {
            this.config.initial_html = this._markdown_to_html(this.config.initial_markdown);
          }
          this.allow_markdown = this.config.allow_markdown;
          this.markdown_mode = this.allow_markdown && this.config.markdown_mode;
          this.markdown_text = this.config.initial_markdown || "";
          this._create_toolbar(context2);
          this._create_editor(context2);
          this.is_dirty = false;
          this.last_html = this.config.initial_html || "";
          if (this.config.read_only) {
            this.set_read_only(true);
          }
        }
        _create_toolbar(context2) {
          const base_buttons = Array.isArray(this.config.toolbar_buttons) ? this.config.toolbar_buttons.slice() : Rich_Text_Toolbar.DEFAULT_BUTTONS.slice();
          if (this.allow_markdown) {
            base_buttons.push({ type: "separator" });
            base_buttons.push({
              command: "toggle_markdown",
              label: "MD",
              title: "Toggle Markdown"
            });
          }
          this.toolbar = new Rich_Text_Toolbar({
            context: context2,
            buttons: base_buttons
          });
          this.add(this.toolbar);
        }
        _create_editor(context2) {
          this.editor_container = new Control2({ context: context2, tag_name: "div" });
          this.editor_container.add_class("rte-editor-container");
          this.editor = new Control2({ context: context2, tag_name: "div" });
          this.editor.add_class("rte-editor");
          this.editor.dom.attributes.contenteditable = this.config.read_only ? "false" : "true";
          this.editor.dom.attributes["data-placeholder"] = this.config.placeholder;
          if (this.config.initial_html) {
            this.editor.dom.innerHTML = this.config.initial_html;
          }
          this.markdown_editor = new Textarea({
            context: context2,
            value: this.markdown_text,
            placeholder: this.config.markdown_placeholder,
            autosize: false
          });
          this.markdown_editor.add_class("rte-markdown");
          this._apply_height_constraints(this.editor);
          this._apply_height_constraints(this.markdown_editor);
          this.editor_container.add(this.editor);
          this.editor_container.add(this.markdown_editor);
          this.add(this.editor_container);
          this._apply_mode_visibility();
        }
        _apply_height_constraints(control) {
          if (!control || !control.dom || !control.dom.attributes) return;
          const styles = [];
          if (this.config.min_height) {
            styles.push(`min-height:${this.config.min_height}`);
          }
          if (this.config.max_height) {
            styles.push(`max-height:${this.config.max_height}`);
          }
          if (styles.length) {
            const style_value = styles.join(";");
            control.dom.attributes.style = control.dom.attributes.style ? `${control.dom.attributes.style};${style_value}` : style_value;
          }
          if (control.dom.el) {
            control.dom.el.style.minHeight = this.config.min_height;
            control.dom.el.style.maxHeight = this.config.max_height;
          }
        }
        _apply_mode_visibility() {
          if (!this.editor || !this.markdown_editor) return;
          if (this.markdown_mode) {
            this.editor.add_class("is-hidden");
            this.markdown_editor.remove_class("is-hidden");
            this.add_class("markdown-mode");
          } else {
            this.editor.remove_class("is-hidden");
            this.markdown_editor.add_class("is-hidden");
            this.remove_class("markdown-mode");
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (this.toolbar && this.toolbar.dom.el) {
              const toolbar_buttons = this.toolbar.dom.el.querySelectorAll(".rte-toolbar-button");
              toolbar_buttons.forEach((btn) => {
                btn.addEventListener("click", (event) => {
                  event.preventDefault();
                  const command = btn.getAttribute("data-command");
                  const value2 = btn.getAttribute("data-value");
                  const button_control = this._get_toolbar_button_control(btn);
                  this._handle_toolbar_action(command, value2, button_control);
                  if (this.editor.dom.el && !this.markdown_mode) {
                    this.editor.dom.el.focus();
                  }
                });
              });
            }
            if (this.editor.dom.el) {
              this.editor.dom.el.addEventListener("input", () => {
                if (this.markdown_mode) return;
                this.is_dirty = true;
                this._handle_change();
              });
              this.editor.dom.el.addEventListener("paste", (event) => {
                if (this.markdown_mode) return;
                event.preventDefault();
                const clipboard = event.clipboardData || window.clipboardData;
                const html = clipboard && clipboard.getData("text/html");
                const text = clipboard && clipboard.getData("text/plain");
                if (html) {
                  const sanitized = this._sanitize_html(html);
                  if (typeof document.execCommand === "function") {
                    document.execCommand("insertHTML", false, sanitized);
                  }
                } else if (text) {
                  if (typeof document.execCommand === "function") {
                    document.execCommand("insertText", false, text);
                  }
                }
              });
              this.editor.dom.el.addEventListener("keydown", (event) => {
                if (this.markdown_mode) return;
                if (event.ctrlKey || event.metaKey) {
                  switch (event.key.toLowerCase()) {
                    case "b":
                      event.preventDefault();
                      this._execute_command("bold");
                      break;
                    case "i":
                      event.preventDefault();
                      this._execute_command("italic");
                      break;
                    case "u":
                      event.preventDefault();
                      this._execute_command("underline");
                      break;
                  }
                }
              });
            }
            if (this.markdown_editor && this.markdown_editor.dom.el) {
              const handle_markdown_input = () => {
                this.markdown_text = this.markdown_editor.dom.el.value;
                this.is_dirty = true;
                this._handle_change();
              };
              this.markdown_editor.dom.el.addEventListener("input", handle_markdown_input);
              this.markdown_editor.dom.el.addEventListener("change", handle_markdown_input);
            }
            if (typeof document !== "undefined") {
              document.addEventListener("selectionchange", () => {
                if (this.markdown_mode) return;
                if (this.editor.dom.el && this.editor.dom.el.contains(document.activeElement)) {
                  this._update_toolbar_states();
                }
              });
            }
            this._update_toolbar_states();
          }
        }
        _get_toolbar_button_control(button_el) {
          if (!this.toolbar || !Array.isArray(this.toolbar.button_controls)) return null;
          return this.toolbar.button_controls.find(
            (button_control) => button_control.dom && button_control.dom.el === button_el
          );
        }
        _handle_toolbar_action(command, value2, button_control) {
          if (!command) return;
          if (button_control && button_control.custom_handler) {
            button_control.custom_handler(command, value2);
            return;
          }
          if (command === "toggle_markdown") {
            this.toggle_markdown_mode();
            return;
          }
          if (this.markdown_mode) return;
          if (command === "createLink") {
            this._handle_create_link();
            return;
          }
          this._execute_command(command, value2);
        }
        _execute_command(command, value2 = null) {
          if (typeof document === "undefined" || typeof document.execCommand !== "function") {
            return;
          }
          document.execCommand(command, false, value2);
          this._handle_change();
        }
        _handle_create_link() {
          if (typeof window === "undefined") return;
          const selection = window.getSelection();
          if (!selection || selection.rangeCount === 0 || selection.isCollapsed) {
            return;
          }
          const url = prompt("Enter URL:", "https://");
          if (url && url.trim() !== "" && url !== "https://") {
            if (!url.startsWith("http://") && !url.startsWith("https://") && !url.startsWith("mailto:")) {
              return;
            }
            this._execute_command("createLink", url);
          }
        }
        _update_toolbar_states() {
          if (!this.toolbar || !this.toolbar.dom.el) return;
          const toolbar_buttons = this.toolbar.dom.el.querySelectorAll(".rte-toolbar-button");
          toolbar_buttons.forEach((btn) => {
            const command = btn.getAttribute("data-command");
            const value2 = btn.getAttribute("data-value");
            if (command === "toggle_markdown") {
              btn.classList.toggle("active", this.markdown_mode);
              return;
            }
            if (this.markdown_mode) {
              btn.classList.remove("active");
              return;
            }
            if (command === "formatBlock" && value2 && typeof document.queryCommandValue === "function") {
              try {
                const current = document.queryCommandValue("formatBlock") || "";
                const normalized = current.toLowerCase();
                const target = value2.toLowerCase();
                btn.classList.toggle("active", normalized.includes(target.replace(/[<>]/g, "")));
              } catch (e) {
                btn.classList.remove("active");
              }
              return;
            }
            if (typeof document.queryCommandState !== "function") {
              btn.classList.remove("active");
              return;
            }
            try {
              const is_active = document.queryCommandState(command);
              btn.classList.toggle("active", !!is_active);
            } catch (e) {
              btn.classList.remove("active");
            }
          });
        }
        _handle_change() {
          const current_html = this.get_html();
          if (current_html !== this.last_html) {
            this.last_html = current_html;
            if (this.config.on_change) {
              this.config.on_change(current_html);
            }
          }
        }
        /**
         * Get HTML content from editor.
         * @returns {string}
         */
        get_html() {
          if (this.markdown_mode) {
            return this._markdown_to_html(this.get_markdown());
          }
          if (this.editor.dom.el) {
            return this._sanitize_html(this.editor.dom.el.innerHTML || "");
          }
          if (this.editor.dom.innerHTML) {
            return this._sanitize_html(this.editor.dom.innerHTML);
          }
          return this._sanitize_html(this.config.initial_html || "");
        }
        /**
         * Set HTML content in editor.
         * @param {string} html - HTML to set.
         * @param {Object} [options] - Options for syncing.
         */
        set_html(html, options = {}) {
          const sanitized = this._sanitize_html(html || "");
          if (this.editor.dom) {
            this.editor.dom.innerHTML = sanitized;
          }
          if (this.editor.dom.el) {
            this.editor.dom.el.innerHTML = sanitized;
          }
          if (this.allow_markdown && options.sync_markdown) {
            this.markdown_text = this._html_to_markdown(sanitized);
            if (this.markdown_editor && this.markdown_editor.dom.el) {
              this.markdown_editor.dom.el.value = this.markdown_text;
            }
          }
          this.last_html = sanitized;
          this.is_dirty = false;
        }
        /**
         * Get markdown content.
         * @returns {string}
         */
        get_markdown() {
          if (this.markdown_editor && this.markdown_editor.dom.el) {
            this.markdown_text = this.markdown_editor.dom.el.value;
          }
          return this.markdown_text || "";
        }
        /**
         * Set markdown content.
         * @param {string} markdown - Markdown to set.
         * @param {Object} [options] - Options for syncing.
         */
        set_markdown(markdown, options = {}) {
          this.markdown_text = is_defined(markdown) ? String(markdown) : "";
          if (this.markdown_editor && this.markdown_editor.dom.el) {
            this.markdown_editor.dom.el.value = this.markdown_text;
          } else if (this.markdown_editor && typeof this.markdown_editor.set_value === "function") {
            this.markdown_editor.set_value(this.markdown_text);
          }
          if (options.sync_html !== false) {
            this.set_html(this._markdown_to_html(this.markdown_text), { sync_markdown: false });
          }
        }
        /**
         * Toggle markdown mode.
         * @param {boolean} [force] - Force mode on/off.
         */
        toggle_markdown_mode(force) {
          if (!this.allow_markdown) return;
          const next_mode = typeof force === "boolean" ? force : !this.markdown_mode;
          if (next_mode === this.markdown_mode) return;
          if (next_mode) {
            const html = this.get_html();
            this.set_markdown(this._html_to_markdown(html), { sync_html: false });
          } else {
            const markdown = this.get_markdown();
            this.set_html(this._markdown_to_html(markdown), { sync_markdown: false });
          }
          this.markdown_mode = next_mode;
          this._apply_mode_visibility();
          this._update_toolbar_states();
        }
        /**
         * Get plain text content.
         * @returns {string}
         */
        get_text() {
          if (this.markdown_mode) {
            return this.get_markdown();
          }
          if (!this.editor.dom.el) return "";
          return this.editor.dom.el.textContent || "";
        }
        _sanitize_html(html) {
          if (!html) return "";
          let sanitized = String(html);
          sanitized = sanitized.replace(
            /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            ""
          );
          sanitized = sanitized.replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, "");
          sanitized = sanitized.replace(/\s*on\w+\s*=\s*[^\s>]*/gi, "");
          sanitized = sanitized.replace(/href\s*=\s*["']javascript:[^"']*["']/gi, "");
          const dangerous_tags = ["script", "iframe", "object", "embed", "form", "input", "button"];
          dangerous_tags.forEach((tag) => {
            const regex = new RegExp(
              `<${tag}\\b[^<]*(?:(?!<\\/${tag}>)<[^<]*)*<\\/${tag}>`,
              "gi"
            );
            sanitized = sanitized.replace(regex, "");
          });
          return sanitized;
        }
        _markdown_to_html(markdown) {
          if (!markdown) return "";
          const lines = String(markdown).split(/\r?\n/);
          const html_lines = [];
          let in_list = false;
          lines.forEach((line) => {
            const trimmed = line.trim();
            if (!trimmed) {
              if (in_list) {
                html_lines.push("</ul>");
                in_list = false;
              }
              html_lines.push("");
              return;
            }
            if (/^#{1,6}\s+/.test(trimmed)) {
              if (in_list) {
                html_lines.push("</ul>");
                in_list = false;
              }
              const level = trimmed.match(/^#{1,6}/)[0].length;
              const text = trimmed.replace(/^#{1,6}\s+/, "");
              html_lines.push(
                `<h${level}>${apply_inline_markdown(escape_html(text))}</h${level}>`
              );
              return;
            }
            if (/^>\s+/.test(trimmed)) {
              if (in_list) {
                html_lines.push("</ul>");
                in_list = false;
              }
              const text = trimmed.replace(/^>\s+/, "");
              html_lines.push(
                `<blockquote>${apply_inline_markdown(escape_html(text))}</blockquote>`
              );
              return;
            }
            if (/^[-*]\s+/.test(trimmed)) {
              const text = trimmed.replace(/^[-*]\s+/, "");
              if (!in_list) {
                html_lines.push("<ul>");
                in_list = true;
              }
              html_lines.push(`<li>${apply_inline_markdown(escape_html(text))}</li>`);
              return;
            }
            if (in_list) {
              html_lines.push("</ul>");
              in_list = false;
            }
            html_lines.push(`<p>${apply_inline_markdown(escape_html(trimmed))}</p>`);
          });
          if (in_list) {
            html_lines.push("</ul>");
          }
          return this._sanitize_html(html_lines.join("\n"));
        }
        _html_to_markdown(html) {
          if (!html) return "";
          let markdown = String(html);
          markdown = markdown.replace(/<br\s*\/?>/gi, "\n");
          markdown = markdown.replace(/<\/p>\s*<p>/gi, "\n\n");
          markdown = markdown.replace(/<h1[^>]*>(.*?)<\/h1>/gi, "# $1\n");
          markdown = markdown.replace(/<h2[^>]*>(.*?)<\/h2>/gi, "## $1\n");
          markdown = markdown.replace(/<h3[^>]*>(.*?)<\/h3>/gi, "### $1\n");
          markdown = markdown.replace(/<h4[^>]*>(.*?)<\/h4>/gi, "#### $1\n");
          markdown = markdown.replace(/<h5[^>]*>(.*?)<\/h5>/gi, "##### $1\n");
          markdown = markdown.replace(/<h6[^>]*>(.*?)<\/h6>/gi, "###### $1\n");
          markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gi, "> $1\n");
          markdown = markdown.replace(/<li[^>]*>(.*?)<\/li>/gi, "- $1\n");
          markdown = markdown.replace(/<\/?ul[^>]*>/gi, "");
          markdown = markdown.replace(/<\/?ol[^>]*>/gi, "");
          markdown = markdown.replace(/<strong[^>]*>(.*?)<\/strong>/gi, "**$1**");
          markdown = markdown.replace(/<b[^>]*>(.*?)<\/b>/gi, "**$1**");
          markdown = markdown.replace(/<em[^>]*>(.*?)<\/em>/gi, "*$1*");
          markdown = markdown.replace(/<i[^>]*>(.*?)<\/i>/gi, "*$1*");
          markdown = markdown.replace(/<code[^>]*>(.*?)<\/code>/gi, "`$1`");
          markdown = markdown.replace(
            /<a[^>]*href=["']([^"']+)["'][^>]*>(.*?)<\/a>/gi,
            "[$2]($1)"
          );
          markdown = markdown.replace(/<[^>]+>/g, "");
          markdown = decode_html(markdown);
          markdown = markdown.replace(/\n{3,}/g, "\n\n");
          return markdown.trim();
        }
        /**
         * Clear all content.
         */
        clear() {
          this.set_html("", { sync_markdown: false });
          if (this.allow_markdown) {
            this.set_markdown("", { sync_html: false });
          }
        }
        /**
         * Check if editor has content.
         * @returns {boolean}
         */
        is_empty() {
          const text = this.get_text().trim();
          return text.length === 0;
        }
        /**
         * Set read-only mode.
         * @param {boolean} read_only - Whether to set read-only mode.
         */
        set_read_only(read_only) {
          this.config.read_only = !!read_only;
          if (this.editor.dom.el) {
            this.editor.dom.el.contentEditable = read_only ? "false" : "true";
          }
          if (this.markdown_editor && this.markdown_editor.dom.el) {
            this.markdown_editor.dom.el.readOnly = !!read_only;
          }
          if (read_only) {
            this.add_class("read-only");
            this.toolbar.add_class("disabled");
          } else {
            this.remove_class("read-only");
            this.toolbar.remove_class("disabled");
          }
        }
        /**
         * Focus the active editor.
         */
        focus() {
          if (this.markdown_mode && this.markdown_editor && this.markdown_editor.dom.el) {
            this.markdown_editor.dom.el.focus();
          } else if (this.editor.dom.el) {
            this.editor.dom.el.focus();
          }
        }
        /**
         * Get character count.
         * @returns {number}
         */
        get_character_count() {
          return this.get_text().length;
        }
        /**
         * Get word count.
         * @returns {number}
         */
        get_word_count() {
          const text = this.get_text().trim();
          if (!text) return 0;
          return text.split(/\s+/).length;
        }
      };
      module.exports = Rich_Text_Editor;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/scrollbar.js
  var require_scrollbar = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/scrollbar.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var clamp_ratio = (value2) => {
        if (value2 < 0) return 0;
        if (value2 > 1) return 1;
        return value2;
      };
      var Scrollbar = class extends Control2 {
        constructor(spec = {}) {
          super(spec);
          this.__type_name = "scrollbar";
          this.add_class("scrollbar");
          this.direction = spec.direction || this.__direction || "vertical";
          this.min = 0;
          this.max = 1e3;
          this.step = spec.step || 1;
          this.value = 0;
          this.ratio = 0;
          this.page_ratio = 0;
          if (!spec.el) {
            this.compose_scrollbar();
          }
        }
        compose_scrollbar() {
          const input_ctrl = new Control2({
            context: this.context
          });
          input_ctrl.dom.tagName = "input";
          input_ctrl.dom.attributes.type = "range";
          input_ctrl.dom.attributes.min = this.min;
          input_ctrl.dom.attributes.max = this.max;
          input_ctrl.dom.attributes.value = this.value;
          input_ctrl.dom.attributes.step = this.step;
          input_ctrl.add_class("scrollbar-input");
          input_ctrl.dom.attributes.role = "scrollbar";
          input_ctrl.dom.attributes["aria-orientation"] = this.direction;
          this.add(input_ctrl);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.input = input_ctrl;
        }
        /**
         * Set the scrollbar ratio (0-1).
         * @param {number} ratio - Ratio to set.
         */
        set_ratio(ratio) {
          const next_ratio = clamp_ratio(Number(ratio) || 0);
          this.ratio = next_ratio;
          const next_value = this.min + (this.max - this.min) * next_ratio;
          this.set_value(next_value, { from_ratio: true });
        }
        /**
         * Set the scrollbar value.
         * @param {number} value - Value to set.
         * @param {Object} [options] - Optional settings.
         */
        set_value(value2, options = {}) {
          const next_value = Number.isNaN(Number(value2)) ? 0 : Number(value2);
          const clamped = Math.min(this.max, Math.max(this.min, next_value));
          this.value = clamped;
          this.ratio = this.max === this.min ? 0 : (clamped - this.min) / (this.max - this.min);
          const input_ctrl = this._ctrl_fields && this._ctrl_fields.input;
          if (input_ctrl) {
            input_ctrl.dom.attributes.value = clamped;
            input_ctrl.dom.attributes["aria-valuenow"] = String(clamped);
            if (input_ctrl.dom.el) {
              input_ctrl.dom.el.value = clamped;
            }
          }
          if (!options.from_ratio) {
            this.raise("scroll", {
              value: this.value,
              ratio: this.ratio
            });
          }
        }
        /**
         * Set page ratio for the scrollbar.
         * @param {number} page_ratio - Ratio of viewport to content.
         */
        set_page_ratio(page_ratio) {
          this.page_ratio = clamp_ratio(Number(page_ratio) || 0);
        }
        /**
         * Sync scrollbar from scroll state.
         * @param {number} offset - Scroll offset.
         * @param {number} total - Total scroll size.
         * @param {number} viewport - Viewport size.
         */
        sync_from_scroll(offset2, total, viewport) {
          if (!total || !viewport) {
            this.set_ratio(0);
            this.set_page_ratio(1);
            return;
          }
          const scroll_range = Math.max(1, total - viewport);
          const ratio = offset2 / scroll_range;
          this.set_ratio(ratio);
          this.set_page_ratio(viewport / total);
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const input_ctrl = this._ctrl_fields && this._ctrl_fields.input;
            if (input_ctrl && input_ctrl.dom && input_ctrl.dom.el) {
              input_ctrl.dom.el.addEventListener("input", () => {
                const next_value = Number(input_ctrl.dom.el.value);
                this.set_value(next_value);
              });
            }
          }
        }
      };
      var Horizontal_Scrollbar = class extends Scrollbar {
        constructor(spec = {}) {
          super(Object.assign({}, spec, { direction: "horizontal" }));
          this.__direction = "horizontal";
          this.add_class("horizontal");
        }
      };
      var Vertical_Scrollbar = class extends Scrollbar {
        constructor(spec = {}) {
          super(Object.assign({}, spec, { direction: "vertical" }));
          this.__direction = "vertical";
          this.add_class("vertical");
        }
      };
      Scrollbar.H = Scrollbar.Horizontal = Horizontal_Scrollbar;
      Scrollbar.V = Scrollbar.Vertical = Vertical_Scrollbar;
      Scrollbar.css = `
.scrollbar {
    display: flex;
    align-items: center;
}
.scrollbar.horizontal .scrollbar-input {
    width: 100%;
}
.scrollbar.vertical .scrollbar-input {
    width: 100%;
}
`;
      module.exports = Scrollbar;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/scroll-view.js
  var require_scroll_view = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/scroll-view.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var Scrollbar = require_scrollbar();
      var H_Scrollbar = Scrollbar.H;
      var V_Scrollbar = Scrollbar.V;
      var Scroll_View = class extends Control2 {
        constructor(spec = {}) {
          super(spec);
          this.__type_name = "scroll_view";
          this.add_class("scroll-view");
          this.show_horizontal = spec.show_horizontal !== false;
          this.show_vertical = spec.show_vertical !== false;
          this.inertia = !!spec.inertia;
          this.inertia_friction = spec.inertia_friction !== void 0 ? spec.inertia_friction : 0.9;
          this.scroll_state = {
            scroll_left: 0,
            scroll_top: 0,
            scroll_width: 0,
            scroll_height: 0,
            viewport_width: 0,
            viewport_height: 0
          };
          if (!spec.el) {
            this.compose_scroll_view();
          }
        }
        compose_scroll_view() {
          const { context: context2 } = this;
          const viewport = new Control2({
            context: context2
          });
          viewport.add_class("scroll-view-viewport");
          viewport.dom.attributes.style.overflow = "auto";
          const content = new Control2({
            context: context2
          });
          content.add_class("scroll-view-content");
          viewport.add(content);
          this.inner_control = content;
          this.viewport = viewport;
          this.add(viewport);
          if (this.show_horizontal) {
            this.h_scrollbar = new H_Scrollbar({ context: context2 });
            this.add(this.h_scrollbar);
          }
          if (this.show_vertical) {
            this.v_scrollbar = new V_Scrollbar({ context: context2 });
            this.add(this.v_scrollbar);
          }
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.viewport = viewport;
          this._ctrl_fields.content = content;
          this._ctrl_fields.h_scrollbar = this.h_scrollbar;
          this._ctrl_fields.v_scrollbar = this.v_scrollbar;
        }
        /**
         * Update scroll state values.
         * @param {Object} next_state - New scroll state.
         */
        set_scroll_state(next_state = {}) {
          Object.assign(this.scroll_state, next_state);
          this.sync_scrollbars();
        }
        /**
         * Set scroll position.
         * @param {Object} position - Scroll positions.
         */
        set_scroll_position(position = {}) {
          const { scroll_left, scroll_top } = position;
          if (this.viewport && this.viewport.dom && this.viewport.dom.el) {
            const viewport_el = this.viewport.dom.el;
            if (scroll_left !== void 0) viewport_el.scrollLeft = scroll_left;
            if (scroll_top !== void 0) viewport_el.scrollTop = scroll_top;
            this.update_scroll_state_from_dom();
          } else {
            this.set_scroll_state({
              scroll_left: scroll_left !== void 0 ? scroll_left : this.scroll_state.scroll_left,
              scroll_top: scroll_top !== void 0 ? scroll_top : this.scroll_state.scroll_top
            });
          }
        }
        update_scroll_state_from_dom() {
          if (!this.viewport || !this.viewport.dom || !this.viewport.dom.el) return;
          const viewport_el = this.viewport.dom.el;
          this.scroll_state.scroll_left = viewport_el.scrollLeft;
          this.scroll_state.scroll_top = viewport_el.scrollTop;
          this.scroll_state.scroll_width = viewport_el.scrollWidth;
          this.scroll_state.scroll_height = viewport_el.scrollHeight;
          this.scroll_state.viewport_width = viewport_el.clientWidth;
          this.scroll_state.viewport_height = viewport_el.clientHeight;
          this.sync_scrollbars();
        }
        sync_scrollbars() {
          const state = this.scroll_state;
          if (this.h_scrollbar) {
            this.h_scrollbar.sync_from_scroll(
              state.scroll_left,
              state.scroll_width,
              state.viewport_width
            );
          }
          if (this.v_scrollbar) {
            this.v_scrollbar.sync_from_scroll(
              state.scroll_top,
              state.scroll_height,
              state.viewport_height
            );
          }
        }
        attach_inertia_scroll(viewport_el) {
          let velocity_x = 0;
          let velocity_y = 0;
          let frame = null;
          const friction = this.inertia_friction;
          const step = () => {
            if (!viewport_el) return;
            velocity_x *= friction;
            velocity_y *= friction;
            if (Math.abs(velocity_x) < 0.1 && Math.abs(velocity_y) < 0.1) {
              velocity_x = 0;
              velocity_y = 0;
              frame = null;
              return;
            }
            viewport_el.scrollLeft += velocity_x;
            viewport_el.scrollTop += velocity_y;
            this.update_scroll_state_from_dom();
            frame = requestAnimationFrame(step);
          };
          viewport_el.addEventListener("wheel", (e_wheel) => {
            e_wheel.preventDefault();
            velocity_x += e_wheel.deltaX;
            velocity_y += e_wheel.deltaY;
            if (!frame) {
              frame = requestAnimationFrame(step);
            }
          }, { passive: false });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.viewport || !this.viewport.dom || !this.viewport.dom.el) return;
            const viewport_el = this.viewport.dom.el;
            viewport_el.addEventListener("scroll", () => {
              this.update_scroll_state_from_dom();
            });
            if (this.h_scrollbar) {
              this.h_scrollbar.on("scroll", (e_scroll) => {
                const state = this.scroll_state;
                const scroll_range = Math.max(1, state.scroll_width - state.viewport_width);
                const next_left = e_scroll.ratio * scroll_range;
                this.set_scroll_position({ scroll_left: next_left });
              });
            }
            if (this.v_scrollbar) {
              this.v_scrollbar.on("scroll", (e_scroll) => {
                const state = this.scroll_state;
                const scroll_range = Math.max(1, state.scroll_height - state.viewport_height);
                const next_top = e_scroll.ratio * scroll_range;
                this.set_scroll_position({ scroll_top: next_top });
              });
            }
            if (this.inertia) {
              this.attach_inertia_scroll(viewport_el);
            }
          }
        }
      };
      Scroll_View.css = `
.scroll-view {
    position: relative;
    display: block;
}
.scroll-view-viewport {
    width: 100%;
    height: 100%;
}
.scroll-view-content {
    min-width: 100%;
    min-height: 100%;
}
`;
      module.exports = Scroll_View;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/search-bar.js
  var require_search_bar = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/search-bar.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var view_model_spec = {
        name: "search_bar",
        version: "0.0.1",
        type: "control",
        fields: {
          number_of_lines: 1
        },
        actions: ["search"]
      };
      var { prop, field } = require_oext();
      var Search_Bar = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "search_bar";
          super(spec);
          this.add_class("search-bar");
          field(this, "value");
          if (!spec.el) {
            const jsguiml = '<Text_Input name="input"></Text_Input><Button name="btn"></Button>';
            jsgui.parse_mount(jsguiml, this, jsgui.controls);
          }
        }
        // onkeypress 
        activate() {
          if (!this.__active) {
            super.activate();
            const { input, btn } = this;
            input.on("change", (e_change) => {
              const { name, value: value2 } = e_change;
              if (name === "value") {
                this.value = value2;
              }
            });
          }
        }
      };
      Search_Bar.prototype.view_model_spec = view_model_spec;
      module.exports = Search_Bar;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/single-line.js
  var require_single_line = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/single-line.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var Single_Line = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        constructor(spec) {
          super(spec);
          this.add_class("single-line");
          this.__type_name = "single_line";
          var value2 = this.value;
          var display_value;
          var meta_field = this.get("meta_field");
          if (meta_field) {
            display_value = value2.meta.get(meta_field.value());
          }
          var el = this.dom.el;
          if (!el) {
            var span = new jsgui.span({
              "context": this.context
              //,
              //'content': display_value
            });
            if (display_value) {
              span.add(display_value);
            }
            this.add(span);
            this.set("span", span);
          }
        }
        "activate"() {
          super.activate();
          var content = this.content;
          var span = content.get(0);
          var val = span.dom.el.innerHTML;
          this.value = val;
        }
      };
      module.exports = Single_Line;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/split_pane.js
  var require_split_pane = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/split_pane.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var normalize_orientation = (value2) => value2 === "vertical" ? "vertical" : "horizontal";
      var normalize_primary = (value2) => value2 === "second" ? "second" : "first";
      var normalize_size = (value2) => {
        if (typeof value2 === "string" && value2.trim()) return value2.trim();
        const num = Number(value2);
        if (Number.isFinite(num)) return num;
        return "50%";
      };
      var size_to_css = (value2) => {
        if (typeof value2 === "string") return value2;
        const num = Number(value2);
        if (Number.isFinite(num)) return `${num}px`;
        return "50%";
      };
      var Split_Pane = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "split_pane";
          super(spec);
          this.add_class("split-pane");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.set_orientation(spec.orientation);
          this.set_primary(spec.primary);
          this.set_min_size(is_defined(spec.min_size) ? spec.min_size : null);
          this.set_max_size(is_defined(spec.max_size) ? spec.max_size : null);
          this.set_size(is_defined(spec.size) ? spec.size : spec.initial_size);
          this.handle_size = is_defined(spec.handle_size) ? Number(spec.handle_size) : 6;
          if (!spec.el) {
            this.compose_split_pane(spec);
          }
          this.bind_model();
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            const name = e_change.name;
            const value2 = e_change.value;
            if (name === "orientation") {
              this.orientation = normalize_orientation(value2);
            }
            if (name === "primary") {
              this.primary = normalize_primary(value2);
            }
            if (name === "size") {
              this.size = normalize_size(value2);
            }
            if (name === "min_size") {
              this.min_size = is_defined(value2) ? Number(value2) : null;
            }
            if (name === "max_size") {
              this.max_size = is_defined(value2) ? Number(value2) : null;
            }
            if (name === "orientation" || name === "primary" || name === "size" || name === "min_size" || name === "max_size") {
              this.update_layout();
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set split orientation.
         * @param {string} orientation - "horizontal" or "vertical".
         */
        set_orientation(orientation) {
          const next = normalize_orientation(orientation);
          this.set_model_value("orientation", next);
          this.orientation = next;
        }
        /**
         * Set primary pane.
         * @param {string} primary - "first" or "second".
         */
        set_primary(primary) {
          const next = normalize_primary(primary);
          this.set_model_value("primary", next);
          this.primary = next;
        }
        /**
         * Set split size.
         * @param {number|string} size - Size in px or css string.
         */
        set_size(size) {
          const next = normalize_size(size);
          this.set_model_value("size", next);
          this.size = next;
          this.update_layout();
        }
        /**
         * Get split size.
         * @returns {number|string}
         */
        get_size() {
          return this.size;
        }
        /**
         * Set minimum size.
         * @param {number|null} min_size - Minimum size in px.
         */
        set_min_size(min_size) {
          const next = is_defined(min_size) ? Number(min_size) : null;
          this.set_model_value("min_size", next);
          this.min_size = Number.isFinite(next) ? next : null;
        }
        /**
         * Set maximum size.
         * @param {number|null} max_size - Maximum size in px.
         */
        set_max_size(max_size) {
          const next = is_defined(max_size) ? Number(max_size) : null;
          this.set_model_value("max_size", next);
          this.max_size = Number.isFinite(next) ? next : null;
        }
        compose_split_pane(spec = {}) {
          const { context: context2 } = this;
          const first_pane = new Control2({ context: context2, tag_name: "div" });
          first_pane.add_class("split-pane-pane");
          first_pane.add_class("split-pane-pane-first");
          const handle = new Control2({ context: context2, tag_name: "div" });
          handle.add_class("split-pane-handle");
          const second_pane = new Control2({ context: context2, tag_name: "div" });
          second_pane.add_class("split-pane-pane");
          second_pane.add_class("split-pane-pane-second");
          if (Array.isArray(spec.panes)) {
            if (spec.panes[0]) first_pane.add(spec.panes[0]);
            if (spec.panes[1]) second_pane.add(spec.panes[1]);
          } else {
            if (spec.first) first_pane.add(spec.first);
            if (spec.second) second_pane.add(spec.second);
          }
          this.add(first_pane);
          this.add(handle);
          this.add(second_pane);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.first_pane = first_pane;
          this._ctrl_fields.second_pane = second_pane;
          this._ctrl_fields.handle = handle;
          this.update_layout();
        }
        /**
         * Get the primary pane control.
         * @returns {Control}
         */
        get_primary_pane() {
          return this.primary === "second" ? this._ctrl_fields.second_pane : this._ctrl_fields.first_pane;
        }
        /**
         * Get the secondary pane control.
         * @returns {Control}
         */
        get_secondary_pane() {
          return this.primary === "second" ? this._ctrl_fields.first_pane : this._ctrl_fields.second_pane;
        }
        update_layout() {
          const first_pane = this._ctrl_fields && this._ctrl_fields.first_pane;
          const second_pane = this._ctrl_fields && this._ctrl_fields.second_pane;
          const handle = this._ctrl_fields && this._ctrl_fields.handle;
          if (!first_pane || !second_pane || !handle) return;
          const orientation = normalize_orientation(this.orientation);
          this.orientation = orientation;
          this.remove_class("split-pane-horizontal");
          this.remove_class("split-pane-vertical");
          this.add_class(`split-pane-${orientation}`);
          const primary_pane = this.get_primary_pane();
          const secondary_pane = this.get_secondary_pane();
          const size_value = size_to_css(this.size);
          first_pane.remove_class("split-pane-pane-primary");
          first_pane.remove_class("split-pane-pane-secondary");
          second_pane.remove_class("split-pane-pane-primary");
          second_pane.remove_class("split-pane-pane-secondary");
          primary_pane.add_class("split-pane-pane-primary");
          secondary_pane.add_class("split-pane-pane-secondary");
          primary_pane.dom.attributes.style.flex = `0 0 ${size_value}`;
          secondary_pane.dom.attributes.style.flex = "1 1 auto";
          if (orientation === "horizontal") {
            handle.dom.attributes.style.width = `${this.handle_size}px`;
            handle.dom.attributes.style.height = "100%";
            handle.dom.attributes.style.cursor = "col-resize";
          } else {
            handle.dom.attributes.style.height = `${this.handle_size}px`;
            handle.dom.attributes.style.width = "100%";
            handle.dom.attributes.style.cursor = "row-resize";
          }
        }
        get_container_size() {
          if (!this.dom.el) return 0;
          const rect = this.dom.el.getBoundingClientRect();
          return this.orientation === "vertical" ? rect.height : rect.width;
        }
        resolve_size_px() {
          const size = this.size;
          if (typeof size === "number") return size;
          if (typeof size === "string") {
            const trimmed = size.trim();
            if (trimmed.endsWith("%")) {
              const percent = Number(trimmed.replace("%", ""));
              if (Number.isFinite(percent)) {
                return this.get_container_size() * percent / 100;
              }
            }
            const numeric = Number(trimmed);
            if (Number.isFinite(numeric)) return numeric;
          }
          return this.get_container_size() * 0.5;
        }
        clamp_size(next_size) {
          let size = next_size;
          if (Number.isFinite(this.min_size)) {
            size = Math.max(this.min_size, size);
          }
          if (Number.isFinite(this.max_size)) {
            size = Math.min(this.max_size, size);
          }
          return size;
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const handle = this._ctrl_fields && this._ctrl_fields.handle;
            if (!handle || !handle.dom.el || typeof document === "undefined") return;
            let dragging = false;
            let start_pos = 0;
            let start_size = 0;
            const on_move = (e_move) => {
              if (!dragging) return;
              const current_pos = this.orientation === "vertical" ? e_move.clientY : e_move.clientX;
              const delta = current_pos - start_pos;
              const next_size = this.clamp_size(start_size + delta);
              this.set_size(next_size);
            };
            const on_up = () => {
              if (!dragging) return;
              dragging = false;
              document.removeEventListener("mousemove", on_move);
              document.removeEventListener("mouseup", on_up);
              this.raise("resize", { size: this.size });
            };
            handle.add_dom_event_listener("mousedown", (e_down) => {
              e_down.preventDefault();
              dragging = true;
              start_pos = this.orientation === "vertical" ? e_down.clientY : e_down.clientX;
              start_size = this.resolve_size_px();
              document.addEventListener("mousemove", on_move);
              document.addEventListener("mouseup", on_up);
            });
          }
        }
      };
      Split_Pane.css = `
.split-pane {
    display: flex;
    width: 100%;
    height: 100%;
    align-items: stretch;
}
.split-pane-vertical {
    flex-direction: column;
}
.split-pane-pane {
    min-width: 0;
    min-height: 0;
}
.split-pane-handle {
    background: #e2e2e2;
}
`;
      module.exports = Split_Pane;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/stack.js
  var require_stack = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/stack.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var Stack = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "stack";
          super(spec);
          this.add_class("stack");
          this.dom.tagName = "div";
          this.direction = spec.direction === "row" ? "row" : "column";
          this.gap = Number.isFinite(Number(spec.gap)) ? Number(spec.gap) : 12;
          this.apply_layout();
        }
        /**
         * Set stack direction.
         * @param {string} direction - "row" or "column".
         */
        set_direction(direction) {
          this.direction = direction === "row" ? "row" : "column";
          this.apply_layout();
        }
        /**
         * Set stack gap.
         * @param {number} gap - Gap in px.
         */
        set_gap(gap) {
          const next_gap = Number(gap);
          if (Number.isFinite(next_gap)) {
            this.gap = next_gap;
            this.apply_layout();
          }
        }
        apply_layout() {
          this.dom.attributes.style.display = "flex";
          this.dom.attributes.style.flexDirection = this.direction;
          this.dom.attributes.style.gap = `${this.gap}px`;
        }
      };
      module.exports = Stack;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/3-page/standard-web-page.js
  var require_standard_web_page = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/3-page/standard-web-page.js"(exports, module) {
      var jsgui = require_html_core();
      var Standard_Web_Page = class extends jsgui.Blank_HTML_Document {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Standard_Web_Page;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/start-stop-toggle-button.js
  var require_start_stop_toggle_button = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/start-stop-toggle-button.js"(exports, module) {
      var jsgui = require_html_core();
      var Toggle_Button = require_toggle_button();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var Start_Stop_Toggle_Button = class extends Toggle_Button {
        //'fields': [
        //['text', String]
        //],
        //  and can have other fields possibly.
        constructor(spec, add, make) {
          spec.states = ["start", "stop"];
          spec.state = spec.state || "start";
          super(spec);
          this.__type_name = "start_stop_toggle_button";
          this.add_class("start-stop toggle-button");
          this.on("change", (e_change) => {
            const { name, value: value2 } = e_change;
            if (name === "state") {
              if (value2 === "stop") {
                this.raise("start");
              }
              if (value2 === "start") {
                this.raise("stop");
              }
            }
          });
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
          }
        }
      };
      module.exports = Start_Stop_Toggle_Button;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/1-advanced/string-span.js
  var require_string_span = __commonJS({
    "../jsgui3-html/controls/organised/0-core/1-advanced/string-span.js"(exports, module) {
      var jsgui = require_html_core();
      var { controls, parse, each, are_equal } = jsgui;
      var { Control: Control2, Text_Node } = controls;
      var Button = require_button();
      var { field, prop } = require_oext();
      var press_events = require_press_events();
      var watch_resize = (ctrl) => {
        let last_size = ctrl.bcr();
        const inner = () => {
          requestAnimationFrame((timestamp) => {
            const current_size = ctrl.bcr();
            const same_size = are_equal(last_size, current_size);
            if (same_size) {
            } else {
              ctrl.raise("resize");
              last_size = current_size;
            }
            inner();
          });
        };
        inner();
      };
      var suspended_frame = (ctrl, opts = {
        offset: 0
      }) => {
        const { context: context2 } = ctrl;
        const body = context2.body();
        let arr_ctrls = [];
        let arr_ctrls_with_poss = [];
        const { offset: offset2 } = opts;
        const measure_ctrl = () => {
          const bcr = ctrl.bcr();
          console.log("bcr", bcr);
          return bcr;
        };
        const clear = () => {
          each(arr_ctrls, (ctrl2) => {
            ctrl2.remove();
          });
          arr_ctrls = [];
          arr_ctrls_with_poss = [];
        };
        const get_suspended_ctrl_doc_pos = (suspended_ctrl, pos) => {
          const m = measure_ctrl();
          const [tl, br, size] = m;
          const map_pos_fns = {
            "tl": () => [tl[0] - offset2, tl[1] - offset2],
            "tm": () => [t1[0] + 1 / 2 * size[0], t1[1] - offset2],
            "tr": () => [br[0] + offset2, tl[1] - offset2]
          };
          if (map_pos_fns[pos]) {
            const retrieved_pos = map_pos_fns[pos]();
            if (retrieved_pos) {
              if (suspended_ctrl.size) {
                const half_size = [suspended_ctrl.size[0] / 2, suspended_ctrl.size[1] / 2];
                const docpos = [retrieved_pos[0] - half_size[0], retrieved_pos[1] - half_size[1]];
                return docpos;
              } else {
                return retrieved_pos;
              }
            }
          }
        };
        const add = (ctrl_to_add, pos) => {
          const docpos = get_suspended_ctrl_doc_pos(ctrl_to_add, pos);
          console.log("docpos", docpos);
          ctrl_to_add.style({
            "position": "absolute",
            "left": docpos[0] + "px",
            "top": docpos[1] + "px"
          });
          body.add(ctrl_to_add);
          arr_ctrls.push(ctrl_to_add);
          arr_ctrls_with_poss.push([ctrl_to_add, pos]);
          ctrl_to_add.activate();
        };
        const sync_dimensions = () => {
          each(arr_ctrls_with_poss, (cwp) => {
            const [ctrl2, pos] = cwp;
            const docpos = get_suspended_ctrl_doc_pos(ctrl2, pos);
            ctrl2.style({
              "left": docpos[0] + "px",
              "top": docpos[1] + "px"
            });
          });
        };
        watch_resize(ctrl);
        ctrl.on("resize", (e_resize) => {
          sync_dimensions();
        });
        const res2 = {
          add,
          clear
        };
        return res2;
      };
      var editable = (ctrl) => {
        field(ctrl, "editable", true);
        field(ctrl, "editing", false);
        const { context: context2 } = ctrl;
        ctrl.on("activate", (e) => {
          console.log("new mini mixin editable ctrl on activate");
          let initial_text = ctrl.dom.el.textContent;
          press_events(ctrl);
          const sframe = suspended_frame(ctrl, {
            offset: 8
          });
          const btn_cancel = new Button({
            context: context2,
            class: "cancel button",
            size: [24, 24],
            text: "\u2B8C"
          });
          btn_cancel.style({
            "line-height": "18px",
            "color": "#8B0000",
            "font-weight": "bold"
          });
          const btn_ok = new Button({
            context: context2,
            class: "ok button",
            size: [24, 24],
            text: "\u2713"
          });
          btn_ok.style({
            "line-height": "18px",
            "color": "#228B22",
            // forest green
            "font-weight": "bold"
          });
          const cancel_editing = () => {
            console.log("cancel_editing");
            sframe.clear();
            ctrl.remove_class("editing");
            ctrl.editing = false;
            ctrl.dom.attributes.contenteditable = false;
            ctrl.dom.el.textContent = initial_text;
          };
          const save_editing = () => {
            console.log("save_editing");
            const new_text = ctrl.dom.el.textContent;
            console.log("new_text", new_text);
            sframe.clear();
            ctrl.remove_class("editing");
            ctrl.editing = false;
            ctrl.dom.attributes.contenteditable = false;
            ctrl.raise("edit-complete", {
              old: initial_text,
              value: new_text
            });
          };
          let has_events = false;
          const start_editing = () => {
            ctrl.editing = true;
            initial_text = ctrl.dom.el.textContent;
            ctrl.add_class("editing");
            sframe.add(btn_cancel, "tl");
            sframe.add(btn_ok, "tr");
            if (!has_events) {
              btn_cancel.on("click", (e2) => {
                cancel_editing();
              });
              btn_ok.on("click", (e2) => {
                save_editing();
              });
              has_events = true;
            }
            ctrl.dom.attributes.contenteditable = true;
          };
          ctrl.on({
            "press-end": (e_press_end) => {
              console.log("e_press_end", e_press_end);
              if (!ctrl.editing) {
                start_editing();
              }
            }
          });
        });
      };
      var String_Span = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "string_span";
          spec.tag_name = "span";
          spec.class = "string";
          super(spec);
          field(this, "value", spec.value);
          editable(this);
          const { context: context2 } = this;
          const compose = () => {
            let tn = new Text_Node({
              context: context2,
              text: spec.value
            });
            this.add(tn);
          };
          if (!spec.el) {
            compose();
          }
        }
        // listen for edit-complete to update the .text property.
        //  silent update?
        activate() {
          if (!this.__active) {
            super.activate();
            this.on({
              "edit-complete": (e) => {
                const { old, value: value2 } = e;
                if (old !== value2) {
                  this.value = value2;
                }
              }
            });
          }
        }
        // Popups outside of this?
        //  Will need to position the popup divs within the DOM.
        //  Suspended_Around_Bounding_Rect
        //  Frame
        // Popups around bounding rect (mixin)?
        //  Would be very useful for a variety of things that appear around the frames / borders of controls.
        // how / when does this get activated...?
        // setup for hover....
        // Click to edit
        // Editable behaviour
        //  Click to edit.
        // 
      };
      module.exports = String_Span;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/tag_input.js
  var require_tag_input = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/tag_input.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2, Data_Object } = jsgui;
      var { is_defined } = jsgui;
      var Tag_Input = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "tag_input";
          super(spec);
          this.add_class("tag-input");
          const { context: context2 } = this;
          const items = Array.isArray(spec.items) ? spec.items.slice() : [];
          this.model = spec.model instanceof Data_Object ? spec.model : new Data_Object({ context: context2, items, input_value: "" });
          if (!spec.el) {
            this.compose_tag_input(items, spec.placeholder);
          }
        }
        compose_tag_input(items, placeholder) {
          const { context: context2 } = this;
          const tags_container = new Control2({ context: context2 });
          tags_container.dom.tagName = "div";
          tags_container.add_class("tag-input-items");
          const input_ctrl = new Control2({ context: context2 });
          input_ctrl.dom.tagName = "input";
          input_ctrl.dom.attributes.type = "text";
          input_ctrl.dom.attributes.autocomplete = "off";
          if (is_defined(placeholder)) {
            input_ctrl.dom.attributes.placeholder = String(placeholder);
          }
          input_ctrl.add_class("tag-input-field");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.tags_container = tags_container;
          this._ctrl_fields.input_ctrl = input_ctrl;
          this.add(tags_container);
          this.add(input_ctrl);
          this.set_items(items);
        }
        render_tags() {
          const tags_container = this._ctrl_fields && this._ctrl_fields.tags_container;
          if (!tags_container) return;
          tags_container.clear();
          const items = this.get_items();
          items.forEach((item2, index) => {
            const tag_ctrl = new Control2({ context: this.context });
            tag_ctrl.dom.tagName = "span";
            tag_ctrl.add_class("tag-input-item");
            const text_ctrl = new Control2({ context: this.context });
            text_ctrl.dom.tagName = "span";
            text_ctrl.add_class("tag-input-text");
            text_ctrl.add(String(item2));
            const remove_ctrl = new Control2({ context: this.context });
            remove_ctrl.dom.tagName = "button";
            remove_ctrl.dom.attributes.type = "button";
            remove_ctrl.dom.attributes["data-tag-index"] = String(index);
            remove_ctrl.add_class("tag-input-remove");
            remove_ctrl.add("x");
            tag_ctrl.add(text_ctrl);
            tag_ctrl.add(remove_ctrl);
            tags_container.add(tag_ctrl);
          });
        }
        /**
         * Set the tag items.
         * @param {Array} items - The items to set.
         */
        set_items(items) {
          const next_items = Array.isArray(items) ? items.slice() : [];
          this.model.items = next_items;
          this.render_tags();
        }
        /**
         * Get the tag items.
         * @returns {Array}
         */
        get_items() {
          return Array.isArray(this.model.items) ? this.model.items : [];
        }
        /**
         * Add a tag item.
         * @param {*} item - The item to add.
         */
        add_item(item2) {
          if (!is_defined(item2)) return;
          const items = this.get_items();
          const next_items = items.slice();
          next_items.push(item2);
          this.set_items(next_items);
        }
        /**
         * Remove a tag item.
         * @param {*} item_or_index - Index or item value to remove.
         */
        remove_item(item_or_index) {
          const items = this.get_items();
          if (!items.length) return;
          let next_items = items.slice();
          if (typeof item_or_index === "number") {
            if (item_or_index >= 0 && item_or_index < next_items.length) {
              next_items.splice(item_or_index, 1);
            }
          } else {
            const index = next_items.indexOf(item_or_index);
            if (index >= 0) {
              next_items.splice(index, 1);
            }
          }
          this.set_items(next_items);
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const tags_container = this._ctrl_fields && this._ctrl_fields.tags_container;
            const input_ctrl = this._ctrl_fields && this._ctrl_fields.input_ctrl;
            if (!tags_container || !input_ctrl || !input_ctrl.dom.el) return;
            const add_from_input = () => {
              const raw_value = input_ctrl.dom.el.value.trim();
              if (!raw_value) return;
              this.add_item(raw_value);
              input_ctrl.dom.el.value = "";
              this.model.input_value = "";
            };
            input_ctrl.add_dom_event_listener("input", () => {
              this.model.input_value = input_ctrl.dom.el.value;
            });
            input_ctrl.add_dom_event_listener("keydown", (e_key) => {
              const key2 = e_key.key || e_key.keyCode;
              if (key2 === "Enter" || key2 === "," || key2 === 13 || key2 === 188) {
                e_key.preventDefault();
                add_from_input();
              } else if ((key2 === "Backspace" || key2 === 8) && input_ctrl.dom.el.value === "") {
                const items = this.get_items();
                if (items.length) {
                  this.remove_item(items.length - 1);
                }
              }
            });
            if (tags_container.dom.el) {
              tags_container.add_dom_event_listener("click", (e_click) => {
                const target = e_click.target;
                if (!target || !target.getAttribute) return;
                const index_str = target.getAttribute("data-tag-index");
                if (!is_defined(index_str)) return;
                const index = parseInt(index_str, 10);
                if (!Number.isNaN(index)) {
                  this.remove_item(index);
                }
              });
            }
          }
        }
      };
      Tag_Input.css = `
.tag-input {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    padding: 6px;
    border: 1px solid #ccc;
    border-radius: 6px;
}
.tag-input-items {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}
.tag-input-item {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 6px;
    border-radius: 999px;
    background: #f0f0f0;
}
.tag-input-remove {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 0.8em;
}
.tag-input-field {
    border: none;
    outline: none;
    min-width: 120px;
}
`;
      module.exports = Tag_Input;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/tel_input.js
  var require_tel_input = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/tel_input.js"(exports, module) {
      var Text_Input = require_Text_Input();
      var Tel_Input = class extends Text_Input {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "tel_input";
          super(spec);
          this.add_class("tel-input");
          this.dom.attributes.type = "tel";
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="tel"]', Tel_Input, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Tel_Input;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/toast.js
  var require_toast = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/toast.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Toast = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "toast";
          super(spec);
          this.add_class("toast-container");
          this.dom.tagName = "div";
          this.dom.attributes["aria-live"] = "polite";
          this.toast_items = /* @__PURE__ */ new Map();
          this.toast_id_counter = 1;
        }
        /**
         * Show a toast message.
         * @param {string} message - The message to show.
         * @param {object} options - Optional toast options.
         * @returns {string} Toast id.
         */
        show(message, options = {}) {
          const msg_text = is_defined(message) ? String(message) : "";
          const id = `toast_${this.toast_id_counter++}`;
          const status = is_defined(options.status) ? String(options.status) : "";
          const toast_ctrl = new Control2({ context: this.context });
          toast_ctrl.dom.tagName = "div";
          toast_ctrl.add_class("toast");
          toast_ctrl.dom.attributes["data-toast-id"] = id;
          if (status) {
            toast_ctrl.add_class(`toast-${status}`);
          }
          const text_ctrl = new Control2({ context: this.context });
          text_ctrl.dom.tagName = "span";
          text_ctrl.add_class("toast-message");
          text_ctrl.add(msg_text);
          const dismiss_ctrl = new Control2({ context: this.context });
          dismiss_ctrl.dom.tagName = "button";
          dismiss_ctrl.dom.attributes.type = "button";
          dismiss_ctrl.dom.attributes["data-toast-id"] = id;
          dismiss_ctrl.add_class("toast-dismiss");
          dismiss_ctrl.add("x");
          toast_ctrl.add(text_ctrl);
          toast_ctrl.add(dismiss_ctrl);
          this.add(toast_ctrl);
          this.toast_items.set(id, toast_ctrl);
          const timeout_ms = options.timeout_ms;
          if (typeof window !== "undefined" && Number.isFinite(timeout_ms) && timeout_ms > 0) {
            setTimeout(() => {
              this.dismiss(id);
            }, timeout_ms);
          }
          return id;
        }
        /**
         * Dismiss a toast by id.
         * @param {string} toast_id - The toast id.
         */
        dismiss(toast_id) {
          const toast_ctrl = this.toast_items.get(toast_id);
          if (!toast_ctrl) return;
          this.toast_items.delete(toast_id);
          toast_ctrl.remove();
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            this.add_dom_event_listener("click", (e_click) => {
              const target = e_click.target;
              if (!target || !target.getAttribute) return;
              const toast_id = target.getAttribute("data-toast-id");
              if (!is_defined(toast_id)) return;
              this.dismiss(toast_id);
            });
          }
        }
      };
      Toast.css = `
.toast-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.toast {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 8px 12px;
    border-radius: 6px;
    background: #333;
    color: #fff;
}
.toast-success {
    background: #1b5e20;
}
.toast-error {
    background: #b71c1c;
}
.toast-warn,
.toast-warning {
    background: #ff6f00;
}
.toast-dismiss {
    border: none;
    background: transparent;
    color: inherit;
    cursor: pointer;
}
`;
      module.exports = Toast;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/toggle_switch.js
  var require_toggle_switch = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/toggle_switch.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Toggle_Switch = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "toggle_switch";
          super(spec);
          this.add_class("toggle-switch");
          this.on_label = is_defined(spec.on_label) ? String(spec.on_label) : "On";
          this.off_label = is_defined(spec.off_label) ? String(spec.off_label) : "Off";
          this.checked = !!spec.checked;
          if (!spec.el) {
            this.compose_toggle_switch();
          }
        }
        compose_toggle_switch() {
          const { context: context2 } = this;
          const input_ctrl = new Control2({ context: context2 });
          input_ctrl.dom.tagName = "input";
          input_ctrl.dom.attributes.type = "checkbox";
          input_ctrl.dom.attributes.id = input_ctrl._id();
          input_ctrl.dom.attributes["aria-checked"] = this.checked ? "true" : "false";
          if (this.checked) {
            input_ctrl.dom.attributes.checked = "checked";
          }
          input_ctrl.add_class("toggle-switch-input");
          const slider_ctrl = new Control2({ context: context2 });
          slider_ctrl.dom.tagName = "span";
          slider_ctrl.add_class("toggle-switch-slider");
          const label_ctrl = new Control2({ context: context2 });
          label_ctrl.dom.tagName = "label";
          label_ctrl.dom.attributes.for = input_ctrl._id();
          label_ctrl.add_class("toggle-switch-label");
          label_ctrl.add(this.checked ? this.on_label : this.off_label);
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.input = input_ctrl;
          this._ctrl_fields.slider = slider_ctrl;
          this._ctrl_fields.label = label_ctrl;
          this.add(input_ctrl);
          this.add(slider_ctrl);
          this.add(label_ctrl);
        }
        /**
         * Set the toggle checked state.
         * @param {boolean} checked - The checked state.
         */
        set_checked(checked) {
          const next_checked = !!checked;
          this.checked = next_checked;
          const input_ctrl = this._ctrl_fields && this._ctrl_fields.input;
          const label_ctrl = this._ctrl_fields && this._ctrl_fields.label;
          if (input_ctrl) {
            input_ctrl.dom.attributes["aria-checked"] = next_checked ? "true" : "false";
            if (next_checked) {
              input_ctrl.dom.attributes.checked = "checked";
            } else {
              input_ctrl.dom.attributes.checked = "";
            }
            if (input_ctrl.dom.el) {
              input_ctrl.dom.el.checked = next_checked;
            }
          }
          if (label_ctrl) {
            const label_text = next_checked ? this.on_label : this.off_label;
            if (label_ctrl.dom && label_ctrl.dom.el) {
              label_ctrl.dom.el.textContent = label_text;
            } else {
              label_ctrl.clear();
              label_ctrl.add(label_text);
            }
          }
        }
        /**
         * Get the toggle checked state.
         * @returns {boolean}
         */
        get_checked() {
          return !!this.checked;
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const input_ctrl = this._ctrl_fields && this._ctrl_fields.input;
            if (!input_ctrl || !input_ctrl.dom || !input_ctrl.dom.el) return;
            input_ctrl.on("change", () => {
              this.set_checked(input_ctrl.dom.el.checked);
              this.raise("change", {
                name: "checked",
                value: this.checked
              });
            });
          }
        }
      };
      Toggle_Switch.css = `
.toggle-switch {
    display: inline-flex;
    align-items: center;
    gap: 8px;
}
.toggle-switch-input {
    margin: 0;
}
.toggle-switch-slider {
    width: 28px;
    height: 16px;
    border-radius: 999px;
    background: #bbb;
    position: relative;
}
.toggle-switch-slider::after {
    content: '';
    position: absolute;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #fff;
    top: 2px;
    left: 2px;
    transition: transform 0.2s ease;
}
.toggle-switch-input:checked + .toggle-switch-slider::after {
    transform: translateX(12px);
}
.toggle-switch-label {
    font-size: 0.9em;
}
`;
      module.exports = Toggle_Switch;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/range_input.js
  var require_range_input = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/range_input.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { apply_full_input_api } = require_input_api();
      var normalize_number_value = (value2) => {
        if (!is_defined(value2)) return "";
        if (value2 === "") return "";
        const numeric = Number(value2);
        if (Number.isFinite(numeric)) return numeric;
        return value2;
      };
      var set_attr_if_defined = (dom_attributes, name, value2) => {
        if (is_defined(value2)) {
          dom_attributes[name] = String(value2);
        }
      };
      var Range_Input = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "range_input";
          super(spec);
          this.add_class("range-input");
          this.dom.tagName = "input";
          this.dom.attributes.type = "range";
          this.enhance_only = !!spec.enhance_only && !!spec.el;
          set_attr_if_defined(this.dom.attributes, "min", spec.min);
          set_attr_if_defined(this.dom.attributes, "max", spec.max);
          set_attr_if_defined(this.dom.attributes, "step", spec.step);
          apply_full_input_api(this, {
            disabled: spec.disabled,
            readonly: spec.readonly,
            required: spec.required
          });
          if (is_defined(spec.value)) {
            this.set_value(spec.value);
          } else if (this.enhance_only && spec.el && is_defined(spec.el.value)) {
            this.set_value(spec.el.value);
          }
          if (is_defined(spec.min)) {
            this.dom.attributes["aria-valuemin"] = String(spec.min);
          }
          if (is_defined(spec.max)) {
            this.dom.attributes["aria-valuemax"] = String(spec.max);
          }
        }
        /**
         * Set the range input value.
         * @param {*} value - The value to set.
         */
        set_value(value2) {
          const normalized = normalize_number_value(value2);
          const value_str = normalized === "" ? "" : String(normalized);
          this.value = normalized;
          this.dom.attributes.value = value_str;
          this.dom.attributes["aria-valuenow"] = value_str;
          if (this.dom.el) {
            this.dom.el.value = value_str;
            this.dom.el.setAttribute("aria-valuenow", value_str);
          }
        }
        /**
         * Get the range input value.
         * @returns {*}
         */
        get_value() {
          return this.value;
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            const sync_value = () => {
              this.set_value(this.dom.el.value);
            };
            this.add_dom_event_listener("input", sync_value);
            this.add_dom_event_listener("change", sync_value);
            sync_value();
          }
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="range"]', Range_Input, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Range_Input;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/stepped_slider.js
  var require_stepped_slider = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/stepped_slider.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Range_Input = require_range_input();
      var Stepped_Slider = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "stepped_slider";
          super(spec);
          this.add_class("stepped-slider");
          this.dom.tagName = "div";
          this.min = is_defined(spec.min) ? Number(spec.min) : 0;
          this.max = is_defined(spec.max) ? Number(spec.max) : 100;
          this.step = is_defined(spec.step) ? Number(spec.step) : 1;
          this.value = is_defined(spec.value) ? Number(spec.value) : this.min;
          this.ticks = Array.isArray(spec.ticks) ? spec.ticks.slice() : [];
          this.show_value = !!spec.show_value;
          if (!spec.el) {
            this.compose_stepped_slider();
          }
        }
        compose_stepped_slider() {
          const { context: context2 } = this;
          const range_ctrl = new Range_Input({
            context: context2,
            min: this.min,
            max: this.max,
            step: this.step,
            value: this.value
          });
          range_ctrl.add_class("stepped-slider-input");
          const value_ctrl = new Control2({ context: context2, tag_name: "span" });
          value_ctrl.add_class("stepped-slider-value");
          if (this.show_value) {
            value_ctrl.add(String(this.value));
          }
          const ticks_ctrl = new Control2({ context: context2, tag_name: "div" });
          ticks_ctrl.add_class("stepped-slider-ticks");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.range = range_ctrl;
          this._ctrl_fields.value = value_ctrl;
          this._ctrl_fields.ticks = ticks_ctrl;
          this.add(range_ctrl);
          this.add(value_ctrl);
          this.add(ticks_ctrl);
          this.render_ticks();
        }
        render_ticks() {
          const ticks_ctrl = this._ctrl_fields && this._ctrl_fields.ticks;
          if (!ticks_ctrl) return;
          ticks_ctrl.clear();
          if (!this.ticks.length) return;
          this.ticks.forEach((tick) => {
            const tick_ctrl = new Control2({ context: this.context, tag_name: "span" });
            tick_ctrl.add_class("stepped-slider-tick");
            tick_ctrl.add(String(tick));
            ticks_ctrl.add(tick_ctrl);
          });
        }
        update_value_label() {
          const value_ctrl = this._ctrl_fields && this._ctrl_fields.value;
          if (!value_ctrl) return;
          if (!this.show_value) return;
          if (value_ctrl.dom && value_ctrl.dom.el) {
            value_ctrl.dom.el.textContent = String(this.value);
          } else {
            value_ctrl.clear();
            value_ctrl.add(String(this.value));
          }
        }
        /**
         * Set slider value.
         * @param {*} value - The value to set.
         */
        set_value(value2) {
          const numeric = Number(value2);
          if (!Number.isFinite(numeric)) return;
          const clamped = Math.min(Math.max(numeric, this.min), this.max);
          this.value = clamped;
          const range_ctrl = this._ctrl_fields && this._ctrl_fields.range;
          if (range_ctrl) {
            range_ctrl.set_value(clamped);
          }
          this.update_value_label();
        }
        /**
         * Get slider value.
         * @returns {number}
         */
        get_value() {
          return this.value;
        }
        /**
         * Set ticks for the slider.
         * @param {Array} ticks - Tick labels to display.
         */
        set_ticks(ticks) {
          this.ticks = Array.isArray(ticks) ? ticks.slice() : [];
          this.render_ticks();
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const range_ctrl = this._ctrl_fields && this._ctrl_fields.range;
            if (!range_ctrl || !range_ctrl.dom.el) return;
            range_ctrl.add_dom_event_listener("input", () => {
              this.set_value(range_ctrl.dom.el.value);
              this.raise("change", { name: "value", value: this.value });
            });
          }
        }
      };
      Stepped_Slider.css = `
.stepped-slider {
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.stepped-slider-input {
    width: 100%;
}
.stepped-slider-value {
    font-size: 0.85em;
    color: #444;
}
.stepped-slider-ticks {
    display: flex;
    justify-content: space-between;
    font-size: 0.75em;
    color: #666;
}
`;
      module.exports = Stepped_Slider;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/timespan-selector.js
  var require_timespan_selector = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/1-compositional/timespan-selector.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var Control2 = jsgui.Control;
      var Date_Picker = jsgui.Date_Picker;
      var Timespan_Selector = class extends Control2 {
        // fields... text, value, type?
        //  type could specify some kind of validation, or also 'password'.
        // single field?
        //  and can have other fields possibly.
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "timespan_selector";
          super(spec);
          if (spec.span) {
            this.span = spec.span;
          } else {
            this.span = [];
          }
          if (!spec.skip_compose) {
            this.compose();
          }
        }
        compose() {
          let context2 = this.context;
          let date_from = this.span[0] || /* @__PURE__ */ new Date("2018-06-20T11:00:00");
          let date_to = this.span[0] || /* @__PURE__ */ new Date("2018-08-20T11:00:00");
          let picker_from = new Date_Picker({
            context: this.context,
            date: date_from
          });
          this.add(picker_from);
          let picker_to = new Date_Picker({
            context: this.context,
            date: date_to
          });
          this.add(picker_to);
        }
      };
      module.exports = Timespan_Selector;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/titled-panel.js
  var require_titled_panel = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/titled-panel.js"(exports, module) {
      var jsgui = require_html_core();
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var tof = jsgui.tof;
      var is_defined = jsgui.is_defined;
      var Control2 = jsgui.Control;
      var Panel = require_panel();
      var Title_Bar = require_title_bar();
      var Titled_Panel = class extends Panel {
        constructor(spec) {
          super(spec);
          this.__type_name = "titled_panel";
          if (!spec.abstract && !spec.el) {
            var title_bar = new Title_Bar({
              "context": this.context,
              "text": this.title
            });
            title_bar.active();
            this.add(title_bar);
            var inner_control = new Control2({
              "context": this.context
            });
            inner_control.active();
            this.add(inner_control);
          }
        }
        "activate"() {
          super.activate();
          const { title_bar, inner_control } = this;
        }
      };
      module.exports = Titled_Panel;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/Toolbar.js
  var require_Toolbar = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/Toolbar.js"(exports, module) {
      var Control2 = require_control();
      var Button = require_button();
      var {
        apply_focus_ring,
        apply_label,
        ensure_sr_text
      } = require_a11y();
      var Toolbar = class extends Control2 {
        constructor(options = {}) {
          super(options);
          this.add_class("toolbar");
          if (options.orientation === "vertical") {
            this.add_class("toolbar-vertical");
          } else {
            this.add_class("toolbar-horizontal");
          }
          this.items = [];
        }
        /**
         * Add a button to the toolbar
         */
        addButton(config) {
          const { context: context2 } = this;
          const button = new Button({ context: context2 });
          button.add_class("toolbar-button");
          apply_focus_ring(button);
          if (config.icon) {
            const icon = new Control2({ context: context2, tag_name: "span" });
            icon.add_class("toolbar-button-icon");
            icon.add(config.icon);
            button.add(icon);
          }
          if (config.label) {
            const label = new Control2({ context: context2, tag_name: "span" });
            label.add_class("toolbar-button-label");
            label.add(config.label);
            button.add(label);
          }
          if (config.aria_label) {
            apply_label(button, config.aria_label, { force: true });
          }
          if (!config.label && config.icon) {
            const sr_text = config.aria_label || config.tooltip || "Toolbar action";
            ensure_sr_text(button, sr_text);
          }
          if (config.tooltip) {
            button.dom.attributes.title = config.tooltip;
          }
          if (config.onClick) {
            button.on("click", config.onClick);
          }
          this.add(button);
          this.items.push(button);
          return button;
        }
        /**
         * Add a separator
         */
        addSeparator() {
          const { context: context2 } = this;
          const separator = new Control2({ context: context2, tag_name: "div" });
          separator.add_class("toolbar-separator");
          this.add(separator);
          this.items.push(separator);
          return separator;
        }
        /**
         * Add a spacer (flexible space)
         */
        addSpacer() {
          const { context: context2 } = this;
          const spacer = new Control2({ context: context2, tag_name: "div" });
          spacer.add_class("toolbar-spacer");
          this.add(spacer);
          this.items.push(spacer);
          return spacer;
        }
        /**
         * Add any custom control
         */
        addControl(control) {
          control.add_class("toolbar-item");
          this.add(control);
          this.items.push(control);
          return control;
        }
        /**
         * Clear all items
         */
        clear() {
          this.content.clear();
          this.items = [];
        }
      };
      module.exports = Toolbar;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/toolbox.js
  var require_toolbox = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/toolbox.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { prop, field } = require_oext();
      var Toolbox = class extends Control2 {
        constructor(spec) {
          spec.__type_name = spec.__type_name || "toolbox";
          super(spec);
          this.add_class("toolbox");
        }
      };
      module.exports = Toolbox;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/5-ui/tooltip.js
  var require_tooltip = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/5-ui/tooltip.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Tooltip = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "tooltip";
          super(spec);
          this.add_class("tooltip");
          this.dom.tagName = "div";
          this.dom.attributes.role = "tooltip";
          this.dom.attributes["aria-hidden"] = "true";
          this.dom.attributes.id = this._id();
          this.message = is_defined(spec.message) ? String(spec.message) : is_defined(spec.text) ? String(spec.text) : "";
          this.placement = is_defined(spec.placement) ? String(spec.placement) : "top";
          this.target = spec.target;
          if (this.placement) {
            this.add_class(`tooltip-${this.placement}`);
          }
          if (!spec.el && this.message) {
            this.add(this.message);
          }
        }
        /**
         * Set the tooltip message.
         * @param {string} message - The message to set.
         */
        set_message(message) {
          this.message = is_defined(message) ? String(message) : "";
          this.clear();
          if (this.message) {
            this.add(this.message);
          }
        }
        /**
         * Show the tooltip.
         */
        show() {
          this.add_class("is-visible");
          this.dom.attributes["aria-hidden"] = "false";
          if (this.dom.el) {
            this.dom.el.setAttribute("aria-hidden", "false");
          }
        }
        /**
         * Hide the tooltip.
         */
        hide() {
          this.remove_class("is-visible");
          this.dom.attributes["aria-hidden"] = "true";
          if (this.dom.el) {
            this.dom.el.setAttribute("aria-hidden", "true");
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            if (typeof document === "undefined") return;
            let target_el;
            if (this.target) {
              if (typeof this.target === "string") {
                target_el = document.querySelector(this.target);
              } else if (this.target.dom && this.target.dom.el) {
                target_el = this.target.dom.el;
              } else if (this.context && typeof this.context.get_ctrl_el === "function") {
                target_el = this.context.get_ctrl_el(this.target);
              }
            }
            if (!target_el) return;
            target_el.setAttribute("aria-describedby", this._id());
            target_el.addEventListener("mouseenter", () => this.show());
            target_el.addEventListener("mouseleave", () => this.hide());
            target_el.addEventListener("focus", () => this.show());
            target_el.addEventListener("blur", () => this.hide());
          }
        }
      };
      Tooltip.css = `
.tooltip {
    position: absolute;
    padding: 6px 8px;
    border-radius: 4px;
    background: #222;
    color: #fff;
    font-size: 0.8em;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
}
.tooltip.is-visible {
    opacity: 1;
}
`;
      module.exports = Tooltip;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/4-data/Tree_View.js
  var require_Tree_View = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/4-data/Tree_View.js"(exports, module) {
      var jsgui = require_html_core();
      var { each, tof } = jsgui;
      var Control2 = jsgui.Control;
      var { field, prop } = require_oext();
      var { press_events, pressed_state, selectable } = require_mx();
      var Tree_View = class extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "tree_view";
          super(spec);
          this.add_class("tree-view");
          field(this.view.data.model, "data");
          field(this.view.data.model, "selected_node");
          this.on("select", (node) => {
            this.view.data.model.selected_node = node;
          });
          if (spec.data) {
            this.view.data.model.data = spec.data;
          }
          if (spec.onSelect) {
            this.on("select", spec.onSelect);
          }
          if (spec.onExpand) {
            this.on("expand", spec.onExpand);
          }
          if (!spec.abstract && !spec.el) {
            this.compose_tree();
          }
        }
        compose_tree() {
          const { context: context2 } = this;
          const data = this.view.data.model.data;
          if (data) {
            each(data, (item2) => {
              const node = new Tree_Node({
                context: context2,
                data: item2,
                tree: this
              });
              this.add(node);
            });
          }
        }
        // Helper to handle selection from nodes
        handle_node_select(node_control) {
          const current = this.selected_node_control;
          if (current) {
            current.remove_class("selected");
            current.selected = false;
          }
          this.selected_node_control = node_control;
          node_control.add_class("selected");
          node_control.selected = true;
          this.raise("select", node_control.data_item);
        }
      };
      var Tree_Node = class _Tree_Node extends Control2 {
        constructor(spec) {
          spec = spec || {};
          spec.__type_name = spec.__type_name || "tree_node";
          super(spec);
          this.tree = spec.tree;
          this.data_item = spec.data;
          this.add_class("tree-node");
          this.compose_node();
        }
        compose_node() {
          const { context: context2, data_item } = this;
          const ctrl_header = new Control2({ context: context2 });
          ctrl_header.add_class("tree-node-header");
          ctrl_header.on("click", (e) => {
            e.stopPropagation();
            if (this.tree) {
              this.tree.handle_node_select(this);
            }
          });
          this.add(ctrl_header);
          if (data_item.children && data_item.children.length > 0) {
            const ctrl_chevron = new Control2({ context: context2 });
            ctrl_chevron.add_class("tree-chevron");
            ctrl_chevron.add("\u25B6");
            if (data_item.expanded) {
              ctrl_chevron.add_class("expanded");
              this.expanded = true;
            } else {
              this.expanded = false;
            }
            ctrl_chevron.on("click", (e) => {
              e.stopPropagation();
              this.toggle_expand();
            });
            this.ctrl_chevron = ctrl_chevron;
            ctrl_header.add(ctrl_chevron);
          } else {
            const ctrl_spacer = new Control2({ context: context2 });
            ctrl_spacer.add_class("tree-chevron-spacer");
            ctrl_header.add(ctrl_spacer);
          }
          if (data_item.icon) {
            const ctrl_icon = new Control2({ context: context2 });
            ctrl_icon.add_class("tree-icon");
            ctrl_icon.add(data_item.icon);
            ctrl_header.add(ctrl_icon);
          }
          const ctrl_label = new Control2({ context: context2 });
          ctrl_label.add_class("tree-label");
          ctrl_label.add(data_item.label || data_item.name || "Node");
          ctrl_header.add(ctrl_label);
          if (data_item.children && data_item.children.length > 0) {
            const ctrl_children = new Control2({ context: context2 });
            ctrl_children.add_class("tree-children");
            if (!this.expanded) {
              ctrl_children.add_class("hidden");
            }
            each(data_item.children, (child_item) => {
              const child_node = new _Tree_Node({
                context: context2,
                data: child_item,
                tree: this.tree
              });
              ctrl_children.add(child_node);
            });
            this.ctrl_children = ctrl_children;
            this.add(ctrl_children);
          }
        }
        toggle_expand() {
          if (!this.ctrl_children) return;
          this.expanded = !this.expanded;
          if (this.expanded) {
            this.ctrl_children.remove_class("hidden");
            this.ctrl_chevron.add_class("expanded");
          } else {
            this.ctrl_children.add_class("hidden");
            this.ctrl_chevron.remove_class("expanded");
          }
          if (this.tree) {
            this.tree.raise("expand", { node: this.data_item, expanded: this.expanded });
          }
        }
      };
      Tree_View.css = `
.tree-view {
    display: flex;
    flex-direction: column;
    user-select: none;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 14px;
    color: #333;
}

.tree-node {
    display: flex;
    flex-direction: column;
}

.tree-node-header {
    display: flex;
    align-items: center;
    padding: 4px 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: background-color 0.1s;
}

.tree-node-header:hover {
    background-color: #f0f0f0;
}

.tree-node.selected > .tree-node-header {
    background-color: #e0eaff; /* Light blue selection */
    color: #0066cc;
}

.tree-chevron {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 4px;
    color: #888;
    transition: transform 0.2s ease;
    cursor: pointer;
    font-size: 10px;
}

.tree-chevron.expanded {
    transform: rotate(90deg);
}

.tree-chevron-spacer {
    width: 24px; 
}

.tree-icon {
    margin-right: 8px;
    font-size: 16px;
}

.tree-label {
    flex-grow: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.tree-children {
    display: flex;
    flex-direction: column;
    padding-left: 24px; /* Indent */
}

.tree-children.hidden {
    display: none;
}
`;
      module.exports = Tree_View;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/4-data/tree_table.js
  var require_tree_table = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/4-data/tree_table.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var normalize_columns = (columns) => {
        if (!Array.isArray(columns)) return [];
        return columns.map((column, index) => {
          if (typeof column === "string") {
            return { key: column, label: column };
          }
          if (column && typeof column === "object") {
            const key2 = is_defined(column.key) ? column.key : index;
            return {
              key: key2,
              label: is_defined(column.label) ? column.label : String(key2),
              accessor: column.accessor
            };
          }
          return { key: index, label: String(column) };
        });
      };
      var get_node_id = (node, fallback) => {
        if (is_defined(node.id)) return String(node.id);
        if (is_defined(node.__tree_table_id)) return String(node.__tree_table_id);
        if (is_defined(fallback)) {
          node.__tree_table_id = String(fallback);
          return node.__tree_table_id;
        }
        return void 0;
      };
      var flatten_nodes = (nodes, expanded_ids, depth = 0, results = [], parent_key = "") => {
        nodes.forEach((node, index) => {
          const node_key = parent_key ? `${parent_key}-${index}` : String(index);
          const node_id = get_node_id(node, node_key);
          results.push({ node, depth, node_id });
          const is_expanded = node_id && expanded_ids.includes(node_id);
          if (is_expanded && Array.isArray(node.children)) {
            flatten_nodes(node.children, expanded_ids, depth + 1, results, node_key);
          }
        });
        return results;
      };
      var get_cell_value = (row, column, column_index) => {
        if (column && typeof column.accessor === "function") {
          return column.accessor(row);
        }
        if (Array.isArray(row)) {
          const index = is_defined(column.index) ? column.index : column_index;
          return row[index];
        }
        if (row && typeof row === "object") {
          const key2 = is_defined(column.key) ? column.key : column_index;
          return row[key2];
        }
        return void 0;
      };
      var Tree_Table = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "tree_table";
          super(spec);
          this.add_class("tree-table");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.set_columns(spec.columns || []);
          this.set_rows(spec.rows || []);
          this.set_expanded_ids(spec.expanded_ids || []);
          if (!spec.el) {
            this.compose_tree_table();
          }
          this.bind_model();
        }
        compose_tree_table() {
          const { context: context2 } = this;
          const head_ctrl = new Control2({ context: context2, tag_name: "div" });
          head_ctrl.add_class("tree-table-head");
          const body_ctrl = new Control2({ context: context2, tag_name: "div" });
          body_ctrl.add_class("tree-table-body");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.head = head_ctrl;
          this._ctrl_fields.body = body_ctrl;
          this.add(head_ctrl);
          this.add(body_ctrl);
          this.render_table();
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            const name = e_change.name;
            if (name === "columns" || name === "rows" || name === "expanded_ids") {
              if (name === "columns") {
                this.columns = normalize_columns(e_change.value);
                if (this.model && typeof this.model.set === "function") {
                  this.model.set("columns", this.columns, true);
                }
              } else if (name === "rows") {
                this.rows = Array.isArray(e_change.value) ? e_change.value : [];
              } else if (name === "expanded_ids") {
                this.expanded_ids = Array.isArray(e_change.value) ? e_change.value.map(String) : [];
              }
              this.render_table();
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set table columns.
         * @param {Array} columns - Columns to set.
         */
        set_columns(columns) {
          const normalized = normalize_columns(columns);
          this.set_model_value("columns", normalized);
          this.columns = normalized;
        }
        /**
         * Set tree rows.
         * @param {Array} rows - Rows to set.
         */
        set_rows(rows) {
          const row_list = Array.isArray(rows) ? rows.slice() : [];
          this.set_model_value("rows", row_list);
          this.rows = row_list;
        }
        /**
         * Set expanded node ids.
         * @param {Array} expanded_ids - Expanded ids.
         */
        set_expanded_ids(expanded_ids) {
          const ids = Array.isArray(expanded_ids) ? expanded_ids.map(String) : [];
          this.set_model_value("expanded_ids", ids);
          this.expanded_ids = ids;
        }
        /**
         * Check whether a node id is expanded.
         * @param {*} node_id - Node id to check.
         * @returns {boolean}
         */
        is_expanded(node_id) {
          return this.expanded_ids && this.expanded_ids.includes(String(node_id));
        }
        /**
         * Toggle a node id.
         * @param {*} node_id - Node id to toggle.
         */
        toggle_node(node_id) {
          const id = String(node_id);
          const expanded_ids = this.expanded_ids ? this.expanded_ids.slice() : [];
          const index = expanded_ids.indexOf(id);
          if (index >= 0) {
            expanded_ids.splice(index, 1);
          } else {
            expanded_ids.push(id);
          }
          this.set_expanded_ids(expanded_ids);
        }
        /**
         * Get visible flattened nodes.
         * @returns {Array}
         */
        get_visible_nodes() {
          return this.visible_nodes || [];
        }
        render_table() {
          const head_ctrl = this._ctrl_fields && this._ctrl_fields.head;
          const body_ctrl = this._ctrl_fields && this._ctrl_fields.body;
          if (!head_ctrl || !body_ctrl) return;
          const columns = this.columns || [];
          head_ctrl.clear();
          const header_row = new Control2({ context: this.context, tag_name: "div" });
          header_row.add_class("tree-table-row");
          header_row.add_class("tree-table-header-row");
          columns.forEach((column) => {
            const cell_ctrl = new Control2({ context: this.context, tag_name: "div" });
            cell_ctrl.add_class("tree-table-cell");
            cell_ctrl.add_class("tree-table-header");
            cell_ctrl.add(column.label || String(column.key));
            header_row.add(cell_ctrl);
          });
          head_ctrl.add(header_row);
          body_ctrl.clear();
          const flattened = flatten_nodes(this.rows || [], this.expanded_ids || []);
          this.visible_nodes = flattened;
          flattened.forEach((entry, row_index) => {
            const { node, depth, node_id } = entry;
            const row_ctrl = new Control2({ context: this.context, tag_name: "div" });
            row_ctrl.add_class("tree-table-row");
            row_ctrl.dom.attributes["data-node-index"] = String(row_index);
            if (is_defined(node_id)) {
              row_ctrl.dom.attributes["data-node-id"] = String(node_id);
            }
            columns.forEach((column, column_index) => {
              const cell_ctrl = new Control2({ context: this.context, tag_name: "div" });
              cell_ctrl.add_class("tree-table-cell");
              if (column_index === 0) {
                const indent_ctrl = new Control2({ context: this.context, tag_name: "span" });
                indent_ctrl.add_class("tree-table-indent");
                indent_ctrl.dom.attributes.style["padding-left"] = `${depth * 16}px`;
                if (Array.isArray(node.children) && node.children.length) {
                  const toggle_ctrl = new Control2({ context: this.context, tag_name: "button" });
                  toggle_ctrl.dom.attributes.type = "button";
                  toggle_ctrl.add_class("tree-table-toggle");
                  toggle_ctrl.dom.attributes["data-toggle-id"] = String(node_id);
                  toggle_ctrl.dom.attributes["aria-expanded"] = this.is_expanded(node_id) ? "true" : "false";
                  toggle_ctrl.add(this.is_expanded(node_id) ? "-" : "+");
                  indent_ctrl.add(toggle_ctrl);
                }
                const label_ctrl = new Control2({ context: this.context, tag_name: "span" });
                label_ctrl.add_class("tree-table-label");
                const label_value = is_defined(node.label) ? node.label : get_cell_value(node, column, column_index);
                if (is_defined(label_value)) label_ctrl.add(String(label_value));
                indent_ctrl.add(label_ctrl);
                cell_ctrl.add(indent_ctrl);
              } else {
                let value2;
                if (typeof column.accessor === "function") {
                  value2 = column.accessor(node);
                } else {
                  value2 = get_cell_value(node, column, column_index);
                }
                if (is_defined(value2)) cell_ctrl.add(String(value2));
              }
              row_ctrl.add(cell_ctrl);
            });
            body_ctrl.add(row_ctrl);
          });
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const body_ctrl = this._ctrl_fields && this._ctrl_fields.body;
            if (!body_ctrl || !body_ctrl.dom.el) return;
            body_ctrl.add_dom_event_listener("click", (e_click) => {
              const target = e_click.target;
              if (!target || !target.getAttribute) return;
              const toggle_id = target.getAttribute("data-toggle-id");
              if (is_defined(toggle_id)) {
                this.toggle_node(toggle_id);
                return;
              }
            });
          }
        }
      };
      Tree_Table.css = `
.tree-table {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.tree-table-row {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: 1fr;
    gap: 12px;
    padding: 4px 0;
}
.tree-table-header {
    font-weight: 600;
}
.tree-table-toggle {
    margin-right: 6px;
}
`;
      module.exports = Tree_Table;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/url_input.js
  var require_url_input = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/url_input.js"(exports, module) {
      var Text_Input = require_Text_Input();
      var Url_Input = class extends Text_Input {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "url_input";
          super(spec);
          this.add_class("url-input");
          this.dom.attributes.type = "url";
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="url"]', Url_Input, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Url_Input;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/center.js
  var require_center = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/center.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var Center = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "center";
          super(spec);
          this.add_class("center");
          this.dom.tagName = "div";
          this.min_height = Number.isFinite(Number(spec.min_height)) ? Number(spec.min_height) : null;
          this.max_width = Number.isFinite(Number(spec.max_width)) ? Number(spec.max_width) : null;
          this.apply_layout();
        }
        /**
         * Set minimum height.
         * @param {number} min_height - Min height in px.
         */
        set_min_height(min_height) {
          const next_value = Number(min_height);
          if (Number.isFinite(next_value)) {
            this.min_height = next_value;
            this.apply_layout();
          }
        }
        /**
         * Set max width.
         * @param {number} max_width - Max width in px.
         */
        set_max_width(max_width) {
          const next_value = Number(max_width);
          if (Number.isFinite(next_value)) {
            this.max_width = next_value;
            this.apply_layout();
          }
        }
        apply_layout() {
          this.dom.attributes.style.display = "grid";
          this.dom.attributes.style.placeItems = "center";
          if (Number.isFinite(this.min_height)) {
            this.dom.attributes.style.minHeight = `${this.min_height}px`;
          }
          if (Number.isFinite(this.max_width)) {
            this.dom.attributes.style.maxWidth = `${this.max_width}px`;
            this.dom.attributes.style.margin = "0 auto";
          }
        }
      };
      module.exports = Center;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/stepper.js
  var require_stepper = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/stepper.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var normalize_steps = (steps) => {
        if (!Array.isArray(steps)) return [];
        return steps.map((step, index) => {
          if (step && typeof step === "object") {
            return {
              id: is_defined(step.id) ? String(step.id) : `step-${index}`,
              title: is_defined(step.title) ? step.title : `Step ${index + 1}`,
              content: step.content,
              completed: !!step.completed
            };
          }
          return {
            id: `step-${index}`,
            title: String(step),
            content: void 0,
            completed: false
          };
        });
      };
      var Stepper = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "stepper";
          super(spec);
          this.add_class("stepper");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          this.set_steps(spec.steps || []);
          this.set_current_step(is_defined(spec.current_step) ? spec.current_step : 0);
          if (!spec.el) {
            this.compose_stepper();
          }
          this.bind_model();
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            if (e_change.name === "steps") {
              this.steps = normalize_steps(e_change.value);
              this.render_steps();
            }
            if (e_change.name === "current_step") {
              this.current_step = Number(e_change.value) || 0;
              this.render_steps();
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set steps.
         * @param {Array} steps - Steps to set.
         */
        set_steps(steps) {
          const normalized = normalize_steps(steps);
          this.set_model_value("steps", normalized);
          this.steps = normalized;
        }
        /**
         * Set current step index.
         * @param {number} index - Step index.
         */
        set_current_step(index) {
          const next_index = Math.max(0, Number(index) || 0);
          this.set_model_value("current_step", next_index);
          this.current_step = next_index;
        }
        /**
         * Get current step index.
         * @returns {number}
         */
        get_current_step() {
          return this.current_step || 0;
        }
        /**
         * Mark a step completed.
         * @param {number} index - Step index.
         */
        mark_completed(index) {
          if (!Array.isArray(this.steps)) return;
          const next_steps = this.steps.slice();
          if (next_steps[index]) {
            next_steps[index] = { ...next_steps[index], completed: true };
            this.set_steps(next_steps);
          }
        }
        /**
         * Move to next step.
         */
        next() {
          const next_index = Math.min(this.steps.length - 1, this.get_current_step() + 1);
          this.set_current_step(next_index);
          this.raise("step_change", { current_step: this.current_step });
        }
        /**
         * Move to previous step.
         */
        previous() {
          const next_index = Math.max(0, this.get_current_step() - 1);
          this.set_current_step(next_index);
          this.raise("step_change", { current_step: this.current_step });
        }
        compose_stepper() {
          const { context: context2 } = this;
          const header_ctrl = new Control2({ context: context2, tag_name: "ol" });
          header_ctrl.add_class("stepper-header");
          const body_ctrl = new Control2({ context: context2, tag_name: "div" });
          body_ctrl.add_class("stepper-body");
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.header = header_ctrl;
          this._ctrl_fields.body = body_ctrl;
          this.add(header_ctrl);
          this.add(body_ctrl);
          this.render_steps();
        }
        render_steps() {
          const header_ctrl = this._ctrl_fields && this._ctrl_fields.header;
          const body_ctrl = this._ctrl_fields && this._ctrl_fields.body;
          if (!header_ctrl || !body_ctrl) return;
          header_ctrl.clear();
          body_ctrl.clear();
          const steps = this.steps || [];
          const current_index = this.get_current_step();
          steps.forEach((step, index) => {
            const item_ctrl = new Control2({ context: this.context, tag_name: "li" });
            item_ctrl.add_class("stepper-step");
            if (index === current_index) item_ctrl.add_class("is-current");
            if (step.completed) item_ctrl.add_class("is-complete");
            const button_ctrl = new Control2({ context: this.context, tag_name: "button" });
            button_ctrl.dom.attributes.type = "button";
            button_ctrl.dom.attributes["data-step-index"] = String(index);
            button_ctrl.add_class("stepper-step-button");
            button_ctrl.dom.attributes["aria-current"] = index === current_index ? "step" : "false";
            button_ctrl.add(step.title);
            item_ctrl.add(button_ctrl);
            header_ctrl.add(item_ctrl);
          });
          const current_step = steps[current_index];
          if (current_step && is_defined(current_step.content)) {
            body_ctrl.add(current_step.content);
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const header_ctrl = this._ctrl_fields && this._ctrl_fields.header;
            if (!header_ctrl || !header_ctrl.dom.el) return;
            header_ctrl.add_dom_event_listener("click", (e_click) => {
              const target = e_click.target;
              if (!target || !target.getAttribute) return;
              const index_str = target.getAttribute("data-step-index");
              if (!is_defined(index_str)) return;
              const index = Number(index_str);
              if (!Number.isFinite(index)) return;
              this.set_current_step(index);
              this.raise("step_change", { current_step: this.current_step });
            });
          }
        }
      };
      Stepper.css = `
.stepper {
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.stepper-header {
    list-style: none;
    display: flex;
    gap: 8px;
    padding: 0;
    margin: 0;
}
.stepper-step {
    flex: 1;
}
.stepper-step-button {
    width: 100%;
    padding: 8px 10px;
    border-radius: 6px;
    border: 1px solid #ccc;
    background: #fff;
    cursor: pointer;
}
.stepper-step.is-current .stepper-step-button {
    border-color: #666;
    background: #f5f5f5;
}
.stepper-step.is-complete .stepper-step-button {
    border-color: #3c8c3c;
}
.stepper-body {
    border: 1px solid #eee;
    padding: 12px;
    border-radius: 8px;
    background: #fff;
}
`;
      module.exports = Stepper;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/window_manager.js
  var require_window_manager = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/window_manager.js"(exports, module) {
      var is_defined = (value2) => value2 !== void 0 && value2 !== null;
      var parse_px = (value2) => {
        if (typeof value2 === "number") return value2;
        if (typeof value2 === "string") {
          const parsed = parseFloat(value2);
          return Number.isNaN(parsed) ? 0 : parsed;
        }
        return 0;
      };
      var get_ctrl_size = (ctrl) => {
        if (ctrl && Array.isArray(ctrl.size) && ctrl.size.length === 2) {
          const [width, height2] = ctrl.size;
          if (is_defined(width) && is_defined(height2)) {
            return [Number(width), Number(height2)];
          }
        }
        const style = ctrl && ctrl.dom && ctrl.dom.attributes && ctrl.dom.attributes.style;
        if (style) {
          const width = parse_px(style.width);
          const height2 = parse_px(style.height);
          if (width || height2) return [width, height2];
        }
        if (ctrl && ctrl.dom && ctrl.dom.el && typeof ctrl.dom.el.getBoundingClientRect === "function") {
          const rect = ctrl.dom.el.getBoundingClientRect();
          return [rect.width, rect.height];
        }
        return [0, 0];
      };
      var get_ctrl_pos = (ctrl) => {
        if (ctrl && typeof ctrl.left === "number" && typeof ctrl.top === "number") {
          return [ctrl.left, ctrl.top];
        }
        if (ctrl && Array.isArray(ctrl.pos) && ctrl.pos.length === 2) {
          return [Number(ctrl.pos[0]), Number(ctrl.pos[1])];
        }
        const style = ctrl && ctrl.dom && ctrl.dom.attributes && ctrl.dom.attributes.style;
        if (style) {
          const left = parse_px(style.left);
          const top = parse_px(style.top);
          return [left, top];
        }
        return [0, 0];
      };
      var reset_translate = (ctrl) => {
        if (ctrl && ctrl.ta && ctrl.ta.length >= 8) {
          ctrl.ta[6] = 0;
          ctrl.ta[7] = 0;
        }
      };
      var Window_Manager = class {
        constructor(options = {}) {
          this.windows = /* @__PURE__ */ new Set();
          this.next_z = options.base_z || 1e3;
          this.snap_threshold = options.snap_threshold || 24;
        }
        register(window_ctrl) {
          if (!window_ctrl) return;
          this.windows.add(window_ctrl);
          window_ctrl.manager = this;
          this.ensure_z(window_ctrl);
        }
        unregister(window_ctrl) {
          if (!window_ctrl) return;
          this.windows.delete(window_ctrl);
        }
        ensure_z(window_ctrl) {
          if (!window_ctrl || !window_ctrl.dom || !window_ctrl.dom.attributes) return;
          const style = window_ctrl.dom.attributes.style;
          if (!is_defined(style["z-index"])) {
            style["z-index"] = this.next_z++;
          }
        }
        bring_to_front(window_ctrl) {
          if (!window_ctrl || !window_ctrl.dom || !window_ctrl.dom.attributes) return;
          const style = window_ctrl.dom.attributes.style;
          style["z-index"] = this.next_z++;
        }
        get_parent_bounds(window_ctrl) {
          const parent = window_ctrl && window_ctrl.parent;
          if (!parent) {
            return {
              pos: [0, 0],
              size: [0, 0]
            };
          }
          const size = get_ctrl_size(parent);
          const pos = get_ctrl_pos(parent);
          return {
            pos,
            size
          };
        }
        dock(window_ctrl, edge, options = {}) {
          if (!window_ctrl) return;
          const bounds2 = this.get_parent_bounds(window_ctrl);
          const [parent_left, parent_top] = bounds2.pos;
          const [parent_width, parent_height] = bounds2.size;
          if (!parent_width || !parent_height) return;
          const dock_edge = edge || "left";
          if (!window_ctrl._pre_dock_state) {
            window_ctrl._pre_dock_state = {
              pos: get_ctrl_pos(window_ctrl),
              size: get_ctrl_size(window_ctrl)
            };
          }
          const size_override = options.size;
          let next_pos = [parent_left, parent_top];
          let next_size = [parent_width, parent_height];
          if (dock_edge === "left") {
            next_size = size_override || [Math.round(parent_width / 2), parent_height];
            next_pos = [parent_left, parent_top];
          } else if (dock_edge === "right") {
            next_size = size_override || [Math.round(parent_width / 2), parent_height];
            next_pos = [parent_left + parent_width - next_size[0], parent_top];
          } else if (dock_edge === "top") {
            next_size = size_override || [parent_width, Math.round(parent_height / 2)];
            next_pos = [parent_left, parent_top];
          } else if (dock_edge === "bottom") {
            next_size = size_override || [parent_width, Math.round(parent_height / 2)];
            next_pos = [parent_left, parent_top + parent_height - next_size[1]];
          } else if (dock_edge === "fill") {
            next_size = size_override || [parent_width, parent_height];
            next_pos = [parent_left, parent_top];
          }
          reset_translate(window_ctrl);
          window_ctrl.pos = next_pos;
          window_ctrl.size = next_size;
          window_ctrl.docked_edge = dock_edge;
          if (window_ctrl.add_class) {
            window_ctrl.add_class(`docked-${dock_edge}`);
          }
        }
        undock(window_ctrl) {
          if (!window_ctrl || !window_ctrl._pre_dock_state) return;
          const { pos, size } = window_ctrl._pre_dock_state;
          reset_translate(window_ctrl);
          if (pos) window_ctrl.pos = pos;
          if (size) window_ctrl.size = size;
          if (window_ctrl.docked_edge && window_ctrl.remove_class) {
            window_ctrl.remove_class(`docked-${window_ctrl.docked_edge}`);
          }
          window_ctrl.docked_edge = null;
          window_ctrl._pre_dock_state = null;
        }
        snap(window_ctrl, options = {}) {
          const threshold = is_defined(options.threshold) ? options.threshold : this.snap_threshold;
          const bounds2 = this.get_parent_bounds(window_ctrl);
          const [parent_left, parent_top] = bounds2.pos;
          const [parent_width, parent_height] = bounds2.size;
          if (!parent_width || !parent_height) return false;
          const pos = get_ctrl_pos(window_ctrl);
          const size = get_ctrl_size(window_ctrl);
          const [left, top] = pos;
          const [width, height2] = size;
          const right = left + width;
          const bottom = top + height2;
          const dist_left = Math.abs(left - parent_left);
          const dist_right = Math.abs(right - (parent_left + parent_width));
          const dist_top = Math.abs(top - parent_top);
          const dist_bottom = Math.abs(bottom - (parent_top + parent_height));
          if (dist_left <= threshold) {
            this.dock(window_ctrl, "left", options);
            return true;
          }
          if (dist_right <= threshold) {
            this.dock(window_ctrl, "right", options);
            return true;
          }
          if (dist_top <= threshold) {
            this.dock(window_ctrl, "top", options);
            return true;
          }
          if (dist_bottom <= threshold) {
            this.dock(window_ctrl, "bottom", options);
            return true;
          }
          return false;
        }
      };
      var get_window_manager = (context2) => {
        if (context2 && context2.window_manager) return context2.window_manager;
        if (context2) {
          context2.window_manager = new Window_Manager();
          return context2.window_manager;
        }
        if (!get_window_manager._singleton) {
          get_window_manager._singleton = new Window_Manager();
        }
        return get_window_manager._singleton;
      };
      module.exports = {
        Window_Manager,
        get_window_manager
      };
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/6-layout/window.js
  var require_window = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/6-layout/window.js"(exports, module) {
      var jsgui = require_html_core();
      var Horizontal_Menu = require_horizontal_menu();
      var Button = require_button();
      var { def, each } = jsgui;
      var Control2 = jsgui.Control;
      var { dragable, resizable } = require_mx();
      var { get_window_manager } = require_window_manager();
      var {
        apply_focus_ring,
        ensure_sr_text
      } = require_a11y();
      var { resolve_params, apply_hooks } = require_theme_params();
      var BUTTON_ICONS = {
        "traffic-light": { minimize: "\u25CF", maximize: "\u25CF", close: "\u25CF" },
        "icons": { minimize: "\u2296", maximize: "\u2295", close: "\u2297" },
        "text": { minimize: "_", maximize: "\u25A1", close: "\xD7" },
        "outlined": { minimize: "\u2212", maximize: "\u25A1", close: "\xD7" },
        "minimal": { minimize: "\u2212", maximize: "+", close: "\xD7" },
        "segoe": { minimize: "\uE921", maximize: "\uE922", close: "\uE8BB" }
      };
      var TRAFFIC_LIGHT_COLORS = {
        close: "#ff5f57",
        minimize: "#ffbd2e",
        maximize: "#28c840"
      };
      var Window = class extends Control2 {
        constructor(spec, add, make) {
          super(spec);
          this.__type_name = "window";
          this.add_class("window");
          const { params, hooks } = resolve_params("window", spec, this.context);
          this._theme_params = params;
          apply_hooks(this, hooks);
          const snap_enabled = spec.snap !== false;
          this.snap_enabled = snap_enabled;
          this.snap_threshold = def(spec.snap_threshold) ? spec.snap_threshold : void 0;
          this.dock_sizes = spec.dock_sizes;
          this.min_size = spec.min_size || [120, 80];
          this.max_size = spec.max_size;
          this.resize_bounds = spec.resize_bounds || spec.extent_bounds || null;
          this.manager = spec.window_manager || spec.manager || null;
          const show_buttons = def(spec.show_buttons) ? spec.show_buttons : params.show_buttons !== false;
          if (!spec.abstract && !spec.el) {
            const { context: context2 } = this;
            const div_relative = new Control2({
              context: context2
            });
            div_relative.add_class("relative");
            const title_bar = new Control2({
              context: context2
            });
            title_bar.add_class("title");
            title_bar.add_class("bar");
            const title_h2 = new jsgui.controls.h2({
              context: context2
            });
            title_bar.add(title_h2);
            if (typeof spec.title === "string") {
              title_h2.add(spec.title);
            }
            div_relative.add(title_bar);
            let btn_minimize, btn_maximize, btn_close;
            if (show_buttons) {
              const button_group = new Control2({
                context: context2
              });
              button_group.add_class("button-group");
              button_group.add_class(params.button_position || "right");
              const button_style = params.button_style || "icons";
              const icons = BUTTON_ICONS[button_style] || BUTTON_ICONS.icons;
              const button_order = params.button_order || ["minimize", "maximize", "close"];
              const span = (text) => {
                const res2 = new jsgui.controls.span({ context: context2 });
                res2.add(text);
                return res2;
              };
              const sr_labels = {
                minimize: "Minimize window",
                maximize: "Maximize window",
                close: "Close window"
              };
              for (const btn_type of button_order) {
                if (btn_type === "minimize" && params.show_minimize === false) continue;
                if (btn_type === "maximize" && params.show_maximize === false) continue;
                if (btn_type === "close" && params.show_close === false) continue;
                const btn = new Button({ context: context2 });
                btn.add_class(btn_type);
                btn.add(span(icons[btn_type] || ""));
                apply_focus_ring(btn);
                ensure_sr_text(btn, sr_labels[btn_type], { add_sr_only: false });
                if (button_style === "traffic-light" && TRAFFIC_LIGHT_COLORS[btn_type]) {
                  btn.dom.attributes = btn.dom.attributes || {};
                  btn.dom.attributes.style = btn.dom.attributes.style || {};
                  btn.dom.attributes.style["--btn-color"] = TRAFFIC_LIGHT_COLORS[btn_type];
                }
                button_group.add(btn);
                if (btn_type === "minimize") btn_minimize = btn;
                if (btn_type === "maximize") btn_maximize = btn;
                if (btn_type === "close") btn_close = btn;
              }
              title_bar.add(button_group);
            }
            const ctrl_inner = new Control2({
              context: context2
            });
            ctrl_inner.add_class("inner");
            div_relative.add(ctrl_inner);
            this.add(div_relative);
            this.ctrl_inner = ctrl_inner;
            this.inner = ctrl_inner;
            this.title_bar = title_bar;
            this.ctrl_relative = div_relative;
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.ctrl_inner = ctrl_inner;
            this._ctrl_fields.inner = ctrl_inner;
            this._ctrl_fields.title_bar = title_bar;
            this._ctrl_fields.ctrl_relative = div_relative;
            if (show_buttons) {
              this._ctrl_fields.btn_minimize = btn_minimize;
              this._ctrl_fields.btn_maximize = btn_maximize;
              this._ctrl_fields.btn_close = btn_close;
            }
          }
        }
        bring_to_front_z() {
          if (this.manager && typeof this.manager.bring_to_front === "function") {
            this.manager.bring_to_front(this);
            return;
          }
          let max_z = 0;
          if (this.parent && this.parent.content) {
            each(this.parent.content, (ctrl) => {
              if (ctrl !== this) {
                const z = parseInt(ctrl.dom.attributes.style["z-index"]);
                if (!isNaN(z) && z > max_z) max_z = z;
              }
            });
          }
          this.dom.attributes.style["z-index"] = parseInt(max_z) + 1;
        }
        /**
         * Snap the window to nearby edges.
         * @param {Object} [options] - Optional settings.
         * @returns {boolean}
         */
        snap_to_bounds(options = {}) {
          if (!this.manager) return false;
          const snap_options = Object.assign({}, options);
          if (this.snap_threshold !== void 0) {
            snap_options.threshold = this.snap_threshold;
          }
          if (this.dock_sizes) {
            snap_options.size = this.dock_sizes;
          }
          return this.manager.snap(this, snap_options);
        }
        /**
         * Dock the window to a specific edge.
         * @param {string} edge - Dock edge.
         * @param {Object} [options] - Optional settings.
         */
        dock_to(edge, options = {}) {
          if (this.manager && typeof this.manager.dock === "function") {
            const dock_options = Object.assign({}, options);
            if (this.dock_sizes) dock_options.size = this.dock_sizes;
            return this.manager.dock(this, edge, dock_options);
          }
        }
        /**
         * Undock the window and restore size/position.
         */
        undock() {
          if (this.manager && typeof this.manager.undock === "function") {
            this.manager.undock(this);
          }
        }
        glide_to_pos(pos) {
          return new Promise((s, j) => {
            const [my_new_left, my_new_top] = pos;
            const x_diff = my_new_left - this.ta[6];
            const y_diff = my_new_top - this.ta[7];
            const ms_total_animation_time = 140;
            let animation_start;
            const start_tx = this.ta[6];
            const start_ty = this.ta[7];
            let i_frame = 0;
            const skip_zeroth_frame = false;
            const process_frame = () => {
              if (skip_zeroth_frame && i_frame === 0) {
                requestAnimationFrame((timestamp) => {
                  i_frame++;
                  process_frame();
                });
              } else {
                requestAnimationFrame((timestamp) => {
                  if (!animation_start) {
                    animation_start = timestamp;
                    process_frame();
                  } else {
                    const time_since = timestamp - animation_start;
                    if (time_since < ms_total_animation_time) {
                      const proportion_through = time_since / ms_total_animation_time;
                      const proportional_x_diff = x_diff * proportion_through;
                      const proportional_y_diff = y_diff * proportion_through;
                      this.ta[6] = start_tx + proportional_x_diff;
                      this.ta[7] = start_ty + proportional_y_diff;
                      i_frame++;
                      process_frame();
                    } else {
                      this.ta[6] = start_tx + x_diff;
                      this.ta[7] = start_ty + y_diff;
                      s();
                    }
                  }
                });
              }
            };
            process_frame();
          });
        }
        async minimize() {
          if (this.manager && typeof this.manager.minimize === "function") {
            this.manager.minimize(this);
          } else {
            const has_parent_bounds = this.parent && typeof this.parent.bcr === "function";
            if (!has_parent_bounds) {
              if (this.has_class("minimized")) {
                this.remove_class("minimized");
              } else {
                this.add_class("minimized");
              }
              return;
            }
            const my_bcr = this.bcr();
            if (!this.has_class("minimized")) {
              const width_to_minimize_to = 280;
              const minimized_height = 31;
              if (this.has_class("maximized")) {
                this.was_maximized_just_before_minimizing = true;
                this.pre_minimized_pos = this.pre_maximized_pos;
                this.pre_minimized_size = this.pre_maximized_size;
                this.remove_class("maximized");
              } else {
                this.was_maximized_just_before_minimizing = false;
                this.pre_minimized_pos = my_bcr[0];
                this.pre_minimized_size = my_bcr[2];
              }
              this.dragable = false;
              const parent_bcr = this.parent.bcr();
              const parent_size = parent_bcr[2];
              setTimeout(() => {
                this.size = [width_to_minimize_to, minimized_height];
              }, 17);
              const determine_pos_to_minimize_to = () => {
                let minimized_sibling_window_bcrs = [];
                each(this.parent.content, (ctrl) => {
                  if (ctrl !== this) {
                    if (ctrl.has_class("window") && ctrl.has_class("minimized")) {
                      const ctrl_bcr = ctrl.bcr();
                      minimized_sibling_window_bcrs.push(ctrl_bcr);
                    }
                  }
                });
                if (minimized_sibling_window_bcrs.length > 0) {
                  minimized_sibling_window_bcrs.sort((a, b) => {
                    if (a[0][1] === b[0][1]) {
                      return a[1][0] - b[1][0];
                    } else {
                      return b[0][1] - a[0][1];
                    }
                  });
                  const last_bcr = minimized_sibling_window_bcrs.at(-1);
                  const last_r = last_bcr[1][0];
                  const extra_margin = 2;
                  if (parent_size[0] >= last_r + width_to_minimize_to + extra_margin) {
                    return [last_bcr[1][0] + extra_margin, last_bcr[0][1]];
                  } else {
                    return [0, last_bcr[0][1] - extra_margin - minimized_height];
                  }
                } else {
                  return [0, parent_size[1] - minimized_height];
                }
              };
              const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map((x) => parseInt(x));
              const dest_pos = determine_pos_to_minimize_to();
              dest_pos[0] -= ltpos[0];
              dest_pos[1] -= ltpos[1];
              await this.glide_to_pos(dest_pos);
              this.add_class("minimized");
            } else {
              if (this.was_maximized_just_before_minimizing) {
                await this.maximize();
              } else {
                setTimeout(() => {
                  this.size = this.pre_minimized_size;
                }, 17);
                const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map((x) => parseInt(x));
                const dest_pos = [this.pre_minimized_pos[0] - ltpos[0], this.pre_minimized_pos[1] - ltpos[1]];
                await this.glide_to_pos(dest_pos);
                this.remove_class("minimized");
                this.dragable = true;
              }
            }
          }
        }
        async maximize() {
          if (this.manager && typeof this.manager.maximize === "function") {
            this.manager.maximize(this);
          } else {
            if (this.has_class("maximized")) {
              this.remove_class("maximized");
              setTimeout(() => {
                this.size = [this.pre_maximized_size[0] - 2, this.pre_maximized_size[1] - 2];
              }, 17);
              this.dragable = true;
              const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map((x) => parseInt(x));
              const dest_pos = [this.pre_maximized_pos[0] - ltpos[0], this.pre_maximized_pos[1] - ltpos[1]];
              await this.glide_to_pos(dest_pos);
            } else {
              const my_bcr = this.bcr();
              const ltpos = [this.dom.attributes.style.left, this.dom.attributes.style.top].map((x) => parseInt(x));
              if (this.has_class("minimized")) {
                this.remove_class("minimized");
                this.pre_maximized_pos = this.pre_minimized_pos;
                this.pre_maximized_size = this.pre_minimized_size;
              } else {
                this.pre_maximized_pos = my_bcr[0];
                this.pre_maximized_size = my_bcr[2];
              }
              this.add_class("maximized");
              this.dragable = false;
              const parent_bcr = this.parent.bcr();
              const parent_size = parent_bcr[2];
              setTimeout(() => {
                this.size = [parent_size[0] - 4, parent_size[1] - 4];
              }, 17);
              const [tx, ty] = [this.ta[6], this.ta[7]];
              const dest_pos = [0 - ltpos[0], 0 - ltpos[1]];
              await this.glide_to_pos(dest_pos);
            }
          }
        }
        close() {
          if (this.manager && typeof this.manager.close === "function") {
            this.manager.close(this);
          } else {
            this.remove();
          }
        }
        "activate"() {
          if (!this.__active) {
            super.activate();
            if (!this.manager) {
              this.manager = get_window_manager(this.context);
            }
            if (this.manager && typeof this.manager.register === "function") {
              this.manager.register(this);
            }
            const { title_bar, btn_minimize, btn_maximize, btn_close } = this;
            if (btn_close) {
              btn_close.on("click", () => {
                this.close();
              });
              btn_close.on("press", () => {
                this.close();
              });
            }
            if (btn_maximize) {
              btn_maximize.on("click", () => {
                this.maximize();
              });
              btn_maximize.on("press", () => {
                this.maximize();
              });
            }
            if (btn_minimize) {
              btn_minimize.on("click", () => {
                this.minimize();
              });
              btn_minimize.on("press", () => {
                this.minimize();
              });
            }
            const dom_el = this.dom && this.dom.el;
            const dom_title_bar = dom_el ? dom_el.querySelector(".title.bar") : null;
            const dom_buttons = dom_el ? dom_el.querySelectorAll(".title.bar button.button") : null;
            const dom_minimize_button = dom_buttons && dom_buttons[0] ? dom_buttons[0] : null;
            const dom_maximize_button = dom_buttons && dom_buttons[1] ? dom_buttons[1] : null;
            const dom_close_button = dom_buttons && dom_buttons[2] ? dom_buttons[2] : null;
            if (!btn_minimize && dom_minimize_button) {
              dom_minimize_button.addEventListener("click", () => {
                this.minimize();
              });
            }
            if (!btn_maximize && dom_maximize_button) {
              dom_maximize_button.addEventListener("click", () => {
                this.maximize();
              });
            }
            if (!btn_close && dom_close_button) {
              dom_close_button.addEventListener("click", () => {
                this.close();
              });
            }
            if (title_bar) {
              title_bar.on("dblclick", () => {
                this.maximize();
              });
            } else if (dom_title_bar) {
              dom_title_bar.addEventListener("dblclick", () => {
                this.maximize();
              });
            }
            this.on("mousedown", () => {
              this.bring_to_front_z();
            });
            dragable(this, {
              drag_mode: "translate",
              handle: this.title_bar,
              bounds: this.parent
            });
            this.dragable = true;
            resizable(this, {
              resize_mode: "br_handle",
              bounds: [this.min_size, this.max_size],
              extent_bounds: this.resize_bounds || this.parent
            });
            if (this.snap_enabled) {
              this.on("dragend", () => {
                this.snap_to_bounds();
              });
            }
            setInterval(() => {
              if (this.has_class("minimized")) {
                const extended_bcr = this.bcr().extend("left", 80);
                const minimized_siblings = this.siblings.filter((x) => x.has_class("minimized"));
                const overlaps = extended_bcr.overlaps(minimized_siblings);
                if (overlaps && overlaps.length > 0) {
                  const max_overlap_width = Math.max(...overlaps.map((x) => x.w));
                  if (max_overlap_width <= 78) {
                    const parent_bcr = this.parent.bcr();
                    const parent_left = parent_bcr[0][0];
                    const my_bcr = this.bcr();
                    const my_left = my_bcr[0][0];
                    const dist_from_parent_left = my_left - parent_left;
                    if (dist_from_parent_left > 2) {
                      this.ta[6] = this.ta[6] - 1;
                    }
                  }
                } else {
                  const parent_bcr = this.parent.bcr();
                  const parent_left = parent_bcr[0][0];
                  const my_bcr = this.bcr();
                  const my_left = my_bcr[0][0];
                  const dist_from_parent_left = my_left - parent_left;
                  if (dist_from_parent_left > 2) {
                    if (dist_from_parent_left > 8) {
                      this.ta[6] = this.ta[6] - 8;
                    } else {
                      this.ta[6] = this.ta[6] - dist_from_parent_left;
                    }
                  }
                }
              }
            }, 18);
          }
        }
      };
      Window.css = `
.relative {
	position: relative;
}
.window.no-transitions {
	transition: none !important; 
}
:root {
	--rhsqsize: 16px;
}
.resize-handle {
	width: var(--rhsqsize);
	height: var(--rhsqsize);
	color: #CCCCCC;
	opacity: 0.45;
	position: absolute;
	line-height: var(--rhsqsize);
	font-size: var(--rhsqsize);
	user-select: none;
	transition: color 0.14s ease-in-out, opacity 0.14s ease-in-out;
}
.resize-handle:hover {
	color: #EFCF00;
	opacity: 0.5;
}
.resize-handle.resizing {
	color: #FFDF00;
	opacity: 1;
}
.bottom-right.resize-handle {
	right: 0;
	bottom: 0;
	cursor: nwse-resize;
	z-index: 10000001;
}
.window {
    position: absolute;
    border: 1px solid #CCCCCC;
	background-color: #F4F4F4;
	width: 360px;
	height: 360px;
	border-radius: 5px;
	transition: width 0.14s linear, height 0.14s linear; 
	overflow: hidden;
	-webkit-user-select: none;
	user-select: none;
}
.window .relative {
	height: inherit;
	overflow: hidden;
}
.window.minimized {
	height: 31px;
}
.window.minimized .bottom-right.resize-handle {
	display: none;
}
.window.maximized .bottom-right.resize-handle {
	display: none;
}
.window.docked-left,
.window.docked-right,
.window.docked-top,
.window.docked-bottom,
.window.docked-fill {
	border-radius: 0;
}
.window .title.bar {
    height: 31px;
	background-color: #0D4F8B;
	background-image: linear-gradient(to right, #0D4F8B , #3fb0d9);
    color: #FFFFFF;
    font-size: 12px;
    line-height: 32px;
    text-indent: 4px;
    -webkit-box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
    -moz-box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
    box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
	border-radius: 4px;
	-webkit-user-select: none;
	user-select: none;
	overflow: hidden;
	cursor: default;
}
.window .title.bar h2 {
	font-weight: 400;
	margin-left: 42px;
	float: left;
}
.window .title.bar > span {
    vertical-align: middle;
    line-height: 31px;
}
.window .title.bar .button > span {
	transform: scale(2);
    display: inline-block;
	line-height: 13px;
    height: 14px;
}
.window .title.bar .right {
    margin-right: 2px;
    margin-top: 2px;
    position: absolute;
    right: 0;
    top: 0;
	height: 29px;
}
.window .title.bar .button {
    width: 26px;
	height: 26px;
	line-height: 24px;
	font-size: 14px;
}
.window .title.bar .button + .button {
    margin-left: 3px;
}
.window .relative .inner {
	width: 100%;
	height: calc(100% - 31px);
}
`;
      module.exports = Window;
    }
  });

  // ../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/password_input.js
  var require_password_input = __commonJS({
    "../jsgui3-html/controls/organised/0-core/0-basic/0-native-compositional/password_input.js"(exports, module) {
      var Text_Input = require_Text_Input();
      var Password_Input = class extends Text_Input {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "password_input";
          super(spec);
          this.add_class("password-input");
          this.dom.attributes.type = "password";
        }
      };
      var { register_swap } = require_swap_registry();
      var should_enhance = (el) => {
        if (!el || !el.classList) return false;
        if (el.classList.contains("jsgui-enhance")) return true;
        if (typeof el.closest === "function" && el.closest(".jsgui-form")) return true;
        return false;
      };
      register_swap('input[type="password"]', Password_Input, {
        enhancement_mode: "enhance",
        predicate: should_enhance
      });
      module.exports = Password_Input;
    }
  });

  // ../jsgui3-html/control_mixins/virtual_window.js
  var require_virtual_window = __commonJS({
    "../jsgui3-html/control_mixins/virtual_window.js"(exports, module) {
      var jsgui = require_html_core();
      var { is_defined } = jsgui;
      var to_number = (value2, fallback) => {
        const num = Number(value2);
        return Number.isFinite(num) ? num : fallback;
      };
      var clamp_non_negative = (value2, fallback) => {
        const num = to_number(value2, fallback);
        return num < 0 ? 0 : num;
      };
      var apply_virtual_window = (ctrl, spec = {}) => {
        const state = {
          item_height: clamp_non_negative(spec.item_height, 32),
          viewport_height: clamp_non_negative(spec.height, 240),
          buffer: clamp_non_negative(spec.buffer, 3)
        };
        ctrl._virtual_window = state;
        ctrl.get_virtual_window_state = () => ({ ...state });
        ctrl.set_virtual_window_state = (next_state) => {
          if (!next_state || typeof next_state !== "object") return;
          if (is_defined(next_state.item_height)) {
            state.item_height = clamp_non_negative(next_state.item_height, state.item_height);
          }
          if (is_defined(next_state.viewport_height) || is_defined(next_state.height)) {
            const next_height = is_defined(next_state.viewport_height) ? next_state.viewport_height : next_state.height;
            state.viewport_height = clamp_non_negative(next_height, state.viewport_height);
          }
          if (is_defined(next_state.buffer)) {
            state.buffer = clamp_non_negative(next_state.buffer, state.buffer);
          }
        };
        ctrl.get_virtual_window_range = (scroll_top, item_count, opts = {}) => {
          const item_height = clamp_non_negative(
            is_defined(opts.item_height) ? opts.item_height : state.item_height,
            state.item_height
          );
          const viewport_height = clamp_non_negative(
            is_defined(opts.viewport_height) ? opts.viewport_height : state.viewport_height,
            state.viewport_height
          );
          const buffer = clamp_non_negative(
            is_defined(opts.buffer) ? opts.buffer : state.buffer,
            state.buffer
          );
          const count = Math.max(0, Number(item_count) || 0);
          const safe_scroll = Math.max(0, Number(scroll_top) || 0);
          const start_index = Math.max(0, Math.floor(safe_scroll / item_height) - buffer);
          const visible_count = Math.ceil(viewport_height / item_height) + buffer * 2;
          const end_index = Math.min(count, start_index + visible_count);
          return {
            start_index,
            end_index,
            visible_count,
            item_height,
            viewport_height,
            buffer
          };
        };
        ctrl.get_virtual_total_height = (item_count, opts = {}) => {
          const row_height = clamp_non_negative(
            is_defined(opts.row_height) ? opts.row_height : state.item_height,
            state.item_height
          );
          const gap = clamp_non_negative(is_defined(opts.gap) ? opts.gap : 0, 0);
          const count = Math.max(0, Number(item_count) || 0);
          if (!count) return 0;
          const total = count * row_height - gap;
          return total < 0 ? 0 : total;
        };
        return state;
      };
      module.exports = apply_virtual_window;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/4-data/virtual_list.js
  var require_virtual_list = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/4-data/virtual_list.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var apply_virtual_window = require_virtual_window();
      var normalize_items = (items) => Array.isArray(items) ? items.slice() : [];
      var Virtual_List = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "virtual_list";
          super(spec);
          this.add_class("virtual-list");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          const item_height = is_defined(spec.item_height) ? Number(spec.item_height) : 32;
          const height2 = is_defined(spec.height) ? Number(spec.height) : 240;
          const buffer = is_defined(spec.buffer) ? Number(spec.buffer) : 3;
          this.item_height = Number.isFinite(item_height) ? item_height : 32;
          this.height = Number.isFinite(height2) ? height2 : 240;
          this.buffer = Number.isFinite(buffer) ? buffer : 3;
          this.item_renderer = spec.item_renderer;
          apply_virtual_window(this, {
            item_height: this.item_height,
            height: this.height,
            buffer: this.buffer
          });
          this.set_items(spec.items || []);
          if (!spec.el) {
            this.compose_virtual_list();
          }
          this.bind_model();
        }
        compose_virtual_list() {
          const { context: context2 } = this;
          const viewport_ctrl = new Control2({ context: context2, tag_name: "div" });
          viewport_ctrl.add_class("virtual-list-viewport");
          viewport_ctrl.dom.attributes.style.height = `${this.height}px`;
          viewport_ctrl.dom.attributes.style["overflow-y"] = "auto";
          viewport_ctrl.dom.attributes.style.position = "relative";
          const spacer_ctrl = new Control2({ context: context2, tag_name: "div" });
          spacer_ctrl.add_class("virtual-list-spacer");
          const items_ctrl = new Control2({ context: context2, tag_name: "div" });
          items_ctrl.add_class("virtual-list-items");
          items_ctrl.dom.attributes.style.position = "absolute";
          items_ctrl.dom.attributes.style.top = "0px";
          items_ctrl.dom.attributes.style.left = "0px";
          items_ctrl.dom.attributes.style.right = "0px";
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.viewport = viewport_ctrl;
          this._ctrl_fields.spacer = spacer_ctrl;
          this._ctrl_fields.items = items_ctrl;
          viewport_ctrl.add(spacer_ctrl);
          viewport_ctrl.add(items_ctrl);
          this.add(viewport_ctrl);
          this.render_window(0);
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            if (e_change.name === "items") {
              this.items = Array.isArray(e_change.value) ? e_change.value : [];
              this.render_window(0);
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set list items.
         * @param {Array} items - Items to set.
         */
        set_items(items) {
          const list_items = normalize_items(items);
          this.set_model_value("items", list_items);
          this.items = list_items;
        }
        /**
         * Get list items.
         * @returns {Array}
         */
        get_items() {
          return this.items || [];
        }
        get_total_height() {
          return this.get_virtual_total_height(this.get_items().length, { row_height: this.item_height });
        }
        render_window(scroll_top) {
          const viewport_ctrl = this._ctrl_fields && this._ctrl_fields.viewport;
          const spacer_ctrl = this._ctrl_fields && this._ctrl_fields.spacer;
          const items_ctrl = this._ctrl_fields && this._ctrl_fields.items;
          if (!viewport_ctrl || !spacer_ctrl || !items_ctrl) return;
          const items = this.get_items();
          const total_height = this.get_total_height();
          spacer_ctrl.dom.attributes.style.height = `${total_height}px`;
          const range = this.get_virtual_window_range(scroll_top, items.length, {
            item_height: this.item_height,
            viewport_height: this.height,
            buffer: this.buffer
          });
          const start_index = range.start_index;
          const end_index = range.end_index;
          items_ctrl.dom.attributes.style.transform = `translateY(${start_index * this.item_height}px)`;
          items_ctrl.clear();
          for (let index = start_index; index < end_index; index += 1) {
            const item2 = items[index];
            let item_ctrl;
            if (typeof this.item_renderer === "function") {
              const rendered = this.item_renderer(item2, index);
              if (rendered instanceof Control2) {
                item_ctrl = rendered;
              } else {
                item_ctrl = new Control2({ context: this.context, tag_name: "div" });
                if (is_defined(rendered)) item_ctrl.add(String(rendered));
              }
            } else {
              item_ctrl = new Control2({ context: this.context, tag_name: "div" });
              if (is_defined(item2)) item_ctrl.add(String(item2));
            }
            item_ctrl.add_class("virtual-list-item");
            item_ctrl.dom.attributes.style.height = `${this.item_height}px`;
            item_ctrl.dom.attributes["data-index"] = String(index);
            items_ctrl.add(item_ctrl);
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const viewport_ctrl = this._ctrl_fields && this._ctrl_fields.viewport;
            if (!viewport_ctrl || !viewport_ctrl.dom.el) return;
            viewport_ctrl.add_dom_event_listener("scroll", () => {
              const scroll_top = viewport_ctrl.dom.el.scrollTop || 0;
              this.render_window(scroll_top);
            });
          }
        }
      };
      Virtual_List.css = `
.virtual-list {
    width: 100%;
}
.virtual-list-item {
    display: flex;
    align-items: center;
    padding: 4px 8px;
    box-sizing: border-box;
}
`;
      module.exports = Virtual_List;
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/4-data/virtual_grid.js
  var require_virtual_grid = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/4-data/virtual_grid.js"(exports, module) {
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var { ensure_control_models } = require_control_model_factory();
      var apply_virtual_window = require_virtual_window();
      var normalize_items = (items) => Array.isArray(items) ? items.slice() : [];
      var Virtual_Grid = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "virtual_grid";
          super(spec);
          this.add_class("virtual-grid");
          this.dom.tagName = "div";
          ensure_control_models(this, spec);
          this.model = this.data.model;
          const item_height = is_defined(spec.item_height) ? Number(spec.item_height) : 120;
          const item_width = is_defined(spec.item_width) ? Number(spec.item_width) : null;
          const height2 = is_defined(spec.height) ? Number(spec.height) : 320;
          const buffer = is_defined(spec.buffer) ? Number(spec.buffer) : 2;
          const column_count = is_defined(spec.column_count) ? Number(spec.column_count) : 3;
          const gap = is_defined(spec.gap) ? Number(spec.gap) : 12;
          this.item_height = Number.isFinite(item_height) ? item_height : 120;
          this.item_width = Number.isFinite(item_width) ? item_width : null;
          this.height = Number.isFinite(height2) ? height2 : 320;
          this.buffer = Number.isFinite(buffer) ? buffer : 2;
          this.column_count = Number.isFinite(column_count) ? Math.max(1, column_count) : 3;
          this.gap = Number.isFinite(gap) ? gap : 12;
          this.item_renderer = spec.item_renderer;
          apply_virtual_window(this, {
            item_height: this.item_height,
            height: this.height,
            buffer: this.buffer
          });
          this.set_items(spec.items || []);
          if (!spec.el) {
            this.compose_virtual_grid();
          }
          this.bind_model();
        }
        compose_virtual_grid() {
          const { context: context2 } = this;
          const viewport_ctrl = new Control2({ context: context2, tag_name: "div" });
          viewport_ctrl.add_class("virtual-grid-viewport");
          viewport_ctrl.dom.attributes.style.height = `${this.height}px`;
          viewport_ctrl.dom.attributes.style["overflow-y"] = "auto";
          viewport_ctrl.dom.attributes.style.position = "relative";
          const spacer_ctrl = new Control2({ context: context2, tag_name: "div" });
          spacer_ctrl.add_class("virtual-grid-spacer");
          const items_ctrl = new Control2({ context: context2, tag_name: "div" });
          items_ctrl.add_class("virtual-grid-items");
          items_ctrl.dom.attributes.style.position = "absolute";
          items_ctrl.dom.attributes.style.top = "0px";
          items_ctrl.dom.attributes.style.left = "0px";
          items_ctrl.dom.attributes.style.right = "0px";
          items_ctrl.dom.attributes.style.display = "grid";
          items_ctrl.dom.attributes.style["grid-auto-rows"] = `${this.item_height}px`;
          items_ctrl.dom.attributes.style.gap = `${this.gap}px`;
          this._ctrl_fields = this._ctrl_fields || {};
          this._ctrl_fields.viewport = viewport_ctrl;
          this._ctrl_fields.spacer = spacer_ctrl;
          this._ctrl_fields.items = items_ctrl;
          viewport_ctrl.add(spacer_ctrl);
          viewport_ctrl.add(items_ctrl);
          this.add(viewport_ctrl);
          this.render_window(0);
        }
        bind_model() {
          if (!this.model || typeof this.model.on !== "function") return;
          this.model.on("change", (e_change) => {
            if (e_change.name === "items") {
              this.items = Array.isArray(e_change.value) ? e_change.value : [];
              this.render_window(0);
            }
          });
        }
        set_model_value(name, value2) {
          if (this.model && typeof this.model.set === "function") {
            this.model.set(name, value2);
          } else if (this.model) {
            this.model[name] = value2;
          }
        }
        /**
         * Set grid items.
         * @param {Array} items - Items to set.
         */
        set_items(items) {
          const list_items = normalize_items(items);
          this.set_model_value("items", list_items);
          this.items = list_items;
        }
        /**
         * Get grid items.
         * @returns {Array}
         */
        get_items() {
          return this.items || [];
        }
        get_row_count() {
          const items = this.get_items();
          return Math.ceil(items.length / this.column_count);
        }
        get_row_height() {
          return this.item_height + this.gap;
        }
        render_window(scroll_top) {
          const viewport_ctrl = this._ctrl_fields && this._ctrl_fields.viewport;
          const spacer_ctrl = this._ctrl_fields && this._ctrl_fields.spacer;
          const items_ctrl = this._ctrl_fields && this._ctrl_fields.items;
          if (!viewport_ctrl || !spacer_ctrl || !items_ctrl) return;
          const items = this.get_items();
          const row_count = this.get_row_count();
          const row_height = this.get_row_height();
          const total_height = this.get_virtual_total_height(row_count, {
            row_height,
            gap: this.gap
          });
          spacer_ctrl.dom.attributes.style.height = `${total_height}px`;
          const range = this.get_virtual_window_range(scroll_top, row_count, {
            item_height: row_height,
            viewport_height: this.height,
            buffer: this.buffer
          });
          const start_row = range.start_index;
          const end_row = range.end_index;
          const grid_columns = this.item_width ? `repeat(${this.column_count}, ${this.item_width}px)` : `repeat(${this.column_count}, minmax(0, 1fr))`;
          items_ctrl.dom.attributes.style["grid-template-columns"] = grid_columns;
          items_ctrl.dom.attributes.style.transform = `translateY(${start_row * row_height}px)`;
          items_ctrl.clear();
          for (let row_index = start_row; row_index < end_row; row_index += 1) {
            for (let col_index = 0; col_index < this.column_count; col_index += 1) {
              const item_index = row_index * this.column_count + col_index;
              if (item_index >= items.length) break;
              const item2 = items[item_index];
              let item_ctrl;
              if (typeof this.item_renderer === "function") {
                const rendered = this.item_renderer(item2, item_index);
                if (rendered instanceof Control2) {
                  item_ctrl = rendered;
                } else {
                  item_ctrl = new Control2({ context: this.context, tag_name: "div" });
                  if (is_defined(rendered)) item_ctrl.add(String(rendered));
                }
              } else {
                item_ctrl = new Control2({ context: this.context, tag_name: "div" });
                if (is_defined(item2)) item_ctrl.add(String(item2));
              }
              item_ctrl.add_class("virtual-grid-item");
              item_ctrl.dom.attributes.style.height = `${this.item_height}px`;
              item_ctrl.dom.attributes["data-index"] = String(item_index);
              items_ctrl.add(item_ctrl);
            }
          }
        }
        activate() {
          if (!this.__active) {
            super.activate();
            const viewport_ctrl = this._ctrl_fields && this._ctrl_fields.viewport;
            if (!viewport_ctrl || !viewport_ctrl.dom.el) return;
            viewport_ctrl.add_dom_event_listener("scroll", () => {
              const scroll_top = viewport_ctrl.dom.el.scrollTop || 0;
              this.render_window(scroll_top);
            });
          }
        }
      };
      Virtual_Grid.css = `
.virtual-grid {
    width: 100%;
}
.virtual-grid-item {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 6px;
    box-sizing: border-box;
    border: 1px solid #e5e5e5;
    background: #fafafa;
}
`;
      module.exports = Virtual_Grid;
    }
  });

  // ../jsgui3-html/validation/error_summary.js
  var require_error_summary = __commonJS({
    "../jsgui3-html/validation/error_summary.js"(exports, module) {
      "use strict";
      var jsgui = require_html_core();
      var { Control: Control2 } = jsgui;
      var { is_defined } = jsgui;
      var Error_Summary = class extends Control2 {
        constructor(spec = {}) {
          spec.__type_name = spec.__type_name || "error_summary";
          super(spec);
          this.add_class("error-summary");
          this.dom.tagName = "div";
          this.dom.attributes.role = "alert";
          this.dom.attributes["aria-live"] = "polite";
          this.dom.attributes["aria-atomic"] = "true";
          this.title = spec.title || "Please correct the following errors:";
          this.errors = {};
          this.field_labels = spec.field_labels || {};
          if (!spec.el) {
            this._compose();
          }
          this.hide();
        }
        /**
         * Compose the error summary structure.
         * @private
         */
        _compose() {
          const { context: context2 } = this;
          this._title_ctrl = new Control2({
            context: context2,
            tag_name: "h3"
          });
          this._title_ctrl.add_class("error-summary-title");
          this._title_ctrl.add(this.title);
          this.add(this._title_ctrl);
          this._list_ctrl = new Control2({
            context: context2,
            tag_name: "ul"
          });
          this._list_ctrl.add_class("error-summary-list");
          this.add(this._list_ctrl);
        }
        /**
         * Set the errors to display.
         * @param {Object} errors - Object with field names as keys and error messages as values.
         */
        set_errors(errors) {
          this.errors = errors || {};
          this._render_errors();
          const has_errors = Object.keys(this.errors).length > 0;
          if (has_errors) {
            this.show();
          } else {
            this.hide();
          }
        }
        /**
         * Add a single error.
         * @param {string} field_name - Field name.
         * @param {string} message - Error message.
         */
        add_error(field_name, message) {
          this.errors[field_name] = message;
          this._render_errors();
          this.show();
        }
        /**
         * Remove a single error.
         * @param {string} field_name - Field name.
         */
        remove_error(field_name) {
          delete this.errors[field_name];
          this._render_errors();
          if (Object.keys(this.errors).length === 0) {
            this.hide();
          }
        }
        /**
         * Clear all errors.
         */
        clear() {
          this.errors = {};
          this._render_errors();
          this.hide();
        }
        /**
         * Get the number of errors.
         * @returns {number}
         */
        get error_count() {
          return Object.keys(this.errors).length;
        }
        /**
         * Check if there are any errors.
         * @returns {boolean}
         */
        has_errors() {
          return this.error_count > 0;
        }
        /**
         * Set field labels for display.
         * @param {Object} labels - Object with field names as keys and labels as values.
         */
        set_field_labels(labels) {
          this.field_labels = labels || {};
          this._render_errors();
        }
        /**
         * Render the error list.
         * @private
         */
        _render_errors() {
          if (!this._list_ctrl) return;
          this._list_ctrl.clear();
          Object.entries(this.errors).forEach(([field_name, message]) => {
            const label = this.field_labels[field_name] || this._humanize_field_name(field_name);
            const item2 = this._create_error_item(field_name, label, message);
            this._list_ctrl.add(item2);
          });
        }
        /**
         * Create an error list item.
         * @private
         */
        _create_error_item(field_name, label, message) {
          const { context: context2 } = this;
          const item2 = new Control2({
            context: context2,
            tag_name: "li"
          });
          item2.add_class("error-summary-item");
          const link = new Control2({
            context: context2,
            tag_name: "a"
          });
          link.add_class("error-summary-link");
          link.dom.attributes.href = `#${field_name}`;
          link.dom.attributes["data-field"] = field_name;
          const field_label = new Control2({
            context: context2,
            tag_name: "span"
          });
          field_label.add_class("error-summary-field");
          field_label.add(label + ": ");
          const error_text = new Control2({
            context: context2,
            tag_name: "span"
          });
          error_text.add_class("error-summary-message");
          error_text.add(message);
          link.add(field_label);
          link.add(error_text);
          item2.add(link);
          return item2;
        }
        /**
         * Convert field_name to human-readable label.
         * @private
         */
        _humanize_field_name(field_name) {
          return field_name.replace(/_/g, " ").replace(/([a-z])([A-Z])/g, "$1 $2").replace(/^./, (str) => str.toUpperCase());
        }
        /**
         * Activate the control.
         */
        activate() {
          if (!this.__active) {
            super.activate();
            if (!this.dom.el) return;
            this.add_dom_event_listener("click", (e) => {
              const link = e.target.closest(".error-summary-link");
              if (!link) return;
              e.preventDefault();
              const field_name = link.getAttribute("data-field");
              if (!field_name) return;
              const field = document.querySelector(
                `[name="${field_name}"], #${field_name}, [data-field-name="${field_name}"]`
              );
              if (field) {
                field.focus();
                field.scrollIntoView({ behavior: "smooth", block: "center" });
              }
              this.raise("error_click", { field_name });
            });
          }
        }
      };
      Error_Summary.css = `
.error-summary {
    background-color: #fef2f2;
    border: 1px solid #ef4444;
    border-radius: 4px;
    padding: 16px;
    margin-bottom: 16px;
}

.error-summary-title {
    color: #b91c1c;
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 12px 0;
}

.error-summary-list {
    list-style: none;
    margin: 0;
    padding: 0;
}

.error-summary-item {
    margin-bottom: 8px;
}

.error-summary-item:last-child {
    margin-bottom: 0;
}

.error-summary-link {
    color: #b91c1c;
    text-decoration: underline;
    cursor: pointer;
}

.error-summary-link:hover {
    color: #991b1b;
}

.error-summary-link:focus {
    outline: 2px solid #ef4444;
    outline-offset: 2px;
}

.error-summary-field {
    font-weight: 600;
}

.error-summary-message {
    font-weight: normal;
}

/* Hidden state */
.error-summary[hidden],
.error-summary.hidden {
    display: none;
}
`;
      module.exports = Error_Summary;
    }
  });

  // ../jsgui3-html/utils/deprecation.js
  var require_deprecation = __commonJS({
    "../jsgui3-html/utils/deprecation.js"(exports, module) {
      "use strict";
      var warned = /* @__PURE__ */ new Set();
      function deprecation_warning(old_name, new_name, removal_version = "1.0.0") {
        if (false) return;
        const key2 = `${old_name}:${new_name}`;
        if (warned.has(key2)) return;
        warned.add(key2);
        console.warn(
          `[jsgui3-html] DEPRECATED: "${old_name}" is deprecated. Use "${new_name}" instead. This will be removed in v${removal_version}.`
        );
      }
      function create_deprecated_alias(canonical_module, old_name, new_name, removal_version = "1.0.0") {
        deprecation_warning(old_name, new_name, removal_version);
        return canonical_module;
      }
      function clear_warnings() {
        warned.clear();
      }
      function has_warned(old_name, new_name) {
        return warned.has(`${old_name}:${new_name}`);
      }
      module.exports = {
        deprecation_warning,
        create_deprecated_alias,
        clear_warnings,
        has_warned
      };
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/FormField.js
  var require_FormField = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/FormField.js"(exports, module) {
      "use strict";
      var { create_deprecated_alias } = require_deprecation();
      var Form_Field = require_form_field();
      module.exports = create_deprecated_alias(
        Form_Field,
        "FormField",
        "Form_Field",
        "1.0.0"
      );
    }
  });

  // ../jsgui3-html/controls/organised/1-standard/1-editor/PropertyEditor.js
  var require_PropertyEditor = __commonJS({
    "../jsgui3-html/controls/organised/1-standard/1-editor/PropertyEditor.js"(exports, module) {
      "use strict";
      var { create_deprecated_alias } = require_deprecation();
      var Property_Editor = require_property_editor();
      module.exports = create_deprecated_alias(
        Property_Editor,
        "PropertyEditor",
        "Property_Editor",
        "1.0.0"
      );
    }
  });

  // ../jsgui3-html/controls/controls.js
  var require_controls = __commonJS({
    "../jsgui3-html/controls/controls.js"(exports, module) {
      "use strict";
      var controls = {
        Active_HTML_Document: require_Active_HTML_Document(),
        Arrow_Button: require_arrow_button(),
        //Audio_Player: require('./audio-player'),
        Audio_Volume: require_audio_volume(),
        Alert_Banner: require_alert_banner(),
        Accordion: require_accordion(),
        Badge: require_badge(),
        Button: require_button(),
        Canvas: require_Canvas(),
        Breadcrumbs: require_breadcrumbs(),
        Cell: require_Cell(),
        // Maybe more advanced?
        Context_Menu: require_context_menu(),
        //Control: 
        Color_Grid: require_color_grid(),
        Color_Palette: require_color_palette(),
        Checkbox: require_checkbox(),
        Combo_Box: require_combo_box(),
        Cluster: require_cluster(),
        Dropdown_Menu: require_Dropdown_Menu(),
        Drawer: require_drawer(),
        // Not using (data-)connected controls.
        Data_Grid: require_data_grid(),
        File_Upload: require_file_upload(),
        Form_Container: require_form_container(),
        Form_Field: require_form_field(),
        // maybe 0-basic/0-layout?
        //  A layout control may be / need to be displayed a little differently.
        Grid: require_grid(),
        Grid_Gap: require_grid_gap(),
        Grid_Cell: require_grid().Cell,
        Horizontal_Menu: require_horizontal_menu(),
        Horizontal_Slider: require_horizontal_slider(),
        //Data_Item: require('./data-item'),
        Data_Row: require_data_row(),
        Data_Table: require_data_table(),
        Date_Picker: require_date_picker(),
        Dropdown_List: require_dropdown_list(),
        Email_Input: require_email_input(),
        // Exclude the connected ones for the moment. Moment passed.
        // May not need to actually be 'connected'?
        //  Or other controls may get data connections too.
        File_Tree: require_file_tree(),
        File_Tree_Node: require_file_tree_node(),
        Icon: require_icon(),
        Inline_Validation_Message: require_inline_validation_message(),
        Item: require_item(),
        Item_Selector: require_item_selector(),
        //Item_View: require('./old/item-view'),
        Left_Right_Arrows_Selector: require_left_right_arrows_selector(),
        //Vector: require('./vector'),
        Line_Chart: require_line_chart(),
        List: require_list(),
        // could be in forms / standard forms.
        Login: require_login(),
        //Media_Scrubber: require('./media-scrubber'),
        Menu_Node: require_menu_node(),
        Meter: require_meter(),
        Modal: require_modal(),
        Month_View: require_month_view(),
        //Multi_Document_Interface: require('./multi-document-interface'),
        Master_Detail: require_master_detail(),
        Matrix: require_Matrix(),
        Multi_Layout_Mode: require_multi_layout_mode(),
        //Object_Editor: require('./editor/object'),
        Number_Input: require_number_input(),
        Number_Stepper: require_number_stepper(),
        Object_Editor: require_object2(),
        Panel: require_panel(),
        Pagination: require_pagination(),
        Plus_Minus_Toggle_Button: require_plus_minus_toggle_button(),
        Property_Editor: require_property_editor(),
        Property_Viewer: require_Property_Viewer(),
        Progress_Bar: require_progress_bar(),
        // More advanced functionality - may require more work to keep it with the right APIs.
        Popup_Menu_Button: require_popup_menu_button(),
        Pop_Over: require_pop_over(),
        Radio_Button: require_radio_button(),
        Radio_Button_Group: require_radio_button_group(),
        //Resize_Handle: require('./organised/0-core/0-basic/_resize-handle'),
        Reorderable_List: require_reorderable_list(),
        Resource_Viewer: require_Resource_Viewer(),
        Rich_Text_Editor: require_Rich_Text_Editor(),
        Rich_Text_Toolbar: require_rich_text_toolbar(),
        Scroll_View: require_scroll_view(),
        Scrollbar: require_scrollbar(),
        Search_Bar: require_search_bar(),
        Select_Options: require_Select_Options(),
        Single_Line: require_single_line(),
        Split_Pane: require_split_pane(),
        Stack: require_stack(),
        Standard_Web_Page: require_standard_web_page(),
        Start_Stop_Toggle_Button: require_start_stop_toggle_button(),
        String_Span: require_string_span(),
        Tag_Input: require_tag_input(),
        Tabbed_Panel: require_tabbed_panel(),
        Tel_Input: require_tel_input(),
        Textarea: require_textarea(),
        Text_Field: require_Text_Field(),
        Text_Item: require_text_item(),
        Text_Input: require_Text_Input(),
        Tile_Slider: require_tile_slide(),
        Toast: require_toast(),
        Toggle_Switch: require_toggle_switch(),
        Stepped_Slider: require_stepped_slider(),
        // May be moved to vector?
        Timespan_Selector: require_timespan_selector(),
        Title_Bar: require_title_bar(),
        Titled_Panel: require_titled_panel(),
        Toggle_Button: require_toggle_button(),
        Toolbar: require_Toolbar(),
        Toolbox: require_toolbox(),
        Tooltip: require_tooltip(),
        Tree: require_tree(),
        Tree_Node: require_tree_node(),
        Tree_View: require_Tree_View(),
        Tree_Table: require_tree_table(),
        Url_Input: require_url_input(),
        Vertical_Expander: require_vertical_expander(),
        Center: require_center(),
        Stepper: require_stepper(),
        Window: require_window(),
        //,
        //mx: require('../control_mixins/mx')
        Indicator: require_Indicator(),
        Status_Indicator: require_Status_Indicator(),
        Validation_Status_Indicator: require_Validation_Status_Indicator(),
        Range_Input: require_range_input(),
        Password_Input: require_password_input(),
        Virtual_List: require_virtual_list(),
        Virtual_Grid: require_virtual_grid(),
        Error_Summary: require_error_summary()
      };
      controls.experimental = {};
      controls.deprecated = {
        // Legacy camelCase names - use Camel_Case versions instead
        FormField: require_FormField(),
        PropertyEditor: require_PropertyEditor()
      };
      controls.FormField = controls.deprecated.FormField;
      controls.PropertyEditor = controls.deprecated.PropertyEditor;
      module.exports = controls;
    }
  });

  // ../jsgui3-html/html.js
  var require_html = __commonJS({
    "../jsgui3-html/html.js"(exports, module) {
      var jsgui = require_html_core();
      jsgui.Router = require_router();
      jsgui.Resource = require_resource();
      jsgui.Resource_Pool = require_pool();
      jsgui.Resource.Data_KV = require_data_kv_resource();
      jsgui.Resource.Data_Transform = require_data_transform_resource();
      jsgui.Resource.Compilation = require_compilation_resource();
      jsgui.Resource.Compiler = require_compiler_resource();
      jsgui.gfx = require_gfx_core();
      jsgui.Resource.load_compiler = (name, jsfn, options) => {
        const compiler_name = name;
        const compiler_fn = jsfn;
        const compiler_options = options || {};
        if (typeof compiler_name !== "string" || compiler_name.length === 0) {
          throw new Error("Resource.load_compiler(name, fn, options) requires a non-empty string name");
        }
        if (typeof compiler_fn !== "function") {
          throw new Error("Resource.load_compiler(name, fn, options) requires a function compiler implementation");
        }
        const compiler_resource = new jsgui.Resource.Compiler({ name: compiler_name });
        compiler_resource.transform = (input, transform_options = {}) => {
          const merged_options = Object.assign({}, compiler_options, transform_options);
          return compiler_fn(input, merged_options);
        };
        jsgui.Resource.compilers = jsgui.Resource.compilers || {};
        jsgui.Resource.compilers[compiler_name] = compiler_resource;
        const pool = compiler_options.pool || compiler_options.resource_pool;
        if (pool && typeof pool.add === "function") {
          pool.add(compiler_resource);
        }
        return compiler_resource;
      };
      jsgui.controls = jsgui.controls || {};
      Object.assign(jsgui.controls, require_controls());
      Object.assign(jsgui, jsgui.controls);
      jsgui.mixins = jsgui.mx = require_mx();
      module.exports = jsgui;
    }
  });

  // ../jsgui3-client/node_modules/lang-mini/lang-mini.js
  var require_lang_mini5 = __commonJS({
    "../jsgui3-client/node_modules/lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              if (ctu == false) break;
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
              if (ctu === false) break;
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "null": "N",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          }
          first = false;
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        if (arr.some((subArray) => subArray.length === 0)) {
          return [];
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else {
              return Object.assign({}, obj2);
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                } else if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return new ctr(input_array);
          } else if (length) {
            return new ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str, 10);
          if (!isNaN(p2) && p2.toString() === str) {
            return p2;
          }
          return void 0;
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        const t_value = typeof value2;
                        is_valid = data_type.validate(value2);
                        if (t_value === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                        console.log("t_value", t_value);
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    } else {
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // ../jsgui3-client/node_modules/lang-mini/lib-lang-mini.js
  var require_lib_lang_mini5 = __commonJS({
    "../jsgui3-client/node_modules/lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini5();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // ../jsgui3-client/node_modules/fnl/fn-io-transform.js
  var require_fn_io_transform2 = __commonJS({
    "../jsgui3-client/node_modules/fnl/fn-io-transform.js"(exports, module) {
      var { deep_sig } = require_lib_lang_mini5();
      var isArguments = (item2) => Object.prototype.toString.call(item2) === "[object Arguments]";
      var fn_transformation = (fn, map_transformations) => {
        const input_transformations = map_transformations.i;
        const output_transformations = map_transformations.o;
        const fn_res = function() {
          const args = arguments;
          if (args.length === 2 && typeof args[1] === "function") {
            let [a, cb_transform_exec_events] = args;
            if (isArguments(a)) {
              if (a.length === 1) {
                a = a[0];
              }
            }
            const sig_called_with = deep_sig(a);
            const sig_arguments = deep_sig(arguments);
            const exec_fn = () => {
              cb_transform_exec_events({
                "name": "exec-start"
                //,
                //sig: evt_output_transform.sig,
                //value: evt_output_transform.value
              });
              const fn_res2 = fn.call(null, a);
              cb_transform_exec_events({
                "name": "exec-complete"
                //,
                //sig: evt_output_transform.sig,
                //value: evt_output_transform.value
              });
              const sig_fn_res = deep_sig(fn_res2);
              if (output_transformations) {
                if (output_transformations[sig_fn_res]) {
                  output_transformations[sig_fn_res].call(null, fn_res2, (evt_output_transform) => {
                    cb_transform_exec_events({
                      "name": "complete",
                      sig: evt_output_transform.sig,
                      value: evt_output_transform.value
                    });
                  });
                } else {
                  cb_transform_exec_events({
                    "name": "complete",
                    sig: sig_fn_res,
                    value: fn_res2
                  });
                }
              } else {
                cb_transform_exec_events({
                  "name": "complete",
                  sig: sig_fn_res,
                  value: fn_res2
                });
              }
            };
            const skip_fn = () => {
              cb_transform_exec_events({
                "name": "complete",
                //sig: sig_fn_res,
                value: a,
                skipped: true
              });
            };
            if (input_transformations) {
              let do_skip = false;
              if (fn.skip) {
                do_skip = fn.skip(a);
              }
              if (do_skip) {
                skip_fn();
              } else {
                if (fn.map_sigs && fn.map_sigs[sig_called_with]) {
                  exec_fn();
                } else {
                  if (input_transformations[sig_called_with]) {
                    cb_transform_exec_events({
                      "name": "input-transform-start"
                    });
                    input_transformations[sig_called_with].call(null, a, (evt_input_transform) => {
                      const { name, sig, value: value2, io_sigs } = evt_input_transform;
                      if (name === "complete") {
                        a = value2;
                        evt_input_transform.name = "input-transform-complete";
                        cb_transform_exec_events(evt_input_transform);
                        exec_fn();
                      } else {
                        console.trace();
                        throw "NYI";
                      }
                    });
                  } else {
                    exec_fn();
                  }
                }
              }
            } else {
              exec_fn();
            }
          } else {
            throw "Expected args: normal_args, cb_transform_event";
          }
        };
        if (fn.name) fn_res.name = fn.name;
        if (fn.main) fn_res.main = fn.main;
        if (fn.skip) fn_res.skip = fn.skip;
        return fn_res;
      };
      module.exports = fn_transformation;
    }
  });

  // ../jsgui3-client/node_modules/fnl/monitor-item.js
  var require_monitor_item2 = __commonJS({
    "../jsgui3-client/node_modules/fnl/monitor-item.js"(exports, module) {
      var { tf: tf2, deep_sig, each, def } = require_lib_lang_mini5();
      var monitor_item = (item2, cb_evt_monitoring) => {
        const ti = tf2(item2);
        if (ti === "A") {
          const l2 = item2.length;
          for (let c2 = 0; c2 < l2; c2++) {
            const arg = item2[c2];
            ((arg2, c3) => {
              monitor_item(arg2, (evt_arg_monitor) => {
                evt_arg_monitor.arg_index = c3;
                cb_evt_monitoring(evt_arg_monitor);
              });
            })(arg, c2);
          }
        } else if (ti === "s") {
          cb_evt_monitoring({
            name: "complete",
            t: "s",
            bytes: item2.length * 2
          });
        } else if (ti === "o") {
          cb_evt_monitoring({
            name: "complete",
            t: "o"
            //,
            //bytes: item.length * 2
          });
        } else if (ti === "R") {
          const rs = item2;
          let bytes = 0;
          const ms_start = Date.now();
          let content_length, bytes_remaining;
          const { headers } = item2;
          if (headers && headers["content-length"]) {
            content_length = parseInt(headers["content-length"], 10);
            bytes_remaining = content_length;
          }
          const o_evt = {
            name: "available",
            t: "R",
            ms: ms_start,
            headers
            //,
            //bytes: item.length * 2
          };
          if (def(content_length)) {
            o_evt.content_length = content_length;
          }
          cb_evt_monitoring(o_evt);
          rs.on("data", (data) => {
            bytes += data.length;
            bytes_remaining -= data.length;
            const ms = Date.now();
            const ms_taken = ms - ms_start;
            const byte_rate = bytes / (ms_taken / 1e3);
            const est_remaining = bytes_remaining / byte_rate * 1e3;
            const proportion = bytes / content_length;
            const ms_est_complete = ms + est_remaining;
            cb_evt_monitoring({
              name: "data",
              t: "B",
              bytes: data.length,
              bytes_total: bytes,
              byte_rate,
              content_length,
              bytes_remaining,
              ms_est_remaining: est_remaining,
              ms_est_complete,
              ms_taken,
              proportion
            });
          });
          rs.on("end", () => {
            const ms_complete = Date.now();
            const ms_taken = ms_complete - ms_start;
            const byte_rate = bytes / (ms_taken / 1e3);
            cb_evt_monitoring({
              name: "complete",
              ms: ms_complete,
              ms_taken,
              t: "R",
              "bytes": bytes,
              byte_rate
              //,
              //bytes: item.length * 2
            });
          });
          rs.on("error", (err) => {
            cb_evt_monitoring({
              name: "error",
              value: err,
              t: "R"
              //,
              //bytes: item.length * 2
            });
          });
        } else if (ti === "B") {
          cb_evt_monitoring({
            name: "complete",
            t: "B",
            bytes: item2.length
          });
        } else if (ti === "a") {
          cb_evt_monitoring({
            name: "complete",
            t: "a"
          });
        } else {
          console.log("ti", ti);
          console.trace();
          throw "stop";
        }
      };
      module.exports = monitor_item;
    }
  });

  // ../jsgui3-client/node_modules/fnl/default-arg-transformations.js
  var require_default_arg_transformations2 = __commonJS({
    "../jsgui3-client/node_modules/fnl/default-arg-transformations.js"(exports, module) {
      var { deep_sig } = require_lib_lang_mini5();
      var transformations = {
        "O": (obs, cb_events) => {
          obs.then((res2) => {
            const sig = deep_sig(res2);
            if (cb_events) cb_events({
              name: "complete",
              io_sigs: ["O", sig],
              sig,
              value: res2
            });
          }, (err) => {
          });
        },
        "p": (p, cb_events) => {
          p.then((res2) => {
            const sig = deep_sig(res2);
            if (cb_events) cb_events({
              name: "complete",
              io_sigs: ["p", sig],
              sig,
              value: res2
            });
          }, (err) => {
          });
        },
        "R": (input_readable_stream, cb_events) => {
          const chunks = [];
          const ms_start = Date.now();
          input_readable_stream.on("data", (data) => {
            chunks.push(data);
          });
          input_readable_stream.on("end", () => {
            const ms_complete = Date.now();
            const buf = Buffer.concat(chunks);
            const ms_taken = ms_complete - ms_start;
            const byte_rate = buf.length / (ms_taken / 1e3);
            if (cb_events) cb_events({
              name: "complete",
              sig: "B",
              io_sigs: ["R", "B"],
              value: buf,
              bytes: buf.length,
              ms: ms_complete,
              ms_taken,
              byte_rate
            });
          });
          input_readable_stream.on("error", (err) => {
            console.log("error reading stream for param transformation in stages()");
            error(err);
          });
        }
        // this level: param sig required
        // this level: param sig given: function to transform
        // promise resolution here?
      };
      module.exports = transformations;
    }
  });

  // ../jsgui3-client/node_modules/fnl/fnl.js
  var require_fnl2 = __commonJS({
    "../jsgui3-client/node_modules/fnl/fnl.js"(exports, module) {
      var { each, Evented_Class, get_a_sig, get_truth_map_from_arr, tof, tf: tf2, mfp, deep_sig, clone, def, is_array } = require_lib_lang_mini5();
      var fn_io_transform = require_fn_io_transform2();
      var log = () => {
      };
      var nce = (obs, next, complete, error2) => {
        obs.on("next", next);
        obs.on("complete", complete);
        obs.on("error", error2);
        return obs;
      };
      var monitor_item = require_monitor_item2();
      var tm_status_strings = {
        "init": true,
        "ok": true,
        "complete": true,
        "error": true,
        "paused": true
      };
      var observable = function(fn_inner, opts) {
        const a = arguments;
        const l2 = a.length;
        const sig = get_a_sig(a);
        let _opts, _fn_inner;
        if (sig === "[f]" || sig === "[f,u]") {
          _opts = {};
          _fn_inner = a[0];
        } else if (sig === "[f,o]") {
          _fn_inner = a[0];
          _opts = a[1];
        } else if (sig === "[o,f]") {
          _opts = a[0];
          _fn_inner = a[1];
        } else {
          if (sig === "[O]" || sig === "[O,u]") {
            return a[0];
          } else {
            console.log("sig", sig);
            console.trace();
            throw "NYI";
          }
        }
        const obs_res = ((opts2, fn_inner2) => {
          const ms_start = Date.now();
          const ms_since_start = () => Date.now() - ms_start;
          const res2 = new Evented_Class();
          const io = res2.io = new Evented_Class();
          let llog = [];
          let _status = "init";
          Object.defineProperty(res2, "ms_start", {
            value: ms_start,
            writable: false
          });
          let ms_ok, ms_complete, ms_error;
          let ms_to_ok, ms_to_complete, ms_to_error;
          const map_status_data = {};
          const map_ms_reached_status = {};
          let stage_number = -1;
          let stage_name = "init";
          const log2 = (data) => {
            const log_item = [Date.now(), data];
            llog.push(log_item);
            res2.raise("log", log_item);
          };
          const status = (str_status, data) => {
            if (tm_status_strings[str_status]) {
              const old_status = _status;
              if (!map_ms_reached_status[str_status]) {
                map_ms_reached_status[str_status] = Date.now();
              }
              map_status_data[str_status] = data;
              _status = str_status;
              res2.raise("status", {
                old: old_status,
                value: str_status,
                data
              });
            } else {
              console.trace();
              log2("str_status", str_status);
              throw "invalid str_status " + str_status;
            }
          };
          let _stage;
          let current_stage_info;
          Object.defineProperty(res2, "log", {
            get() {
              return llog;
            }
          });
          Object.defineProperty(res2, "status", {
            get() {
              return _status;
            }
          });
          let had_next = false, had_complete = false, had_error = false;
          setTimeout(() => {
            const res_fn_inner = fn_inner2((data) => {
              let passes = true;
              had_next = true;
              if (!had_complete && !had_error) {
                if (this.filters) {
                  for (let filter of this.filters) {
                    passes = filter(data);
                    if (!passes) break;
                  }
                }
              } else {
                if (had_complete) {
                  console.warn('Observable can not raise "next" event after having raised its "complete" event.');
                }
                if (had_error) {
                  console.warn('Observable can not raise "next" event after having raised its "error" event.');
                }
              }
              if (passes) {
                res2.raise("next", data);
                res2.raise("data", data);
              }
            }, (last_data) => {
              if (!had_complete && !had_error) {
                had_complete = true;
                const tld = tf2(last_data);
                const ms_complete2 = Date.now();
                res2.ms_complete = ms_complete2;
                res2.ms_taken = ms_complete2 - ms_start;
                if (tld !== "u") {
                  if (tld === "R") {
                    io.ongoing = true;
                    last_data.on("complete", () => {
                      io.ongoing = false;
                      io.raise("complete");
                    });
                  } else {
                    res2.raise("complete", last_data);
                    io.raise("complete");
                  }
                } else {
                  res2.raise("complete");
                }
              } else {
                if (had_complete) {
                  console.warn('WARNING: Observable can not raise "complete" event after having raised it already.');
                }
                if (had_error) {
                  console.warn('WARNING: Observable can not raise "complete" event after having raised its "error" event.');
                }
              }
            }, (error2) => {
              if (!had_complete && !had_error) {
                had_error = true;
                res2.raise("error", error2);
              } else {
                if (had_complete) {
                  console.warn('WARNING: Observable can not raise "error" event after having raised its "complete" event.');
                }
                if (had_error) {
                  console.warn('WARNING: Observable can not raise "error" event after having raised it already.');
                }
              }
            }, status, log2) || [];
            if (is_array(res_fn_inner)) {
              const [stop, pause, resume] = res_fn_inner;
              if (stop) res2.stop = stop;
              if (pause) res2.pause = pause;
              if (resume) res2.resume = resume;
              if (pause && resume) {
                res2.delay = (ms) => {
                  pause();
                  res2.raise("paused");
                  setTimeout(() => {
                    res2.resume();
                    res2.raise("resumed");
                  }, ms);
                };
              }
            }
          }, 0);
          res2.next = (handler) => {
            res2.on("next", handler);
            return res2;
          };
          res2.data = res2.next;
          res2.complete = (handler) => {
            res2.on("complete", handler);
            return res2;
          };
          res2.on("complete", (data) => {
            status("complete");
            const store_res = () => {
              if (data) {
                if (data.data) {
                  res2.res = data.data;
                } else {
                  res2.res = data;
                }
              }
            };
          });
          res2.done = res2.end = res2.complete;
          res2.error = (handler) => {
            res2.on("error", handler);
            return res2;
          };
          res2.then = (handler) => {
            let res_all = [];
            res2.next((data) => {
              res_all.push(data);
              had_next = true;
            });
            if (res2.completed) {
              if (res2.singular_result) {
                handler(res_all[0]);
              } else {
                handler(res_all);
              }
            } else {
              res2.complete((last) => {
                if (had_next && res_all.length > 0) {
                  if (res2.singular_result) {
                    handler(res_all[0]);
                  } else {
                    handler(res_all);
                  }
                } else {
                  handler(last);
                }
              });
            }
          };
          res2.__type_name = "observable";
          res2._is_obs = res2._is_observable = true;
          res2._ = new Evented_Class();
          res2.meta = (k, v) => {
            if (v === void 0) {
            } else {
              res2._[key] = value;
              res2._.raise("change", {
                key: k,
                value: v
              });
            }
          };
          return res2;
        })(_opts, _fn_inner);
        return obs_res;
      };
      observable._ = {
        name: "observable",
        return_type: "observable",
        async: true
      };
      var obsfilter = (obs, next_filter) => observable((next, complete, error2) => {
        obs.on("next", (data) => {
          if (next_filter(data)) {
            next(data);
          }
        });
        obs.on("complete", (data) => {
          if (data) {
            complete(data);
          } else {
            complete();
          }
        });
        obs.on("error", (err) => {
          error2(err);
        });
      });
      var obsmap = (obs, fn_map) => observable((next, complete, error2) => {
        obs.on("next", (data) => next(fn_map(data)));
        obs.on("complete", complete);
        obs.on("error", error2);
      });
      var obsalias = (obs_like, mapping) => {
        let next, complete, error2;
        const tmapping = tof(mapping);
        if (tmapping === "array") {
          [next, complete, error2] = mapping;
        } else if (tmapping === "object") {
          next = mapping.next;
          complete = mapping.complete;
          error2 = mapping.error;
        }
        return observable((n, c2, e) => {
          if (next) {
            obs_like.on(next, n);
          } else {
            obs_like.on("next", n);
          }
          if (complete) {
            obs_like.on(complete, c2);
          } else {
            obs_like.on("complete", c2);
          }
          if (error2) {
            obs_like.on(error2, e);
          } else {
            obs_like.on("error", e);
          }
        });
      };
      var obscollect = (obs, fn_collect, arr_res) => {
        obs.on("next", (data) => {
          const item_res = fn_collect(data);
          arr_res.push(item_res);
        });
        return obs;
      };
      var obspool = () => {
        console.trace();
        throw "out of order";
      };
      var seq = (q_obs) => {
        return observable((next, complete, error2) => {
          let c2 = 0, obs_q_item;
          let process2 = () => {
            if (c2 < q_obs.length) {
              let q_item = q_obs[c2];
              obs_q_item = q_item[1].apply(q_item[0], q_item[2]);
              obs_q_item.on("next", (data) => {
                next(data);
              });
              obs_q_item.on("error", (error3) => {
                error3(error3);
              });
              obs_q_item.on("complete", (data) => {
                c2++;
                process2();
              });
            } else {
              complete();
            }
          };
          process2();
          let stop = () => {
            obs_q_item.stop();
            complete();
          };
          let pause = () => {
            obs_q_item.pause();
          };
          let resume = () => {
            obs_q_item.resume();
          };
          return [stop, pause, resume];
        });
      };
      var obs_to_cb = (obs, callback2) => {
        let _obs = observable(obs);
        let arr_all = [];
        _obs.on("next", (data) => arr_all.push(data));
        _obs.on("error", (err) => callback2(err));
        _obs.on("complete", (last) => {
          if (typeof last !== "undefined") {
            callback2(null, last, arr_all);
          } else {
            callback2(null, arr_all);
          }
        });
      };
      var unpage = (obs) => {
        return observable((next, complete, error2) => {
          obs.on("next", (arr_data) => {
            if ("unpaged" in arr_data) {
              let unpaged = arr_data.unpaged;
              for (let c2 = 0, l2 = unpaged.length; c2 < l2; c2++) {
                next(unpaged[c2]);
              }
            } else {
              for (let c2 = 0, l2 = arr_data.length; c2 < l2; c2++) {
                next(arr_data[c2]);
              }
            }
          });
          obs.on("complete", () => {
            complete();
          });
          obs.on("error", (err) => error2(err));
          return [];
        });
      };
      var obs_or_cb = (obs, callback2, always_plural) => {
        if (callback2) {
          obs_to_cb(obs, callback2);
        } else {
          return observable(obs, always_plural);
        }
      };
      var sig_obs_or_cb = (a, inner) => {
        let a2;
        let callback2;
        if (typeof a[a.length - 1] === "function") {
          a2 = Array.prototype.slice.call(a, 0, -1);
          callback2 = a[a.length - 1];
        } else if (typeof a[a.length - 1] === "undefined") {
          a2 = Array.prototype.slice.call(a, 0, -1);
        } else {
          a2 = Array.prototype.slice.call(a);
        }
        let sig = get_a_sig(a2);
        let obs = observable((next, complete, error2) => {
          return inner(a2, sig, next, complete, error2, a2.length);
        });
        return obs_or_cb(obs, callback2);
      };
      var cb_to_prom_or_cb = (inner_with_cb, opt_cb) => {
        if (typeof opt_cb !== "undefined") {
          inner_with_cb(opt_cb);
        } else {
          return new Promise((resolve, reject) => {
            inner_with_cb((err, res2) => {
              if (err) {
                reject(err);
              } else {
                resolve(res2);
              }
            });
          });
        }
      };
      var prom_or_cb = (prom2, opt_cb) => {
        let _prom;
        if (prom2 instanceof Promise) {
          _prom = prom2;
        } else {
          _prom = new Promise(prom2);
        }
        if (opt_cb) {
          _prom.then((res2) => {
            opt_cb(null, res2);
          }, (err) => {
            opt_cb(err);
          });
        } else {
          return _prom;
        }
      };
      var prom = (prom2) => {
        if (prom2 instanceof Promise) {
          return prom2;
        } else {
          return new Promise(prom2);
        }
      };
      var is_obs = (obj2) => {
        return obj2.is_obs === true;
      };
      var is_prom = (obj2) => {
        return obj2 instanceof Promise || obj2.is_obs === true;
      };
      var obs_prom_arr_item = (obj2, obs, prom2, arr, item2) => {
        if (obj2.is_obs === true) {
          return obs(obj2);
        } else {
          if (obj2 instanceof Promise) {
            return prom2(obj2);
          } else {
            if (Array.isArray(obj2)) {
              return arr(obj2);
            } else {
              return item2(obj2);
            }
          }
        }
      };
      var arg_transformation = require_default_arg_transformations2();
      var transform_stage_input = {
        "R": arg_transformation.R
      };
      var stages = mfp({
        name: "stages",
        return_type: "function"
        // function that returns an observable.
      }, function() {
        const a = arguments, l2 = a.length;
        const sig = get_a_sig(a);
        let arr_stages;
        let num_stages;
        let fn_inner;
        const prepare_arr_fns = (ofns) => {
          const input_ofns2 = (ofns2) => {
            const map_stage_reserved_names = {
              _raise_stage_event: true
            };
            const res2 = [];
            const o_filtered_stage_fns = {};
            let num_stages2 = 0;
            let last_stage_name;
            each(ofns2, (fn_stage, stage_name) => {
              if (!map_stage_reserved_names[stage_name]) {
                o_filtered_stage_fns[stage_name] = fn_stage;
                num_stages2++;
                last_stage_name = stage_name;
              }
            });
            each(o_filtered_stage_fns, (fn_stage, stage_name) => {
              const is_last_stage = stage_name === last_stage_name;
              const map_sigs = fn_stage.map_sigs;
              if (Object.keys(fn_stage).length === 0) {
                const io_transform = {};
                if (!is_last_stage) {
                  io_transform.o = {
                    p: arg_transformation.p
                  };
                }
                const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                io_transformed_stage.name = stage_name;
                res2.push([stage_name, io_transformed_stage]);
              } else {
                if (map_sigs) {
                  const io_transform = {
                    i: transform_stage_input
                  };
                  io_transform.o = {
                    "p": arg_transformation.p,
                    "O": arg_transformation.O
                  };
                  const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                  io_transformed_stage.name = stage_name;
                  res2.push([stage_name, io_transformed_stage]);
                } else {
                  const io_transform = {};
                  io_transform.o = {
                    "p": arg_transformation.p,
                    "O": arg_transformation.O
                  };
                  const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                  io_transformed_stage.name = stage_name;
                  res2.push([stage_name, io_transformed_stage]);
                }
              }
            });
            return res2;
          };
          return input_ofns2(ofns);
        };
        const prepare = () => {
          if (sig === "[a]") {
            valid = true;
            each(a[0], (stage) => {
              if (get_a_sig(stage) === "[s,f]") {
                const [stage_name, fn_stage] = stage;
                if (!fn_stage.name) fn_stage.name = stage_name;
              } else {
                valid = false;
                console.trace();
                throw "expected stage to be specified as an array [s,f]";
              }
            });
            if (valid) {
              arr_stages = prepare_arr_fns(a[0]);
              num_stages = arr_stages.length;
            }
          } else if (sig === "[o]") {
            input_ofns(a[0]);
          } else if (sig === "[f]") {
            arr_stages = prepare_arr_fns(a[0]());
            num_stages = arr_stages.length;
          } else {
            console.trace();
            throw "stages expected an array or object (may become more flexible in the future)";
          }
        };
        const ms_pre_prepare = Date.now();
        let res_prepare = prepare();
        const ms_prep_time = Date.now() - ms_pre_prepare;
        if (res_prepare) {
          log("ms_prep_time", ms_prep_time);
          return res_prepare;
        }
        const arr_stages_info = new Array(arr_stages.length);
        each(arr_stages, (arr_stage, i) => {
          const stage_name = arr_stage[0];
          arr_stages_info[i] = {
            name: stage_name
          };
        });
        const process2 = () => {
          const res2 = function() {
            const a2 = arguments, l22 = a2.length;
            const sig2 = get_a_sig(a2);
            let next_apply_args = a2.length === 0 ? void 0 : a2;
            const obs_res = observable((next, complete, error2, status, log2, stage) => {
              const log_stage_events = [];
              obs_res.log_stage_events = log_stage_events;
              const map_stage_events_by_name = {};
              let ms_last_stage_event;
              let c2 = 0;
              const cb_stage_event = (name, evt) => {
                evt = evt || {
                  name
                };
                const now = Date.now();
                evt.ms = now;
                evt.i_stage = c2;
                evt.stage_name = arr_stages2[c2][0];
                if (ms_last_stage_event) {
                  evt.ms_since_last = now - ms_last_stage_event;
                }
                ms_last_stage_event = now;
                log_stage_events.push(evt);
                map_stage_events_by_name[name] = evt;
                if (name === "have-response") {
                  obs_res.ms_latency = now - map_stage_events_by_name["make-request"].ms;
                }
                obs_res.raise("stage", evt);
              };
              const t12 = Date.now();
              const new_obj_fns = a[0](cb_stage_event);
              const newly_prepared_stages = prepare_arr_fns(new_obj_fns);
              const arr_stages2 = newly_prepared_stages;
              const reprep_time = Date.now() - t12;
              log2("reprep_time", reprep_time);
              const res_input = obs_res.input = {};
              const res_output = obs_res.output = {};
              const res_stages = obs_res.stages = clone(arr_stages_info);
              monitor_item(a2, (evt_input_args) => {
                const event_name = evt_input_args.name;
              });
              let i_last_unskipped_stage = -1;
              let exec_is_complete = false;
              const process_next = () => {
                const have_next_stage = !!arr_stages2[c2];
                const i_stage = c2;
                log2("have_next_stage", have_next_stage);
                if (have_next_stage) {
                  const stage_name = arr_stages2[c2][0];
                  const fn_stage = arr_stages2[c2][1];
                  const is_main_stage = fn_stage.main === true;
                  const is_last_stage = c2 === arr_stages2.length - 1;
                  const res_stage = res_stages[c2];
                  const res_prev_stage = res_stages[c2 - 1];
                  const res_next_stage = res_stages[c2 + 1];
                  res_stage.ms_start = Date.now();
                  if (is_main_stage) {
                    res_stage.main = true;
                  }
                  let fn_ready_args;
                  const exec_fn = () => {
                    const i_stage2 = c2;
                    console.log("calling exec_fn " + stage_name);
                    console.trace();
                    const stage_res = fn_stage.call(this, fn_ready_args, (transform_call_event) => {
                      const { name, sig: sig3, value: value2 } = transform_call_event;
                      if (name === "complete") {
                        if (transform_call_event.skipped === true) {
                          res_stage.skipped = true;
                        } else {
                          if (i_stage2 > i_last_unskipped_stage) i_last_unskipped_stage = i_stage2;
                          let content_length;
                          monitor_item(value2, (evt_stage_res) => {
                            const cl_evt = clone(evt_stage_res);
                            const event_name = evt_stage_res.name;
                            if (event_name === "complete") {
                              console.log("c", c2);
                              console.log("stage item complete");
                              const ms_output_complete = Date.now();
                              const ms_taken = ms_output_complete - res_stage.ms_start;
                              res_stage.ms_output_complete = ms_output_complete;
                              if (res_stage.ms_output_start) {
                                const ms_output_taken = res_stage.ms_output_taken = ms_output_complete - res_stage.ms_output_start;
                                if (ms_output_taken > 0) {
                                  if (res_stage.bytes_out) {
                                    const output_rate = res_stage.bytes_out / (ms_output_taken / 1e3);
                                    res_stage.output_rate = output_rate;
                                    if (is_main_stage) {
                                      obs_res.main_rate = output_rate;
                                    }
                                  }
                                }
                              }
                              res_stage.ms_taken = ms_taken;
                              console.log("c", c2);
                              console.log("i_stage", i_stage2);
                              console.log("is_last_stage", is_last_stage);
                            } else if (event_name === "available") {
                              if (evt_stage_res.content_length) {
                                res_stage.content_length = evt_stage_res.content_length;
                                if (is_main_stage) {
                                  content_length = obs_res.content_length = evt_stage_res.content_length;
                                }
                              }
                              res_stage.ms_output_start = Date.now();
                            } else if (event_name === "data") {
                              const { bytes, bytes_total, byte_rate, content_length: content_length2, bytes_remaining, ms_est_remaining, ms_est_complete, ms_taken, proportion } = evt_stage_res;
                              const ms_processing_output = ms_taken;
                              const out_rate = byte_rate;
                              res_stage.bytes_out = bytes_total;
                              if (res_stage.bytes_in) {
                                res_stage.bytes_oi_ratio = res_stage.bytes_out / res_stage.bytes_in;
                              }
                              if (is_main_stage) {
                                obs_res.main_bytes_out = bytes_total;
                                obs_res.main_output_rate = out_rate;
                              }
                              if (i_last_unskipped_stage === i_stage2) {
                                obs_res.bytes_out = bytes_total;
                                obs_res.output_rate = out_rate;
                                if (def(proportion)) obs_res.proportion = proportion;
                                if (def(bytes_remaining)) obs_res.bytes_remaining = bytes_remaining;
                                if (def(ms_est_remaining)) obs_res.ms_est_remaining = ms_est_remaining;
                                if (def(ms_est_complete)) obs_res.ms_est_complete = ms_est_complete;
                              }
                              if (res_next_stage) {
                                res_next_stage.bytes_in = res_next_stage.bytes_in || 0;
                                res_next_stage.bytes_in += cl_evt.bytes;
                              }
                            } else {
                              log2("event_name", event_name);
                              console.trace();
                              throw "stop";
                            }
                          });
                        }
                        next_apply_args = value2;
                        c2++;
                        log2("pre process next stage");
                        process_next();
                      } else {
                        log2("transform_call_event", transform_call_event);
                        if (name === "input-transform-complete") {
                          const ms_input_transform_complete = Date.now();
                          res_stage.ms_input_transform_complete = ms_input_transform_complete;
                          res_stage.ms_input_transform_taken = ms_input_transform_complete - res_stage.ms_input_transform_start;
                        } else if (name === "input-transform-start") {
                          res_stage.ms_input_transform_start = Date.now();
                        } else if (name === "exec-start") {
                          res_stage.ms_exec_start = Date.now();
                        } else if (name === "exec-complete") {
                          const ms_exec_complete = Date.now();
                          res_stage.ms_exec_complete = ms_exec_complete;
                          res_stage.ms_exec_taken = ms_exec_complete - res_stage.ms_exec_start;
                        } else {
                          log2("name", name);
                          log2("transform_call_event", transform_call_event);
                          console.trace();
                          throw "stop";
                        }
                      }
                    });
                  };
                  fn_ready_args = next_apply_args;
                  log2("pre exec_fn");
                  exec_fn();
                } else {
                  const tsr = tf2(next_apply_args);
                  c2++;
                  log2("tsr", tsr);
                  console.log("the stages exec is complete");
                  console.log("i_last_unskipped_stage", i_last_unskipped_stage);
                  exec_is_complete = true;
                  complete(next_apply_args);
                }
              };
              process_next();
            });
            return obs_res;
          };
          res2.is_staged = true;
          res2.return_type = "observable";
          return res2;
        };
        return process2();
      });
      module.exports = {
        "observable": observable,
        "nce": nce,
        "obs": observable,
        "obsalias": obsalias,
        "obscollect": obscollect,
        "obsfilter": obsfilter,
        "obspool": obspool,
        "obsmap": obsmap,
        "seq": seq,
        "sequence": seq,
        "sig_obs_or_cb": sig_obs_or_cb,
        "cb_to_prom_or_cb": cb_to_prom_or_cb,
        "prom_or_cb": prom_or_cb,
        "prom": prom,
        "obs_or_cb": obs_or_cb,
        "unpage": unpage,
        "is_obs": is_obs,
        "is_prom": is_prom,
        "obs_prom_arr_item": obs_prom_arr_item,
        "stages": stages
      };
      if (__require.main === module) {
        console.log("running fnl as main");
        const make_timer_obs = () => observable((next, complete, error2) => {
          let c2 = 2;
          let paused = false;
          let cease = () => {
            clearInterval(ivl);
          };
          let stop = () => {
            clearInterval(ivl);
            complete();
          };
          let ivl = setInterval(() => {
            if (!paused) {
              let v = c2 * 2;
              next({
                "v": v
              });
              c2++;
              if (c2 > 6) {
                error2(new Error("A problem"));
                cease();
              }
              if (c2 > 8) {
                stop();
              }
            }
          }, 1e3);
          return [stop, () => {
            paused = true;
          }, () => {
            paused = false;
          }];
        });
        let obs = make_timer_obs();
        let test_obs = () => {
          obs.on("paused", () => log("* paused"));
          obs.on("resumed", () => log("* resumed"));
          obs.on("error", (err) => log("* error", err));
          obs.next((data) => {
            log("data", data);
          });
        };
        test_obs();
        let test_then = () => {
          (async () => {
            let res2 = await obs;
            log("awaited res", res2);
          })();
        };
        log("stages", stages);
        let test_split = () => {
          obs.on("paused", () => log("* paused"));
          obs.on("resumed", () => log("* resumed"));
          let [obs1, obs2] = obs.split((data) => data.v % 3 === 0);
          obs1.on("next", (data) => log("obs1 data", data));
          obs2.on("next", (data) => log("obs2 data", data));
        };
        let test_filter = () => {
          obs.filter((data) => {
            return data.v !== 8;
          }).filter((data) => {
            return data.v % 3 !== 0;
          });
          obs.next((data) => {
            if (data === 8) {
              obs.delay(5e3);
              obs.pause();
              log("paused");
              setTimeout(() => {
                log("wait over");
                obs.resume();
              }, 2e3);
            }
          }).end(() => {
            log("end");
          });
        };
      } else {
      }
    }
  });

  // ../jsgui3-client/resource.js
  var require_resource2 = __commonJS({
    "../jsgui3-client/resource.js"(exports, module) {
      var jsgui = require_html();
      var Resource = jsgui.Resource;
      var fnl = require_fnl2();
      var prom_or_cb = fnl.prom_or_cb;
      var stringify = jsgui.stringify;
      var each = jsgui.each;
      var arrayify = jsgui.arrayify;
      var tof = jsgui.tof;
      var get_a_sig = jsgui.get_a_sig;
      var filter_map_by_regex = jsgui.filter_map_by_regex;
      var Class = jsgui.Class;
      var Data_Object = jsgui.Data_Object;
      var Enhanced_Data_Object = jsgui.Enhanced_Data_Object;
      var fp = jsgui.fp;
      var is_defined = jsgui.is_defined;
      var Collection = jsgui.Collection;
      var ends_with = function(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
      };
      var Client_Resource = class extends Resource {
        //'fields': {
        //	'url': String
        //},
        // Subscribe?
        // Should likely work more like an observable.
        //  At least it extends evented_class
        constructor(spec = {}) {
          super(spec);
          if (spec.meta) {
            var meta = spec.meta;
            if (meta.url) this.meta.set("url", meta.url);
            if (meta.type_levels) this.meta.set("type_levels", meta.type_levels);
          }
          this.data = new Data_Object();
          this.data.on("change", (property_name, property_value) => {
            this.trigger("change", property_name, property_value);
          });
        }
        // Set as well?
        "get"(path, callback2) {
          return prom_or_cb((resolve, reject) => {
            let ends_dot_json = ends_with(path, ".json");
            let json_url;
            if (!ends_dot_json) {
              json_url = path + ".json";
            } else {
              json_url = path;
            }
            json_url = "resources/" + this.name + "/" + json_url;
            jsgui.http(json_url, function(err, res2) {
              if (err) {
                reject(err);
              } else {
                resolve(res2);
              }
            });
          }, callback2);
        }
        get status() {
          return (async () => {
            let res2 = await jsgui.http("/resources/" + this.name + "/status.json");
            return res2;
          })();
        }
        // We don't notify it this way.
        //  Thinking of making a serparate Resource that uses websockets or sockjs. Should continue to have the normal non-sock client-side resource as well.
        ///  Will not make its own HTTP connections.
        // Not that clear how this type of resource will receive these change notifications.
        //  Seems less likely that we will need this function here.
        //  06/06/2015 - about to make the socks resource connection for the client, it's going to allow for real-time updates, while using generally RESTful addressing.
        "notify_change_from_server"(property_name, property_value) {
          var data = this.data;
          this.data._[property_name] = property_value;
          this.data.trigger("change", property_name, property_value);
        }
      };
      module.exports = Client_Resource;
    }
  });

  // ../jsgui3-client/data-get-post-delete-http-resource.js
  var require_data_get_post_delete_http_resource = __commonJS({
    "../jsgui3-client/data-get-post-delete-http-resource.js"(exports, module) {
      var jsgui = require_html();
      var Client_Resource = require_resource2();
      var fnl = require_fnl2();
      var { prom_or_cb } = fnl;
      var Data_Get_Post_Delete_HTTP_Resource = class extends Client_Resource {
        // Obersvable download...?
        //  Can we get the amount downloaded / uploaded in the browser api yet?
        constructor(spec) {
          super(spec);
          this.data = {};
        }
        get(key2, callback2) {
          return prom_or_cb((solve, jettison) => {
            jsgui.http("/resources/" + key2, (err, res_http) => {
              if (err) {
                jettison(err);
              } else {
                solve(res_http);
              }
            });
          }, callback2);
        }
        // Saving values to the server.
        post(key2, value2, callback2) {
          return prom_or_cb((solve, jettison) => {
            jsgui.http_post("/resources/" + key2, value2, (err, res_http) => {
              if (err) {
                console.log("err", err);
                jettison(err);
              } else {
                solve(res_http);
              }
            });
          }, callback2);
        }
        delete(key2, callback2) {
          return prom_or_cb((solve, jettison) => {
            jsgui.http_delete("/resources/" + key2, (err, res_http) => {
              if (err) {
                console.log("err", err);
                jettison(err);
              } else {
                solve(res_http);
              }
            });
          }, callback2);
        }
      };
      module.exports = Data_Get_Post_Delete_HTTP_Resource;
    }
  });

  // ../jsgui3-client/client-resource-pool.js
  var require_client_resource_pool = __commonJS({
    "../jsgui3-client/client-resource-pool.js"(exports, module) {
      var jsgui = require_html();
      var Resource_Pool = jsgui.Resource_Pool;
      var Data_Get_Post_Delete_HTTP_Resource = require_data_get_post_delete_http_resource();
      var fnl = require_fnl2();
      var prom_or_cb = fnl.prom_or_cb;
      var Client_Resource_Pool = class extends Resource_Pool {
        //'fields': ,
        constructor(spec) {
          super(spec);
          this.data_resource = new Data_Get_Post_Delete_HTTP_Resource({
            name: "data"
          });
          this.add(this.data_resource);
          this._started_resource_names = /* @__PURE__ */ new Set();
        }
        "start"(callback2) {
          return prom_or_cb((resolve, reject) => {
            const start_resource = (resource) => {
              return new Promise((resolve_start, reject_start) => {
                if (!resource || typeof resource.start !== "function") return resolve_start(true);
                let settled = false;
                const settle_ok = (value2) => {
                  if (settled) return;
                  settled = true;
                  resolve_start(value2);
                };
                const settle_err = (err) => {
                  if (settled) return;
                  settled = true;
                  reject_start(err);
                };
                const cb = (err, value2) => {
                  if (err) {
                    settle_err(err);
                  } else {
                    settle_ok(value2);
                  }
                };
                try {
                  const maybe_promise = resource.start(cb);
                  if (maybe_promise && typeof maybe_promise.then === "function") {
                    maybe_promise.then(settle_ok, settle_err);
                  }
                } catch (e) {
                  settle_err(e);
                }
              });
            };
            (async () => {
              try {
                const arr_resources = this.resources && this.resources._arr ? Array.from(this.resources._arr) : [];
                const remaining = new Set(arr_resources.filter((r) => r && !this._started_resource_names.has(r.name)));
                if (remaining.size === 0) {
                  this.__started = true;
                  return resolve(true);
                }
                const started = [];
                let progressed = true;
                while (remaining.size && progressed) {
                  progressed = false;
                  for (const resource of Array.from(remaining)) {
                    let meets_requirements = true;
                    if (resource && typeof resource.meets_requirements === "function") {
                      meets_requirements = resource.meets_requirements();
                    }
                    if (meets_requirements) {
                      await start_resource(resource);
                      remaining.delete(resource);
                      started.push(resource);
                      this._started_resource_names.add(resource.name);
                      progressed = true;
                    }
                  }
                }
                if (remaining.size) {
                  const remaining_names = Array.from(remaining).map((r) => r && r.name).filter(Boolean);
                  const err = new Error("Unable to start all resources (unmet requirements): " + remaining_names.join(", "));
                  err.code = "RESOURCE_REQUIREMENTS_UNMET";
                  err.remaining_resource_names = remaining_names;
                  throw err;
                }
                this.__started = this._started_resource_names.size === arr_resources.length;
                resolve(true);
              } catch (e) {
                reject(e);
              }
            })();
          }, callback2);
        }
      };
      module.exports = Client_Resource_Pool;
    }
  });

  // ../jsgui3-client/page-context.js
  var require_page_context2 = __commonJS({
    "../jsgui3-client/page-context.js"(exports, module) {
      var jsgui = require_html();
      var {
        Control: Control2,
        controls,
        deep_sig,
        each
      } = jsgui;
      var {
        Modal
      } = controls;
      var Client_Resource_Pool = require_client_resource_pool();
      var Client_Page_Context = class extends jsgui.Page_Context {
        constructor(spec) {
          spec = spec || {};
          super(spec);
          const {
            map_controls,
            map_control_iids,
            next_iid
          } = this;
          this.document = spec.document || document;
          this.resource_pool = new Client_Resource_Pool({});
          this.__is_active = true;
          this.map_els = {};
          let ctrl_modal;
          this.mixins = jsgui.mixins;
          Object.defineProperty(this, "modal", {
            get() {
              if (ctrl_modal) {
                return ctrl_modal;
              } else {
                ctrl_modal = new Modal({
                  context: this,
                  class: "modal"
                });
                const body = this.body();
                if (body) {
                  body.add(ctrl_modal);
                }
                return ctrl_modal;
              }
            },
            enumerable: true
          });
          let ctrl_overlay;
          Object.defineProperty(this, "overlay", {
            get() {
              if (ctrl_overlay) {
                return ctrl_overlay;
              } else {
                ctrl_overlay = new Control2({
                  context: this,
                  class: "overlay"
                });
                const body = this.body();
                if (body) {
                  body.add(ctrl_overlay);
                  ctrl_overlay.activate();
                }
                ctrl_overlay.place = (ctrl, location) => {
                  const sloc = deep_sig(location);
                  let placement_abs_pos;
                  if (sloc === "[s,C]") {
                    const [str_description, ctrl_target] = location;
                    const target_bcr = ctrl_target.bcr();
                    const body_bcr = body.bcr();
                    const body_top = body_bcr[0][1];
                    const body_left = body_bcr[0][0];
                    const body_right = body_bcr[1][0];
                    const body_bottom = body_bcr[1][1];
                    if (str_description === "below") {
                      placement_abs_pos = [target_bcr[0][0], target_bcr[1][1]];
                      const height_left_below_placement = body_bottom - placement_abs_pos[1];
                      ctrl.pos = placement_abs_pos;
                      ctrl.dom.attributes.style.position = "absolute";
                      ctrl.dom.attributes.style["max-height"] = height_left_below_placement + "px";
                    } else if (str_description === "above") {
                      placement_abs_pos = [target_bcr[0][0], target_bcr[0][1]];
                      const height_left_above_placement = target_bcr[0][1] - body_top;
                      ctrl.pos = placement_abs_pos;
                      ctrl.dom.attributes.style.position = "absolute";
                      ctrl.dom.attributes.style["max-height"] = height_left_above_placement + "px";
                      const existing_transform = ctrl.dom.attributes.style.transform;
                      ctrl.dom.attributes.style.transform = existing_transform ? "translateY(-100%) " + existing_transform : "translateY(-100%)";
                    } else if (str_description === "right") {
                      placement_abs_pos = [target_bcr[1][0], target_bcr[0][1]];
                      const width_left_right_placement = body_right - placement_abs_pos[0];
                      ctrl.pos = placement_abs_pos;
                      ctrl.dom.attributes.style.position = "absolute";
                      ctrl.dom.attributes.style["max-width"] = width_left_right_placement + "px";
                    } else if (str_description === "left") {
                      placement_abs_pos = [Math.max(body_left, target_bcr[0][0]), target_bcr[0][1]];
                      const width_left_left_placement = target_bcr[0][0] - body_left;
                      ctrl.pos = placement_abs_pos;
                      ctrl.dom.attributes.style.position = "absolute";
                      ctrl.dom.attributes.style["max-width"] = width_left_left_placement + "px";
                      const existing_transform = ctrl.dom.attributes.style.transform;
                      ctrl.dom.attributes.style.transform = existing_transform ? "translateX(-100%) " + existing_transform : "translateX(-100%)";
                    } else {
                      throw new Error('overlay.place: unsupported placement "' + str_description + '" (supported: below, above, right, left)');
                    }
                  }
                  ctrl_overlay.add(ctrl);
                };
                return ctrl_overlay;
              }
            },
            enumerable: true
          });
          let frame_num = 0;
          let last_timestamp;
          let was_resized = false;
          this.map_controls_being_removed_in_frame = false;
          this.map_controls_being_added_in_frame = false;
          let map_ctrls_in_last_frame = {};
          let map_ctrls_in_this_frame;
          let count_dom_ctrls = 0;
          const num_data_points_per_ctrl = 32;
          this.on("activate", () => {
            each(map_controls, (ctrl, jsgui_id) => {
              var _a;
              if ((_a = ctrl.dom) == null ? void 0 : _a.el) {
                map_ctrls_in_last_frame[jsgui_id] = ctrl;
                count_dom_ctrls++;
              }
            });
            let ta_last_frame;
            let ta_current_frame_stored;
            let ta_current_frame_for_user;
            let ta_user_frame_changes;
            let map_current_dom_ctrl_iids;
            let map_current_dom_ctrls_by_iid = {};
            const create_controls_number_props_ta = () => {
              const ta_length = num_data_points_per_ctrl * count_dom_ctrls;
              const res2 = new Float32Array(ta_length);
              const create_map_ctrls_iids = (map_dom_ctrls) => {
                const keys = Object.keys(map_dom_ctrls);
                const res3 = {};
                each(keys, (jsgui_id, i) => {
                  res3[jsgui_id] = i;
                  map_current_dom_ctrls_by_iid[i] = map_dom_ctrls[jsgui_id];
                });
                return res3;
              };
              map_current_dom_ctrl_iids = create_map_ctrls_iids(map_ctrls_in_last_frame);
              const record_ctrls_info = (map_dom_ctrls, map_dom_ctrl_iids, ta2) => {
                each(map_dom_ctrls, (ctrl, jsgui_id) => {
                  const iid = map_dom_ctrl_iids[jsgui_id];
                  const el = ctrl.dom.el;
                  const bcr = el.getBoundingClientRect();
                  const start_pos = iid * num_data_points_per_ctrl;
                  let wpos = start_pos;
                  ta2[wpos++] = bcr.left;
                  ta2[wpos++] = bcr.top;
                  ta2[wpos++] = bcr.width;
                  ta2[wpos++] = bcr.height;
                  ta2[wpos++] = bcr.right;
                  ta2[wpos++] = bcr.bottom;
                });
              };
              record_ctrls_info(map_ctrls_in_last_frame, map_current_dom_ctrl_iids, res2);
              return res2;
            };
            const assign_ctrls_ta_subarrays = (ta_current_frame_for_user2, map_dom_controls, map_iids) => {
              each(map_dom_controls, (ctrl, jsgui_id) => {
                const ctrl_iid = map_iids[jsgui_id];
                const pos_start = ctrl_iid * num_data_points_per_ctrl;
                const pos_end = pos_start + num_data_points_per_ctrl;
                ctrl.ta = ta_current_frame_for_user2.subarray(pos_start, pos_end);
              });
            };
            const frame_process = (timestamp) => {
              frame_num++;
              const find_control_numeric_values_changed = () => {
                let i_ctrl = 0;
                let pos = 0;
                const l2 = ta_current_frame_for_user.length;
                let has_change;
                const ta_controls_which_have_changed_iids = new Int8Array(count_dom_ctrls);
                ta_controls_which_have_changed_iids.fill(-1);
                let tacwhci_wpos = 0;
                while (pos < l2) {
                  const change = ta_current_frame_for_user[pos] - ta_current_frame_stored[pos];
                  let ctrl_iid = Math.floor(pos / num_data_points_per_ctrl);
                  if (change !== 0) {
                    has_change = true;
                    ta_controls_which_have_changed_iids[tacwhci_wpos++] = ctrl_iid;
                  }
                  ta_user_frame_changes[pos] = change;
                  pos++;
                }
                if (has_change) {
                  let c2 = 0;
                  let l3 = ta_user_frame_changes.length;
                  let stop = false;
                  while (!stop && c2 < l3) {
                    const ctrl_iid = ta_controls_which_have_changed_iids[c2];
                    if (ctrl_iid === -1) {
                      stop = true;
                    } else {
                      const changed_ctrl = map_current_dom_ctrls_by_iid[ctrl_iid];
                      const ta_ctrl_changes = ta_user_frame_changes.subarray(ctrl_iid * num_data_points_per_ctrl, (ctrl_iid + 1) * num_data_points_per_ctrl);
                      const ctrl_ta = changed_ctrl.ta;
                      let i = 0, l4 = ctrl_ta.length;
                      let changed_transform = false;
                      for (i = 0; i < l4; i++) {
                        if (ta_ctrl_changes[i] !== 0) {
                          const new_val = ctrl_ta[i];
                          const X2 = 0, Y2 = 1, H2 = 2, W2 = 3, R2 = 4, B2 = 5, TX2 = 6, TY2 = 7;
                          if (i === 1) {
                          } else if (i === 2) {
                          } else if (i === 3) {
                          } else if (i === 4) {
                          } else if (i === 5) {
                          } else if (i === 6 || i === 7) {
                            if (!changed_transform) {
                              const tx = ctrl_ta[6];
                              const ty = ctrl_ta[7];
                              changed_ctrl.dom.attributes.style.transform = "translate3d(" + tx + "px, " + ty + "px, 0px)";
                              changed_transform = true;
                            }
                          }
                        }
                      }
                      let w_pos_ctrl = ctrl_iid * num_data_points_per_ctrl;
                      for (let i2 = 0; i2 < l4; i2++) {
                        ta_current_frame_stored[w_pos_ctrl++] = ctrl_ta[i2];
                      }
                    }
                    c2++;
                  }
                }
              };
              if (frame_num > 1) {
                find_control_numeric_values_changed();
              } else {
                assign_ctrls_ta_subarrays(ta_current_frame_for_user, map_ctrls_in_last_frame, map_current_dom_ctrl_iids);
              }
              let count_add = 0;
              let count_remove = 0;
              if (this.map_controls_being_removed_in_frame) {
                const map_ctrls_being_removed = this.map_controls_being_removed_in_frame;
                map_ctrls_in_this_frame = {};
                each(map_ctrls_in_last_frame, (ctrl_in_last_frame, ctrl_id) => {
                  if (!map_ctrls_being_removed[ctrl_id]) {
                    map_ctrls_in_this_frame[ctrl_id] = ctrl_in_last_frame;
                  }
                });
                count_remove += Object.keys(map_ctrls_being_removed).length;
                this.map_controls_being_removed_in_frame = false;
              } else {
                map_ctrls_in_this_frame = map_ctrls_in_last_frame;
              }
              if (this.map_controls_being_added_in_frame) {
                const map_ctrls_being_added = this.map_controls_being_added_in_frame;
                this.map_controls_being_added_in_frame = false;
                each(map_ctrls_being_added, (ctrl_added, ctrl_id) => {
                  map_ctrls_in_this_frame[ctrl_id] = ctrl_added;
                  count_add++;
                });
              }
              this.raise("frame", {
                number: frame_num,
                timestamp,
                window_was_resized: was_resized,
                count_ctrls_added: count_add,
                count_ctrls_removed: count_remove,
                map_dom_controls: map_ctrls_in_this_frame,
                count_dom_ctrls,
                ta_dom_controls_numeric_values: ta_current_frame_for_user,
                map_dom_ctrl_iids: map_current_dom_ctrl_iids
              });
              last_timestamp = timestamp;
              window.requestAnimationFrame(frame_process);
              was_resized = false;
              map_ctrls_in_last_frame = map_ctrls_in_this_frame;
            };
            window.requestAnimationFrame(frame_process);
            window.addEventListener("resize", (e) => {
              was_resized = true;
              this.raise("window-resize", e);
            });
            ta_current_frame_stored = create_controls_number_props_ta();
            ta_current_frame_for_user = new Float32Array(ta_current_frame_stored.length);
            ta_user_frame_changes = new Float32Array(ta_current_frame_stored.length);
            ta_current_frame_for_user.set(ta_current_frame_stored);
          });
        }
        "get_ctrl_el"(ctrl) {
          return this.map_els[ctrl._id()];
        }
        "register_el"(el) {
          let jsgui_id = el.getAttribute("data-jsgui-id");
          if (jsgui_id) {
            this.map_els[jsgui_id] = el;
          }
        }
        "create_dims_from_current_ctrls"() {
          const { next_iid, map_controls } = this;
          const ctrl_length = 6;
          const ta_res = new Float32Array(next_iid * ctrl_length);
          let wpos = 0;
          each(map_controls, (ctrl, id) => {
            const ctrl_iid = ctrl.iid;
            wpos = ctrl_iid * ctrl_length;
            if (ctrl.dom && ctrl.dom.el) {
              const bcr = ctrl.dom.el.getBoundingClientRect();
              ta_res[wpos++] = bcr.left;
              ta_res[wpos++] = bcr.top;
              ta_res[wpos++] = bcr.right;
              ta_res[wpos++] = bcr.bottom;
              ta_res[wpos++] = bcr.width;
              ta_res[wpos++] = bcr.height;
            }
          });
          return ta_res;
        }
        "body"() {
          var doc = this.document;
          var bod = doc.body;
          if (!this._body) {
            var existing_jsgui_id = bod.getAttribute("data-jsgui-id");
            if (!existing_jsgui_id) {
              var ctrl_body = new jsgui.body({
                "el": bod,
                "context": this
              });
              ctrl_body.dom.el.setAttribute("data-jsgui-id", ctrl_body._id());
              this.register_control(ctrl_body);
              this._body = ctrl_body;
            } else {
              if (this.map_controls[existing_jsgui_id]) {
                this._body = this.map_controls[existing_jsgui_id];
              } else {
                var ctrl_body = new jsgui.body({
                  "el": bod,
                  "context": this
                });
                ctrl_body.dom.el.setAttribute("data-jsgui-id", ctrl_body._id());
                this.register_control(ctrl_body);
                this._body = ctrl_body;
              }
            }
          } else {
          }
          return this._body;
        }
      };
      Client_Page_Context.css = `
body .modal {
    position: absolute;
    left: 0px;
    top: 0px;
}
body .overlay {
    position: absolute;
    left: 0px;
    top: 0px;
}
`;
      module.exports = Client_Page_Context;
    }
  });

  // ../jsgui3-client/sse-resource.js
  var require_sse_resource = __commonJS({
    "../jsgui3-client/sse-resource.js"(exports, module) {
      "use strict";
      var jsgui = require_html();
      var { Evented_Class } = jsgui;
      var DEFAULT_BACKOFF_INITIAL = 1e3;
      var DEFAULT_BACKOFF_MAX = 3e4;
      var DEFAULT_BACKOFF_MULTIPLIER = 2;
      var SSE_Resource = class _SSE_Resource extends Evented_Class {
        /**
         * @param {object} spec
         * @param {string} spec.url - SSE endpoint URL
         * @param {string} [spec.name] - Resource name for identification
         * @param {boolean} [spec.reconnect=true] - Auto-reconnect on disconnect
         * @param {object} [spec.backoff] - Backoff configuration
         * @param {number} [spec.backoff.initial=1000] - Initial backoff delay (ms)
         * @param {number} [spec.backoff.max=30000] - Maximum backoff delay (ms)
         * @param {number} [spec.backoff.multiplier=2] - Backoff multiplier
         * @param {boolean} [spec.parseJSON=true] - Auto-parse JSON event data
         * @param {boolean} [spec.withCredentials=false] - Include credentials in request
         */
        constructor(spec = {}) {
          super();
          this.name = spec.name || "sse_resource";
          this.url = spec.url;
          this.reconnect = spec.reconnect !== false;
          this.parseJSON = spec.parseJSON !== false;
          this.withCredentials = !!spec.withCredentials;
          const backoff = spec.backoff || {};
          this._backoffInitial = backoff.initial || DEFAULT_BACKOFF_INITIAL;
          this._backoffMax = backoff.max || DEFAULT_BACKOFF_MAX;
          this._backoffMultiplier = backoff.multiplier || DEFAULT_BACKOFF_MULTIPLIER;
          this._backoffCurrent = this._backoffInitial;
          this._eventSource = null;
          this._connected = false;
          this._connecting = false;
          this._reconnectTimer = null;
          this._eventTypes = /* @__PURE__ */ new Set(["message"]);
          this._onOpen = this._handleOpen.bind(this);
          this._onError = this._handleError.bind(this);
          this._onMessage = this._handleMessage.bind(this);
        }
        /**
         * Check if EventSource is available in the environment
         */
        static isSupported() {
          return typeof EventSource !== "undefined";
        }
        /**
         * Connect to the SSE stream
         * @returns {boolean} true if connection initiated
         */
        connect() {
          if (this._connected || this._connecting) {
            return false;
          }
          if (!_SSE_Resource.isSupported()) {
            this.raise("error", { type: "unsupported", message: "EventSource not supported" });
            return false;
          }
          if (!this.url) {
            this.raise("error", { type: "config", message: "URL is required" });
            return false;
          }
          this._connecting = true;
          try {
            this._eventSource = new EventSource(this.url, {
              withCredentials: this.withCredentials
            });
            this._eventSource.addEventListener("open", this._onOpen);
            this._eventSource.addEventListener("error", this._onError);
            this._eventSource.addEventListener("message", this._onMessage);
            for (const eventType of this._eventTypes) {
              if (eventType !== "message") {
                this._eventSource.addEventListener(eventType, this._onMessage);
              }
            }
            return true;
          } catch (err) {
            this._connecting = false;
            this.raise("error", { type: "connection", message: err.message, error: err });
            return false;
          }
        }
        /**
         * Disconnect from the SSE stream
         */
        disconnect() {
          this._clearReconnectTimer();
          if (this._eventSource) {
            this._eventSource.removeEventListener("open", this._onOpen);
            this._eventSource.removeEventListener("error", this._onError);
            this._eventSource.removeEventListener("message", this._onMessage);
            for (const eventType of this._eventTypes) {
              if (eventType !== "message") {
                this._eventSource.removeEventListener(eventType, this._onMessage);
              }
            }
            this._eventSource.close();
            this._eventSource = null;
          }
          const wasConnected = this._connected;
          this._connected = false;
          this._connecting = false;
          this._backoffCurrent = this._backoffInitial;
          if (wasConnected) {
            this.raise("disconnect");
          }
        }
        /**
         * Subscribe to a custom event type
         * @param {string} eventType - Event type name
         */
        subscribe(eventType) {
          if (!eventType || this._eventTypes.has(eventType)) {
            return;
          }
          this._eventTypes.add(eventType);
          if (this._eventSource) {
            this._eventSource.addEventListener(eventType, this._onMessage);
          }
        }
        /**
         * Unsubscribe from a custom event type
         * @param {string} eventType - Event type name
         */
        unsubscribe(eventType) {
          if (!eventType || eventType === "message") {
            return;
          }
          this._eventTypes.delete(eventType);
          if (this._eventSource) {
            this._eventSource.removeEventListener(eventType, this._onMessage);
          }
        }
        /**
         * Check if currently connected
         * @returns {boolean}
         */
        isConnected() {
          return this._connected;
        }
        /**
         * Get the current EventSource ready state
         * @returns {number|null} 0=CONNECTING, 1=OPEN, 2=CLOSED
         */
        getReadyState() {
          return this._eventSource ? this._eventSource.readyState : null;
        }
        // ==================== Private Methods ====================
        _handleOpen() {
          this._connected = true;
          this._connecting = false;
          this._backoffCurrent = this._backoffInitial;
          this.raise("connect");
        }
        _handleError(event) {
          const wasConnected = this._connected;
          this._connected = false;
          this._connecting = false;
          this.raise("error", {
            type: "stream",
            readyState: this._eventSource ? this._eventSource.readyState : null
          });
          if (wasConnected && this.reconnect) {
            this._scheduleReconnect();
          }
        }
        _handleMessage(event) {
          let data = event.data;
          if (this.parseJSON && typeof data === "string") {
            try {
              data = JSON.parse(data);
            } catch (e) {
            }
          }
          this.raise("message", {
            type: event.type,
            data,
            lastEventId: event.lastEventId,
            origin: event.origin
          });
          if (event.type !== "message") {
            this.raise(event.type, {
              data,
              lastEventId: event.lastEventId,
              origin: event.origin
            });
          }
        }
        _scheduleReconnect() {
          this._clearReconnectTimer();
          this.raise("reconnecting", { delay: this._backoffCurrent });
          this._reconnectTimer = setTimeout(() => {
            this._reconnectTimer = null;
            this.connect();
          }, this._backoffCurrent);
          this._backoffCurrent = Math.min(
            this._backoffCurrent * this._backoffMultiplier,
            this._backoffMax
          );
        }
        _clearReconnectTimer() {
          if (this._reconnectTimer) {
            clearTimeout(this._reconnectTimer);
            this._reconnectTimer = null;
          }
        }
      };
      module.exports = SSE_Resource;
    }
  });

  // ../jsgui3-client/remote-observable.js
  var require_remote_observable = __commonJS({
    "../jsgui3-client/remote-observable.js"(exports, module) {
      "use strict";
      var SSE_Resource = require_sse_resource();
      var SSE_EVENTS = {
        PAUSED: "paused",
        RESUMED: "resumed",
        STOPPED: "stopped",
        COMPLETE: "complete",
        ERROR: "error"
      };
      var Remote_Observable = class extends SSE_Resource {
        /**
         * @param {object} spec
         * @param {string} spec.url - SSE endpoint URL (GET for stream, POST for control)
         * @param {boolean} [spec.reconnect=true] - Auto-reconnect on disconnect
         * @param {object} [spec.backoff] - Backoff configuration
         */
        constructor(spec = {}) {
          super({ ...spec, parseJSON: true, name: spec.name || "remote_observable" });
          this._latest = null;
          this._isPaused = false;
          Object.values(SSE_EVENTS).forEach((eventName) => {
            this.subscribe(eventName);
          });
        }
        /**
         * Override _handleMessage to transform SSE events to observable events
         * SSE_Resource calls this for both 'message' and named events
         */
        _handleMessage(event) {
          let data = event.data;
          if (this.parseJSON && typeof data === "string") {
            try {
              data = JSON.parse(data);
            } catch (e) {
            }
          }
          const eventType = event.type;
          if (eventType === "message") {
            if (data === "OK" || data === '"OK"') {
              return;
            }
            this._latest = data;
            this.raise("next", data);
          } else if (eventType === SSE_EVENTS.PAUSED) {
            this._isPaused = true;
            this.raise("paused", data);
          } else if (eventType === SSE_EVENTS.RESUMED) {
            this._isPaused = false;
            this.raise("resumed", data);
          } else if (eventType === SSE_EVENTS.STOPPED) {
            this.raise("stopped", data);
          } else if (eventType === SSE_EVENTS.COMPLETE) {
            this.raise("complete", data);
          } else if (eventType === SSE_EVENTS.ERROR) {
            const message = data && data.message || "Remote error";
            this.raise("error", new Error(message));
          } else {
            this.raise(eventType, data);
          }
        }
        /**
         * Get the latest received value
         * @returns {any}
         */
        getLatest() {
          return this._latest;
        }
        /**
         * Check if stream is paused
         * @returns {boolean}
         */
        isPaused() {
          return this._isPaused;
        }
        /**
         * Send a control action to the server
         * Uses the same endpoint with POST method
         * 
         * @param {string} action - 'pause', 'resume', 'stop', or 'status'
         * @returns {Promise<object>}
         */
        async control(action) {
          if (typeof fetch === "undefined") {
            throw new Error("fetch not available");
          }
          const response = await fetch(this.url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action })
          });
          if (!response.ok) {
            throw new Error(`Control action failed: ${response.status}`);
          }
          const result = await response.json();
          if (result.status === "paused") {
            this._isPaused = true;
          } else if (result.status === "ok") {
            this._isPaused = false;
          }
          return result;
        }
        /**
         * Convenience: pause the remote observable
         */
        async pause() {
          return this.control("pause");
        }
        /**
         * Convenience: resume the remote observable
         */
        async resume() {
          return this.control("resume");
        }
        /**
         * Convenience: stop the remote observable
         */
        async stop() {
          return this.control("stop");
        }
        /**
         * Convenience: get status
         */
        async status() {
          return this.control("status");
        }
      };
      Remote_Observable.SSE_EVENTS = SSE_EVENTS;
      module.exports = Remote_Observable;
    }
  });

  // ../jsgui3-client/client.js
  var require_client = __commonJS({
    "../jsgui3-client/client.js"(exports, module) {
      var jsgui = require_html();
      jsgui.Resource_Pool = require_client_resource_pool();
      jsgui.Client_Page_Context = require_page_context2();
      jsgui.Client_Resource = require_resource2();
      jsgui.SSE_Resource = require_sse_resource();
      jsgui.Remote_Observable = require_remote_observable();
      var fnl = require_fnl2();
      var prom_or_cb = fnl.prom_or_cb;
      var { each, tf: tf2 } = jsgui;
      var Control2 = jsgui.Control;
      if (Control2 && Control2.prototype && !Control2.prototype.bindRemote) {
        Control2.prototype.bindRemote = function(observable, options = {}) {
          const { properties, transform, autoConnect = true } = options;
          let obs = observable;
          if (typeof observable === "string") {
            obs = new jsgui.Remote_Observable({ url: observable });
            if (autoConnect) {
              obs.connect();
            }
          }
          const dataModel = this.data && this.data.model;
          if (!dataModel || typeof dataModel.set !== "function") {
            console.warn("[bindRemote] Control has no data.model with set()");
            return obs;
          }
          obs.on("next", (data) => {
            const mapped = typeof transform === "function" ? transform(data) : data;
            if (!mapped || typeof mapped !== "object") return;
            if (Array.isArray(properties) && properties.length > 0) {
              properties.forEach((key2) => {
                if (key2 in mapped) {
                  dataModel.set(key2, mapped[key2]);
                }
              });
            } else {
              Object.entries(mapped).forEach(([key2, value2]) => {
                dataModel.set(key2, value2);
              });
            }
          });
          if (typeof this.on === "function") {
            this.on("destroy", () => {
              if (obs && typeof obs.disconnect === "function") {
                obs.disconnect();
              }
            });
          }
          this._boundObservables = this._boundObservables || [];
          this._boundObservables.push(obs);
          return obs;
        };
      }
      if (typeof window !== "undefined") {
        let context2;
        let page_context;
        jsgui.http = (url, callback2) => {
          return prom_or_cb((resolve, reject) => {
            let timeout = 2500;
            if (Number.isFinite(jsgui.timeout)) timeout = jsgui.timeout;
            var oReq = new XMLHttpRequest();
            let settled = false;
            const settle_ok = (value2) => {
              if (settled) return;
              settled = true;
              resolve(value2);
            };
            const settle_err = (err) => {
              if (settled) return;
              settled = true;
              reject(err);
            };
            oReq.timeout = timeout;
            oReq.ontimeout = () => settle_err({ status: 0, timeout: true });
            oReq.onerror = () => settle_err({ status: 0, network_error: true });
            oReq.onreadystatechange = function() {
              if (this.readyState === 4) {
                if (this.status === 200) {
                  try {
                    var o = JSON.parse(this.responseText);
                    settle_ok(o);
                  } catch (e) {
                    settle_err({
                      status: this.status,
                      responseText: this.responseText,
                      parse_error: true
                    });
                  }
                } else {
                  settle_err(this.status);
                }
              }
            };
            oReq.open("GET", url, true);
            oReq.send();
          }, callback2);
        };
        jsgui.http_post = (url, value2, callback2) => {
          return prom_or_cb((resolve, reject) => {
            var oReq = new XMLHttpRequest();
            let timeout = 2500;
            if (Number.isFinite(jsgui.timeout)) timeout = jsgui.timeout;
            let settled = false;
            const settle_ok = (value3) => {
              if (settled) return;
              settled = true;
              resolve(value3);
            };
            const settle_err = (err) => {
              if (settled) return;
              settled = true;
              reject(err);
            };
            oReq.timeout = timeout;
            oReq.ontimeout = () => settle_err({ status: 0, timeout: true });
            oReq.onerror = () => settle_err({ status: 0, network_error: true });
            oReq.onreadystatechange = function() {
              if (this.readyState === 4) {
                if (this.status === 200) {
                  try {
                    var o = JSON.parse(this.responseText);
                    settle_ok(o);
                  } catch (e) {
                    settle_err({
                      status: this.status,
                      responseText: this.responseText,
                      parse_error: true
                    });
                  }
                } else {
                  settle_err({
                    status: this.status,
                    responseText: this.responseText
                  });
                }
              }
            };
            oReq.open("POST", url, true);
            let o_to_send;
            let tval = tf2(value2);
            if (tval === "s") {
              o_to_send = value2;
            } else if (tval === "B") {
              o_to_send = value2;
            } else if (tval === "a" || tval === "o") {
              const json = JSON.stringify(value2);
              o_to_send = json;
              oReq.setRequestHeader("content-type", "application/json");
            }
            oReq.send(o_to_send);
          }, callback2);
        };
        jsgui.http_delete = (url, callback2) => {
          return prom_or_cb((resolve, reject) => {
            var oReq = new XMLHttpRequest();
            let timeout = 2500;
            if (Number.isFinite(jsgui.timeout)) timeout = jsgui.timeout;
            let settled = false;
            const settle_ok = (value2) => {
              if (settled) return;
              settled = true;
              resolve(value2);
            };
            const settle_err = (err) => {
              if (settled) return;
              settled = true;
              reject(err);
            };
            oReq.timeout = timeout;
            oReq.ontimeout = () => settle_err({ status: 0, timeout: true });
            oReq.onerror = () => settle_err({ status: 0, network_error: true });
            oReq.onreadystatechange = function() {
              if (this.readyState === 4) {
                if (this.status === 200) {
                  try {
                    var o = JSON.parse(this.responseText);
                    settle_ok(o);
                  } catch (e) {
                    settle_err({
                      status: this.status,
                      responseText: this.responseText,
                      parse_error: true
                    });
                  }
                } else {
                  settle_err(this.status);
                }
              }
            };
            oReq.open("DELETE", url, true);
            oReq.send();
          }, callback2);
        };
        jsgui.http_put = (url, value2, callback2) => {
          return prom_or_cb((resolve, reject) => {
            var oReq = new XMLHttpRequest();
            let timeout = 2500;
            if (Number.isFinite(jsgui.timeout)) timeout = jsgui.timeout;
            let settled = false;
            const settle_ok = (val) => {
              if (settled) return;
              settled = true;
              resolve(val);
            };
            const settle_err = (err) => {
              if (settled) return;
              settled = true;
              reject(err);
            };
            oReq.timeout = timeout;
            oReq.ontimeout = () => settle_err({ status: 0, timeout: true });
            oReq.onerror = () => settle_err({ status: 0, network_error: true });
            oReq.onreadystatechange = function() {
              if (this.readyState === 4) {
                if (this.status === 200) {
                  try {
                    var o = JSON.parse(this.responseText);
                    settle_ok(o);
                  } catch (e) {
                    settle_err({
                      status: this.status,
                      responseText: this.responseText,
                      parse_error: true
                    });
                  }
                } else {
                  settle_err({
                    status: this.status,
                    responseText: this.responseText
                  });
                }
              }
            };
            oReq.open("PUT", url, true);
            let o_to_send;
            let tval = tf2(value2);
            if (tval === "s") {
              o_to_send = value2;
            } else if (tval === "B") {
              o_to_send = value2;
            } else if (tval === "a" || tval === "o") {
              const json = JSON.stringify(value2);
              o_to_send = json;
              oReq.setRequestHeader("content-type", "application/json");
            }
            oReq.send(o_to_send);
          }, callback2);
        };
        jsgui.http_patch = (url, value2, callback2) => {
          return prom_or_cb((resolve, reject) => {
            var oReq = new XMLHttpRequest();
            let timeout = 2500;
            if (Number.isFinite(jsgui.timeout)) timeout = jsgui.timeout;
            let settled = false;
            const settle_ok = (val) => {
              if (settled) return;
              settled = true;
              resolve(val);
            };
            const settle_err = (err) => {
              if (settled) return;
              settled = true;
              reject(err);
            };
            oReq.timeout = timeout;
            oReq.ontimeout = () => settle_err({ status: 0, timeout: true });
            oReq.onerror = () => settle_err({ status: 0, network_error: true });
            oReq.onreadystatechange = function() {
              if (this.readyState === 4) {
                if (this.status === 200) {
                  try {
                    var o = JSON.parse(this.responseText);
                    settle_ok(o);
                  } catch (e) {
                    settle_err({
                      status: this.status,
                      responseText: this.responseText,
                      parse_error: true
                    });
                  }
                } else {
                  settle_err({
                    status: this.status,
                    responseText: this.responseText
                  });
                }
              }
            };
            oReq.open("PATCH", url, true);
            let o_to_send;
            let tval = tf2(value2);
            if (tval === "s") {
              o_to_send = value2;
            } else if (tval === "B") {
              o_to_send = value2;
            } else if (tval === "a" || tval === "o") {
              const json = JSON.stringify(value2);
              o_to_send = json;
              oReq.setRequestHeader("content-type", "application/json");
            }
            oReq.send(o_to_send);
          }, callback2);
        };
        jsgui.update_standard_Controls = (page_context2) => {
          each(jsgui.controls, (Control_Subclass, name) => {
            page_context2.update_Controls(name, Control_Subclass);
          });
        };
        let context_data;
        jsgui.register_server_resources = (o_server_resources) => {
          jsgui.def_server_resources = o_server_resources;
        };
        jsgui.register_context_data = (o_context_data) => {
          context_data = o_context_data;
        };
        let activate = () => {
          const { def_server_resources } = jsgui;
          page_context = new jsgui.Client_Page_Context({
            "document": document
          });
          context2 = page_context;
          jsgui.context = page_context;
          if (context_data) {
            Object.assign(page_context, context_data);
          }
          jsgui.update_standard_Controls(page_context);
          jsgui.pre_activate(page_context);
          jsgui.activate(page_context);
          const resource_pool = context2.resource_pool;
          const arr_resources = resource_pool.resources._arr;
          const data_resource = resource_pool.data_resource || resource_pool.data || arr_resources[0];
          const activate_server_resource_fn = (obj_def) => {
            const { name, type } = obj_def;
            if (type === "function") {
              const blocked_names = /* @__PURE__ */ new Set(["__proto__", "prototype", "constructor"]);
              if (typeof name !== "string" || blocked_names.has(name)) {
                console.warn("Refusing to register unsafe server resource name:", name);
                return;
              }
              const fn_remote_call = async (single_param) => {
                const res_dl = await jsgui.http_post("/" + name, single_param);
                console.log("res_dl", res_dl);
                return res_dl;
              };
              data_resource[name] = fn_remote_call;
            }
          };
          const activate_server_resource_fns = () => {
            each(def_server_resources, (server_resource_def, name) => {
              activate_server_resource_fn(server_resource_def);
            });
          };
          activate_server_resource_fns();
          jsgui.raise("activate", {
            context: context2
          });
          page_context.raise("activate", {
            context: context2
          });
        };
        window.addEventListener("load", () => {
          console.log("client.js window onload");
          activate();
        });
      }
      module.exports = jsgui;
    }
  });

  // node_modules/lang-tools/node_modules/lang-mini/lang-mini.js
  var require_lang_mini6 = __commonJS({
    "node_modules/lang-tools/node_modules/lang-mini/lang-mini.js"(exports, module) {
      var running_in_browser = typeof window !== "undefined";
      var running_in_node = !running_in_browser;
      var Readable_Stream;
      var Writable_Stream;
      var Transform_Stream;
      var get_stream = () => {
        if (running_in_node) {
          return (() => {
            const str_libname = "stream";
            const stream2 = __require(str_libname);
            Readable_Stream = stream2.Readable;
            Writable_Stream = stream2.Writable;
            Transform_Stream = stream2.Transform;
            return stream2;
          })();
        } else {
          return void 0;
        }
      };
      var stream = get_stream();
      var each = (collection, fn, context2) => {
        if (collection) {
          if (collection.__type == "collection") {
            return collection.each(fn, context2);
          }
          let ctu = true;
          let stop = function() {
            ctu = false;
          };
          if (is_array(collection)) {
            let res2 = [], res_item;
            for (let c2 = 0, l2 = collection.length; c2 < l2; c2++) {
              res_item;
              if (ctu == false) break;
              if (context2) {
                res_item = fn.call(context2, collection[c2], c2, stop);
              } else {
                res_item = fn(collection[c2], c2, stop);
              }
              if (ctu == false) break;
              res2.push(res_item);
            }
            return res2;
          } else {
            let name, res2 = {};
            for (name in collection) {
              if (ctu === false) break;
              if (context2) {
                res2[name] = fn.call(context2, collection[name], name, stop);
              } else {
                res2[name] = fn(collection[name], name, stop);
              }
              if (ctu === false) break;
            }
            return res2;
          }
        }
      };
      var is_array = Array.isArray;
      var is_dom_node = function isDomNode(obj2) {
        return !!obj2 && typeof obj2.nodeType !== "undefined" && typeof obj2.childNodes !== "undefined";
      };
      var get_truth_map_from_arr = function(arr) {
        let res2 = {};
        each(arr, function(v, i) {
          res2[v] = true;
        });
        return res2;
      };
      var get_arr_from_truth_map = function(truth_map) {
        let res2 = [];
        each(truth_map, function(v, i) {
          res2.push(i);
        });
        return res2;
      };
      var get_map_from_arr = function(arr) {
        let res2 = {};
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[arr[c2]] = c2;
        }
        return res2;
      };
      var arr_like_to_arr = function(arr_like) {
        let res2 = new Array(arr_like.length);
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          res2[c2] = arr_like[c2];
        }
        ;
        return res2;
      };
      var is_ctrl = function(obj2) {
        return typeof obj2 !== "undefined" && obj2 !== null && is_defined(obj2.__type_name) && is_defined(obj2.content) && is_defined(obj2.dom);
      };
      var map_loaded_type_fn_checks = {};
      var map_loaded_type_abbreviations = {
        "object": "o",
        "number": "n",
        "string": "s",
        "function": "f",
        "boolean": "b",
        "undefined": "u",
        "null": "N",
        "array": "a",
        "arguments": "A",
        "date": "d",
        "regex": "r",
        "error": "e",
        "buffer": "B",
        "promise": "p",
        "observable": "O",
        "readable_stream": "R",
        "writable_stream": "W",
        "data_value": "V"
      };
      var using_type_plugins = false;
      var invert = (obj2) => {
        if (!is_array(obj2)) {
          let res2 = {};
          each(obj2, (v, k) => {
            res2[v] = k;
          });
          return res2;
        } else {
          console.trace();
          throw "invert(obj) not supported on arrays";
        }
      };
      var map_loaded_type_names = invert(map_loaded_type_abbreviations);
      var load_type = (name, abbreviation, fn_detect_instance) => {
        map_loaded_type_fn_checks[name] = fn_detect_instance;
        map_loaded_type_names[abbreviation] = name;
        map_loaded_type_abbreviations[name] = abbreviation;
        using_type_plugins = true;
      };
      var tof = (obj2, t12) => {
        let res2 = t12 || typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = name;
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean") {
          return res2;
        }
        if (res2 === "object") {
          if (typeof obj2 !== "undefined") {
            if (obj2 === null) {
              return "null";
            }
            if (obj2.__type) {
              return obj2.__type;
            } else if (obj2.__type_name) {
              return obj2.__type_name;
            } else {
              if (obj2 instanceof Promise) {
                return "promise";
              }
              if (is_ctrl(obj2)) {
                return "control";
              }
              if (obj2 instanceof Date) {
                return "date";
              }
              if (is_array(obj2)) {
                return "array";
              } else {
                if (obj2 instanceof Error) {
                  res2 = "error";
                } else if (obj2 instanceof RegExp) res2 = "regex";
                if (typeof window === "undefined") {
                  if (obj2 && obj2.readInt8) res2 = "buffer";
                }
              }
              return res2;
            }
          } else {
            return "undefined";
          }
        }
        return res2;
      };
      var tf2 = (obj2) => {
        let res2 = typeof obj2;
        if (using_type_plugins) {
          let res3;
          each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
            if (fn_check(obj2)) {
              res3 = map_loaded_type_abbreviations[name];
              stop();
            }
          });
          if (res3) {
            return res3;
          }
        }
        if (res2 === "number" || res2 === "string" || res2 === "function" || res2 === "boolean" || res2 === "undefined") {
          return res2[0];
        } else {
          if (obj2 === null) {
            return "N";
          } else {
            if (running_in_node) {
              if (obj2 instanceof Readable_Stream) {
                return "R";
              } else if (obj2 instanceof Writable_Stream) {
                return "W";
              } else if (obj2 instanceof Transform_Stream) {
                return "T";
              }
            }
            if (typeof Buffer !== "undefined" && obj2 instanceof Buffer) {
              return "B";
            } else if (obj2 instanceof Promise) {
              return "p";
            } else if (obj2 instanceof Date) {
              return "d";
            } else if (is_array(obj2)) {
              return "a";
            } else {
              if (obj2._is_observable === true) {
                return "O";
              } else {
                if (typeof obj2.callee === "function") {
                  return "A";
                } else if (obj2 instanceof Error) {
                  return "e";
                } else if (obj2 instanceof RegExp) return "r";
                return "o";
              }
            }
            return res2;
          }
        }
        console.trace();
        console.log("item", item);
        throw "type not found";
        return res2;
      };
      var atof = (arr) => {
        let res2 = new Array(arr.length);
        for (let c2 = 0, l2 = arr.length; c2 < l2; c2++) {
          res2[c2] = tof(arr[c2]);
        }
        return res2;
      };
      var is_defined = (value2) => {
        return typeof value2 != "undefined";
      };
      var stringify = JSON.stringify;
      var _get_item_sig = (i, arr_depth) => {
        let res2;
        let t12 = typeof i;
        if (t12 === "string") {
          res2 = "s";
        } else if (t12 === "number") {
          res2 = "n";
        } else if (t12 === "boolean") {
          res2 = "b";
        } else if (t12 === "function") {
          res2 = "f";
        } else {
          let t = tof(i, t12);
          if (t === "array") {
            if (arr_depth) {
              res2 = "[";
              for (let c2 = 0, l2 = i.length; c2 < l2; c2++) {
                if (c2 > 0) res2 = res2 + ",";
                res2 = res2 + get_item_sig(i[c2], arr_depth - 1);
              }
              res2 = res2 + "]";
            } else {
              res2 = "a";
            }
          } else if (t === "control") {
            res2 = "c";
          } else if (t === "date") {
            res2 = "d";
          } else if (t === "observable") {
            res2 = "O";
          } else if (t === "regex") {
            res2 = "r";
          } else if (t === "buffer") {
            res2 = "B";
          } else if (t === "readable_stream") {
            res2 = "R";
          } else if (t === "writable_stream") {
            res2 = "W";
          } else if (t === "object") {
            res2 = "o";
          } else if (t === "undefined") {
            res2 = "u";
          } else {
            if (t === "collection_index") {
              return "X";
            } else if (t === "data_object") {
              if (i._abstract) {
                res2 = "~D";
              } else {
                res2 = "D";
              }
            } else {
              if (t === "data_value") {
                if (i._abstract) {
                  res2 = "~V";
                } else {
                  res2 = "V";
                }
              } else if (t === "null") {
                res2 = "!";
              } else if (t === "collection") {
                if (i._abstract) {
                  res2 = "~C";
                } else {
                  res2 = "C";
                }
              } else {
                res2 = "?";
              }
            }
          }
        }
        return res2;
      };
      var get_item_sig = (item2, arr_depth) => {
        if (arr_depth) {
          return _get_item_sig(item2, arr_depth);
        }
        const t = tof(item2);
        if (map_loaded_type_abbreviations[t]) {
          return map_loaded_type_abbreviations[t];
        } else {
          let bt = typeof item2;
          if (bt === "object") {
            if (is_array(item2)) {
              return "a";
            } else {
              return "o";
            }
          } else {
            console.log("map_loaded_type_abbreviations type name not found", t);
            console.log("bt", bt);
            console.trace();
            throw "stop";
          }
        }
      };
      var get_a_sig = (a) => {
        let c2 = 0, l2 = a.length;
        let res2 = "[";
        let first = true;
        for (c2 = 0; c2 < l2; c2++) {
          if (!first) {
            res2 = res2 + ",";
          }
          first = false;
          res2 = res2 + get_item_sig(a[c2]);
        }
        res2 = res2 + "]";
        return res2;
      };
      var deep_sig = (item2, max_depth = -1, depth = 0) => {
        const t = tf2(item2);
        let res2 = "";
        if (t === "a") {
          const l2 = item2.length;
          if (max_depth === -1 || depth <= max_depth) {
            res2 = res2 + "[";
            let first = true;
            for (let c2 = 0; c2 < l2; c2++) {
              if (!first) res2 = res2 + ",";
              res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
              first = false;
            }
            res2 = res2 + "]";
          } else {
            return "a";
          }
        } else if (t === "A") {
          const l2 = item2.length;
          let first = true;
          for (let c2 = 0; c2 < l2; c2++) {
            if (!first) res2 = res2 + ",";
            res2 = res2 + deep_sig(item2[c2], max_depth, depth + 1);
            first = false;
          }
        } else if (t === "o") {
          if (max_depth === -1 || depth <= max_depth) {
            let res3 = "{";
            let first = true;
            each(item2, (v, k) => {
              if (!first) res3 = res3 + ",";
              res3 = res3 + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
              first = false;
            });
            res3 = res3 + "}";
            return res3;
          } else {
            return "o";
          }
        } else {
          res2 = res2 + t;
        }
        return res2;
      };
      var trim_sig_brackets = function(sig) {
        if (tof(sig) === "string") {
          if (sig.charAt(0) == "[" && sig.charAt(sig.length - 1) == "]") {
            return sig.substring(1, sig.length - 1);
          } else {
            return sig;
          }
        }
      };
      var arr_trim_undefined = function(arr_like) {
        let res2 = [];
        let last_defined = -1;
        let t, v;
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          v = arr_like[c2];
          t = tof(v);
          if (t == "undefined") {
          } else {
            last_defined = c2;
          }
        }
        for (let c2 = 0, l2 = arr_like.length; c2 < l2; c2++) {
          if (c2 <= last_defined) {
            res2.push(arr_like[c2]);
          }
        }
        return res2;
      };
      var functional_polymorphism = function(options, fn) {
        let a0 = arguments;
        if (a0.length === 1) {
          fn = a0[0];
          options = null;
        }
        let arr_slice = Array.prototype.slice;
        let arr, sig, a2, l2, a;
        return function() {
          a = arguments;
          l2 = a.length;
          if (l2 === 1) {
            sig = get_item_sig([a[0]], 1);
            a2 = [a[0]];
            a2.l = 1;
            return fn.call(this, a2, sig);
          } else if (l2 > 1) {
            arr = arr_trim_undefined(arr_slice.call(a, 0));
            sig = get_item_sig(arr, 1);
            arr.l = arr.length;
            return fn.call(this, arr, sig);
          } else if (a.length === 0) {
            arr = new Array(0);
            arr.l = 0;
            return fn.call(this, arr, "[]");
          }
        };
      };
      var fp = functional_polymorphism;
      var parse_sig = (str_sig, opts = {}) => {
        const sig2 = str_sig.split(", ").join(",");
        const sig_items = sig2.split(",");
        const res2 = [];
        each(sig_items, (sig_item) => {
          if (sig_item.length === 1) {
            let type_name = map_loaded_type_names[sig_item];
            res2.push({
              abbreviation: sig_item,
              type_name
            });
          } else {
            let suffix_modifiers;
            let zero_or_more = false;
            let one_or_more = false;
            let type_name = sig_item;
            const obj_res = {
              type_name
            };
            const distil_suffix_modifiers = () => {
              let last_char = type_name.substr(type_name.length - 1);
              if (last_char === "*") {
                type_name = type_name.substr(0, type_name.length - 1);
                zero_or_more = true;
                obj_res.zero_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("*");
                distil_suffix_modifiers();
              } else if (last_char === "+") {
                type_name = type_name.substr(0, type_name.length - 1);
                one_or_more = true;
                obj_res.one_or_more = true;
                obj_res.modifiers = obj_res.modifiers || [];
                obj_res.modifiers.push("+");
                distil_suffix_modifiers();
              } else {
              }
            };
            distil_suffix_modifiers();
            obj_res.type_name = type_name;
            res2.push(obj_res);
          }
        });
        return res2;
      };
      var mfp_not_sigs = get_truth_map_from_arr(["pre", "default", "post"]);
      var log = () => {
      };
      var combinations = (arr, arr_idxs_to_ignore) => {
        const map_ignore_idxs = {};
        if (arr_idxs_to_ignore) {
          each(arr_idxs_to_ignore, (idx_to_ignore) => {
            map_ignore_idxs[idx_to_ignore] = true;
          });
        }
        if (arr.some((subArray) => subArray.length === 0)) {
          return [];
        }
        const res2 = [];
        const l2 = arr.length;
        const arr_idxs_num_options = new Uint32Array(l2);
        each(arr, (arr_item1, i1) => {
          arr_idxs_num_options[i1] = arr_item1.length;
        });
        const arr_current_option_idxs = new Uint32Array(l2).fill(0);
        const result_from_indexes = (arr2, arg_indexes) => {
          const res3 = new Array(l2);
          if (arg_indexes.length === l2) {
            for (var c2 = 0; c2 < l2; c2++) {
              res3[c2] = arr2[c2][arg_indexes[c2]];
            }
          } else {
            console.trace();
            throw "Arguments length mismatch";
          }
          return res3;
        };
        const incr = () => {
          for (c = l2 - 1; c >= 0; c--) {
            const ival = arr_current_option_idxs[c];
            const max = arr_idxs_num_options[c] - 1;
            if (ival < max) {
              arr_current_option_idxs[c]++;
              break;
            } else {
              if (c === 0) {
                return false;
              } else {
                arr_current_option_idxs.fill(0, c);
              }
            }
          }
          return true;
        };
        let vals = result_from_indexes(arr, arr_current_option_idxs);
        res2.push(vals);
        while (incr()) {
          let vals2 = result_from_indexes(arr, arr_current_option_idxs);
          res2.push(vals2);
        }
        return res2;
      };
      var map_native_types = {
        "string": true,
        "boolean": true,
        "number": true,
        "object": true
      };
      var mfp = function() {
        const a1 = arguments;
        const sig1 = get_a_sig(a1);
        let options = {};
        let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {}, inner_map_parsed_sigs = {}, arr_sig_parsed_sig_fns = [], fn_post;
        let tm_sig_fns;
        let fn_default;
        let single_fn;
        let req_sig_single_fn;
        if (sig1 === "[o]") {
          provided_map_sig_fns = a1[0];
        } else if (sig1 === "[o,o]") {
          options = a1[0];
          provided_map_sig_fns = a1[1];
        } else if (sig1 === "[o,f]") {
          options = a1[0];
          single_fn = a1[1];
        } else if (sig1 === "[o,s,f]") {
          options = a1[0];
          req_sig_single_fn = a1[1];
          single_fn = a1[2];
          provided_map_sig_fns = {};
          provided_map_sig_fns[req_sig_single_fn] = single_fn;
        } else if (sig1 === "[f,o]") {
          single_fn = a1[0];
          options = a1[1];
        } else if (sig1 === "[f]") {
          single_fn = a1[0];
        } else {
          console.log("sig1", sig1);
          console.trace();
          throw "mfp NYI";
        }
        let {
          single,
          name,
          grammar,
          verb,
          noun,
          return_type,
          return_subtype,
          pure,
          main,
          skip
        } = options;
        let parsed_grammar;
        let identify, validate;
        let dsig = deep_sig;
        (() => {
          if (provided_map_sig_fns) {
            if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
            each(provided_map_sig_fns, (fn, sig) => {
              if (typeof fn === "function") {
                if (!mfp_not_sigs[sig]) {
                  const parsed_sig = parse_sig(sig);
                  const arr_args_with_modifiers = [];
                  const arr_args_all_modification_versions = [];
                  each(parsed_sig, (arg, i) => {
                    arr_args_all_modification_versions[i] = [];
                    if (arg.modifiers) {
                      const arg_num_modifiers = arg.modifiers.length;
                      if (arg_num_modifiers > 1) {
                        throw "Use of more than 1 modifier is currently unsupported.";
                      } else if (arg_num_modifiers === 1) {
                        arr_args_with_modifiers.push([i, arg]);
                        const single_modifier = arg.modifiers[0];
                        if (single_modifier === "*") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "+") {
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                          const plural_name = grammar.maps.sing_plur[arg.type_name];
                          arr_args_all_modification_versions[i].push(plural_name);
                        }
                        if (single_modifier === "?") {
                          arr_args_all_modification_versions[i].push("");
                          arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                        }
                      }
                    } else {
                      arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
                    }
                  });
                  const combo_args = combinations(arr_args_all_modification_versions);
                  const combo_sigs = [];
                  let i_first_of_last_undefined = -1;
                  each(combo_args, (arg_set) => {
                    let combo_sig = "";
                    each(arg_set, (arg, i) => {
                      let lsigb4 = combo_sig.length;
                      if (i > 0) {
                        combo_sig = combo_sig + ",";
                      }
                      if (arg === "") {
                        combo_sig = combo_sig + "u";
                        if (i_first_of_last_undefined === -1) {
                          i_first_of_last_undefined = lsigb4;
                        }
                      } else {
                        combo_sig = combo_sig + arg;
                        i_first_of_last_undefined = -1;
                      }
                    });
                    if (i_first_of_last_undefined > 0) {
                      const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
                      combo_sigs.push(combo_sig_no_last_undefined);
                    }
                    combo_sigs.push(combo_sig);
                  });
                  if (combo_sigs.length > 0) {
                    each(combo_sigs, (combo_sig) => {
                      inner_map_sig_fns[combo_sig] = fn;
                    });
                  } else {
                    inner_map_sig_fns[sig] = fn;
                  }
                  inner_map_parsed_sigs[sig] = parsed_sig;
                  arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
                } else {
                  console.log("ommiting, not parsing sig", sig);
                }
              } else {
                console.log("fn", fn);
                console.trace();
                throw "Expected: function";
              }
              ;
            });
          }
          each(inner_map_sig_fns, (fn, sig) => {
            tm_sig_fns = tm_sig_fns || {};
            tm_sig_fns[sig] = true;
          });
        })();
        const res2 = function() {
          const a2 = arguments;
          const l2 = a2.length;
          console.log("");
          console.log("calling mfp function");
          console.log("--------------------");
          console.log("");
          let mfp_fn_call_deep_sig;
          let ltof = tof;
          const lsig = dsig;
          let ltf = tf2;
          mfp_fn_call_deep_sig = lsig(a2);
          const mfp_fn_call_shallow_sig = (() => {
            if (!a2 || a2.length === 0) return "";
            let res3 = "";
            for (let i = 0; i < a2.length; i++) {
              if (i > 0) res3 = res3 + ",";
              res3 = res3 + ltf(a2[i]);
            }
            return res3;
          })();
          let do_skip = false;
          if (skip) {
            if (skip(a2)) {
              do_skip = true;
            } else {
            }
          }
          if (!do_skip) {
            if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
              return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
            } else if (mfp_fn_call_shallow_sig && inner_map_sig_fns[mfp_fn_call_shallow_sig]) {
              return inner_map_sig_fns[mfp_fn_call_shallow_sig].apply(this, a2);
            } else {
              let idx_last_fn = -1;
              let idx_last_obj = -1;
              each(a2, (arg, i_arg) => {
                i_arg = parseInt(i_arg, 10);
                const targ = tf2(arg);
                if (targ === "o") {
                  idx_last_obj = i_arg;
                }
                if (targ === "f") {
                  idx_last_fn = i_arg;
                }
              });
              const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
              const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
              const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
              let possible_options_obj;
              if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
              const new_args_arrangement = [];
              for (let f = 0; f < idx_last_obj; f++) {
                new_args_arrangement.push(a2[f]);
              }
              each(possible_options_obj, (value2, key2) => {
                new_args_arrangement.push(value2);
              });
              let naa_sig = lsig(new_args_arrangement);
              naa_sig = naa_sig.substring(1, naa_sig.length - 1);
              if (inner_map_sig_fns[naa_sig]) {
                return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
              } else {
                if (fn_default) {
                  return fn_default.call(this, a2, mfp_fn_call_deep_sig);
                } else {
                  if (single_fn) {
                    console.log("pre apply single_fn");
                    return single_fn.apply(this, a2);
                  } else {
                    console.log("Object.keys(inner_map_parsed_sigs)", Object.keys(inner_map_parsed_sigs));
                    console.trace();
                    console.log("mfp_fn_call_deep_sig", mfp_fn_call_deep_sig);
                    console.log("provided_map_sig_fns", provided_map_sig_fns);
                    if (provided_map_sig_fns) log("Object.keys(provided_map_sig_fns)", Object.keys(provided_map_sig_fns));
                    console.log("Object.keys(inner_map_sig_fns)", Object.keys(inner_map_sig_fns));
                    console.trace();
                    throw "no signature match found. consider using a default signature. mfp_fn_call_deep_sig: " + mfp_fn_call_deep_sig;
                  }
                }
              }
            }
          }
        };
        const _ = {};
        if (name) _.name = name;
        if (single) _.single = single;
        if (skip) _.skip = skip;
        if (grammar) _.grammar = grammar;
        if (typeof options !== "undefined" && options.async) _.async = options.async;
        if (main === true) _.main = true;
        if (return_type) _.return_type = return_type;
        if (return_subtype) _.return_subtype = return_subtype;
        if (pure) _.pure = pure;
        if (tm_sig_fns) _.map_sigs = tm_sig_fns;
        if (Object.keys(_).length > 0) {
          res2._ = _;
        }
        return res2;
      };
      var arrayify = fp(function(a, sig) {
        let param_index, num_parallel = 1, delay = 0, fn;
        let res2;
        let process_as_fn = function() {
          res2 = function() {
            let a2 = arr_like_to_arr(arguments), ts = atof(a2), t = this;
            let last_arg = a2[a2.length - 1];
            if (tof(last_arg) == "function") {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                let fns = [];
                each(a2[param_index], function(v, i) {
                  let new_params = a2.slice(0, a2.length - 1);
                  new_params[param_index] = v;
                  fns.push([t, fn, new_params]);
                });
                call_multiple_callback_functions(fns, num_parallel, delay, (err, res4) => {
                  if (err) {
                    console.trace();
                    throw err;
                  } else {
                    let a3 = [];
                    a3 = a3.concat.apply(a3, res4);
                    let callback2 = last_arg;
                    callback2(null, a3);
                  }
                });
              } else {
                return fn.apply(t, a2);
              }
            } else {
              if (typeof param_index !== "undefined" && ts[param_index] == "array") {
                let res3 = [];
                for (let c2 = 0, l2 = a2[param_index].length; c2 < l2; c2++) {
                  a2[param_index] = arguments[param_index][c2];
                  let result = fn.apply(t, a2);
                  res3.push(result);
                }
                return res3;
              } else {
                return fn.apply(t, a2);
              }
            }
          };
        };
        if (sig == "[o]") {
          let res3 = [];
          each(a[0], function(v, i) {
            res3.push([v, i]);
          });
        } else if (sig == "[f]") {
          param_index = 0, fn = a[0];
          process_as_fn();
        } else if (sig == "[n,f]") {
          param_index = a[0], fn = a[1];
          process_as_fn();
        } else if (sig == "[n,n,f]") {
          param_index = a[0], num_parallel = a[1], fn = a[2];
          process_as_fn();
        } else if (sig == "[n,n,n,f]") {
          param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
          process_as_fn();
        }
        return res2;
      });
      var mapify = (target) => {
        let tt = tof(target);
        if (tt == "function") {
          let res2 = fp(function(a, sig) {
            let that2 = this;
            if (sig == "[o]") {
              let map = a[0];
              each(map, function(v, i) {
                target.call(that2, v, i);
              });
            } else if (sig == "[o,f]") {
              let map = a[0];
              let callback2 = a[1];
              let fns = [];
              each(map, function(v, i) {
                fns.push([target, [v, i]]);
              });
              call_multi(fns, function(err_multi, res_multi) {
                if (err_multi) {
                  callback2(err_multi);
                } else {
                  callback2(null, res_multi);
                }
              });
            } else if (a.length >= 2) {
              target.apply(this, a);
            }
          });
          return res2;
        } else if (tt == "array") {
          let res2 = {};
          if (arguments.length == 1) {
            if (is_arr_of_strs(target)) {
              each(target, function(v, i) {
                res2[v] = true;
              });
            } else {
              each(target, function(v, i) {
                res2[v[0]] = v[1];
              });
            }
          } else {
            let by_property_name = arguments[1];
            each(target, function(v, i) {
              res2[v[by_property_name]] = v;
            });
          }
          return res2;
        }
      };
      var clone = fp((a, sig) => {
        let obj2 = a[0];
        if (a.l === 1) {
          if (obj2 && typeof obj2.clone === "function") {
            return obj2.clone();
          } else {
            let t = tof(obj2);
            if (t === "array") {
              let res2 = [];
              each(obj2, (v) => {
                res2.push(clone(v));
              });
              return res2;
            } else if (t === "undefined") {
              return void 0;
            } else if (t === "string") {
              return obj2;
            } else if (t === "number") {
              return obj2;
            } else if (t === "function") {
              return obj2;
            } else if (t === "boolean") {
              return obj2;
            } else if (t === "null") {
              return obj2;
            } else if (t === "date") {
              return new Date(obj2.getTime());
            } else if (t === "regex") {
              return new RegExp(obj2.source, obj2.flags);
            } else if (t === "buffer") {
              if (typeof Buffer !== "undefined" && Buffer.from) {
                return Buffer.from(obj2);
              } else if (obj2 && typeof obj2.slice === "function") {
                return obj2.slice(0);
              } else {
                return obj2;
              }
            } else if (t === "error") {
              const cloned_error = new obj2.constructor(obj2.message);
              cloned_error.name = obj2.name;
              cloned_error.stack = obj2.stack;
              each(obj2, (value2, key2) => {
                if (key2 !== "message" && key2 !== "name" && key2 !== "stack") {
                  cloned_error[key2] = clone(value2);
                }
              });
              return cloned_error;
            } else if (t === "object") {
              const res2 = {};
              each(obj2, (value2, key2) => {
                res2[key2] = clone(value2);
              });
              return res2;
            } else {
              return obj2;
            }
          }
        } else if (a.l === 2 && tof(a[1]) === "number") {
          let res2 = [];
          for (let c2 = 0; c2 < a[1]; c2++) {
            res2.push(clone(obj2));
          }
          return res2;
        }
      });
      var set_vals = function(obj2, map) {
        each(map, function(v, i) {
          obj2[i] = v;
        });
      };
      var ll_set = (obj2, prop_name2, prop_value) => {
        let arr = prop_name2.split(".");
        let c2 = 0, l2 = arr.length;
        let i = obj2._ || obj2, s;
        while (c2 < l2) {
          s = arr[c2];
          if (typeof i[s] == "undefined") {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            } else {
              i[s] = {};
            }
          } else {
            if (c2 - l2 == -1) {
              i[s] = prop_value;
            }
          }
          i = i[s];
          c2++;
        }
        ;
        return prop_value;
      };
      var ll_get = (a0, a1) => {
        if (a0 && a1) {
          let i = a0._ || a0;
          if (a1 == ".") {
            if (typeof i["."] == "undefined") {
              return void 0;
            } else {
              return i["."];
            }
          } else {
            let arr = a1.split(".");
            let c2 = 0, l2 = arr.length, s;
            while (c2 < l2) {
              s = arr[c2];
              if (typeof i[s] == "undefined") {
                if (c2 - l2 == -1) {
                } else {
                  throw "object " + s + " not found";
                }
              } else {
                if (c2 - l2 == -1) {
                  return i[s];
                }
              }
              i = i[s];
              c2++;
            }
          }
        }
      };
      var truth = function(value2) {
        return value2 === true;
      };
      var iterate_ancestor_classes = (obj2, callback2) => {
        let ctu = true;
        let stop = () => {
          ctu = false;
        };
        callback2(obj2, stop);
        if (obj2._superclass && ctu) {
          iterate_ancestor_classes(obj2._superclass, callback2);
        }
      };
      var is_arr_of_t = function(obj2, type_name) {
        let t = tof(obj2), tv;
        if (t === "array") {
          let res2 = true;
          each(obj2, function(v, i) {
            tv = tof(v);
            if (tv != type_name) res2 = false;
          });
          return res2;
        } else {
          return false;
        }
      };
      var is_arr_of_arrs = function(obj2) {
        return is_arr_of_t(obj2, "array");
      };
      var is_arr_of_strs = function(obj2) {
        return is_arr_of_t(obj2, "string");
      };
      var input_processors = {};
      var output_processors = {};
      var call_multiple_callback_functions = fp(function(a, sig) {
        let arr_functions_params_pairs, callback2, return_params = false;
        let delay;
        let num_parallel = 1;
        if (a.l === 1) {
        } else if (a.l === 2) {
          arr_functions_params_pairs = a[0];
          callback2 = a[1];
        } else if (a.l === 3) {
          if (sig === "[a,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            callback2 = a[2];
          } else if (sig === "[n,a,f]") {
            arr_functions_params_pairs = a[1];
            num_parallel = a[0];
            callback2 = a[2];
          } else if (sig === "[a,f,b]") {
            arr_functions_params_pairs = a[0];
            callback2 = a[1];
            return_params = a[2];
          }
        } else if (a.l === 4) {
          if (sig === "[a,n,n,f]") {
            arr_functions_params_pairs = a[0];
            num_parallel = a[1];
            delay = a[2];
            callback2 = a[3];
          } else if (sig == "[n,n,a,f]") {
            arr_functions_params_pairs = a[2];
            num_parallel = a[0];
            delay = a[1];
            callback2 = a[3];
          }
        }
        let res2 = [];
        let l2 = arr_functions_params_pairs.length;
        let c2 = 0;
        let count_unfinished = l2;
        let num_currently_executing = 0;
        let process2 = (delay2) => {
          num_currently_executing++;
          let main = () => {
            let pair = arr_functions_params_pairs[c2];
            let context2;
            let fn, params, fn_callback;
            let pair_sig = get_item_sig(pair);
            let t_pair = tof(pair);
            if (t_pair == "function") {
              fn = pair;
              params = [];
            } else {
              if (pair) {
                if (pair.length == 1) {
                }
                if (pair.length == 2) {
                  if (tof(pair[1]) == "function") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = [];
                  } else {
                    fn = pair[0];
                    params = pair[1];
                  }
                }
                if (pair.length == 3) {
                  if (tof(pair[0]) === "function" && tof(pair[1]) === "array" && tof(pair[2]) === "function") {
                    fn = pair[0];
                    params = pair[1];
                    fn_callback = pair[2];
                  }
                  if (tof(pair[1]) === "function" && tof(pair[2]) === "array") {
                    context2 = pair[0];
                    fn = pair[1];
                    params = pair[2];
                  }
                }
                if (pair.length == 4) {
                  context2 = pair[0];
                  fn = pair[1];
                  params = pair[2];
                  fn_callback = pair[3];
                }
              } else {
              }
            }
            let i = c2;
            c2++;
            let cb = (err, res22) => {
              num_currently_executing--;
              count_unfinished--;
              if (err) {
                let stack = new Error().stack;
                callback2(err);
              } else {
                if (return_params) {
                  res2[i] = [params, res22];
                } else {
                  res2[i] = res22;
                }
                if (fn_callback) {
                  fn_callback(null, res22);
                }
                if (c2 < l2) {
                  if (num_currently_executing < num_parallel) {
                    process2(delay2);
                  }
                } else {
                  if (count_unfinished <= 0) {
                    callback2(null, res2);
                  }
                }
              }
            };
            let arr_to_call = params || [];
            arr_to_call.push(cb);
            if (fn) {
              if (context2) {
                fn.apply(context2, arr_to_call);
              } else {
                fn.apply(this, arr_to_call);
              }
            } else {
            }
          };
          if (arr_functions_params_pairs[c2]) {
            if (delay2) {
              setTimeout(main, delay2);
            } else {
              main();
            }
          }
        };
        if (arr_functions_params_pairs.length > 0) {
          while (c2 < l2 && num_currently_executing < num_parallel) {
            if (delay) {
              process2(delay * c2);
            } else {
              process2();
            }
          }
        } else {
          if (callback2) {
          }
        }
      });
      var call_multi = call_multiple_callback_functions;
      var Fns = function(arr) {
        let fns = arr || [];
        fns.go = function(parallel, delay, callback2) {
          let a = arguments;
          let al = a.length;
          if (al == 1) {
            call_multi(fns, a[0]);
          }
          if (al == 2) {
            call_multi(parallel, fns, delay);
          }
          if (al == 3) {
            call_multi(parallel, delay, fns, callback2);
          }
        };
        return fns;
      };
      var native_constructor_tof = function(value2) {
        if (value2 === String) {
          return "String";
        }
        if (value2 === Number) {
          return "Number";
        }
        if (value2 === Boolean) {
          return "Boolean";
        }
        if (value2 === Array) {
          return "Array";
        }
        if (value2 === Object) {
          return "Object";
        }
      };
      var sig_match = function(sig1, sig2) {
        let sig1_inner = sig1.substr(1, sig1.length - 2);
        let sig2_inner = sig2.substr(1, sig2.length - 2);
        if (sig1_inner.indexOf("[") > -1 || sig1_inner.indexOf("]") > -1 || sig2_inner.indexOf("[") > -1 || sig2_inner.indexOf("]") > -1) {
          throw "sig_match only supports flat signatures.";
        }
        let sig1_parts = sig1_inner.split(",");
        let sig2_parts = sig2_inner.split(",");
        let res2 = true;
        if (sig1_parts.length == sig2_parts.length) {
          let c2 = 0, l2 = sig1_parts.length, i1, i2;
          while (res2 && c2 < l2) {
            i1 = sig1_parts[c2];
            i2 = sig2_parts[c2];
            if (i1 === i2) {
            } else {
              if (i1 !== "?") {
                res2 = false;
              }
            }
            c2++;
          }
          return res2;
        } else {
          return false;
        }
      };
      var remove_sig_from_arr_shell = function(sig) {
        if (sig[0] == "[" && sig[sig.length - 1] == "]") {
          return sig.substring(1, sig.length - 1);
        }
        return sig;
      };
      var str_arr_mapify = function(fn) {
        let res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              let s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              let res22 = {}, that2 = this;
              each(a[0], function(v, i) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var to_arr_strip_keys = (obj2) => {
        let res2 = [];
        each(obj2, (v) => {
          res2.push(v);
        });
        return res2;
      };
      var arr_objs_to_arr_keys_values_table = (arr_objs) => {
        let keys = Object.keys(arr_objs[0]);
        let arr_items = [], arr_values;
        each(arr_objs, (item2) => {
          arr_items.push(to_arr_strip_keys(item2));
        });
        return [keys, arr_items];
      };
      var set_arr_tree_value = (arr_tree, arr_path, value2) => {
        let item_current = arr_tree;
        let last_item_current, last_path_item;
        each(arr_path, (path_item) => {
          last_item_current = item_current;
          item_current = item_current[path_item];
          last_path_item = path_item;
        });
        last_item_current[last_path_item] = value2;
      };
      var get_arr_tree_value = (arr_tree, arr_path) => {
        let item_current = arr_tree;
        each(arr_path, (path_item) => {
          item_current = item_current[path_item];
        });
        return item_current;
      };
      var deep_arr_iterate = (arr, path = [], callback2) => {
        if (arguments.length === 2) {
          callback2 = path;
          path = [];
        }
        each(arr, (item2, i) => {
          let c_path = clone(path);
          c_path.push(i);
          let t = tof(item2);
          if (t === "array") {
            deep_arr_iterate(item2, c_path, callback2);
          } else {
            callback2(c_path, item2);
          }
        });
      };
      var prom = (fn) => {
        let fn_res = function() {
          const a = arguments;
          const t_a_last = typeof a[a.length - 1];
          if (t_a_last === "function") {
            fn.apply(this, a);
          } else {
            return new Promise((resolve, reject) => {
              [].push.call(a, (err, res2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res2);
                }
              });
              fn.apply(this, a);
            });
          }
        };
        return fn_res;
      };
      var vectorify = (n_fn) => {
        let fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            throw "stop - need to check.";
            let res2 = a[0];
            for (let c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig === "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              const ats = atof(a);
              if (ats[0] === "array") {
                if (ats[1] === "number") {
                  const res2 = [], n = a[1], l2 = a[0].length;
                  let c2;
                  for (c2 = 0; c2 < l2; c2++) {
                    res2.push(fn_res(a[0][c2], n));
                  }
                  return res2;
                } else if (ats[1] === "array") {
                  if (ats[0].length !== ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    const l2 = a[0].length, res2 = new Array(l2), arr2 = a[1];
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = fn_res(a[0][c2], arr2[c2]);
                    }
                    return res2;
                  }
                }
              }
            }
          }
          ;
        });
        return fn_res;
      };
      var n_add = (n1, n2) => n1 + n2;
      var n_subtract = (n1, n2) => n1 - n2;
      var n_multiply = (n1, n2) => n1 * n2;
      var n_divide = (n1, n2) => n1 / n2;
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var map_tas_by_type = {
        "c": Uint8ClampedArray,
        "ui8": Uint8Array,
        "i16": Int16Array,
        "i32": Int32Array,
        "ui16": Uint16Array,
        "ui32": Uint32Array,
        "f32": Float32Array,
        "f64": Float64Array
      };
      var get_typed_array = function() {
        const a = arguments;
        let length, input_array;
        const type = a[0];
        if (is_array(a[1])) {
          input_array = a[1];
        } else {
          length = a[1];
        }
        const ctr = map_tas_by_type[type];
        if (ctr) {
          if (input_array) {
            return new ctr(input_array);
          } else if (length) {
            return new ctr(length);
          }
        }
      };
      var Grammar = class {
        constructor(spec) {
          const eg_spec = {
            name: "User Auth Grammar"
          };
          const {
            name
          } = spec;
          this.name = name;
          const eg_indexing = () => {
            let map_sing_plur = {};
            let map_plur_sing = {};
            let map_sing_def = {};
            let map_sig_sing = {};
            let map_sig0_sing = {};
            let map_sig1_sing = {};
            let map_sig2_sing = {};
          };
          this.maps = {
            sing_plur: {},
            plur_sing: {},
            sing_def: {},
            deep_sig_sing: {},
            obj_sig_sing: {},
            sig_levels_sing: {}
          };
          this.load_grammar(spec.def);
        }
        load_grammar(grammar_def) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const resolve_def = (def) => {
            const td = tf2(def);
            if (td === "a") {
              const res2 = [];
              each(def, (def_item) => {
                res2.push(resolve_def(def_item));
              });
              return res2;
            } else if (td === "s") {
              if (def === "string") {
                return "string";
              } else if (def === "number") {
                return "number";
              } else if (def === "boolean") {
                return "boolean";
              } else {
                const found_sing_def = sing_def[def];
                return found_sing_def;
              }
            } else if (td === "n") {
              console.trace();
              throw "NYI";
            } else if (td === "b") {
              console.trace();
              throw "NYI";
            }
          };
          const resolved_def_to_sig = (resolved_def, level = 0) => {
            const trd = tf2(resolved_def);
            if (trd === "s") {
              if (resolved_def === "string") {
                return "s";
              } else if (resolved_def === "number") {
                return "n";
              } else if (resolved_def === "boolean") {
                return "b";
              }
            } else if (trd === "a") {
              let res2 = "";
              if (level === 0) {
              } else {
                res2 = res2 + "[";
              }
              each(resolved_def, (item2, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                res2 = res2 + resolved_def_to_sig(item2, level + 1);
              });
              if (level === 0) {
              } else {
                res2 = res2 + "]";
              }
              return res2;
            } else {
              console.trace();
              throw "NYI";
            }
            return res;
          };
          each(grammar_def, (def1, sing_word) => {
            const {
              def,
              plural
            } = def1;
            sing_def[sing_word] = def;
            sing_plur[sing_word] = plural;
            plur_sing[plural] = sing_word;
            const tdef = tf2(def);
            const resolved_def = resolve_def(def);
            const resolved_def_sig = resolved_def_to_sig(resolved_def);
            deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
            deep_sig_sing[resolved_def_sig].push(sing_word);
            let def_is_all_custom_types = true;
            each(def, (def_item, c2, stop) => {
              const tdi = tf2(def_item);
              if (tdi === "s") {
                if (sing_def[def_item]) {
                } else {
                  def_is_all_custom_types = false;
                  stop();
                }
              } else {
                def_is_all_custom_types = false;
                stop();
              }
            });
            let obj_sig;
            if (def_is_all_custom_types) {
              obj_sig = "{";
              each(def, (def_item, c2, stop) => {
                if (c2 > 0) {
                  obj_sig = obj_sig + ",";
                }
                const resolved = resolve_def(def_item);
                const abr_resolved = resolved_def_to_sig(resolved);
                obj_sig = obj_sig + '"' + def_item + '":';
                obj_sig = obj_sig + abr_resolved;
              });
              obj_sig = obj_sig + "}";
            }
            if (obj_sig) {
              obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
              obj_sig_sing[obj_sig].push(sing_word);
            }
          });
        }
        tof(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const titem = tf2(item2);
          console.log("titem", titem);
          if (titem === "a") {
            let all_arr_items_type;
            each(item2, (subitem, c2, stop) => {
              const subitem_type = this.tof(subitem);
              console.log("subitem_type", subitem_type);
              if (c2 === 0) {
                all_arr_items_type = subitem_type;
              } else {
                if (all_arr_items_type === subitem_type) {
                } else {
                  all_arr_items_type = null;
                  stop();
                }
              }
            });
            if (all_arr_items_type) {
              console.log("has all_arr_items_type", all_arr_items_type);
              if (!map_native_types[all_arr_items_type]) {
                const res2 = sing_plur[all_arr_items_type];
                return res2;
              }
            } else {
              console.log("no all_arr_items_type");
            }
          } else {
            return tof(item2);
          }
          const item_deep_sig = deep_sig(item2);
          console.log("Grammar tof() item_deep_sig", item_deep_sig);
          let arr_sing;
          if (titem === "a") {
            const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
            console.log("unenclosed_sig", unenclosed_sig);
            arr_sing = deep_sig_sing[unenclosed_sig];
          } else {
            arr_sing = deep_sig_sing[item_deep_sig];
          }
          if (arr_sing) {
            if (arr_sing.length === 1) {
              return arr_sing[0];
            } else {
              console.trace();
              throw "NYI";
            }
          }
        }
        sig(item2, max_depth = -1, depth = 0) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          const extended_sig = (item3) => {
            const ti = tf2(item3);
            let res2 = "";
            let same_grammar_type;
            const record_subitem_sigs = (item4) => {
              same_grammar_type = void 0;
              let same_sig = void 0;
              each(item4, (subitem, c2) => {
                if (c2 > 0) {
                  res2 = res2 + ",";
                }
                const sig_subitem = this.sig(subitem, max_depth, depth + 1);
                if (same_sig === void 0) {
                  same_sig = sig_subitem;
                } else {
                  if (sig_subitem !== same_sig) {
                    same_sig = false;
                    same_grammar_type = false;
                  }
                }
                if (same_sig) {
                  if (sing_def[sig_subitem]) {
                    if (same_grammar_type === void 0) {
                      same_grammar_type = sig_subitem;
                    } else {
                      if (same_grammar_type === sig_subitem) {
                      } else {
                        same_grammar_type = false;
                      }
                    }
                  } else {
                  }
                }
                res2 = res2 + sig_subitem;
              });
            };
            if (ti === "A") {
              record_subitem_sigs(item3);
              return res2;
            } else if (ti === "a") {
              record_subitem_sigs(item3);
              if (same_grammar_type) {
                const plur_name = sing_plur[same_grammar_type];
                return plur_name;
              } else {
                const found_obj_type = obj_sig_sing[res2];
                const found_deep_sig_type = deep_sig_sing[res2];
                let found_type_sing;
                if (found_deep_sig_type) {
                  if (found_deep_sig_type.length === 1) {
                    found_type_sing = found_deep_sig_type[0];
                  }
                }
                if (found_type_sing) {
                  return found_type_sing;
                } else {
                  const enclosed_res = "[" + res2 + "]";
                  return enclosed_res;
                }
              }
            } else if (ti === "o") {
              if (max_depth === -1 || depth <= max_depth) {
                res2 = res2 + "{";
                let first = true;
                each(item3, (value2, key2) => {
                  const vsig = this.sig(value2, max_depth, depth + 1);
                  if (!first) {
                    res2 = res2 + ",";
                  } else {
                    first = false;
                  }
                  res2 = res2 + '"' + key2 + '":' + vsig;
                });
                res2 = res2 + "}";
                return res2;
              } else {
                return "o";
              }
            } else if (ti === "s" || ti === "n" || ti === "b") {
              return ti;
            } else {
              return ti;
            }
          };
          return extended_sig(item2);
        }
        single_forms_sig(item2) {
          const {
            sing_plur,
            plur_sing,
            sing_def,
            sig_levels_sing,
            deep_sig_sing,
            obj_sig_sing
          } = this.maps;
          let sig = this.sig(item2);
          let s_sig = sig.split(",");
          const arr_res = [];
          each(s_sig, (sig_item, c2) => {
            const sing = plur_sing[sig_item] || sig_item;
            arr_res.push(sing);
          });
          const res2 = arr_res.join(",");
          return res2;
        }
      };
      var Evented_Class = class {
        "constructor"() {
          Object.defineProperty(this, "_bound_events", {
            value: {}
          });
        }
        "raise_event"() {
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          a.l = a.length;
          let target = this;
          let c2, l2, res2;
          if (sig === "[s]") {
            let target2 = this;
            let event_name = a[0];
            let bgh = this._bound_general_handler;
            let be = this._bound_events;
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target2, event_name));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) == "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target2));
                }
                return res2;
              }
            }
          }
          if (sig === "[s,a]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,b]" || sig === "[s,s]" || sig === "[s,n]" || sig === "[s,B]" || sig === "[s,O]" || sig === "[s,e]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          }
          if (sig === "[s,o]" || sig === "[s,?]") {
            let be = this._bound_events;
            let bgh = this._bound_general_handler;
            let event_name = a[0];
            res2 = [];
            if (bgh) {
              for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                res2.push(bgh[c2].call(target, event_name, a[1]));
              }
            }
            if (be) {
              let bei = be[event_name];
              if (tof(bei) === "array") {
                for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                  res2.push(bei[c2].call(target, a[1]));
                }
              }
            }
          } else {
            if (a.l > 2) {
              let event_name = a[0];
              let additional_args = [];
              let bgh_args = [event_name];
              for (c2 = 1, l2 = a.l; c2 < l2; c2++) {
                additional_args.push(a[c2]);
                bgh_args.push(a[c2]);
              }
              let be = this._bound_events;
              let bgh = this._bound_general_handler;
              res2 = [];
              if (bgh) {
                for (c2 = 0, l2 = bgh.length; c2 < l2; c2++) {
                  res2.push(bgh[c2].apply(target, bgh_args));
                }
              }
              if (be) {
                let bei = be[event_name];
                if (tof(bei) == "array") {
                  if (bei.length > 0) {
                    for (c2 = 0, l2 = bei.length; c2 < l2; c2++) {
                      if (bei[c2]) res2.push(bei[c2].apply(target, additional_args));
                    }
                    return res2;
                  } else {
                    return res2;
                  }
                }
              }
            } else {
            }
          }
          return res2;
        }
        "add_event_listener"() {
          const {
            event_events
          } = this;
          let a = Array.prototype.slice.call(arguments), sig = get_a_sig(a);
          if (sig === "[f]") {
            this._bound_general_handler = this._bound_general_handler || [];
            if (is_array(this._bound_general_handler)) {
              this._bound_general_handler.push(a[0]);
            }
            ;
          }
          if (sig === "[s,f]") {
            let event_name = a[0], fn_listener = a[1];
            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
            let bei = this._bound_events[event_name];
            if (is_array(bei)) {
              bei.push(fn_listener);
              if (event_events) {
                this.raise("add-event-listener", {
                  "name": event_name
                });
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        "remove_event_listener"(event_name, fn_listener) {
          const {
            event_events
          } = this;
          if (this._bound_events) {
            let bei = this._bound_events[event_name] || [];
            if (is_array(bei)) {
              let c2 = 0, l2 = bei.length, found = false;
              while (!found && c2 < l2) {
                if (bei[c2] === fn_listener) {
                  found = true;
                } else {
                  c2++;
                }
              }
              if (found) {
                bei.splice(c2, 1);
                if (event_events) {
                  this.raise("remove-event-listener", {
                    "name": event_name
                  });
                }
              }
            } else {
              console.trace();
              throw "Expected: array";
            }
          }
          return this;
        }
        get bound_named_event_counts() {
          const res2 = {};
          if (this._bound_events) {
            const keys = Object.keys(this._bound_events);
            each(keys, (key2) => {
              res2[key2] = this._bound_events[key2].length;
            });
          }
          return res2;
        }
        "one"(event_name, fn_handler) {
          let inner_handler = function(e) {
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
          };
          this.on(event_name, inner_handler);
        }
        "changes"(obj_changes) {
          if (!this.map_changes) {
            this.map_changes = {};
          }
          each(obj_changes, (handler, name) => {
            this.map_changes[name] = this.map_changes[name] || [];
            this.map_changes[name].push(handler);
          });
          if (!this._using_changes) {
            this._using_changes = true;
            this.on("change", (e_change) => {
              const {
                name,
                value: value2
              } = e_change;
              if (this.map_changes[name]) {
                each(this.map_changes[name], (h_change) => {
                  h_change(value2);
                });
              }
            });
          }
        }
      };
      var p = Evented_Class.prototype;
      p.raise = p.raise_event;
      p.trigger = p.raise_event;
      p.subscribe = p.add_event_listener;
      p.on = p.add_event_listener;
      p.off = p.remove_event_listener;
      var eventify = (obj2) => {
        const bound_events = {};
        const add_event_listener = (name, handler) => {
          if (handler === void 0 && typeof name === "function") {
            handler = name;
            name = "";
          }
          if (!bound_events[name]) bound_events[name] = [];
          bound_events[name].push(handler);
        };
        const remove_event_listener = (name, handler) => {
          if (bound_events[name]) {
            const i = bound_events[name].indexOf(handler);
            if (i > -1) {
              bound_events[name].splice(i, 1);
            }
          }
        };
        const raise_event = (name, optional_param) => {
          const arr_named_events = bound_events[name];
          if (arr_named_events !== void 0) {
            if (optional_param !== void 0) {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2, optional_param);
              }
            } else {
              const l2 = arr_named_events.length;
              for (let c2 = 0; c2 < l2; c2++) {
                arr_named_events[c2].call(obj2);
              }
            }
          }
        };
        obj2.on = obj2.add_event_listener = add_event_listener;
        obj2.off = obj2.remove_event_listener = remove_event_listener;
        obj2.raise = obj2.raise_event = raise_event;
        return obj2;
      };
      var Publisher = class extends Evented_Class {
        constructor(spec = {}) {
          super({});
          this.one("ready", () => {
            this.is_ready = true;
          });
        }
        get when_ready() {
          return new Promise((solve, jettison) => {
            if (this.is_ready === true) {
              solve();
            } else {
              this.one("ready", () => {
                solve();
              });
            }
          });
        }
      };
      var prop = (...a) => {
        let s = get_a_sig(a);
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length === 2) {
            if (ia(a[1])) {
              const target = a[0];
              each(a[1], (item2) => {
                if (ia(item2)) {
                  throw "NYI 468732";
                } else {
                  prop(target, item2);
                }
              });
            } else {
              const ta1 = tof(a[1]);
              if (ta1 === "string") {
                [obj, prop_name] = a;
              } else {
                throw "NYI 468732b";
              }
            }
          } else if (a.length > 2) {
            if (is_array(a[0])) {
              throw "stop";
              let objs = a.shift();
              each(objs, (obj2) => {
                prop.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, default_value, fn_onchange, fn_transform, fn_on_ready, options;
              const load_options = (options2) => {
                prop_name2 = prop_name2 || options2.name || options2.prop_name;
                fn_onchange = options2.fn_onchange || options2.onchange || options2.change;
                fn_transform = options2.fn_transform || options2.ontransform || options2.transform;
                fn_on_ready = options2.ready || options2.on_ready;
                default_value = default_value || options2.default_value || options2.default;
              };
              if (a.length === 2) {
                [obj2, options] = a;
                load_options(options);
              } else if (a.length === 3) {
                if (ifn(a[2])) {
                  [obj2, prop_name2, fn_onchange] = a;
                } else {
                  if (a[2].change || a[2].ready) {
                    load_options(a[2]);
                    [obj2, prop_name2] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (ifn(a[2]) && ifn(a[3])) {
                  [obj2, prop_name2, fn_transform, fn_onchange] = a;
                } else if (ifn(a[3])) {
                  [obj2, prop_name2, default_value, fn_onchange] = a;
                } else {
                  [obj2, prop_name2, default_value, options] = a;
                  load_options(options);
                }
              } else if (a.length === 5) {
                [obj2, prop_name2, default_value, fn_transform, fn_onchange] = a;
              }
              let _prop_value;
              if (typeof default_value !== "undefined") _prop_value = default_value;
              const _silent_set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                _prop_value = _value;
              };
              const _set = (value2) => {
                let _value;
                if (fn_transform) {
                  _value = fn_transform(value2);
                } else {
                  _value = value2;
                }
                let old = _prop_value;
                _prop_value = _value;
                if (fn_onchange) {
                  fn_onchange({
                    old,
                    value: _prop_value
                  });
                }
                if (obj2.raise && raise_change_events) {
                  obj2.raise("change", {
                    name: prop_name2,
                    old,
                    value: _prop_value
                  });
                }
              };
              if (is_defined(default_value)) {
                _prop_value = default_value;
              }
              const t_prop_name = tf2(prop_name2);
              if (t_prop_name === "s") {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    return _prop_value;
                  },
                  set(value2) {
                    _set(value2);
                  }
                });
              } else if (t_prop_name === "a") {
                const l2 = prop_name2.length;
                let item_prop_name;
                for (let c2 = 0; c2 < l2; c2++) {
                  item_prop_name = prop_name2[c2];
                  Object.defineProperty(obj2, item_prop_name, {
                    get() {
                      return _prop_value;
                    },
                    set(value2) {
                      _set(value2);
                    }
                  });
                }
              } else {
                throw "Unexpected name type: " + t_prop_name;
              }
              if (fn_on_ready) {
                fn_on_ready({
                  silent_set: _silent_set
                });
              }
            }
          }
        }
      };
      var Data_Type = class {
      };
      var Functional_Data_Type = class extends Data_Type {
        constructor(spec) {
          super(spec);
          if (spec.supertype) this.supertype = spec.supertype;
          if (spec.name) this.name = spec.name;
          if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
          if (spec.named_property_access) this.named_property_access = spec.named_property_access;
          if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
          if (spec.property_names) this.property_names = spec.property_names;
          if (spec.property_data_types) this.property_data_types = spec.property_data_types;
          if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
          if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
          if (spec.value_js_type) this.value_js_type = spec.value_js_type;
          if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
          if (spec.validate) this.validate = spec.validate;
          if (spec.validate_explain) this.validate_explain = spec.validate_explain;
          if (spec.parse_string) this.parse_string = spec.parse_string;
          if (spec.parse) this.parse = spec.parse;
        }
      };
      Functional_Data_Type.number = new Functional_Data_Type({
        name: "number",
        abbreviated_name: "n",
        validate: (x) => {
          return !isNaN(x);
        },
        parse_string(str) {
          const p2 = parseFloat(str);
          if (p2 + "" === str) {
            const parsed_is_valid = this.validate(p2);
            if (parsed_is_valid) {
              return p2;
            }
          }
        }
      });
      Functional_Data_Type.integer = new Functional_Data_Type({
        name: "integer",
        abbreviated_name: "int",
        validate: (x) => {
          return Number.isInteger(x);
        },
        parse_string(str) {
          const p2 = parseInt(str, 10);
          if (!isNaN(p2) && p2.toString() === str) {
            return p2;
          }
          return void 0;
        }
      });
      var field = (...a) => {
        const raise_change_events = true;
        const ifn = (item2) => typeof item2 === "function";
        let s = get_a_sig(a);
        if (s === "[a]") {
          each(a[0], (item_params2) => {
            prop.apply(exports, item_params2);
          });
        } else {
          if (a.length > 1) {
            if (is_array(a[0])) {
              throw "stop - need to fix";
              let objs = a.shift();
              each(objs, (obj2) => {
                field.apply(exports, [obj2].concat(item_params));
              });
            } else {
              let obj2, prop_name2, data_type, default_value, fn_transform;
              if (a.length === 2) {
                [obj2, prop_name2] = a;
              } else if (a.length === 3) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  if (ifn(a[2])) {
                    [obj2, prop_name2, fn_transform] = a;
                  } else {
                    [obj2, prop_name2, default_value] = a;
                  }
                }
              } else if (a.length === 4) {
                if (a[2] instanceof Data_Type) {
                  [obj2, prop_name2, data_type, default_value] = a;
                } else {
                  [obj2, prop_name2, default_value, fn_transform] = a;
                }
              }
              if (obj2 !== void 0) {
                Object.defineProperty(obj2, prop_name2, {
                  get() {
                    if (is_defined(obj2._)) {
                      return obj2._[prop_name2];
                    } else {
                      return void 0;
                    }
                  },
                  set(value2) {
                    let old = (obj2._ = obj2._ || {})[prop_name2];
                    if (old !== value2) {
                      let is_valid = true;
                      if (data_type) {
                        const t_value = typeof value2;
                        is_valid = data_type.validate(value2);
                        if (t_value === "string") {
                          const parsed_value = data_type.parse_string(value2);
                          is_valid = data_type.validate(parsed_value);
                          if (is_valid) value2 = parsed_value;
                        }
                        console.log("t_value", t_value);
                      }
                      if (is_valid) {
                        let _value;
                        if (fn_transform) {
                          _value = fn_transform(value2);
                        } else {
                          _value = value2;
                        }
                        obj2._[prop_name2] = _value;
                        if (raise_change_events) {
                          obj2.raise("change", {
                            name: prop_name2,
                            old,
                            value: _value
                          });
                        }
                      }
                    } else {
                    }
                  }
                });
                if (is_defined(default_value)) {
                  let is_valid = true;
                  if (data_type) {
                    is_valid = data_type.validate(default_value);
                  }
                  if (is_valid) {
                    (obj2._ = obj2._ || {})[prop_name2] = default_value;
                  }
                }
              } else {
                throw "stop";
              }
            }
          }
        }
      };
      var KEYWORD_LITERALS = /* @__PURE__ */ new Set(["true", "false", "null", "undefined"]);
      var KEYWORD_OPERATORS = /* @__PURE__ */ new Set(["typeof", "void", "delete", "in", "instanceof"]);
      var MULTI_CHAR_OPERATORS = [
        "===",
        "!==",
        "==",
        "!=",
        "<=",
        ">=",
        "&&",
        "||",
        "??",
        "++",
        "--",
        "+=",
        "-=",
        "*=",
        "/=",
        "%=",
        "&=",
        "|=",
        "^=",
        "<<",
        ">>",
        ">>>",
        "**"
      ];
      var SINGLE_CHAR_OPERATORS = /* @__PURE__ */ new Set(["+", "-", "*", "/", "%", "=", "!", "<", ">", "&", "|", "^", "~"]);
      var PUNCTUATION_CHARS = /* @__PURE__ */ new Set(["(", ")", "{", "}", "[", "]", ",", ":", "?", "."]);
      var GLOBAL_SCOPE = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var DEFAULT_ALLOWED_GLOBALS = ["Math"];
      var EXPRESSION_PARSER_DEFAULTS = {
        cache: true,
        cacheSize: 64,
        cacheKeyResolver: null,
        maxExpressionLength: 1e4,
        maxMemberDepth: 2,
        helpers: {},
        allowedFunctions: [],
        allowedGlobals: DEFAULT_ALLOWED_GLOBALS,
        allowCall: null,
        strict: false
      };
      var NORMALIZED_OPTIONS_FLAG = /* @__PURE__ */ Symbol("ExpressionParserOptions");
      var DISALLOWED_IDENTIFIERS = /* @__PURE__ */ new Set(["this", "new"]);
      var ExpressionParserError = class extends Error {
        constructor(code, message, details = {}) {
          super(message);
          this.name = "ExpressionParserError";
          this.code = code;
          this.details = details;
        }
      };
      var ExpressionCache = class {
        constructor(limit = 0) {
          this.limit = Math.max(0, limit || 0);
          this.map = /* @__PURE__ */ new Map();
        }
        get(key2) {
          if (!this.limit || !this.map.has(key2)) {
            return void 0;
          }
          const value2 = this.map.get(key2);
          this.map.delete(key2);
          this.map.set(key2, value2);
          return value2;
        }
        set(key2, value2) {
          if (!this.limit) {
            return;
          }
          if (this.map.has(key2)) {
            this.map.delete(key2);
          }
          this.map.set(key2, value2);
          while (this.map.size > this.limit) {
            const oldestKey = this.map.keys().next().value;
            this.map.delete(oldestKey);
          }
        }
        clear() {
          this.map.clear();
        }
        get size() {
          return this.map.size;
        }
      };
      var Tokenizer = class {
        constructor(expression) {
          this.expression = typeof expression === "string" ? expression : String(expression || "");
          this.length = this.expression.length;
          this.position = 0;
          this.line = 1;
          this.column = 1;
        }
        tokenize() {
          const tokens = [];
          if (!this.expression.trim()) {
            return tokens;
          }
          while (!this.isAtEnd()) {
            this.skipWhitespace();
            if (this.isAtEnd()) break;
            const ch = this.peek();
            if (this.isIdentifierStart(ch)) {
              tokens.push(this.tokenizeIdentifier());
            } else if (this.isDigit(ch) || ch === "." && this.isDigit(this.peek(1))) {
              tokens.push(this.tokenizeNumber());
            } else if (ch === '"' || ch === "'") {
              tokens.push(this.tokenizeString());
            } else if (this.isOperatorStart(ch)) {
              tokens.push(this.tokenizeOperator());
            } else if (PUNCTUATION_CHARS.has(ch)) {
              tokens.push(this.tokenizePunctuation());
            } else {
              this.throwError("TOKEN_INVALID_CHAR", `Unexpected character: ${ch}`);
            }
          }
          return tokens;
        }
        isAtEnd() {
          return this.position >= this.length;
        }
        skipWhitespace() {
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (/\s/.test(ch)) {
              this.advance();
              continue;
            }
            if (ch === "/" && this.peek(1) === "/") {
              while (!this.isAtEnd() && this.peek() !== "\n") {
                this.advance();
              }
              continue;
            }
            if (ch === "/" && this.peek(1) === "*") {
              this.advance();
              this.advance();
              while (!this.isAtEnd()) {
                if (this.peek() === "*" && this.peek(1) === "/") {
                  this.advance();
                  this.advance();
                  break;
                }
                this.advance();
              }
              continue;
            }
            break;
          }
        }
        peek(offset2 = 0) {
          if (this.position + offset2 >= this.length) return "\0";
          return this.expression[this.position + offset2];
        }
        advance() {
          if (this.isAtEnd()) {
            return "\0";
          }
          const char = this.expression[this.position++];
          if (char === "\n") {
            this.line += 1;
            this.column = 1;
          } else {
            this.column += 1;
          }
          return char;
        }
        getLocationSnapshot() {
          return { index: this.position, line: this.line, column: this.column };
        }
        createToken(type, value2, start, end) {
          return { type, value: value2, start, end };
        }
        throwError(code, message) {
          throw new ExpressionParserError(code, message, { location: this.getLocationSnapshot() });
        }
        isIdentifierStart(ch) {
          return /[A-Za-z_$]/.test(ch);
        }
        isIdentifierPart(ch) {
          return /[A-Za-z0-9_$]/.test(ch);
        }
        isDigit(ch) {
          return /[0-9]/.test(ch);
        }
        isOperatorStart(ch) {
          if (ch === "." && this.peek(1) === "." && this.peek(2) === ".") {
            this.throwError("SYNTAX_UNSUPPORTED", "Spread syntax is not supported");
          }
          if (ch === "?" && this.peek(1) === "?") {
            return true;
          }
          return SINGLE_CHAR_OPERATORS.has(ch);
        }
        tokenizeIdentifier() {
          const start = this.getLocationSnapshot();
          let value2 = "";
          while (!this.isAtEnd() && this.isIdentifierPart(this.peek())) {
            value2 += this.advance();
          }
          const end = this.getLocationSnapshot();
          if (KEYWORD_LITERALS.has(value2)) {
            return this.createToken("KEYWORD", value2, start, end);
          }
          if (KEYWORD_OPERATORS.has(value2)) {
            return this.createToken("OPERATOR", value2, start, end);
          }
          return this.createToken("IDENTIFIER", value2, start, end);
        }
        tokenizeNumber() {
          const start = this.getLocationSnapshot();
          let value2 = "";
          let hasDot = false;
          while (!this.isAtEnd()) {
            const ch = this.peek();
            if (this.isDigit(ch)) {
              value2 += this.advance();
            } else if (ch === "." && !hasDot) {
              hasDot = true;
              value2 += this.advance();
            } else {
              break;
            }
          }
          const end = this.getLocationSnapshot();
          return this.createToken("NUMBER", Number(value2), start, end);
        }
        tokenizeString() {
          const quote = this.advance();
          const start = this.getLocationSnapshot();
          let value2 = "";
          while (!this.isAtEnd()) {
            const ch = this.advance();
            if (ch === quote) {
              return this.createToken("STRING", value2, start, this.getLocationSnapshot());
            }
            if (ch === "\\") {
              const next = this.advance();
              switch (next) {
                case "n":
                  value2 += "\n";
                  break;
                case "r":
                  value2 += "\r";
                  break;
                case "t":
                  value2 += "	";
                  break;
                case "\\":
                  value2 += "\\";
                  break;
                case '"':
                  value2 += '"';
                  break;
                case "'":
                  value2 += "'";
                  break;
                default:
                  value2 += next;
              }
            } else {
              value2 += ch;
            }
          }
          this.throwError("TOKEN_UNTERMINATED_STRING", "Unterminated string literal");
        }
        tokenizeOperator() {
          const remaining = this.expression.slice(this.position);
          const start = this.getLocationSnapshot();
          for (const op of MULTI_CHAR_OPERATORS) {
            if (remaining.startsWith(op)) {
              if (op === "=>") {
                this.throwError("SYNTAX_UNSUPPORTED", "Arrow functions are not supported");
              }
              this.position += op.length;
              this.column += op.length;
              return this.createToken("OPERATOR", op, start, this.getLocationSnapshot());
            }
          }
          const ch = this.advance();
          if (ch === "=" && this.peek() === ">") {
            this.throwError("SYNTAX_UNSUPPORTED", "Arrow functions are not supported");
          }
          if (!SINGLE_CHAR_OPERATORS.has(ch) && ch !== "?") {
            this.throwError("TOKEN_UNEXPECTED_OPERATOR", "Unexpected operator");
          }
          return this.createToken("OPERATOR", ch, start, this.getLocationSnapshot());
        }
        tokenizePunctuation() {
          const start = this.getLocationSnapshot();
          const ch = this.advance();
          if (ch === "." && this.peek() === "." && this.peek(1) === ".") {
            this.throwError("SYNTAX_UNSUPPORTED", "Spread syntax is not supported");
          }
          return this.createToken("PUNCTUATION", ch, start, this.getLocationSnapshot());
        }
      };
      var Parser = class {
        constructor(tokens, options = {}) {
          this.tokens = tokens;
          this.pos = 0;
          this.maxMemberDepth = options.maxMemberDepth || EXPRESSION_PARSER_DEFAULTS.maxMemberDepth;
          const disallowed = new Set(DISALLOWED_IDENTIFIERS);
          if (options.disallowedIdentifiers) {
            options.disallowedIdentifiers.forEach((identifier) => disallowed.add(identifier));
          }
          this.disallowedIdentifiers = disallowed;
        }
        parse() {
          if (!this.tokens.length) {
            throw new ExpressionParserError("EMPTY_EXPRESSION", "Empty expression");
          }
          const ast = this.parseExpression();
          if (!this.isAtEnd()) {
            this.error("UNEXPECTED_TOKEN", `Unexpected token: ${this.peek().value}`, this.peek());
          }
          return ast;
        }
        parseExpression() {
          return this.parseConditionalExpression();
        }
        parseConditionalExpression() {
          let expr = this.parseLogicalOrExpression();
          if (this.matchPunctuation("?")) {
            const consequent = this.parseExpression();
            this.consume("PUNCTUATION", ":");
            const alternate = this.parseExpression();
            expr = {
              type: "ConditionalExpression",
              test: expr,
              consequent,
              alternate
            };
          }
          return expr;
        }
        parseLogicalOrExpression() {
          let expr = this.parseLogicalAndExpression();
          while (this.matchOperator("||")) {
            const operator = this.previous().value;
            const right = this.parseLogicalAndExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseLogicalAndExpression() {
          let expr = this.parseNullishExpression();
          while (this.matchOperator("&&")) {
            const operator = this.previous().value;
            const right = this.parseNullishExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseNullishExpression() {
          let expr = this.parseEqualityExpression();
          while (this.matchOperator("??")) {
            const operator = this.previous().value;
            const right = this.parseEqualityExpression();
            expr = this.buildLogicalExpression(operator, expr, right);
          }
          return expr;
        }
        parseEqualityExpression() {
          let expr = this.parseRelationalExpression();
          while (this.matchOperator("===", "!==", "==", "!=")) {
            const operator = this.previous().value;
            const right = this.parseRelationalExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseRelationalExpression() {
          let expr = this.parseShiftExpression();
          while (this.matchOperator("<", ">", "<=", ">=", "instanceof", "in")) {
            const operator = this.previous().value;
            const right = this.parseShiftExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseShiftExpression() {
          let expr = this.parseAdditiveExpression();
          while (this.matchOperator("<<", ">>", ">>>")) {
            const operator = this.previous().value;
            const right = this.parseAdditiveExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseAdditiveExpression() {
          let expr = this.parseMultiplicativeExpression();
          while (this.matchOperator("+", "-")) {
            const operator = this.previous().value;
            const right = this.parseMultiplicativeExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseMultiplicativeExpression() {
          let expr = this.parseUnaryExpression();
          while (this.matchOperator("*", "/", "%")) {
            const operator = this.previous().value;
            const right = this.parseUnaryExpression();
            expr = this.buildBinaryExpression(operator, expr, right);
          }
          return expr;
        }
        parseUnaryExpression() {
          if (this.matchOperator("+", "-", "!", "~", "typeof", "void", "delete")) {
            const operator = this.previous().value;
            const argument = this.parseUnaryExpression();
            return { type: "UnaryExpression", operator, argument };
          }
          return this.parseLeftHandSideExpression();
        }
        parseLeftHandSideExpression() {
          let expr = this.parsePrimaryExpression();
          while (true) {
            if (this.matchPunctuation(".")) {
              const operatorToken = this.previous();
              const property = this.consumePropertyIdentifier();
              const depth = this.getChainDepth(expr) + 1;
              this.assertMemberDepth(depth, operatorToken);
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: false
              };
              this.setChainDepth(expr, depth);
            } else if (this.matchPunctuation("[")) {
              const operatorToken = this.previous();
              const property = this.parseExpression();
              this.consume("PUNCTUATION", "]");
              const depth = this.getChainDepth(expr) + 1;
              this.assertMemberDepth(depth, operatorToken);
              expr = {
                type: "MemberExpression",
                object: expr,
                property,
                computed: true
              };
              this.setChainDepth(expr, depth);
            } else if (this.matchPunctuation("(")) {
              const args = this.parseArguments();
              expr = {
                type: "CallExpression",
                callee: expr,
                arguments: args
              };
              this.setChainDepth(expr, this.getChainDepth(expr.callee));
            } else {
              break;
            }
          }
          return expr;
        }
        parsePrimaryExpression() {
          const token = this.peek();
          if (!token) {
            this.error("UNEXPECTED_END", "Unexpected end of expression", token);
          }
          if (token.type === "NUMBER" || token.type === "STRING") {
            this.advance();
            return { type: "Literal", value: token.value };
          }
          if (token.type === "KEYWORD") {
            this.advance();
            return { type: "Literal", value: this.literalFromKeyword(token.value) };
          }
          if (token.type === "IDENTIFIER") {
            this.advance();
            this.assertIdentifierAllowed(token);
            return { type: "Identifier", value: token.value };
          }
          if (this.matchPunctuation("(")) {
            const expr = this.parseExpression();
            this.consume("PUNCTUATION", ")");
            return expr;
          }
          if (this.matchPunctuation("[")) {
            const elements = [];
            if (!this.check("PUNCTUATION", "]")) {
              do {
                elements.push(this.parseExpression());
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "]");
            return { type: "ArrayExpression", elements };
          }
          if (this.matchPunctuation("{")) {
            const properties = [];
            if (!this.check("PUNCTUATION", "}")) {
              do {
                const key2 = this.parsePropertyKey();
                this.consume("PUNCTUATION", ":");
                const value2 = this.parseExpression();
                properties.push({ key: key2, value: value2 });
              } while (this.matchPunctuation(","));
            }
            this.consume("PUNCTUATION", "}");
            return { type: "ObjectExpression", properties };
          }
          this.error("UNEXPECTED_TOKEN", `Unexpected token: ${token.value}`, token);
        }
        parsePropertyKey() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          this.error("INVALID_OBJECT_KEY", "Invalid object property key", token);
        }
        parseArguments() {
          const args = [];
          if (!this.check("PUNCTUATION", ")")) {
            do {
              args.push(this.parseExpression());
            } while (this.matchPunctuation(","));
          }
          this.consume("PUNCTUATION", ")");
          return args;
        }
        literalFromKeyword(value2) {
          switch (value2) {
            case "true":
              return true;
            case "false":
              return false;
            case "null":
              return null;
            case "undefined":
              return void 0;
            default:
              return value2;
          }
        }
        consume(type, value2) {
          if (this.check(type, value2)) {
            return this.advance();
          }
          const expected = value2 ? `${type} '${value2}'` : type;
          this.error("MISSING_TOKEN", `Expected ${expected}`, this.peek());
        }
        check(type, value2) {
          if (this.isAtEnd()) return false;
          const token = this.peek();
          if (token.type !== type) return false;
          if (typeof value2 === "undefined") return true;
          return token.value === value2;
        }
        matchOperator(...operators) {
          if (this.check("OPERATOR") && operators.includes(this.peek().value)) {
            this.advance();
            return true;
          }
          return false;
        }
        matchPunctuation(value2) {
          if (this.check("PUNCTUATION", value2)) {
            this.advance();
            return true;
          }
          return false;
        }
        consumePropertyIdentifier() {
          const token = this.peek();
          if (token.type === "IDENTIFIER") {
            this.advance();
            return { type: "Identifier", value: token.value };
          }
          if (token.type === "STRING" || token.type === "NUMBER" || token.type === "KEYWORD") {
            this.advance();
            const value2 = token.type === "KEYWORD" ? this.literalFromKeyword(token.value) : token.value;
            return { type: "Literal", value: value2 };
          }
          this.error("INVALID_PROPERTY", "Expected property name", token);
        }
        buildBinaryExpression(operator, left, right) {
          return { type: "BinaryExpression", operator, left, right };
        }
        buildLogicalExpression(operator, left, right) {
          return { type: "LogicalExpression", operator, left, right };
        }
        getChainDepth(node) {
          if (!node || typeof node !== "object") {
            return 0;
          }
          return node.__chainDepth || 0;
        }
        setChainDepth(node, depth) {
          if (!node || typeof node !== "object") {
            return;
          }
          Object.defineProperty(node, "__chainDepth", {
            value: depth,
            enumerable: false,
            configurable: true
          });
        }
        assertMemberDepth(depth, token) {
          if (depth > this.maxMemberDepth) {
            this.error("MEMBER_DEPTH_EXCEEDED", `Member access depth ${depth} exceeds maximum of ${this.maxMemberDepth}`, token);
          }
        }
        assertIdentifierAllowed(token) {
          if (this.disallowedIdentifiers.has(token.value)) {
            this.error("DISALLOWED_IDENTIFIER", `Identifier '${token.value}' is not allowed in expressions`, token);
          }
        }
        error(code, message, token) {
          throw new ExpressionParserError(code, message, token ? { location: token.start } : void 0);
        }
        advance() {
          if (!this.isAtEnd()) {
            this.pos += 1;
          }
          return this.tokens[this.pos - 1];
        }
        peek() {
          if (this.isAtEnd()) return null;
          return this.tokens[this.pos];
        }
        previous() {
          return this.tokens[this.pos - 1];
        }
        isAtEnd() {
          return this.pos >= this.tokens.length;
        }
      };
      var Evaluator = class {
        constructor(context2 = {}, options = {}) {
          this.context = context2 || {};
          this.helpers = options.helpers || {};
          this.strict = options.strict || false;
          this.allowCall = options.allowCall || null;
          this.allowedFunctions = new Set(options.allowedFunctions || []);
          this.allowedGlobals = new Set(options.allowedGlobals || []);
          Object.values(this.helpers).forEach((value2) => {
            if (typeof value2 === "function") {
              this.allowedFunctions.add(value2);
            }
          });
        }
        evaluate(node) {
          switch (node.type) {
            case "Literal":
              return node.value;
            case "Identifier":
              return this.evaluateIdentifier(node);
            case "MemberExpression":
              return this.evaluateMemberExpression(node);
            case "CallExpression":
              return this.evaluateCallExpression(node);
            case "UnaryExpression":
              return this.evaluateUnaryExpression(node);
            case "BinaryExpression":
              return this.evaluateBinaryExpression(node);
            case "LogicalExpression":
              return this.evaluateLogicalExpression(node);
            case "ArrayExpression":
              return node.elements.map((element) => this.evaluate(element));
            case "ObjectExpression":
              return this.evaluateObjectExpression(node);
            case "ConditionalExpression":
              return this.evaluateConditionalExpression(node);
            default:
              throw new ExpressionParserError("UNSUPPORTED_NODE", `Unsupported AST node type: ${node.type}`);
          }
        }
        evaluateIdentifier(node) {
          const name = node.value;
          if (Object.prototype.hasOwnProperty.call(this.helpers, name)) {
            return this.helpers[name];
          }
          if (this.context && Object.prototype.hasOwnProperty.call(this.context, name)) {
            return this.context[name];
          }
          if (this.allowedGlobals.has(name) && name in GLOBAL_SCOPE) {
            return GLOBAL_SCOPE[name];
          }
          if (this.strict) {
            throw new ExpressionParserError("UNDEFINED_IDENTIFIER", `Undefined identifier: ${name}`);
          }
          console.error(`Undefined identifier: ${name}`);
          return void 0;
        }
        evaluateMemberExpression(node) {
          const object = this.evaluate(node.object);
          if (object === null || object === void 0) {
            throw new ExpressionParserError("NULL_MEMBER_ACCESS", "Cannot read property of null or undefined");
          }
          const property = node.computed ? this.evaluate(node.property) : node.property.type === "Identifier" ? node.property.value : node.property.value;
          return object[property];
        }
        evaluateCallExpression(node) {
          let callee;
          let thisArg;
          if (node.callee.type === "MemberExpression") {
            const object = this.evaluate(node.callee.object);
            if (object === null || object === void 0) {
              throw new ExpressionParserError("NULL_MEMBER_CALL", "Cannot call property of null or undefined");
            }
            const property = node.callee.computed ? this.evaluate(node.callee.property) : node.callee.property.type === "Identifier" ? node.callee.property.value : node.callee.property.value;
            callee = object[property];
            thisArg = object;
          } else {
            callee = this.evaluate(node.callee);
            thisArg = void 0;
          }
          if (typeof callee !== "function") {
            throw new ExpressionParserError("CALL_NON_FUNCTION", "Attempted to call a non-function");
          }
          if (!this.isCallAllowed(callee, thisArg)) {
            throw new ExpressionParserError("CALL_NOT_ALLOWED", "Function call not allowed by policy");
          }
          const args = node.arguments.map((arg) => this.evaluate(arg));
          return callee.apply(thisArg, args);
        }
        isCallAllowed(fn, thisArg) {
          if (this.allowCall) {
            const decision = this.allowCall(fn, thisArg);
            if (decision === true) return true;
            if (decision === false) return false;
          }
          return this.allowedFunctions.has(fn);
        }
        evaluateUnaryExpression(node) {
          let argumentValue;
          if (node.operator === "delete") {
            argumentValue = node.argument;
          } else if (node.operator === "typeof" && node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
            argumentValue = void 0;
          } else {
            argumentValue = this.evaluate(node.argument);
          }
          switch (node.operator) {
            case "+":
              return +argumentValue;
            case "-":
              return -argumentValue;
            case "!":
              return !argumentValue;
            case "~":
              return ~argumentValue;
            case "typeof":
              if (node.argument.type === "Identifier" && !this.isIdentifierDefined(node.argument.value)) {
                return "undefined";
              }
              return typeof argumentValue;
            case "void":
              return void argumentValue;
            case "delete":
              return this.performDelete(node.argument);
            default:
              throw new ExpressionParserError("UNSUPPORTED_UNARY", `Unsupported unary operator: ${node.operator}`);
          }
        }
        isIdentifierDefined(name) {
          return Object.prototype.hasOwnProperty.call(this.helpers, name) || this.context && Object.prototype.hasOwnProperty.call(this.context, name) || this.allowedGlobals.has(name) && name in GLOBAL_SCOPE;
        }
        performDelete(argument) {
          if (argument.type === "Identifier" && this.context && typeof this.context === "object") {
            return delete this.context[argument.value];
          }
          if (argument.type === "MemberExpression") {
            const target = this.evaluate(argument.object);
            if (target === null || target === void 0) {
              return true;
            }
            const property = argument.computed ? this.evaluate(argument.property) : argument.property.type === "Identifier" ? argument.property.value : argument.property.value;
            return delete target[property];
          }
          this.evaluate(argument);
          return true;
        }
        evaluateBinaryExpression(node) {
          const left = this.evaluate(node.left);
          const right = this.evaluate(node.right);
          switch (node.operator) {
            case "+":
              return left + right;
            case "-":
              return left - right;
            case "*":
              return left * right;
            case "/":
              return left / right;
            case "%":
              return left % right;
            case "==":
              return left == right;
            case "!=":
              return left != right;
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "in":
              return left in right;
            case "instanceof":
              return left instanceof right;
            default:
              throw new ExpressionParserError("UNSUPPORTED_BINARY", `Unsupported binary operator: ${node.operator}`);
          }
        }
        evaluateLogicalExpression(node) {
          switch (node.operator) {
            case "&&": {
              const left = this.evaluate(node.left);
              return left ? this.evaluate(node.right) : left;
            }
            case "||": {
              const left = this.evaluate(node.left);
              return left ? left : this.evaluate(node.right);
            }
            case "??": {
              const left = this.evaluate(node.left);
              return left !== null && left !== void 0 ? left : this.evaluate(node.right);
            }
            default:
              throw new ExpressionParserError("UNSUPPORTED_LOGICAL", `Unsupported logical operator: ${node.operator}`);
          }
        }
        evaluateObjectExpression(node) {
          const obj2 = {};
          node.properties.forEach((property) => {
            const key2 = this.evaluatePropertyKey(property.key);
            obj2[key2] = this.evaluate(property.value);
          });
          return obj2;
        }
        evaluatePropertyKey(node) {
          if (node.type === "Identifier") {
            return node.value;
          }
          return node.value;
        }
        evaluateConditionalExpression(node) {
          const test = this.evaluate(node.test);
          return test ? this.evaluate(node.consequent) : this.evaluate(node.alternate);
        }
      };
      var ExpressionParser = class {
        constructor(options = {}) {
          this.options = normalizeOptions(null, options);
          const cacheLimit = this.options.cache !== false ? this.options.cacheSize : 0;
          this.astCache = new ExpressionCache(cacheLimit);
          this.valueCache = new ExpressionCache(cacheLimit);
        }
        tokenize(expression) {
          return new Tokenizer(expression).tokenize();
        }
        parse(expression, overrideOptions) {
          const options = this.ensureNormalizedOptions(overrideOptions);
          this.ensureExpressionLength(expression, options);
          const useCache = this.shouldUseCache(options);
          if (useCache) {
            const cachedAst = this.astCache.get(expression);
            if (cachedAst) {
              return cachedAst;
            }
          }
          const tokens = this.tokenize(expression);
          if (!tokens.length) {
            throw new ExpressionParserError("EMPTY_EXPRESSION", "Empty expression");
          }
          const parser = new Parser(tokens, options);
          const ast = parser.parse();
          Object.defineProperty(ast, "tokens", {
            value: tokens,
            enumerable: false,
            configurable: true
          });
          if (useCache) {
            this.astCache.set(expression, ast);
          }
          return ast;
        }
        evaluate(expression, context2 = {}, overrideOptions = {}) {
          const mergedOptions = this.mergeOptions(overrideOptions);
          const useCache = this.shouldUseCache(mergedOptions);
          if (useCache) {
            const cached = this.getCachedValue(expression, context2, mergedOptions);
            if (cached.hit) {
              return cached.value;
            }
          }
          const ast = this.parse(expression, mergedOptions);
          const evaluator = new Evaluator(context2, mergedOptions);
          const result = evaluator.evaluate(ast);
          if (useCache) {
            this.storeCachedValue(expression, context2, result, mergedOptions);
          }
          return result;
        }
        compile(expression, overrideOptions = {}) {
          const baseOptions = this.mergeOptions(overrideOptions);
          const ast = this.parse(expression, baseOptions);
          return (context2 = {}, runtimeOptions = {}) => {
            const invocationOptions = this.mergeOptions(runtimeOptions, baseOptions);
            const evaluator = new Evaluator(context2, invocationOptions);
            return evaluator.evaluate(ast);
          };
        }
        shouldUseCache(options) {
          return options.cache !== false && options.cacheSize > 0;
        }
        ensureNormalizedOptions(options) {
          if (options && options[NORMALIZED_OPTIONS_FLAG]) {
            return options;
          }
          if (!options) {
            return this.options;
          }
          return this.mergeOptions(options);
        }
        ensureExpressionLength(expression, options) {
          if (expression.length > options.maxExpressionLength) {
            throw new ExpressionParserError(
              "EXPRESSION_TOO_LONG",
              `Expression exceeds maximum length of ${options.maxExpressionLength} characters`
            );
          }
        }
        mergeOptions(override = {}, baseOptions) {
          const base = baseOptions && baseOptions[NORMALIZED_OPTIONS_FLAG] ? baseOptions : baseOptions || this.options;
          return normalizeOptions(base, override);
        }
        getCachedValue(expression, context2, options) {
          const bucket = this.valueCache.get(expression);
          if (!bucket) {
            return { hit: false };
          }
          if (this.isObjectLike(context2)) {
            if (bucket.objectCache && bucket.objectCache.has(context2)) {
              return { hit: true, value: bucket.objectCache.get(context2) };
            }
            return { hit: false };
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return { hit: false };
          }
          if (bucket.primitiveCache && bucket.primitiveCache.has(key2)) {
            return { hit: true, value: bucket.primitiveCache.get(key2) };
          }
          return { hit: false };
        }
        storeCachedValue(expression, context2, value2, options) {
          if (!this.shouldUseCache(options)) {
            return;
          }
          let bucket = this.valueCache.get(expression);
          if (!bucket) {
            bucket = { objectCache: /* @__PURE__ */ new WeakMap(), primitiveCache: /* @__PURE__ */ new Map() };
            this.valueCache.set(expression, bucket);
          }
          if (this.isObjectLike(context2)) {
            bucket.objectCache.set(context2, value2);
            return;
          }
          const key2 = this.resolvePrimitiveKey(context2, options);
          if (key2 === void 0) {
            return;
          }
          bucket.primitiveCache.set(key2, value2);
        }
        resolvePrimitiveKey(context2, options) {
          if (options.cacheKeyResolver) {
            return options.cacheKeyResolver(context2);
          }
          return context2;
        }
        isObjectLike(value2) {
          return value2 !== null && (typeof value2 === "object" || typeof value2 === "function");
        }
        getCacheStats() {
          return {
            astEntries: this.astCache.size,
            valueEntries: this.valueCache.size
          };
        }
      };
      function normalizeOptions(baseOptions, overrideOptions = {}) {
        const base = baseOptions && baseOptions[NORMALIZED_OPTIONS_FLAG] ? baseOptions : { ...EXPRESSION_PARSER_DEFAULTS, ...baseOptions || {} };
        const helpers = { ...base.helpers || {}, ...overrideOptions.helpers || {} };
        const allowedFunctions = /* @__PURE__ */ new Set([
          ...base.allowedFunctions || [],
          ...overrideOptions.allowedFunctions || []
        ]);
        const allowedGlobals = /* @__PURE__ */ new Set([
          ...base.allowedGlobals || DEFAULT_ALLOWED_GLOBALS,
          ...overrideOptions.allowedGlobals || []
        ]);
        const normalized = {
          ...EXPRESSION_PARSER_DEFAULTS,
          ...base,
          ...overrideOptions,
          helpers,
          allowedFunctions: Array.from(allowedFunctions),
          allowedGlobals: Array.from(allowedGlobals)
        };
        Object.defineProperty(normalized, NORMALIZED_OPTIONS_FLAG, {
          value: true,
          enumerable: false
        });
        return normalized;
      }
      var lang_mini_props = {
        each,
        is_array,
        is_dom_node,
        is_ctrl,
        clone,
        get_truth_map_from_arr,
        tm: get_truth_map_from_arr,
        get_arr_from_truth_map,
        arr_trim_undefined,
        get_map_from_arr,
        arr_like_to_arr,
        tof,
        atof,
        tf: tf2,
        load_type,
        is_defined,
        def: is_defined,
        Grammar,
        stringify,
        functional_polymorphism,
        fp,
        mfp,
        arrayify,
        mapify,
        str_arr_mapify,
        get_a_sig,
        deep_sig,
        get_item_sig,
        set_vals,
        truth,
        trim_sig_brackets,
        ll_set,
        ll_get,
        iterate_ancestor_classes,
        is_arr_of_t,
        is_arr_of_arrs,
        is_arr_of_strs,
        input_processors,
        output_processors,
        call_multiple_callback_functions,
        call_multi,
        multi: call_multi,
        native_constructor_tof,
        Fns,
        sig_match,
        remove_sig_from_arr_shell,
        to_arr_strip_keys,
        arr_objs_to_arr_keys_values_table,
        set_arr_tree_value,
        get_arr_tree_value,
        deep_arr_iterate,
        prom,
        combinations,
        combos: combinations,
        Evented_Class,
        eventify,
        vectorify,
        v_add,
        v_subtract: v_subtract2,
        v_multiply,
        v_divide,
        vector_magnitude,
        distance_between_points,
        get_typed_array,
        gta: get_typed_array,
        Publisher,
        field,
        prop,
        Data_Type,
        Functional_Data_Type,
        ExpressionParser,
        ExpressionParserError
      };
      var lang_mini = new Evented_Class();
      Object.assign(lang_mini, lang_mini_props);
      lang_mini.note = (str_name, str_state, obj_properties) => {
        obj_properties = obj_properties || {};
        obj_properties.name = str_name;
        obj_properties.state = str_state;
        lang_mini.raise("note", obj_properties);
      };
      module.exports = lang_mini;
      if (__require.main === module) {
        let test_evented_class2 = function(test_data2) {
          const res2 = create_empty_test_res();
          const evented_class = new Evented_Class();
          test_data2.forEach((test_event) => {
            const event_name = test_event.event_name;
            const event_data = test_event.event_data;
            const listener = (data) => {
              if (data === event_data) {
                res2.passed.push(event_name);
              } else {
                res2.failed.push(event_name);
              }
            };
            evented_class.on(event_name, listener);
            evented_class.raise_event(event_name, event_data);
          });
          return res2;
        };
        test_evented_class = test_evented_class2;
        const test_data = [
          {
            event_name: "foo",
            event_data: "hello"
          },
          {
            event_name: "bar",
            event_data: "world"
          },
          {
            event_name: "baz",
            event_data: true
          }
        ];
        const create_empty_test_res = () => ({
          passed: [],
          failed: []
        });
        const result = test_evented_class2(test_data);
        console.log("Passed:", result.passed);
        console.log("Failed:", result.failed);
      }
      var test_evented_class;
    }
  });

  // node_modules/lang-tools/node_modules/lang-mini/lib-lang-mini.js
  var require_lib_lang_mini6 = __commonJS({
    "node_modules/lang-tools/node_modules/lang-mini/lib-lang-mini.js"(exports, module) {
      var lang = require_lang_mini6();
      var { each, tof } = lang;
      var Type_Signifier = class _Type_Signifier {
        // Name
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const map_reserved_property_names = {
            name: true,
            parent: true
          };
          const _ = {};
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Signifier(o_extension);
          return res2;
        }
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
      };
      var Type_Representation = class _Type_Representation {
        // Name
        //  Other options?
        //  Disambiguiation? Descriptive text?
        //    Or is naming them the main thing there?
        // Color representation
        //   And that is simple, does not go into internal representation.
        // This should be able to represent types and lang features not available to JS.
        //   Names may be optional? May be autogenerated and quite long?
        constructor(spec = {}) {
          const name = spec.name;
          Object.defineProperty(this, "name", {
            get() {
              return name;
            }
          });
          const parent = spec.parent;
          Object.defineProperty(this, "parent", {
            get() {
              return parent;
            }
          });
          const _ = {};
          const map_reserved_property_names = {
            "name": true
          };
          each(spec, (value2, name2) => {
            if (map_reserved_property_names[name2]) {
            } else {
              _[name2] = value2;
              Object.defineProperty(this, name2, {
                get() {
                  return _[name2];
                },
                enumerable: true
              });
            }
          });
        }
        extend(o_extension) {
          const o = {
            parent: this
          };
          Object.assign(o, o_extension);
          const res2 = new _Type_Representation(o_extension);
          return res2;
        }
      };
      var st_color = new Type_Signifier({ "name": "color" });
      var st_24bit_color = st_color.extend({ "bits": 24 });
      var st_24bit_rgb_color = st_24bit_color.extend({ "components": ["red byte", "green byte", "blue byte"] });
      var tr_string = new Type_Representation({ "name": "string" });
      var tr_binary = new Type_Representation({ "name": "binary" });
      var rt_bin_24bit_rgb_color = new Type_Representation({
        // A binary type representation.
        "signifier": st_24bit_rgb_color,
        "bytes": [
          [0, "red", "ui8"],
          [1, "green", "ui8"],
          [2, "blue", "ui8"]
        ]
      });
      var rt_hex_24bit_rgb_color = new Type_Representation({
        // Likely some kind of string template.
        //  Or a function?
        //  Best to keep this function free here.
        //  Or maybe make a few quite standard ones.
        "signifier": st_24bit_rgb_color,
        // Or could just have the sequence / template literal even.
        "bytes": [
          [0, "#", "char"],
          [1, "hex(red)", "string(2)"],
          [3, "hex(green)", "string(2)"],
          [5, "hex(blue)", "string(2)"]
        ]
      });
      var st_date = new Type_Signifier({ "name": "date", "components": ["day uint", "month uint", "year int"] });
      var rt_string_date_uk_ddmmyy = new Type_Representation({
        "signifier": st_date,
        "bytes": [
          [0, "#", "char"],
          [1, "day", "string(2)"],
          [3, "/", "char"],
          [4, "month", "string(2)"],
          [6, "/", "char"],
          [7, "year", "string(2)"]
        ]
      });
      lang.Type_Signifier = Type_Signifier;
      lang.Type_Representation = Type_Representation;
      module.exports = lang;
    }
  });

  // node_modules/lang-tools/collective.js
  var require_collective2 = __commonJS({
    "node_modules/lang-tools/collective.js"(exports, module) {
      var { each, is_array } = require_lib_lang_mini6();
      var collective = (arr) => {
        if (is_array(arr)) {
          const target = {};
          const handler2 = {
            get(target2, prop, receiver) {
              if (arr.length > 0 && arr[0] && typeof arr[0][prop] === "function") {
                return (...a) => {
                  const res3 = [];
                  each(arr, (item2) => {
                    res3.push(item2[prop](...a));
                  });
                  return res3;
                };
              }
              if (prop in arr) {
                const val = arr[prop];
                if (typeof val === "function") return val.bind(arr);
                return val;
              }
              const res2 = [];
              each(arr, (item2) => {
                res2.push(item2[prop]);
              });
              return res2;
            }
          };
          const proxy2 = new Proxy(target, handler2);
          return proxy2;
        } else {
          console.trace();
          throw "NYI";
        }
      };
      module.exports = collective;
    }
  });

  // node_modules/lang-tools/Data_Model/Data_Model.js
  var require_Data_Model2 = __commonJS({
    "node_modules/lang-tools/Data_Model/Data_Model.js"(exports, module) {
      var { Evented_Class } = require_lib_lang_mini6();
      var Data_Model = class extends Evented_Class {
        constructor(spec = {}) {
          super(spec);
          this.__data_model = true;
          if (spec && spec.context) {
            this.context = spec.context;
          }
          if (spec && spec.name) {
            this.name = spec.name;
          }
          this.__type = "data_model";
        }
      };
      module.exports = Data_Model;
    }
  });

  // node_modules/lang-tools/Data_Model/new/tools.js
  var require_tools2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/tools.js"(exports, module) {
      var Data_Model = require_Data_Model2();
      var { tof } = require_lib_lang_mini6();
      var more_general_equals = (that2, other) => {
        const t_that = tof(that2), t_other = tof(other);
        if (t_that !== t_other) return false;
        if (t_that === "number" || t_that === "string" || t_that === "boolean" || t_that === "undefined" || t_that === "null") {
          return Object.is(that2, other);
        }
        if (t_that === "array") {
          if (!Array.isArray(other) || that2.length !== other.length) return false;
          for (let i = 0; i < that2.length; i++) {
            if (!more_general_equals(that2[i], other[i])) return false;
          }
          return true;
        }
        if (that2 instanceof Data_Model && other instanceof Data_Model) {
          if (typeof that2.toJSON === "function" && typeof other.toJSON === "function") {
            return that2.toJSON() === other.toJSON();
          }
          if (that2 === other) return true;
          return false;
        }
        if (t_that === "object" && "value" in that2) {
          return more_general_equals(that2.value, other);
        }
        if (t_that === "object") {
          const keysA = Object.keys(that2);
          const keysB = Object.keys(other);
          if (keysA.length !== keysB.length) return false;
          for (const k of keysA) {
            if (!Object.prototype.hasOwnProperty.call(other, k)) return false;
            if (!more_general_equals(that2[k], other[k])) return false;
          }
          return true;
        }
        return Object.is(that2, other);
      };
      module.exports = {
        more_general_equals
      };
    }
  });

  // node_modules/lang-tools/b-plus-tree/stiffarray.js
  var require_stiffarray2 = __commonJS({
    "node_modules/lang-tools/b-plus-tree/stiffarray.js"(exports, module) {
      var StiffArray = function(capacity) {
        var m_public = {
          items: new Array(capacity),
          // internal storage array
          count: 0,
          // items count
          first: function() {
            if (this.count == 0) throw "StiffArray.first()";
            return this.items[0];
          },
          last: function() {
            if (this.count == 0) throw "StiffArray.last()";
            return this.items[this.count - 1];
          },
          add: function(item2) {
            if (this.count >= capacity) throw "StiffArray.add()";
            this.items[this.count++] = item2;
          },
          add_from: function(source) {
            if (this.count + source.count > capacity) throw "StiffArray.add_from()";
            for (var i = 0; i < source.count; i++) this.items[this.count++] = source.items[i];
          },
          insert: function(index, item2) {
            if (index < 0 || index > this.count) throw "StiffArray.insert(): index";
            if (this.count >= capacity) throw "StiffArray.insert(): overflow";
            for (var i = this.count; i > index; i--) this.items[i] = this.items[i - 1];
            this.items[index] = item2;
            this.count++;
          },
          removeAt: function(index) {
            if (index < 0 || index >= this.count) throw "StiffArray.removeAt()";
            this.count--;
            for (var i = index; i < this.count; i++) this.items[i] = this.items[i + 1];
          },
          removeFirst: function() {
            this.removeAt(0);
          },
          removeLast: function() {
            this.removeAt(this.count - 1);
          },
          copy_from: function(source, index, count) {
            for (var i = 0; i < count; i++) {
              this.items[i] = source.items[i + index];
            }
            this.count = count;
          },
          search_first: function(item2) {
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              if (this.items[index] < item2) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first < this.count) {
              return { found: this.items[first] == item2, index: first };
            }
            return { found: false, index: first };
          },
          search_last: function(item2) {
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              if (item2 >= this.items[index]) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first > 0 && first <= this.count) {
              if (this.items[first - 1] == item2) {
                return { found: true, index: first - 1 };
              }
            }
            return { found: false, index: first };
          },
          search_last_prefix: function(prefix) {
            var prefix_length = prefix.length;
            var check_prefix = function(item3) {
              if (prefix_length > item3.length) return false;
              return item3.substr(0, prefix_length) == prefix;
            };
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
              var step = Math.floor(cnt / 2);
              var index = first + step;
              var item2 = this.items[index];
              if (prefix > item2 || check_prefix(item2)) {
                first = index + 1;
                cnt -= step + 1;
              } else {
                cnt = step;
              }
            }
            if (first > 0 && first <= this.count) {
              if (check_prefix(this.items[first - 1])) {
                return { found: true, index: first - 1 };
              }
            }
            return { found: false, index: first };
          },
          toString: function() {
            return this.items.slice(0, this.count).toString();
          }
        };
        return m_public;
      };
      module.exports = StiffArray;
    }
  });

  // node_modules/lang-tools/b-plus-tree/b-plus-tree.js
  var require_b_plus_tree2 = __commonJS({
    "node_modules/lang-tools/b-plus-tree/b-plus-tree.js"(exports, module) {
      var StiffArray = require_stiffarray2();
      var B_Plus_Node = function(nodeCapacity) {
        var m_public = {
          isLeaf: false,
          parent: null,
          keys: new StiffArray(nodeCapacity + 1),
          // +1: to allow temporary owerflow
          children: new StiffArray(nodeCapacity + 2)
          // +2: children.length == keys.length + 1
        };
        return m_public;
      };
      var B_Plus_Leaf = function(nodeCapacity) {
        var m_public = {
          isLeaf: true,
          parent: null,
          keys: new StiffArray(nodeCapacity + 1),
          values: new StiffArray(nodeCapacity + 1),
          //
          // leafs chain:
          prevLeaf: null,
          nextLeaf: null
        };
        return m_public;
      };
      var FindInfo = (key2, value2, isPrefixSearch) => {
        isPrefixSearch = !!isPrefixSearch;
        var isKeyPresent = key2 != void 0;
        var isValuePresent = value2 != void 0;
        var prefixLength = 0;
        if (isPrefixSearch) {
          if (typeof key2 != "string") {
            isPrefixSearch = false;
          } else {
            prefixLength = key2.length;
          }
        }
        return {
          key: key2,
          // key to find (if present)
          value: value2,
          // value to find (if present)
          isPrefixSearch,
          // prefix search mode
          leaf: null,
          // found leaf
          index: -1,
          // found leaf item index
          isKeyPresent,
          // function () { return this.key !== undefined; }, // is the search criteria contains key
          isValuePresent,
          // function () { return this.value !== undefined; }, // is the search criteria contains value
          foundKey: function() {
            return this.leaf.keys.items[this.index];
          },
          // found items's key
          foundValue: function() {
            return this.leaf.values.items[this.index];
          },
          // found item's value
          //
          prefix_length: prefixLength,
          // prefix length
          check_prefix: function() {
            if (!isPrefixSearch) return false;
            if (this.index >= this.leaf.keys.count) return false;
            var keyToCheck = this.foundKey();
            if (this.prefix_length > keyToCheck.length) return false;
            return keyToCheck.substr(0, this.prefix_length) == this.key;
          }
        };
      };
      var B_Plus_Tree = function(nodeCapacity) {
        if (nodeCapacity === void 0) nodeCapacity = 10;
        if (nodeCapacity < 4) throw "B_Plus_Tree(): node capacity must be >= 4";
        var m_public = {
          // tree root:
          root: new B_Plus_Leaf(nodeCapacity),
          //
          // leafs chain:
          firstLeaf: null,
          //
          lastLeaf: null,
          //
          // ---------------------
          //     editing:
          // ---------------------
          //
          // clear the tree:
          clear: function() {
            p_Clear();
          },
          //
          // insert(key, value)
          // insert([key, value])
          insert: function(key2, value2) {
            if (arguments.length == 2) {
              return p_Insert(key2, value2);
            } else {
              return p_Insert(key2[0], key2[1]);
            }
          },
          //
          // remove(key) - remove all values with given key
          // remove(key, value) - remove one value occurrence
          remove: function(key2, value2) {
            if (arguments.length == 2) {
              return p_Remove(key2, value2);
            } else {
              p_RemoveKey(key2);
            }
          },
          //
          // ---------------------
          //       finding:
          // ---------------------
          //
          // findFirst() - find the very first item
          // findFirst(key) - find the first item for the given key
          // findFirst(key, value) - find the first key+value occurrence
          //
          // returns the FindInfo object:
          //    key: key,     // key to find (if present)
          //    value: value, // value to find (if present)
          //
          //    leaf: null,   // the current found leaf
          //    index: -1,    // the current found index
          //
          //    foundKey():   // the current found key
          //    foundValue(): // the current found value
          //
          findFirst: function(key2, value2) {
            return p_FindFirst(key2, value2);
          },
          //
          // find first key matching the prefix:
          findFirstPrefix: function(prefix) {
            return p_FindFirst(prefix, void 0, true);
          },
          //
          // find next search conditions occurence
          findNext: function(findInfo) {
            return p_FindNext(findInfo);
          },
          //
          // findLast() - find the very last item
          // findLast(key) - find the last item for the given key
          // findLast(key, value) - find the last key+value occurrence
          findLast: function(key2, value2) {
            return p_FindLast(key2, value2);
          },
          //
          // find last key matching the prefix:
          findLastPrefix: function(prefix) {
            return p_FindLast(prefix, void 0, true);
          },
          //
          // find previous search conditions occurence
          findPrevious: function(findInfo) {
            return p_FindPrev(findInfo);
          },
          //
          // ---------------------
          // dictionary-like usage:
          // ---------------------
          //
          // get one value by key (or null):
          getValue: function(key2) {
            return p_GetValue(key2);
          },
          // set one value by key (insert or update):
          setValue: function(key2, value2) {
            p_SetValue(key2, value2);
          },
          //
          //
          // ---------------------
          //   other functions:
          // ---------------------
          //
          // count() - count all values
          // count(key) - count values with the given key
          count: function(key2) {
            if (arguments.length == 1) {
              return p_CountKey(key2);
            } else {
              return p_Count();
            }
          },
          //
          // tree capacity:
          getCapacity: function() {
            return m_nodeMaxCount;
          },
          //
          // ---------------------
          // additional functions:
          // ---------------------
          //
          // iterate through each key + value pair
          // callback is function(key, value)
          "each": function(callback2) {
            return p_each(callback2);
          },
          //
          // get all keys
          "keys": function() {
            return p_keys();
          },
          //
          // get all [key, value] pairs
          "keys_and_values": function() {
            return p_keys_and_values();
          },
          //
          //
          // get keys and values by prefix
          "get_by_prefix": function(prefix) {
            return p_get_by_prefix(prefix);
          },
          //
          // get keys by prefix
          "get_keys_by_prefix": function(prefix) {
            return p_get_keys_by_prefix(prefix);
          },
          //
          // get values at key...
          "get_values_by_key": function(key2) {
            return p_get_values_by_key(key2);
          }
        };
        m_public.firstLeaf = m_public.root;
        m_public.lastLeaf = m_public.root;
        var m_nodeMaxCount = nodeCapacity;
        var m_nodeMinCount = Math.floor(m_nodeMaxCount / 2);
        var p_Clear = function() {
          m_public.root = new B_Plus_Leaf(m_nodeMaxCount);
          m_public.firstLeaf = m_public.root;
          m_public.lastLeaf = m_public.root;
        };
        var p_keys = function() {
          var res2 = [];
          _p_each_key(function(key2) {
            res2.push(key2);
          });
          return res2;
        };
        var p_keys_and_values = function() {
          var res2 = [];
          p_each(function(key2, value2) {
            res2.push([key2, value2]);
          });
          return res2;
        };
        var _p_each_key = function(callback2) {
          var findInfo = p_FindFirst();
          while (findInfo != null) {
            var fk = findInfo.foundKey();
            callback2(fk);
            findInfo = p_FindNext(findInfo);
          }
        };
        var p_each = function(callback2) {
          var findInfo = p_FindFirst();
          var doStop = false;
          while (findInfo != null) {
            var fk = findInfo.foundKey();
            var fv = findInfo.foundValue();
            callback2(fk, fv, function() {
              doStop = true;
            });
            if (doStop) {
              findInfo = null;
            } else {
              findInfo = p_FindNext(findInfo);
            }
          }
        };
        var p_Insert = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          var leaf = searchResult.node;
          leaf.keys.insert(searchResult.index, key2);
          leaf.values.insert(searchResult.index, value2);
          if (leaf.keys.count > m_nodeMaxCount) {
            if (leaf.prevLeaf != null && leaf.prevLeaf.keys.count < m_nodeMaxCount && leaf.prevLeaf.parent == leaf.parent) {
              rotateAmongLeavesToLeft(leaf.prevLeaf, leaf);
            } else if (leaf.nextLeaf != null && leaf.nextLeaf.keys.count < m_nodeMaxCount && leaf.nextLeaf.parent == leaf.parent) {
              rotateAmongLeavesToRight(leaf, leaf.nextLeaf);
            } else {
              splitLeaf(leaf);
            }
          }
        };
        var splitLeaf = function(leaf) {
          var leftCount = m_nodeMinCount;
          var rightCount = leaf.keys.count - leftCount;
          var newRightLeaf = new B_Plus_Leaf(m_nodeMaxCount);
          newRightLeaf.parent = leaf.parent;
          newRightLeaf.keys.copy_from(leaf.keys, leftCount, rightCount);
          newRightLeaf.values.copy_from(leaf.values, leftCount, rightCount);
          leaf.keys.count = leftCount;
          leaf.values.count = leftCount;
          newRightLeaf.nextLeaf = leaf.nextLeaf;
          if (newRightLeaf.nextLeaf != null) newRightLeaf.nextLeaf.prevLeaf = newRightLeaf;
          newRightLeaf.prevLeaf = leaf;
          leaf.nextLeaf = newRightLeaf;
          if (m_public.lastLeaf == leaf) m_public.lastLeaf = newRightLeaf;
          if (leaf.parent != null) {
            var leafIndex = calcChildIndex(leaf.parent, leaf);
            insertToParent(leaf.parent, newRightLeaf, newRightLeaf.keys.first(), leafIndex + 1);
          } else {
            createNewRoot(leaf, newRightLeaf, newRightLeaf.keys.first());
          }
        };
        var createNewRoot = function(nodeLeft, nodeRight, key2) {
          var newRoot = new B_Plus_Node(m_nodeMaxCount);
          newRoot.keys.add(key2);
          newRoot.children.add(nodeLeft);
          newRoot.children.add(nodeRight);
          nodeLeft.parent = newRoot;
          nodeRight.parent = newRoot;
          m_public.root = newRoot;
        };
        var insertToParent = function(parentNode, newChildNode, newChildFirstKey, newChildIndex) {
          parentNode.keys.insert(newChildIndex - 1, newChildFirstKey);
          parentNode.children.insert(newChildIndex, newChildNode);
          newChildNode.parent = parentNode;
          if (parentNode.keys.count > m_nodeMaxCount) {
            splitNode(parentNode);
          }
        };
        var splitNode = function(node) {
          var newLeftCount = m_nodeMinCount;
          var newRightCount = m_nodeMaxCount - newLeftCount;
          var middleKey = node.keys.items[newLeftCount];
          var newRightNode = new B_Plus_Node(m_nodeMaxCount);
          newRightNode.keys.copy_from(node.keys, newLeftCount + 1, newRightCount);
          newRightNode.children.copy_from(node.children, newLeftCount + 1, newRightCount + 1);
          node.keys.count = newLeftCount;
          node.children.count = newLeftCount + 1;
          for (var i = 0; i < newRightNode.children.count; i++) newRightNode.children.items[i].parent = newRightNode;
          if (node.parent == null) {
            createNewRoot(node, newRightNode, middleKey);
          } else {
            var nodeIndex = calcChildIndex(node.parent, node);
            insertToParent(node.parent, newRightNode, middleKey, nodeIndex + 1);
          }
        };
        var p_Remove = function(key2, value2) {
          var searchResult = searchLeafValue(key2, value2);
          if (!searchResult.found) return false;
          removeFromLeaf(searchResult.node, searchResult.index);
          return true;
        };
        var p_RemoveKey = function(key2) {
          while (true) {
            var searchResult = searchLeaf(key2);
            if (!searchResult.found) break;
            removeFromLeaf(searchResult.node, searchResult.index);
          }
        };
        var removeFromLeaf = function(leaf, index) {
          leaf.keys.removeAt(index);
          leaf.values.removeAt(index);
          if (leaf.keys.count < m_nodeMinCount) {
            if (leaf.prevLeaf != null && leaf.parent == leaf.prevLeaf.parent && leaf.prevLeaf.keys.count > m_nodeMinCount) {
              rotateAmongLeavesToRight(leaf.prevLeaf, leaf);
            } else if (leaf.nextLeaf != null && leaf.parent == leaf.nextLeaf.parent && leaf.nextLeaf.keys.count > m_nodeMinCount) {
              rotateAmongLeavesToLeft(leaf, leaf.nextLeaf);
            } else {
              mergeLeaf(leaf);
            }
          }
          return true;
        };
        var mergeLeaf = function(leaf) {
          if (leaf.parent == null) {
            return;
          }
          var leftCount = m_nodeMaxCount + 1;
          var rightCount = m_nodeMaxCount + 1;
          if (leaf.prevLeaf != null && leaf.prevLeaf.parent == leaf.parent) {
            leftCount = leaf.prevLeaf.keys.count;
          }
          if (leaf.nextLeaf != null && leaf.nextLeaf.parent == leaf.parent) {
            rightCount = leaf.nextLeaf.keys.count;
          }
          if (leftCount < rightCount) {
            if (leftCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): leftCount";
            mergeLeaves(leaf.prevLeaf, leaf);
          } else {
            if (rightCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): rightCount";
            mergeLeaves(leaf, leaf.nextLeaf);
          }
        };
        var mergeLeaves = function(leafLeft, leafRight) {
          leafLeft.keys.add_from(leafRight.keys);
          leafLeft.values.add_from(leafRight.values);
          leafLeft.nextLeaf = leafRight.nextLeaf;
          if (leafLeft.nextLeaf != null) leafLeft.nextLeaf.prevLeaf = leafLeft;
          if (m_public.lastLeaf == leafRight) m_public.lastLeaf = leafLeft;
          var parent = leafRight.parent;
          var leafRightIndex = calcChildIndex(parent, leafRight);
          parent.keys.removeAt(leafRightIndex - 1);
          parent.children.removeAt(leafRightIndex);
          if (parent.keys.count < m_nodeMinCount) {
            mergeNode(parent);
          }
          ;
        };
        var mergeNode = function(node) {
          var parent = node.parent;
          if (node.parent == null) {
            if (node.keys.count == 0) {
              m_public.root = node.children.items[0];
              m_public.root.parent = null;
            }
            return;
          }
          var nodeIndex = calcChildIndex(parent, node);
          var leftSibling = nodeIndex > 0 ? parent.children.items[nodeIndex - 1] : null;
          var rightSibling = nodeIndex + 1 < parent.children.count ? parent.children.items[nodeIndex + 1] : null;
          if (leftSibling != null && leftSibling.keys.count > m_nodeMinCount) {
            rotateAmongNodesToRight(leftSibling, node);
            return;
          }
          if (rightSibling != null && rightSibling.keys.count > m_nodeMinCount) {
            rotateAmongNodesToLeft(node, rightSibling);
            return;
          }
          var leftCount = m_nodeMaxCount + 1;
          var rightCount = m_nodeMaxCount + 1;
          if (leftSibling != null) {
            leftCount = leftSibling.keys.count;
          }
          if (rightSibling != null) {
            rightCount = rightSibling.keys.count;
          }
          if (leftCount < rightCount) {
            if (leftSibling == null) throw "B_Plus_Tree.mergeNode(): leftSibling";
            mergeNodes(leftSibling, node, nodeIndex);
          } else {
            if (rightSibling == null) throw "B_Plus_Tree.mergeNode(): rightSibling";
            mergeNodes(node, rightSibling, nodeIndex + 1);
          }
        };
        var mergeNodes = function(nodeLeft, nodeRight, nodeRightIndex) {
          var parent = nodeLeft.parent;
          for (var i = 0; i < nodeRight.children.count; i++) nodeRight.children.items[i].parent = nodeLeft;
          nodeLeft.keys.add(nodeLeft.parent.keys.items[nodeRightIndex - 1]);
          nodeLeft.keys.add_from(nodeRight.keys);
          nodeLeft.children.add_from(nodeRight.children);
          parent.keys.removeAt(nodeRightIndex - 1);
          parent.children.removeAt(nodeRightIndex);
          if (parent.keys.count < m_nodeMinCount) {
            mergeNode(parent);
          }
          ;
        };
        var p_FindFirst = function(key2, value2, isPrefixSearch) {
          var findInfo = FindInfo(key2, value2, isPrefixSearch);
          if (findInfo.isKeyPresent) {
            if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindFirst(): arguments error: isPrefixSearch, but value is present";
            var searchResult = findInfo.isValuePresent ? searchLeafValue(key2, value2) : searchLeaf(key2);
            findInfo.leaf = searchResult.node;
            findInfo.index = searchResult.index;
            if (!searchResult.found) {
              if (!findInfo.check_prefix()) {
                return null;
              }
            }
          } else {
            if (findInfo.isValuePresent) throw "B_Plus_Tree.findFirst(): arguments error: key is not present, but value is present";
            findInfo.leaf = m_public.firstLeaf;
            findInfo.index = 0;
            if (findInfo.leaf.keys.count <= 0) return null;
          }
          return findInfo;
        };
        var p_FindLast = function(key2, value2, isPrefixSearch) {
          var findInfo = new FindInfo(key2, value2, isPrefixSearch);
          if (findInfo.isKeyPresent) {
            if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindLast(): arguments error: isPrefixSearch, but value is present";
            if (findInfo.isPrefixSearch) {
              var searchResult = searchLastLeafByPrefix(key2);
              findInfo.leaf = searchResult.node;
              findInfo.index = searchResult.index;
              if (!searchResult.found) {
                return null;
              }
            } else {
              var searchResult = findInfo.isValuePresent ? searchLastLeafValue(key2, value2) : searchLastLeaf(key2);
              findInfo.leaf = searchResult.node;
              findInfo.index = searchResult.index;
              if (!searchResult.found) {
                return null;
              }
            }
          } else {
            if (findInfo.isValuePresent) throw "B_Plus_Tree.findLast(): arguments error: key is not present, but value is present";
            findInfo.leaf = m_public.lastLeaf;
            findInfo.index = findInfo.leaf.keys.count - 1;
            if (findInfo.index < 0) return null;
          }
          return findInfo;
        };
        var findGoToNext = function(findInfo) {
          findInfo.index++;
          if (findInfo.index >= findInfo.leaf.keys.count) {
            findInfo.leaf = findInfo.leaf.nextLeaf;
            findInfo.index = 0;
          }
          return findInfo.leaf != null;
        };
        var findGoToPrev = function(findInfo) {
          findInfo.index--;
          if (findInfo.index < 0) {
            findInfo.leaf = findInfo.leaf.prevLeaf;
            if (findInfo.leaf == null) return false;
            findInfo.index = findInfo.leaf.keys.count - 1;
          }
          return true;
        };
        var p_FindNext = function(findInfo) {
          while (true) {
            if (!findGoToNext(findInfo)) return null;
            if (findInfo.isPrefixSearch) {
              if (!findInfo.check_prefix()) return null;
            } else {
              if (findInfo.isKeyPresent && findInfo.key != findInfo.foundKey()) return null;
            }
            if (findInfo.isValuePresent) {
              if (findInfo.value == findInfo.foundValue()) return findInfo;
            } else {
              return findInfo;
            }
          }
        };
        var p_FindPrev = function(findInfo) {
          while (true) {
            if (!findGoToPrev(findInfo)) return null;
            if (findInfo.isPrefixSearch) {
              if (!findInfo.check_prefix()) return null;
            } else {
              if (findInfo.isKeyPresent && findInfo.key != findInfo.foundKey()) return null;
            }
            if (findInfo.isValuePresent) {
              if (findInfo.value == findInfo.foundValue()) return findInfo;
            } else {
              return findInfo;
            }
          }
        };
        var p_get_values_by_key = function(key2) {
          var res2 = [];
          var findInfo = p_FindFirst(key2);
          while (findInfo != null) {
            res2.push(findInfo.foundValue());
            findInfo = p_FindNext(findInfo);
          }
          return res2;
        };
        var p_get_by_prefix = function(prefix) {
          var res2 = [];
          var findInfo = m_public.findFirstPrefix(prefix);
          while (findInfo != null) {
            res2.push([findInfo.foundKey(), findInfo.foundValue()]);
            findInfo = m_public.findNext(findInfo);
          }
          return res2;
        };
        var p_get_keys_by_prefix = function(prefix) {
          var res2 = [];
          var findInfo = m_public.findFirstPrefix(prefix);
          while (findInfo != null) {
            res2.push(findInfo.foundKey());
            findInfo = m_public.findNext(findInfo);
          }
          return res2;
        };
        var p_GetValue = function(key2) {
          var searchResult = searchLeaf(key2);
          if (!searchResult.found) return null;
          return searchResult.node.values.items[searchResult.index];
        };
        var p_SetValue = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          if (searchResult.found) {
            removeFromLeaf(searchResult.node, searchResult.index);
          }
          p_Insert(key2, value2);
        };
        var p_Count = function() {
          var result = 0;
          var leaf = m_public.firstLeaf;
          while (leaf != null) {
            result += leaf.keys.count;
            leaf = leaf.nextLeaf;
          }
          return result;
        };
        var p_CountKey = function(key2) {
          var result = 0;
          var findInfo = m_public.findFirst(key2);
          while (findInfo != null) {
            result++;
            findInfo = m_public.findNext(findInfo);
          }
          return result;
        };
        var rotateAmongNodesToLeft = function(leftNode, rightNode) {
          var parent = rightNode.parent;
          var rightIndex = calcChildIndex(parent, rightNode);
          leftNode.keys.add(parent.keys.items[rightIndex - 1]);
          parent.keys.items[rightIndex - 1] = rightNode.keys.first();
          rightNode.keys.removeFirst();
          rightNode.children.first().parent = leftNode;
          leftNode.children.add(rightNode.children.first());
          rightNode.children.removeFirst();
        };
        var rotateAmongNodesToRight = function(leftNode, rightNode) {
          var parent = rightNode.parent;
          var rightIndex = calcChildIndex(parent, rightNode);
          rightNode.keys.insert(0, parent.keys.items[rightIndex - 1]);
          parent.keys.items[rightIndex - 1] = leftNode.keys.last();
          leftNode.keys.removeLast();
          rightNode.children.insert(0, leftNode.children.last());
          rightNode.children.first().parent = rightNode;
          leftNode.children.removeLast();
        };
        var rotateAmongLeavesToLeft = function(leftLeaf, rightLeaf) {
          var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
          leftLeaf.keys.add(rightLeaf.keys.first());
          leftLeaf.values.add(rightLeaf.values.first());
          rightLeaf.keys.removeFirst();
          rightLeaf.values.removeFirst();
          rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
        };
        var rotateAmongLeavesToRight = function(leftLeaf, rightLeaf) {
          var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
          rightLeaf.keys.insert(0, leftLeaf.keys.last());
          rightLeaf.values.insert(0, leftLeaf.values.last());
          leftLeaf.keys.removeLast();
          leftLeaf.values.removeLast();
          rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
        };
        var calcChildIndex = function(node, child) {
          var key2 = child.keys.first();
          var searchResult = node.keys.search_first(key2);
          if (!searchResult.found) {
            if (node.children.items[searchResult.index] != child) throw "B_PlusTree.calcChildIndex(): 1";
            return searchResult.index;
          }
          var index = searchResult.index;
          for (; ; ) {
            if (node.children.items[index] == child) return index;
            index++;
            if (index >= node.children.count) break;
            if (node.keys.items[index - 1] != key2) break;
          }
          throw "B_PlusTree.calcChildIndex(): 2";
        };
        var searchLeaf = function(key2) {
          var doSearchLeaf = function(node, key3) {
            var searchResult = node.keys.search_first(key3);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultLeft = doSearchLeaf(node.children.items[searchResult.index], key3);
              if (resultLeft.found) return resultLeft;
              return doSearchLeaf(node.children.items[searchResult.index + 1], key3);
            } else {
              return doSearchLeaf(node.children.items[searchResult.index], key3);
            }
          };
          return doSearchLeaf(m_public.root, key2);
        };
        var searchLastLeaf = function(key2) {
          var doSearchLastLeaf = function(node, key3) {
            var searchResult = node.keys.search_last(key3);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultRight = doSearchLastLeaf(node.children.items[searchResult.index + 1], key3);
              if (resultRight.found) return resultRight;
              return doSearchLastLeaf(node.children.items[searchResult.index], key3);
            } else {
              return doSearchLastLeaf(node.children.items[searchResult.index], key3);
            }
          };
          return doSearchLastLeaf(m_public.root, key2);
        };
        var searchLastLeafByPrefix = function(prefix) {
          var doSearchLastLeafByPrefix = function(node, prefix2) {
            var searchResult = node.keys.search_last_prefix(prefix2);
            if (node.isLeaf) {
              return { node, found: searchResult.found, index: searchResult.index };
            }
            if (searchResult.found) {
              var resultRight = doSearchLastLeafByPrefix(node.children.items[searchResult.index + 1], prefix2);
              if (resultRight.found) return resultRight;
              return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix2);
            } else {
              return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix2);
            }
          };
          return doSearchLastLeafByPrefix(m_public.root, prefix);
        };
        var searchLeafValue = function(key2, value2) {
          var searchResult = searchLeaf(key2);
          if (!searchResult.found) return searchResult;
          var valueFound = false;
          var leaf = searchResult.node;
          var index = searchResult.index;
          for (; ; ) {
            if (index >= leaf.values.count) {
              leaf = leaf.nextLeaf;
              if (leaf == null) break;
              index = 0;
            }
            if (leaf.keys.items[index] != key2) break;
            if (leaf.values.items[index] == value2) {
              valueFound = true;
              break;
            }
            index++;
          }
          return { node: leaf, found: valueFound, index };
        };
        var searchLastLeafValue = function(key2, value2) {
          var searchResult = searchLastLeaf(key2);
          if (!searchResult.found) return searchResult;
          var valueFound = false;
          var leaf = searchResult.node;
          var index = searchResult.index;
          for (; ; ) {
            if (index < 0) {
              leaf = leaf.prevLeaf;
              if (leaf == null) break;
              index = leaf.values.count - 1;
            }
            if (leaf.keys.items[index] != key2) break;
            if (leaf.values.items[index] == value2) {
              valueFound = true;
              break;
            }
            index--;
          }
          return { node: leaf, found: valueFound, index };
        };
        return m_public;
      };
      B_Plus_Tree.FindInfo = FindInfo;
      module.exports = B_Plus_Tree;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Immutable_Data_Model.js
  var require_Immutable_Data_Model2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Immutable_Data_Model.js"(exports, module) {
      var Data_Model = require_Data_Model2();
      var Immutable_Data_Model = class extends Data_Model {
        constructor(...a) {
          super(...a);
        }
      };
      module.exports = Immutable_Data_Model;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Validation_Result.js
  var require_Validation_Result2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Validation_Result.js"(exports, module) {
      var Validation_Result = class {
      };
      module.exports = Validation_Result;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Validation_Success.js
  var require_Validation_Success2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Validation_Success.js"(exports, module) {
      var Validation_Result = require_Validation_Result2();
      var Validation_Success = class extends Validation_Result {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Validation_Success;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Validation_Failure.js
  var require_Validation_Failure2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Validation_Failure.js"(exports, module) {
      var Validation_Result = require_Validation_Result2();
      var Validation_Failure = class extends Validation_Result {
        constructor(spec) {
          super(spec);
        }
      };
      module.exports = Validation_Failure;
    }
  });

  // node_modules/lang-tools/Data_Model/new/setup_base_data_value_value_property.js
  var require_setup_base_data_value_value_property2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/setup_base_data_value_value_property.js"(exports, module) {
      var Validation_Success = require_Validation_Success2();
      var Validation_Failure = require_Validation_Failure2();
      var setup_base_data_value_value_property = (data_value) => {
        let local_js_value;
        const set_value_with_valid_and_changed_value = (valid_and_changed_value) => {
          const old = local_js_value;
          local_js_value = valid_and_changed_value;
          data_value.raise("change", {
            name: "value",
            old,
            value: local_js_value
          });
        };
        const create_validation_error = (validation, value2) => {
          const failure = validation instanceof Validation_Failure ? validation : new Validation_Failure({ value: value2 });
          const error2 = new Error("Validation failed for value assignment");
          error2.validation = failure;
          error2.value = value2;
          return error2;
        };
        Object.defineProperty(data_value, "value", {
          configurable: true,
          get() {
            return local_js_value;
          },
          set(value2) {
            if (data_value.transform_validate_value) {
              const obj_transform_and_validate_value_results = data_value.transform_validate_value(value2);
              const validation = obj_transform_and_validate_value_results && obj_transform_and_validate_value_results.validation;
              if (!(validation instanceof Validation_Success)) {
                throw create_validation_error(validation, value2);
              }
              const next_value = Object.prototype.hasOwnProperty.call(obj_transform_and_validate_value_results, "transformed_value") ? obj_transform_and_validate_value_results.transformed_value : obj_transform_and_validate_value_results.value;
              if (!Object.is(local_js_value, next_value)) {
                set_value_with_valid_and_changed_value(next_value);
              }
            } else {
              if (!Object.is(local_js_value, value2)) {
                set_value_with_valid_and_changed_value(value2);
              }
            }
          }
        });
      };
      module.exports = setup_base_data_value_value_property;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Base_Data_Value.js
  var require_Base_Data_Value2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Base_Data_Value.js"(exports, module) {
      var jsgui = require_lib_lang_mini6();
      var { more_general_equals } = require_tools2();
      var Data_Model = require_Data_Model2();
      var Immutable_Data_Model = require_Immutable_Data_Model2();
      var { is_defined, input_processors, field, tof, each } = jsgui;
      var setup_base_data_value_value_property = require_setup_base_data_value_value_property2();
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var Base_Data_Value = class extends Data_Model {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          this.__type = "data_value";
          this._relationships = {};
          const { data_type, context: context2 } = this;
          setup_base_data_value_value_property(this);
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        // Maybe see about immutable mode Data_Values / Data_Models.
        //   Or do make the immutable versions of all of them!!!
        //     And could make core functionality for both the immutable and mutable versions.
        //       Mutability Independent Code.
        // Immutable_Data_Integer does seem like it would in principle be (really?) simple.
        /*
            toImmutable() {
                // May be slightly difficult / tricky / complex.
                const {context, data_type, value} = this;
        
                // Create the new item...
                // Needs to copy the inner value....?
        
                const res = new Immutable_Data_Value({
                    context, data_type, value
                });
                return res;
            }
            */
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          return JSON.stringify(this.get());
        }
        // Need to copy / clone the ._ value
        /*
            'clone'() {
        
                //return this.toImmutable();
            }
            */
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
            return this.__id;
          }
          return void 0;
        }
      };
      module.exports = Base_Data_Value;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Value_Set_Attempt.js
  var require_Value_Set_Attempt2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Value_Set_Attempt.js"(exports, module) {
      var Value_Set_Attempt = class {
        constructor(spec = {}) {
          Object.assign(this, spec);
        }
      };
      module.exports = Value_Set_Attempt;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Immutable_Base_Data_Value.js
  var require_Immutable_Base_Data_Value2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Immutable_Base_Data_Value.js"(exports, module) {
      var jsgui = require_lib_lang_mini6();
      var { more_general_equals } = require_tools2();
      var Data_Model = require_Data_Model2();
      var Immutable_Data_Model = require_Immutable_Data_Model2();
      var { is_defined, input_processors, field, tof, each } = jsgui;
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var Immutable_Base_Data_Value = class extends Immutable_Data_Model {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          this.__type = "data_value";
          this._relationships = {};
          const { data_type, context: context2 } = this;
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        // Maybe see about immutable mode Data_Values / Data_Models.
        //   Or do make the immutable versions of all of them!!!
        //     And could make core functionality for both the immutable and mutable versions.
        //       Mutability Independent Code.
        // Immutable_Data_Integer does seem like it would in principle be (really?) simple.
        /*
            toImmutable() {
                // May be slightly difficult / tricky / complex.
                const {context, data_type, value} = this;
        
                // Create the new item...
                // Needs to copy the inner value....?
        
                const res = new Immutable_Data_Value({
                    context, data_type, value
                });
                return res;
            }
            */
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          return JSON.stringify(this.get());
        }
        // Need to copy / clone the ._ value
        /*
            'clone'() {
        
                //return this.toImmutable();
            }
            */
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "Immutable_Base_Data_Value should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
      };
      module.exports = Immutable_Base_Data_Value;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Immutable_Data_Value.js
  var require_Immutable_Data_Value2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Immutable_Data_Value.js"(exports, module) {
      var jsgui = require_lib_lang_mini6();
      var { more_general_equals } = require_tools2();
      var Data_Model = require_Data_Model2();
      var Immutable_Data_Model = require_Immutable_Data_Model2();
      var Immutable_Base_Data_Value = require_Immutable_Base_Data_Value2();
      var throw_immutable_assignment = () => {
        throw new TypeError("Cannot modify immutable Data_Value");
      };
      var { is_defined, input_processors, field, tof, each } = jsgui;
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var ldarkPurple = (x) => `\x1B[38;5;54m${x}\x1B[0m`;
      var Immutable_Data_Value = class _Immutable_Data_Value extends Immutable_Base_Data_Value {
        constructor(spec = {}) {
          super(spec);
          this.__data_value = true;
          this.__immutable = true;
          this.__type_name = "data_value";
          if (spec.data_type) this.data_type = spec.data_type;
          if (spec.context) {
            this.context = spec.context;
          }
          const { data_type, context: context2 } = this;
          if (data_type) {
            const to_local_js_value = (value2) => {
              if (value2 !== void 0) {
                const t = tof(value2);
                if (t === "number" || t === "string" || t === "boolean") {
                  return value2;
                } else {
                  if (t === "array") {
                    const l2 = value2.length;
                    const res2 = new Array(l2);
                    for (let c2 = 0; c2 < l2; c2++) {
                      res2[c2] = to_local_js_value(value2[c2]);
                    }
                    return res2;
                  } else if (t === "data_value") {
                    return value2.toImmutable();
                  } else {
                    console.log("to_local_js_value value", value2);
                    console.log("t", t);
                    console.trace();
                    throw "NYI";
                  }
                }
              }
            };
            const local_js_value = to_local_js_value(spec.value);
            Object.defineProperty(this, "value", {
              get() {
                return local_js_value;
              },
              set: throw_immutable_assignment
            });
          } else {
            let value2;
            if (spec.value instanceof Array) {
              value2 = spec.value.map((x) => {
                if (x instanceof Data_Model) {
                  return x.toImmutable();
                } else {
                  return x;
                }
              });
            } else {
              value2 = spec.value;
            }
            Object.defineProperty(this, "value", {
              get() {
                return value2;
              },
              set: throw_immutable_assignment
            });
          }
          this.__type = "data_value";
          this._relationships = {};
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        toImmutable() {
          const { context: context2, data_type, value: value2 } = this;
          const res2 = new _Immutable_Data_Value({
            context: context2,
            data_type,
            value: value2
          });
          return res2;
        }
        "get"() {
          return this.value;
        }
        "toString"() {
          return this.get() + "";
        }
        // Maybe a particular stringify function?
        "toJSON"() {
          const t_value = tof(this.value);
          if (t_value === "string") {
            return JSON.stringify(this.value);
          } else if (t_value === "number") {
            return this.value + "";
          } else if (t_value === "boolean") {
            this.value ? "true" : "false";
          } else if (t_value === "array") {
            let res2 = "[";
            const l2 = this.value.length;
            for (let c2 = 0; c2 < l2; c2++) {
              const item2 = this.value[c2];
              if (c2 > 0) res2 += ",";
              if (item2.toJSON) {
                res2 += item2.toJSON();
              } else {
                res2 += JSON.stringify(item2);
              }
            }
            res2 = res2 + "]";
            return res2;
          } else if (t_value === "data_value") {
            return this.value.toJSON();
          } else if (t_value === "undefined") {
            return "null";
          } else if (t_value === "null") {
            return "null";
          } else {
            console.log("toJSON this.value", this.value);
            console.log("t_value", t_value);
            console.trace();
            throw "NYI";
          }
        }
        // Need to copy / clone the ._ value
        "clone"() {
          return this.toImmutable();
        }
        // This is important to the running of jsgui3.
        //   Move to the lower level of Data_Model?
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (!is_defined(this.__id)) {
              throw "Data_Value should have context";
              this.__id = new_data_value_id();
            }
          }
          return this.__id;
        }
        "toObject"() {
          return this._;
        }
      };
      if (util) {
        Immutable_Data_Value.prototype[util.inspect.custom] = function(depth, opts) {
          const { value: value2 } = this;
          if (value2 instanceof Array) {
            let res2 = ldarkPurple("[ ");
            let first = true;
            each(value2, (item2) => {
              if (!first) {
                res2 = res2 + ldarkPurple(", ");
              } else {
                first = false;
              }
              if (item2 instanceof Data_Model) {
                const item_value = item2.value;
                res2 = res2 + ldarkPurple(item_value);
              } else [
                res2 = res2 + ldarkPurple(item2)
              ];
            });
            res2 = res2 + ldarkPurple(" ]");
            return res2;
          } else {
            return ldarkPurple(this.value);
          }
        };
      }
      module.exports = Immutable_Data_Value;
    }
  });

  // node_modules/lang-tools/Data_Model/new/setup_data_value_data_type_set.js
  var require_setup_data_value_data_type_set2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/setup_data_value_data_type_set.js"(exports, module) {
      var jsgui = require_lib_lang_mini6();
      var { more_general_equals } = require_tools2();
      var Base_Data_Value = require_Base_Data_Value2();
      var Data_Model = require_Data_Model2();
      var Immutable_Data_Model = require_Immutable_Data_Model2();
      var Immutable_Data_Value = require_Immutable_Data_Value2();
      var { is_defined, input_processors, field, tof, each, is_array } = jsgui;
      var Validation_Success = require_Validation_Success2();
      var setup_data_value_data_type_set = (data_value, data_type) => {
        let local_js_value;
        const validation_success = (value2, transformed_value) => {
          const res2 = {
            validation: new Validation_Success(),
            value: value2
          };
          if (transformed_value !== void 0) {
            res2.transformed_value = transformed_value;
          }
          return res2;
        };
        const unwrap_data_value = (value2) => value2 instanceof Base_Data_Value ? value2.value : value2;
        const is_functional_data_type = (dt) => !!dt && typeof dt.validate === "function";
        const define_string_value_property = () => {
          if (!Object.getOwnPropertyDescriptor(data_value, "value")) {
            Object.defineProperty(data_value, "value", {
              get() {
                return local_js_value;
              },
              set(value2) {
                const old_value = local_js_value;
                const immu = data_value.toImmutable();
                const value_equals_current = immu.equals(value2);
                if (!value_equals_current) {
                  const t_value = tof(value2);
                  let made_change = false;
                  if (t_value === "string") {
                    if (local_js_value instanceof Base_Data_Value) {
                      console.log("existing local_js_value instanceof Data_Value");
                      console.log("local_js_value.value", local_js_value.value);
                      console.log("local_js_value.data_type.name", local_js_value.data_type.name);
                      console.trace();
                      throw "NYI";
                    } else if (local_js_value === void 0) {
                      local_js_value = value2;
                      made_change = true;
                    } else if (typeof local_js_value === "string") {
                      local_js_value = value2;
                      made_change = true;
                    } else {
                      console.trace();
                      throw "stop";
                    }
                  } else {
                    if (value2 instanceof Base_Data_Value) {
                      console.log("t_value", t_value);
                      console.log("value", value2);
                      console.trace();
                      throw "stop";
                    } else {
                      const tval = tof(value2);
                      if (tval === "number") {
                        local_js_value = value2 + "";
                        made_change = true;
                      } else {
                        console.log("-- INVALID TYPE --");
                        console.log("tof(old_value)", tof(old_value));
                        console.log("tof(value)", tof(value2));
                        data_value.raise("validate", {
                          valid: false,
                          reason: "Invalid Type",
                          value: value2,
                          old: local_js_value
                        });
                      }
                    }
                  }
                  if (made_change) {
                    const my_e = {
                      name: "value",
                      old: old_value,
                      value: local_js_value
                    };
                    data_value.raise("change", my_e);
                  }
                }
              }
            });
          } else {
            const transform_string_value = (raw) => {
              const candidate = unwrap_data_value(raw);
              if (candidate === void 0 || candidate === null) {
                return validation_success(candidate);
              }
              if (typeof candidate === "string") {
                return validation_success(candidate);
              }
              if (typeof candidate === "number" || typeof candidate === "boolean") {
                return validation_success(candidate, candidate + "");
              }
              return {
                validation: false,
                value: candidate
              };
            };
            data_value.transform_validate_value = transform_string_value;
          }
        };
        const define_number_value_property = () => {
          const transform_number_value = (raw) => {
            const candidate = unwrap_data_value(raw);
            if (candidate === void 0 || candidate === null) {
              return validation_success(candidate);
            }
            if (typeof candidate === "number") {
              if (Number.isNaN(candidate)) {
                return {
                  validation: false,
                  value: candidate
                };
              }
              return validation_success(candidate);
            }
            if (typeof candidate === "string") {
              const trimmed = candidate.trim();
              if (trimmed.length === 0) {
                return {
                  validation: false,
                  value: candidate
                };
              }
              const parsed = Number(trimmed);
              if (!Number.isNaN(parsed)) {
                return validation_success(candidate, parsed);
              }
              return {
                validation: false,
                value: candidate
              };
            }
            return {
              validation: false,
              value: candidate
            };
          };
          data_value.transform_validate_value = transform_number_value;
        };
        const define_data_type_typed_value_property = () => {
          const descriptor = Object.getOwnPropertyDescriptor(data_value, "value");
          if (descriptor) {
            const transform_data_type_value = (raw) => {
              const candidate = unwrap_data_value(raw);
              if (data_type.validate(candidate)) {
                return validation_success(candidate);
              }
              if (typeof candidate === "string" && typeof data_type.parse_string === "function") {
                const parsed = data_type.parse_string(candidate);
                if (parsed !== void 0 && data_type.validate(parsed)) {
                  return validation_success(candidate, parsed);
                }
              }
              return {
                validation: false,
                value: candidate
              };
            };
            data_value.transform_validate_value = transform_data_type_value;
            return;
          }
          const {
            wrap_properties,
            property_names,
            property_data_types,
            wrap_value_inner_values,
            value_js_type,
            abbreviated_property_names,
            named_property_access,
            numbered_property_access,
            parse_string
          } = data_type;
          let num_properties;
          if (property_names && property_data_types) {
            if (property_names.length === property_data_types.length) {
              num_properties = property_names.length;
              if (numbered_property_access) {
              }
            }
          } else if (property_names) {
            num_properties = property_names.length;
          }
          let _current_immutable_value, _previous_immutable_value;
          let prev_outer_value, current_outer_value;
          let _numbered_property_access_has_been_set_up = false, _named_property_access_has_been_set_up = false;
          Object.defineProperty(data_value, "value", {
            get() {
              return local_js_value;
            },
            set(value2) {
              const immu = data_value.toImmutable();
              const value_equals_current = immu.equals(value2);
              if (value_equals_current) {
              } else {
                const passed_first_validation = data_type.validate(value2);
                let passed_validation = passed_first_validation;
                if (!passed_first_validation) {
                  const t_value = tof(value2);
                  if (t_value === "string" && data_type.parse_string) {
                    const parsed_value = data_type.parse_string(value2);
                    if (parsed_value !== void 0) {
                      if (data_type.validate(parsed_value)) {
                        if (!immu.equals(parsed_value)) {
                          value2 = parsed_value;
                          passed_validation = true;
                        }
                      }
                    }
                  }
                }
                if (passed_validation) {
                  data_value.raise("validate", {
                    valid: true,
                    value: value2
                  });
                } else {
                  data_value.raise("validate", {
                    valid: false,
                    value: value2
                  });
                }
                if (passed_validation) {
                  const do_actual_set = (value3) => {
                    const array_specific_value_processing = () => {
                      if (value_js_type === Array) {
                        let t = tof(local_js_value);
                        if (t === "undefined") {
                          const create_array_with_wrapped_items = () => {
                            if (num_properties) {
                              if (wrap_value_inner_values) {
                                if (property_data_types) {
                                  let i = 0;
                                  if (value3.__immutable) {
                                    const l2 = value3.length;
                                    const arr_wrapped_value_values = new Array(l2);
                                    const value_value = value3.value;
                                    do_actual_set(value_value);
                                  } else {
                                    if (value3 instanceof Data_Value) {
                                      const arr_wrapped_value_values = new Array(num_properties);
                                      const arr_dv_value = value3.value;
                                      console.log("arr_dv_value", arr_dv_value);
                                      console.trace();
                                      throw "stop";
                                    } else if (is_array(value3)) {
                                      const arr_wrapped_value_values = value3.map((value4) => {
                                        const property_index = i;
                                        let property_name;
                                        if (property_names) {
                                          property_name = property_names[property_index];
                                        }
                                        const wrapped_value = new Data_Value({ context, value: value4, data_type: property_data_types[i] });
                                        wrapped_value.on("change", (e) => {
                                          const { name } = e;
                                          if (name === "value") {
                                            current_outer_value = data_value.toImmutable();
                                            const my_e2 = {
                                              name,
                                              event_originator: wrapped_value,
                                              parent_event: e,
                                              value: current_outer_value
                                            };
                                            if (property_name) {
                                              my_e2.property_name = property_name;
                                            }
                                            my_e2.property_index = property_index;
                                            data_value.raise("change", my_e2);
                                            prev_outer_value = current_outer_value;
                                          }
                                        });
                                        i++;
                                        return wrapped_value;
                                      });
                                      local_js_value = arr_wrapped_value_values;
                                      const my_e = {
                                        name: "value",
                                        old: _previous_immutable_value,
                                        value: data_value.toImmutable()
                                      };
                                      data_value.raise("change", my_e);
                                    }
                                  }
                                } else {
                                  let i = 0;
                                  const arr_wrapped_value_values = value3.map((value4) => {
                                    const property_index = i;
                                    let property_name;
                                    if (property_names) {
                                      property_name = property_names[property_index];
                                    }
                                    const wrapped_value = new Data_Value({ context, value: value4 });
                                    wrapped_value.on("change", (e) => {
                                      const { name } = e;
                                      if (name === "value") {
                                        const my_e = {
                                          name,
                                          event_originator: wrapped_value,
                                          parent_event: e,
                                          value: data_value.toImmutable()
                                        };
                                        if (property_name) {
                                          my_e.property_name = property_name;
                                        }
                                        my_e.property_index = property_index;
                                        data_value.raise("change", my_e);
                                      }
                                    });
                                    i++;
                                    return wrapped_value;
                                  });
                                  local_js_value = arr_wrapped_value_values;
                                }
                              } else {
                                local_js_value = value3;
                              }
                            } else {
                              console.trace();
                              throw "stop - number of properties not found";
                            }
                          };
                          create_array_with_wrapped_items();
                        } else if (t === "array") {
                          const t_value = tof(value3);
                          if (t_value === "data_value") {
                            if (is_array(value3.value)) {
                              if (value3.value.length === local_js_value.length) {
                                each(value3.value, (inner_value, idx) => {
                                  if (inner_value instanceof Data_Model) {
                                    const matching_local_inner_value = local_js_value[idx];
                                    if (inner_value.equals(matching_local_inner_value)) {
                                    } else {
                                      matching_local_inner_value.value = inner_value;
                                    }
                                  } else {
                                    console.trace();
                                    throw "NYI";
                                  }
                                });
                              } else {
                                console.trace();
                                throw "NYI";
                              }
                            } else {
                              console.trace();
                              throw "NYI";
                            }
                          } else {
                            if (t_value === "array") {
                              if (local_js_value.length === value3.length) {
                                const l2 = value3.length;
                                let all_local_js_items_are_data_model = true, c2 = 0;
                                do {
                                  const local_item = local_js_value[c2];
                                  if (!(local_item instanceof Data_Model)) {
                                    all_local_js_items_are_data_model = false;
                                  }
                                  c2++;
                                } while (all_local_js_items_are_data_model && c2 < l2);
                                if (all_local_js_items_are_data_model) {
                                  let c3 = 0;
                                  do {
                                    const local_item = local_js_value[c3];
                                    local_item.value = value3[c3];
                                    c3++;
                                  } while (c3 < l2);
                                } else {
                                  console.trace();
                                  throw "NYI";
                                }
                              } else {
                                console.trace();
                                throw "NYI";
                              }
                            } else {
                              console.log("value", value3);
                              console.trace();
                              throw "NYI";
                            }
                          }
                        } else {
                        }
                      } else {
                      }
                    };
                    array_specific_value_processing();
                    const general_value_processing = () => {
                      if (local_js_value instanceof Base_Data_Value) {
                        console.log("existing local_js_value instanceof Data_Value");
                        console.log("local_js_value.value", local_js_value.value);
                        console.log("local_js_value.data_type.name", local_js_value.data_type.name);
                        console.trace();
                        throw "NYI";
                      } else if (local_js_value instanceof Array) {
                        if (value3 instanceof Data_Model) {
                          if (value3.equals(local_js_value)) {
                          } else {
                            console.log("value", value3);
                            console.log("local_js_value", local_js_value);
                            console.trace();
                            throw "NYI";
                          }
                        } else if (value3 instanceof Array) {
                          if (property_names.length === value3.length) {
                            if (property_data_types) {
                              const num_properties2 = property_names.length;
                              for (let i_property = 0; i_property < num_properties2; i_property++) {
                                const name = property_names[i_property];
                                const data_type2 = property_data_types[i_property];
                                if (local_js_value[i_property] instanceof Data_Value) {
                                  local_js_value[i_property].value = value3[i_property];
                                } else {
                                  console.trace();
                                  throw "NYI";
                                }
                              }
                              if (numbered_property_access && !_numbered_property_access_has_been_set_up) {
                                for (let i_property = 0; i_property < num_properties2; i_property++) {
                                  const name = property_names[i_property];
                                  const data_type2 = property_data_types[i_property];
                                  Object.defineProperty(data_value, i_property, {
                                    get() {
                                      return local_js_value[i_property];
                                    },
                                    set(value4) {
                                      const item_already_there = local_js_value[i_property];
                                      if (item_already_there instanceof Data_Model) {
                                        item_already_there.value = value4;
                                      } else {
                                        console.log("item_already_there", item_already_there);
                                        console.trace();
                                        throw "stop";
                                      }
                                      if (value4 instanceof Data_Model) {
                                      } else {
                                      }
                                    }
                                  });
                                }
                                Object.defineProperty(data_value, "length", {
                                  get() {
                                    return local_js_value.length;
                                  }
                                });
                                _numbered_property_access_has_been_set_up = true;
                              }
                              if (named_property_access && !_named_property_access_has_been_set_up) {
                                if (numbered_property_access) {
                                  if (property_names) {
                                    for (let i_property = 0; i_property < num_properties2; i_property++) {
                                      const name = property_names[i_property];
                                      const data_type2 = property_data_types[i_property];
                                      Object.defineProperty(data_value, name, {
                                        get() {
                                          return local_js_value[i_property];
                                        },
                                        set(value4) {
                                          const item_already_there = local_js_value[i_property];
                                          if (item_already_there instanceof Data_Model) {
                                            item_already_there.value = value4;
                                          } else {
                                            console.log("item_already_there", item_already_there);
                                            console.trace();
                                            throw "stop";
                                          }
                                        }
                                      });
                                    }
                                  }
                                  if (abbreviated_property_names) {
                                    for (let i_property = 0; i_property < num_properties2; i_property++) {
                                      const name = abbreviated_property_names[i_property];
                                      const data_type2 = property_data_types[i_property];
                                      Object.defineProperty(data_value, name, {
                                        get() {
                                          return local_js_value[i_property];
                                        },
                                        set(value4) {
                                          const item_already_there = local_js_value[i_property];
                                          if (item_already_there instanceof Data_Model) {
                                            item_already_there.value = value4;
                                          } else {
                                            console.log("item_already_there", item_already_there);
                                            console.trace();
                                            throw "stop";
                                          }
                                          if (value4 instanceof Data_Model) {
                                          } else {
                                          }
                                        }
                                      });
                                    }
                                  }
                                }
                                _named_property_access_has_been_set_up = true;
                              }
                            }
                          } else {
                            console.trace();
                            throw "NYI";
                          }
                        } else {
                          console.log("value", value3);
                          console.log("local_js_value", local_js_value);
                          console.log("value_equals_current", value_equals_current);
                          console.log("immu", immu);
                          console.trace();
                          throw "NYI";
                        }
                      } else {
                        if (value3 instanceof Data_Model) {
                          if (value3.data_type === data_value.data_type) {
                            const tvv = tof(value3.value);
                            if (tvv === "number" || tvv === "string" || tvv === "boolean") {
                              local_js_value = value3.value;
                            } else {
                              console.trace();
                              throw "NYI";
                            }
                          } else {
                            console.trace();
                            throw "NYI";
                          }
                        } else {
                          local_js_value = value3;
                        }
                        data_value.raise("change", {
                          name: "value",
                          old: immu,
                          value: value3
                        });
                        prev_outer_value = current_outer_value;
                      }
                    };
                    general_value_processing();
                  };
                  do_actual_set(value2);
                } else {
                }
              }
            }
          });
        };
        if (data_type === String) {
          define_string_value_property();
        } else if (data_type === Number) {
          define_number_value_property();
        } else if (is_functional_data_type(data_type)) {
          define_data_type_typed_value_property();
        } else {
          console.trace();
          throw "NYI";
        }
      };
      module.exports = setup_data_value_data_type_set;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Data_Value.js
  var require_Data_Value2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Data_Value.js"(exports, module) {
      var jsgui = require_lib_lang_mini6();
      var { more_general_equals } = require_tools2();
      var Base_Data_Value = require_Base_Data_Value2();
      var Value_Set_Attempt = require_Value_Set_Attempt2();
      var Data_Model = require_Data_Model2();
      var Immutable_Data_Model = require_Immutable_Data_Model2();
      var Immutable_Data_Value = require_Immutable_Data_Value2();
      var { is_defined, input_processors, tof, each, is_array, Data_Type } = jsgui;
      var setup_data_value_data_type_set = require_setup_data_value_data_type_set2();
      var util;
      if (typeof window === "undefined") {
        const str_utl = "util";
        util = __require(str_utl);
      }
      var lpurple = (x) => "\x1B[38;5;129m" + x + "\x1B[0m";
      var Data_Value2 = class _Data_Value extends Base_Data_Value {
        constructor(spec = {}) {
          const spec_is_plain_object = spec !== null && typeof spec === "object" && !Array.isArray(spec);
          const actual_spec = spec_is_plain_object ? spec : { value: spec };
          super(actual_spec);
          const initial_value_is_present = Object.prototype.hasOwnProperty.call(actual_spec, "value");
          const initial_value = initial_value_is_present ? actual_spec.value : void 0;
          const { data_type } = this;
          if (data_type) {
            setup_data_value_data_type_set(this, data_type);
            if (initial_value_is_present && is_defined(initial_value)) {
              this.value = initial_value;
            }
          } else {
            if (initial_value_is_present) {
              this.value = actual_spec.value;
            }
          }
          const attempt_set_value = this.attempt_set_value = (value2) => {
            const get_local_js_value_copy = () => {
              const lv = this.value;
              const tljsv = tof(lv);
              if (tljsv === "undefined" || tljsv === "string" || tljsv === "number" || tljsv === "array" || tljsv === "object" || tljsv === "data_value") {
                return lv;
              } else {
                return lv;
              }
            };
            const old_local_js_value = get_local_js_value_copy();
            const old_equals_new = more_general_equals(old_local_js_value, value2);
            if (old_equals_new === true) {
              return new Value_Set_Attempt({ success: false, equal_values: true });
            }
            try {
              this.value = value2;
            } catch (error2) {
              return new Value_Set_Attempt({ success: false, value: old_local_js_value, error: error2 });
            }
            const new_local_js_value = get_local_js_value_copy();
            const changed = !more_general_equals(old_local_js_value, new_local_js_value);
            return new Value_Set_Attempt({
              success: changed,
              old: old_local_js_value,
              value: new_local_js_value
            });
          };
          this.__type = "data_value";
          this._relationships = {};
        }
        toImmutable() {
          const { context: context2, data_type, value: value2 } = this;
          const res2 = new Immutable_Data_Value({
            context: context2,
            data_type,
            value: value2
          });
          return res2;
        }
        "toObject"() {
          return this._;
        }
        "set"(val) {
          this.value = val;
        }
        "get"() {
          return this.value;
        }
        equals(other) {
          return more_general_equals(this, other);
        }
        "toString"() {
          return this.get() + "";
        }
        "toJSON"() {
          const t_value = tof(this.value);
          if (t_value === "string") {
            return JSON.stringify(this.value);
          } else if (t_value === "number") {
            return this.value + "";
          } else if (t_value === "boolean") {
            this.value ? "true" : "false";
          } else if (t_value === "array") {
            return JSON.stringify(this.value);
          } else if (t_value === "data_value") {
            return this.value.toJSON();
          } else if (t_value === "undefined") {
            return "null";
          } else if (t_value === "null") {
            return "null";
          } else {
            console.log("toJSON this.value", this.value);
            console.log("t_value", t_value);
            console.trace();
            throw "NYI";
          }
        }
        "clone"() {
          console.trace();
          throw "NYI";
          var res2 = new _Data_Value({
            "value": this._
          });
          return res2;
        }
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
            return this.__id;
          }
          return void 0;
        }
      };
      var ensure_sync_state = (data_value) => {
        if (!data_value.__sync_state) {
          Object.defineProperty(data_value, "__sync_state", {
            value: {
              updatingFrom: /* @__PURE__ */ new Set()
            },
            enumerable: false
          });
        }
        return data_value.__sync_state;
      };
      var has_defined_value = (data_value) => typeof data_value.value !== "undefined";
      var copy_initial_value = (from, to) => {
        const source_state = ensure_sync_state(from);
        source_state.updatingFrom.add(to);
        try {
          to.value = from.value;
        } finally {
          source_state.updatingFrom.delete(to);
        }
      };
      var propagate_sync_value = (source, target) => {
        source.on("change", (e) => {
          if (e.name !== "value") {
            return;
          }
          const { updatingFrom } = ensure_sync_state(target);
          if (updatingFrom.has(source)) {
            return;
          }
          updatingFrom.add(source);
          try {
            target.value = e.value;
          } finally {
            updatingFrom.delete(source);
          }
        });
      };
      var align_initial_values = (a, b) => {
        const a_has_value = has_defined_value(a);
        const b_has_value = has_defined_value(b);
        if (a_has_value && !b_has_value) {
          copy_initial_value(a, b);
        } else if (!a_has_value && b_has_value) {
          copy_initial_value(b, a);
        }
      };
      Data_Value2.sync = (a, b) => {
        if (a instanceof Base_Data_Value && b instanceof Base_Data_Value) {
          propagate_sync_value(a, b);
          propagate_sync_value(b, a);
          align_initial_values(a, b);
        } else {
          console.trace();
          throw "Unexpected types";
        }
      };
      if (util) {
        Data_Value2.prototype[util.inspect.custom] = function(depth, opts) {
          const { value: value2 } = this;
          const tv = tof(value2);
          if (tv === "number" || tv === "string" || tv === "boolean") {
            return lpurple(value2);
          } else {
            if (value2 instanceof Array) {
              let res2 = lpurple("[ ");
              let first = true;
              each(value2, (item2) => {
                if (!first) {
                  res2 = res2 + lpurple(", ");
                } else {
                  first = false;
                }
                if (item2 instanceof Data_Model) {
                  const item_value = item2.value;
                  res2 = res2 + lpurple(item_value);
                } else [
                  res2 = res2 + lpurple(item2)
                ];
              });
              res2 = res2 + lpurple(" ]");
              return res2;
            } else if (value2 instanceof Data_Model) {
              return value2[util.inspect.custom]();
            } else {
              return lpurple(this.value);
            }
          }
        };
      }
      module.exports = Data_Value2;
    }
  });

  // node_modules/lang-tools/Data_Model/Mini_Context.js
  var require_Mini_Context2 = __commonJS({
    "node_modules/lang-tools/Data_Model/Mini_Context.js"(exports, module) {
      var Mini_Context = class {
        // Need quite a simple mechanism to get IDs for objects.
        // They will be typed objects/
        constructor(spec) {
          const map_typed_counts = /* @__PURE__ */ Object.create(null);
          this.new_id = (str_type = "item") => {
            const current = map_typed_counts[str_type] || 0;
            map_typed_counts[str_type] = current + 1;
            return `${str_type}_${current}`;
          };
        }
        "make"(abstract_object) {
          if (abstract_object._abstract) {
            var constructor = abstract_object.constructor;
            var aos = abstract_object._spec;
            aos.abstract = null;
            aos.context = this;
            var res2 = new constructor(aos);
            return res2;
          } else {
            throw "Object must be abstract, having ._abstract == true";
          }
        }
      };
      module.exports = Mini_Context;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Data_Object.js
  var require_Data_Object2 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Data_Object.js"(exports, module) {
      var jsgui = require_lib_lang_mini6();
      var { each, tof, is_defined, get_a_sig, ll_get } = jsgui;
      var Mini_Context = require_Mini_Context2();
      var Data_Model = require_Data_Model2();
      var Data_Value2 = require_Data_Value2();
      jsgui.__data_id_method = "init";
      var Data_Object = class extends Data_Model {
        constructor(spec = {}, fields) {
          super(spec);
          this._ = this._ || {};
          if (spec.id) {
            this.__id = spec.id;
          }
          if (spec.__id) {
            this.__id = spec.__id;
          }
          this.__type_name = spec.__type_name || "data_object";
          if (fields) this.set_fields_from_spec(fields, spec);
          this.__data_object = true;
          if (spec.abstract === true) {
            this._abstract = true;
            var tSpec = tof(spec);
            if (tSpec == "function") {
              this._type_constructor = spec;
            } else if (tSpec == "object") {
              this._spec = spec;
            }
          } else {
            var t_spec = tof(spec);
            this.__type = "data_object";
            if (t_spec === "object" || t_spec === "control") {
              if (spec.context) {
                this.context = spec.context;
              }
              if (spec.id) {
                this.__id = spec.id;
              }
              if (spec._id) {
                this.__id = spec._id;
              }
              if (spec.__id) {
                this.__id = spec.__id;
              }
            } else if (t_spec == "data_object") {
              if (spec.context) this.context = spec.context;
            }
            if (is_defined(spec.parent)) {
              this.parent = spec.parent;
            }
            if (this.context) {
              this.init_default_events();
            }
            const reserved_keys = {
              "context": true,
              "id": true,
              "_id": true,
              "__id": true,
              "parent": true,
              "__type": true,
              "__type_name": true,
              "abstract": true,
              "data_def": true,
              "load_array": true,
              "items": true,
              "fn_index": true,
              "constraint": true,
              "index_by": true,
              "accepts": true
            };
            if (t_spec === "object" && spec) {
              Object.keys(spec).forEach((key2) => {
                if (reserved_keys[key2] || key2.startsWith("__")) return;
                this.set(key2, spec[key2], true);
              });
            }
          }
        }
        "set_fields_from_spec"(fields, spec) {
          const normalized = [];
          if (Array.isArray(fields)) {
            each(fields, (field) => {
              if (Array.isArray(field)) {
                normalized.push(field);
              } else if (typeof field === "object" && field.name) {
                normalized.push([field.name, field.type, field.default]);
              }
            });
          } else if (typeof fields === "object") {
            each(fields, (val, key2) => {
              if (Array.isArray(val)) {
                normalized.push([key2, val[0], val[1]]);
              } else {
                normalized.push([key2, val]);
              }
            });
          }
          each(normalized, (field) => {
            const field_name = field[0];
            const field_default = field[2];
            let value_to_set;
            if (spec && typeof spec[field_name] !== "undefined") {
              value_to_set = spec[field_name];
            } else if (typeof field_default !== "undefined") {
              value_to_set = field_default;
            }
            if (typeof value_to_set !== "undefined") {
              if (typeof this.set === "function") {
                this.set(field_name, value_to_set, true);
              } else {
                this._[field_name] = value_to_set;
              }
            }
          });
        }
        "init_default_events"() {
        }
        /*
             'data_def': fp(function(a, sig) {
             if (sig == '[o]') {
             // create the new data_def constraint.
        
        
             }
             }),
             */
        "keys"() {
          return Object.keys(this._);
        }
        // fromJSON
        "toJSON"() {
          var res2 = [];
          res2.push("Data_Object(" + JSON.stringify(this._) + ")");
          return res2.join("");
        }
        // using_fields_connection()
        //  will search up the object heirachy, to see if the Data_Objects fields need to be connected through the use of functions.
        //  that will make the fields easy to change by calling a function. Should make things much faster to access than when programming with Backbone.
        // then will connect the fields with connect_fields()
        /*
        'using_fields_connection'() {
            var res = false;
            iterate_ancestor_classes(this.constructor, function (a_class, stop) {
                if (is_defined(a_class._connect_fields)) {
                    res = a_class._connect_fields;
                    stop();
                }
            });
            return res;
        }
        */
        // using _relationships or whatever
        get parent() {
          return this._parent;
        }
        set parent(value2) {
          return this._parent = value2;
        }
        "_id"() {
          if (this.__id) return this.__id;
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
            if (this._abstract) {
              return void 0;
            } else if (!is_defined(this.__id)) {
              return void 0;
            }
          }
          return this.__id;
        }
        // Problems with name (fields).
        //  Fields are given as a description of the fields.
        //   Gets more complicated when we have a function to access the fields as well.
        //   What if we want to override that function?
        // Will call it field
        //  18/12/2016 - Getting rid of this confusion, will mostly remove / greatly simplify field functionality.
        //  Just need to know which fields any class has, keeping track of this will use some data structures like Sorted_KVS,
        //   but not much complex code within this part.
        // Not so sure what a field function will do right now.
        //  Does not seem like such an essential part of the API.
        //   Can just define the fields, then they act a bit differently.
        //   Have field handling in Data_Object.
        //   Collection would have the same field capabilities. Fields should not be so important anyway.
        // 18/12/2016 Will remove constraints, then make them much more functional.
        //  Go through the keys....
        "each"(callback2) {
          each(this._, callback2);
        }
        // could make this polymorphic so that it
        //   sibling_index I think.
        "position_within"(parent) {
          var p_id = parent._id();
          if (this._parents && is_defined(this._parents[p_id])) {
            var parent_rel_info = this._parents[p_id];
            var pos_within = parent_rel_info[1];
            return pos_within;
          }
        }
        // Maybe just 'remove' function.
        //  This may be needed with multiple parents, which are not being used at the moment.
        // ???? late 2023
        "remove_from"(parent) {
          var p_id = parent._id();
          if (this._parents && is_defined(this._parents[p_id])) {
            var parent = this._parents[p_id][0];
            var pos_within = this._parents[p_id][1];
            var item2 = parent._arr[pos_within];
            parent.remove(pos_within);
            delete this._parents[p_id];
          }
        }
        //  
        // Maybe only do this with the fields anyway
        "load_from_spec"(spec, arr_item_names) {
          console.trace();
          throw "Deprecated in new Data_Object version";
          each(arr_item_names, (v) => {
            var spec_item = spec[v];
            if (is_defined(spec_item)) {
              this.set(v, spec_item);
            }
          });
        }
        // They will be treated as values in many cases anyway.
        //  Will turn them to different types of object where possible.
        /*
            'value'() {
                var a = arguments; a.l = arguments.length; var sig = get_a_sig(a, 1);
                // could operate like both get and set, but does not return data_objects, returns the value itself.
                var name;
                //var res;
                if (sig === '[s]') {
                    name = a[0];
                    var possibly_dobj = this.get(name);
                    //var t_obj = tof(possibly_dobj);
        
                    if (possibly_dobj) {
                        if (possibly_dobj.value && typeof possibly_dobj.value === 'function') {
                            return possibly_dobj.value();
                        } else {
                            return possibly_dobj;
                        }
                    }
                }
            }
            */
        // Get could be greatly simplified as well.
        //  Input and output processing will be more streamlined in a functional way.
        // 19/12/2016 - Not using get or set nearly as much anyway.
        "get"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          var do_typed_processing = false;
          if (do_typed_processing) {
            if (a.l === 0) {
              var output_obj = jsgui.output_processors[this.__type_name](this._);
              return output_obj;
            } else {
              console.log("a", a);
              console.trace();
              throw "not yet implemented";
            }
          } else {
            if (sig == "[s,f]") {
              throw "Asyncronous access not allowed on Data_Object get.";
              var res2 = this.get(a[0]);
              var callback2 = a[1];
              if (typeof res2 == "function") {
                res2(callback2);
              } else {
                return res2;
              }
            } else if (sig == "[s]") {
              var res2 = ll_get(this, a[0]);
              return res2;
            } else if (a.l === 0) {
              return this._;
            }
          }
        }
        "ensure_data_value"(property_name, default_value) {
          if (this._abstract) return void 0;
          if (!property_name || typeof property_name !== "string") throw "property_name expected: string";
          if (property_name.indexOf(".") > -1 && property_name !== ".") throw "ensure_data_value does not support dotted paths (yet)";
          const has_key = this._ && Object.prototype.hasOwnProperty.call(this._, property_name);
          const existing = has_key ? this._[property_name] : void 0;
          if (existing && existing.__data_value) return existing;
          const initial_value = has_key ? existing : default_value;
          const dv = new Data_Value2({
            value: initial_value
          });
          this._[property_name] = dv;
          return dv;
        }
        // Or don't use / support get and set for the moment?
        //   Only use property / field access?
        //   Define property, with getter and setter, seems like a more cleanly defined system.
        // May see about making a new simplified implementation of this and running it through tests.
        //   Though the new Data_Value seems like the more appropriate way for the moment.
        // May look into seeing where Data_Value is used in the current system too.
        //   Could see about further incorportating its use (in places).
        //'set': fp(function(a, sig) {
        "set"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (this._abstract) return false;
          var that2 = this, res2;
          var input_processors = jsgui.input_processors;
          if (a.l === 2 || a.l === 3) {
            var property_name = a[0], value2 = a[1];
            var ta2 = tof(a[2]);
            var silent = false;
            var source;
            if (ta2 == "string" || ta2 == "boolean") {
              silent = a[2];
            }
            if (ta2 == "control") {
              source = a[2];
            }
            if (!this._initializing && this._map_read_only && this._map_read_only[property_name]) {
              throw 'Property "' + property_name + '" is read-only.';
            } else {
              var split_pn = property_name.split(".");
              if (split_pn.length > 1 && property_name != ".") {
                var spn_first = split_pn[0];
                var spn_arr_next = split_pn.slice(1);
                var data_object_next = this.get(spn_first);
                if (data_object_next) {
                  res2 = data_object_next.set(spn_arr_next.join("."), value2);
                  if (!silent) {
                    const bubbled_stored = this.get(property_name);
                    var e_change = {
                      "name": property_name,
                      // Back-compat: bubbled events historically provided the input value.
                      "value": value2,
                      // MVVM-friendly additions:
                      "data_value": bubbled_stored && bubbled_stored.__data_value ? bubbled_stored : void 0,
                      "raw_value": bubbled_stored && bubbled_stored.__data_value ? bubbled_stored.value : bubbled_stored && typeof bubbled_stored.value === "function" ? bubbled_stored.value() : value2,
                      "bubbled": true
                    };
                    if (source) {
                      e_change.source = source;
                    }
                    this.raise_event("change", e_change);
                  }
                } else {
                  throw "No data object at this level.";
                }
              } else {
                var data_object_next = this.get(property_name);
                const had_existing = is_defined(data_object_next) && data_object_next !== null;
                const incoming_is_node = value2 && (value2.__data_object || value2.__data_value || value2.__data_grid);
                const existing_is_data_value = data_object_next && data_object_next.__data_value;
                const existing_is_data_object = data_object_next && data_object_next.__data_object;
                const incoming_t = tof(value2);
                let stored;
                if (existing_is_data_value) {
                  data_object_next.set(value2);
                  stored = data_object_next;
                  res2 = data_object_next;
                } else if (existing_is_data_object && incoming_t === "object" && value2 !== null && !incoming_is_node && incoming_t !== "array") {
                  data_object_next.set(value2);
                  stored = data_object_next;
                  res2 = data_object_next;
                } else {
                  if (incoming_is_node) {
                    stored = value2;
                  } else {
                    if (!had_existing) {
                      stored = this.ensure_data_value(property_name);
                      stored.set(value2);
                    } else {
                      stored = value2;
                    }
                  }
                  this._[property_name] = stored;
                  res2 = stored;
                }
                if (!silent) {
                  var e_change = {
                    "name": property_name,
                    // Back-compat: historically sometimes emitted Data_Value (when creating) and sometimes raw JS value (when updating).
                    "value": !had_existing ? stored : stored && stored.__data_value ? stored.value : stored && typeof stored.value === "function" ? stored.value() : stored,
                    // MVVM-friendly additions:
                    "data_value": stored && stored.__data_value ? stored : void 0,
                    "raw_value": stored && stored.__data_value ? stored.value : stored && typeof stored.value === "function" ? stored.value() : stored
                  };
                  if (source) {
                    e_change.source = source;
                  }
                  this.raise_event("change", e_change);
                }
                return had_existing ? res2 : value2;
              }
            }
          } else {
            var value2 = a[0];
            var property_name = a[1];
            var input_processor = input_processors[this.__type_name];
            if (input_processor) {
              var processed_input = input_processor(value2);
              value2 = processed_input;
              this._[property_name] = value2;
              this.raise_event("change", {
                "value": value2
              });
              return value2;
            } else {
              if (sig === "[D]") {
                this._[property_name] = value2;
                this.raise_event("change", [property_name, value2]);
                return value2;
              } else if (sig === "[o]") {
                res2 = {};
                each(a[0], function(v, i) {
                  res2[i] = that2.set(i, v);
                });
                return res2;
              } else if (sig === "[c]") {
                this._[property_name] = value2;
                this.raise_event("change", [property_name, value2]);
                return value2;
              }
            }
          }
        }
        "has"(property_name) {
          return is_defined(this.get(property_name));
        }
      };
      jsgui.map_classes = jsgui.map_classes || {};
      var dobj = (obj2, data_def) => {
        var cstr = Data_Object;
        var res2;
        if (data_def) {
          res2 = new cstr({
            "data_def": data_def
          });
        } else {
          res2 = new cstr({});
        }
        var tobj = tof(obj2);
        if (tobj == "object") {
          var res_set = res2.set;
          each(obj2, (v, i) => {
            res_set.call(res2, i, v);
          });
        }
        return res2;
      };
      Data_Object.dobj = dobj;
      Data_Object.Mini_Context = Mini_Context;
      module.exports = Data_Object;
    }
  });

  // node_modules/lang-tools/sorted-kvs.js
  var require_sorted_kvs2 = __commonJS({
    "node_modules/lang-tools/sorted-kvs.js"(exports, module) {
      var jsgui = require_lib_lang_mini6();
      var mapify = jsgui.mapify;
      var B_Plus_Tree = require_b_plus_tree2();
      var Sorted_KVS = class {
        constructor(spec) {
          spec = spec || {};
          if (typeof spec.unique_keys !== "undefined") this.unique_keys = spec.unique_keys;
          this.tree = B_Plus_Tree(12);
        }
        "clear"() {
          this.tree.clear();
        }
        /*
        	'put': mapify(function (key, value) {
        		// inserting a bunch of things at once... could that be done more efficiently, such as in one traversal?
        		//  sort the items, then can skip through the tree a bit quicker?
        
        
        		var insert_res = this.tree.insert(key, value);
        		// with tree.insert - nice if we can keep the treenode as a result.
        		//  the tree does not store objects in the node.
        		//   could make the tree node hold a reference to the object?
        
        		//console.log('put insert_res ' + insert_res);
        		//this.dict[key] = value;
        	}),
        	*/
        "out"(key2) {
          this.tree.remove(key2);
        }
        "get"(key2) {
          return this.tree.get_values_by_key(key2);
        }
        "has"(key2) {
          return this.key_count(key2) > 0;
        }
        "get_cursor"() {
        }
        "keys"() {
          return this.tree.keys();
        }
        "keys_and_values"() {
          return this.tree.keys_and_values();
        }
        /*
        	 'values': function() {
        	 var keys = this.keys();
        	 var res = [];
        	 var that = this;
        	 console.log('keys.length ' + keys.length );
        	 console.log('keys ' + jsgui.stringify(keys));
        
        	 each(keys, function(i, v) {
        	 res.push(that.dict[v]);
        	 });
        	 return res;
        	 },
        	 */
        "key_count"(key2) {
          if (typeof key2 !== "undefined") {
            return this.tree.count(key2);
          } else {
            return this.tree.count();
          }
        }
        "get_keys_by_prefix"(prefix) {
          return this.tree.get_keys_by_prefix(prefix);
        }
        "each"(callback2) {
          return this.tree.each(callback2);
        }
        "get_by_prefix"(prefix) {
          return this.tree.get_by_prefix(prefix);
        }
      };
      Sorted_KVS.prototype.put = mapify(function(key2, value2) {
        var insert_res = this.tree.insert(key2, value2);
      });
      module.exports = Sorted_KVS;
    }
  });

  // node_modules/lang-tools/Data_Model/new/Collection.js
  var require_Collection3 = __commonJS({
    "node_modules/lang-tools/Data_Model/new/Collection.js"(exports, module) {
      var lang = require_lib_lang_mini6();
      var Data_Value2 = require_Data_Value2();
      var Data_Object = require_Data_Object2();
      var Sorted_KVS = require_sorted_kvs2();
      var dobj = Data_Object.dobj;
      var Constraint = Data_Object.Constraint;
      var each = lang.each;
      var tof = lang.tof;
      var is_defined = lang.is_defined;
      var stringify = lang.stringify;
      var get_a_sig = lang.get_a_sig;
      var native_constructor_tof = lang.native_constructor_tof;
      var dop = Data_Object.prototype;
      var Collection = class _Collection extends Data_Object {
        constructor(spec = {}, arr_values) {
          super(spec);
          this.__type = "collection";
          this.__type_name = "collection";
          var t_spec = tof(spec);
          if (spec.abstract === true) {
            if (t_spec === "function") {
              this.constraint(spec);
            }
          } else {
            this._relationships = this._relationships || {};
            this._arr_idx = 0;
            this._arr = [];
            this.index = new Sorted_KVS();
            this.fn_index = spec.fn_index;
            if (t_spec === "array") {
              spec = {
                "load_array": spec
              };
            } else {
              if (t_spec === "function") {
                if (spec.abstract === true) {
                  this._abstract = true;
                } else {
                }
              } else if (t_spec === "string") {
                var map_native_constructors = {
                  "array": Array,
                  "boolean": Boolean,
                  "number": Number,
                  "string": String,
                  "object": Object
                };
                var nc = map_native_constructors[spec];
                if (nc) {
                  spec = {
                    "constraint": nc
                  };
                  if (nc == String) {
                    spec.index_by = "value";
                  }
                }
              }
            }
            if (is_defined(spec.items)) {
              spec.load_array = spec.load_array || spec.items;
            }
            if (arr_values) {
              spec.load_array = arr_values;
            }
            if (is_defined(spec.accepts)) {
              this._accepts = spec.accepts;
            }
            if (lang.__data_id_method === "init") {
              if (this.context) {
                this.__id = this.context.new_id(this.__type_name || this.__type);
                this.context.map_objects[this.__id] = this;
              } else {
              }
            }
            if (!this.__type) {
            }
            if (spec.load_array) {
              this.load_array(spec.load_array);
            }
          }
        }
        // maybe use fp, and otherwise apply with the same params and context.
        "set"(value2) {
          var tval = tof(value2);
          if (tval === "data_object" || tval === "data_value" || tval === "data_model") {
            this.clear();
            return this.push(value2);
          } else if (tval === "array") {
            this.clear();
            each(value2, (v, i) => {
              this.push(v);
            });
          } else {
            if (tval === "collection") {
              throw "stop";
              this.clear();
              value2.each(function(v, i) {
                that.push(v);
              });
            } else if (tval === "string" || tval === "number" || tval === "boolean" || tval === "null" || tval === "undefined") {
              this.clear();
              return this.push(value2);
            } else {
              const Data_Object2 = require_Data_Object2();
              return Data_Object2.prototype.set.call(this, value2);
            }
          }
        }
        "clear"() {
          this._arr_idx = 0;
          this._arr = [];
          this.index.clear();
          this.raise("change", {
            "name": "clear"
          });
        }
        "stringify"() {
          var res2 = [];
          if (this._abstract) {
            var ncto = native_constructor_tof(this._type_constructor);
            res2.push("~Collection(");
            if (ncto) {
              res2.push(ncto);
            } else {
            }
            res2.push(")");
          } else {
            res2.push("Collection(");
            var first = true;
            this.each(function(v, i) {
              if (!first) {
                res2.push(", ");
              } else {
                first = false;
              }
              res2.push(stringify(v));
            });
            res2.push(")");
          }
          return res2.join("");
        }
        "toString"() {
          return stringify(this._arr);
        }
        "toObject"() {
          var res2 = [];
          this.each(function(v, i) {
            res2.push(v.toObject());
          });
          return res2;
        }
        "each"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig == "[f]") {
            return each(this._arr, a[0]);
          } else {
            if (sig == "[X,f]") {
              var index = a[0];
              var callback2 = a[1];
              return index.each(callback2);
            } else {
              if (a.l == 2) {
                return each(this._arr, a[0], a[1]);
              }
            }
          }
        }
        "_id"() {
          if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
          } else {
          }
          return this.__id;
        }
        "length"() {
          return this._arr.length;
        }
        get len() {
          return this._arr.length;
        }
        "find"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (a.l == 1) {
            var pos = this.index.get(a[0])[0];
            var item2 = this._arr[pos];
            return item2;
          }
          if (sig == "[o,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[s,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[a,s]") {
            return this.index_system.find(a[0], a[1]);
          }
          if (sig == "[s,o]") {
            var propertyName = a[0];
            var query = a[1];
            var foundItems = [];
            each(this, (item3, index) => {
              if (item3.get) {
                var itemProperty = item3.get(propertyName);
              } else {
                var itemProperty = item3[propertyName];
              }
              var tip = tof(itemProperty);
              var tip2;
              var ip2;
              if (tip === "data_value") {
                var ip2 = itemProperty.value;
                tip2 = tof(ip2);
              } else {
                ip2 = itemProperty;
                tip2 = tip;
              }
              if (tip2 === "array") {
                each(ip2, (v, i) => {
                  var matches = obj_matches_query_obj(v, query);
                  if (matches) {
                    foundItems.push(v);
                  }
                });
              }
              ;
            });
            var res2 = new _Collection(foundItems);
            return res2;
          }
        }
        // get seems like the way to get unique values.
        "get"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig == "[n]" || sig == "[i]") {
            return this._arr[a[0]];
          }
          if (sig == "[s]") {
            var ix_sys = this.index_system;
            var res2;
            if (ix_sys) {
              var pui = ix_sys._primary_unique_index;
              res2 = pui.get(a[0])[0];
            }
            if (res2) {
              return res2;
            }
            return Data_Object.prototype.get.apply(this, a);
          }
        }
        "insert"(item2, pos) {
          this._arr.splice(pos, 0, item2);
          this.raise("change", {
            "name": "insert",
            "item": item2,
            "value": item2,
            "pos": pos
          });
        }
        swap(item2, replacement) {
          let r_parent = replacement.parent;
          let repl_pos = replacement.parent.content.remove(replacement);
          let i_parent = item2.parent;
          let item_pos = item2.parent.content.remove(item2);
          let item_index;
          i_parent.content.insert(replacement, item_pos);
          r_parent.content.insert(item2, repl_pos);
        }
        // may have efficiencies for adding and removing multiple items at once.
        //  can be sorted for insertion into index with more rapid algorithmic time.
        "remove"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig === "[n]") {
            var pos = a[0];
            var item2 = this._arr[pos];
            var spliced_pos = pos;
            this._arr.splice(pos, 1);
            this._arr_idx--;
            var e = {
              "target": this,
              "value": item2,
              "position": spliced_pos,
              "name": "remove"
            };
            this.raise("change", e);
            return pos;
          } else if (sig === "[s]") {
            var key2 = a[0];
            var obj2 = this.index_system.find([
              ["value", key2]
            ]);
            var my_id = this.__id;
            var item_pos_within_this = obj2[0]._relationships[my_id];
            this._arr.splice(item_pos_within_this, 1);
            for (var c2 = item_pos_within_this, l2 = this._arr.length; c2 < l2; c2++) {
              var item2 = this._arr[c2];
              item2._relationships[my_id]--;
            }
            var e = {
              "target": this,
              "value": obj2[0],
              "position": item_pos_within_this,
              "name": "remove"
            };
            this.raise("change", e);
          } else {
            let item_index;
            const item3 = a[0];
            let arr = this._arr, l3 = arr.length;
            if (typeof item3 === "number") {
              item_index = item3;
            } else {
              let found = false, c3 = 0;
              while (!found && c3 < l3) {
                found = arr[c3] === item3;
                if (found) {
                  item_index = c3;
                }
                c3++;
              }
              if (is_defined(item_index)) {
                return this.remove(item_index);
              }
            }
          }
        }
        "has"(obj_key) {
          if (this.get_index(obj_key) === void 0) {
            return false;
          } else {
            return true;
          }
        }
        "get_index"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          if (sig === "[s]") {
            if (this.index_system) {
              return this.index_system.search(a[0]);
            } else {
              if (this._arr.length === 0) {
                return void 0;
              } else {
                for (let c2 = 0; c2 < this._arr.length; c2++) {
                  const item2 = this._arr[c2];
                  if ((item2 == null ? void 0 : item2.name) === a[0]) {
                    return c2;
                  }
                }
                return void 0;
              }
            }
          } else {
            console.trace();
            throw "Expected [s]";
          }
        }
        // More fp way of indexing.
        "index_by"() {
          var a = arguments;
          a.l = arguments.length;
          var sig = get_a_sig(a, 1);
          console.log("Indexing not implemented (like this)");
          console.trace();
        }
        "push"(value2) {
          const { silent } = this;
          let tv = tof(value2);
          let fn_index = this.fn_index;
          let idx_key, has_idx_key = false, pos;
          if (fn_index) {
            idx_key = fn_index(value2);
            has_idx_key = true;
          }
          if (tv === "object" || tv === "function") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "data_value") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "collection") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "data_object" || tv === "control" || tv === "data_model") {
            pos = this._arr.length;
            this._arr.push(value2);
            this._arr_idx++;
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          } else if (tv === "array") {
            const new_coll = new _Collection(value2);
            pos = this._arr.length;
            this._arr.push(new_coll);
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          }
          if (tv === "string" || tv === "number" || tv === "boolean" || tv === "null" || tv === "undefined") {
            const dv = new Data_Value2({
              "value": value2
            });
            pos = this._arr.length;
            this._arr.push(dv);
            if (!silent) {
              const e = {
                "target": this,
                "item": value2,
                "value": value2,
                "position": pos,
                "name": "insert"
              };
              this.raise("change", e);
            }
          }
          if (has_idx_key) {
            this.index.put(idx_key, pos);
          }
          return value2;
        }
        "load_array"(arr) {
          for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
            this.push(arr[c2]);
          }
          this.raise("load");
        }
        "values"() {
          var a = arguments;
          a.l = a.length;
          if (a.l === 0) {
            return this._arr;
          } else {
            var stack = new Error().stack;
            throw "not yet implemented";
          }
        }
        "value"() {
          const res2 = [];
          this.each((v, i) => {
            if (v && typeof v.value !== "undefined") {
              res2.push(v.value);
            } else {
              res2.push(v);
            }
          });
          return res2;
        }
      };
      var p = Collection.prototype;
      p.add = function(value2) {
        return this.push(value2);
      };
      module.exports = Collection;
    }
  });

  // node_modules/lang-tools/doubly-linked-list.js
  var require_doubly_linked_list2 = __commonJS({
    "node_modules/lang-tools/doubly-linked-list.js"(exports, module) {
      var Node = class {
        constructor(spec) {
          this.neighbours = spec.neighbours || [];
          this.value = spec.value;
        }
        "previous"() {
          return this.neighbours[0];
        }
        "next"() {
          return this.neighbours[1];
        }
      };
      var Doubly_Linked_List = class {
        constructor(spec) {
          this.first = null;
          this.last = null;
          this.length = 0;
        }
        "each_node"(callback2) {
          var node = this.first;
          var ctu = true;
          var stop = function() {
            ctu = false;
          };
          while (node && ctu) {
            callback2(node, stop);
            node = node.neighbours[1];
          }
        }
        "each"(callback2) {
          this.each_node(function(node, stop) {
            callback2(node.value, stop);
          });
        }
        "remove"(node) {
          if (node.neighbours[0]) {
            node.neighbours[0].neighbours[1] = node.neighbours[1];
          } else {
            this.first = node.neighbours[1];
          }
          if (node.neighbours[1]) {
            node.neighbours[1].neighbours[0] = node.neighbours[0];
          } else {
            this.last = node.neighbours[0];
          }
          node.neighbours = [];
          if (node.parent == this) {
            delete node.parent;
            this.length--;
          }
        }
        // check to see if the item is a 'node' object.
        //  if it is, can insert it as a node, otherwise create the node object and insert it.
        //   a bit like wrapping values in Data_Value.
        "insert_beginning"(val) {
          if (val instanceof Node) {
            if (this.first == null) {
              this.first = val;
              this.last = val;
              val.neighbours = [];
              if (val.parent != this) {
                val.parent = this;
                this.length++;
              }
            } else {
              this.insert_before(val, this.first);
            }
            return val;
          } else {
            var node = new Node({ "value": val });
            return this.insert_beginning(node);
          }
        }
        // could use a nodify function.
        //  or ensure_data_wrapper
        "insert_before"(val, node) {
          if (val instanceof Node) {
            val.neighbours = [node.neighbours[0], node];
            if (node.neighbours[0] == null) {
              this.first = val;
            } else {
              node.neighbours[0].neighbours[1] = val;
            }
            node.neighbours[0] = val;
            if (val.parent != this) {
              val.parent = this;
              this.length++;
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.insert_before(new_node, node);
          }
        }
        "insert_after"(val, node) {
          if (val instanceof Node) {
            val.neighbours = [node, node.neighbours[1]];
            if (node.neighbours[1] == null) {
              this.last = val;
            } else {
              node.neighbours[1].neighbours[0] = val;
            }
            node.neighbours[1] = val;
            if (val.parent != this) {
              val.parent = this;
              this.length++;
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.insert_after(new_node, node);
          }
        }
        // not wrapping the item in a node?
        // want one where we are not pushing nodes, but items stored in nodes.
        //  Perhaps this is a Data_Value?
        // Or a doubly_linked_node.
        // Doubly_Linked_Node could take the form [prev, item, next]
        //  [prev, item, key, next]? probably not
        //  Maybe we could put more private variables, such as 'neighbours' as a var within the init statement.
        "push"(val) {
          if (val instanceof Node) {
            if (this.last == null) {
              this.insert_beginning(val);
            } else {
              return this.insert_after(val, this.last);
            }
            return val;
          } else {
            var new_node = new Node({ "value": val });
            return this.push(new_node);
          }
        }
      };
      Doubly_Linked_List.Node = Node;
      module.exports = Doubly_Linked_List;
    }
  });

  // node_modules/lang-tools/ordered-kvs.js
  var require_ordered_kvs2 = __commonJS({
    "node_modules/lang-tools/ordered-kvs.js"(exports, module) {
      var Doubly_Linked_List = require_doubly_linked_list2();
      var Ordered_KVS = class {
        constructor() {
          this.dll = new Doubly_Linked_List();
          this.node_map = {};
        }
        "length"() {
          return this.dll.length;
        }
        "put"(key2, value2) {
          return this.push(key2, value2);
        }
        "get"(key2) {
          var kvs_node = this.node_map[key2];
          if (kvs_node) {
            return kvs_node.value;
          } else {
            return void 0;
          }
        }
        "push"(key2, value2) {
          var node = this.dll.push(value2);
          node.key = key2;
          this.node_map[key2] = node;
        }
        "out"(key2) {
          var node = this.node_map[key2];
          delete this.node_map[key2];
          this.dll.remove(node);
        }
        "each"(callback2) {
          this.dll.each_node(function(node, stop) {
            callback2(node.key, node.value, stop);
          });
        }
        "values"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push(value2);
          });
          return res2;
        }
        "keys"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push(key2);
          });
          return res2;
        }
        "keys_and_values"() {
          var res2 = [];
          this.each(function(key2, value2) {
            res2.push([key2, value2]);
          });
          return res2;
        }
        // will not need to deal with nodes on the user level.
        // want to be able to add and remove items, normally items will get pushed to the end of the list.
        // will provide a key and value in order to do this.
      };
      module.exports = Ordered_KVS;
    }
  });

  // node_modules/lang-tools/ordered-string-list.js
  var require_ordered_string_list2 = __commonJS({
    "node_modules/lang-tools/ordered-string-list.js"(exports, module) {
      var Ordered_String_List = class {
        constructor() {
          var arr = [];
          var dict_indexes = {};
          var reindex_dict_indexes = function() {
            dict_indexes = {};
            for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
              dict_indexes[arr[c2]] = c2;
            }
          };
          this.has = function(value2) {
            return typeof dict_indexes[value2] !== "undefined";
          };
          this.put = function(value2) {
            if (this.has(value2)) {
            } else {
              var index = arr.length;
              arr.push(value2);
              dict_indexes[value2] = index;
            }
          };
          this.out = function(value2) {
            if (this.has(value2)) {
              var idx = dict_indexes[value2];
              arr.splice(idx, 1);
              delete dict_indexes[value2];
              for (var c2 = idx, l2 = arr.length; c2 < l2; c2++) {
                var i = arr[c2];
                dict_indexes[i]--;
              }
            }
          };
          this.toggle = function(value2) {
            if (this.has(value2)) {
              this.out(value2);
            } else {
              this.put(value2);
            }
          };
          this.move_value = function(value2, index) {
            if (this.has(value2) && dict_indexes[value2] != index) {
              var old_index = dict_indexes[value2];
              arr.splice(old_index, 1);
              arr.splice(index, 0, value2);
              if (index < old_index) {
                dict_indexes[arr[index]] = index;
                for (var c2 = index + 1; c2 <= old_index; c2++) {
                  dict_indexes[arr[c2]]++;
                }
              } else if (index > old_index) {
                dict_indexes[arr[index]] = index;
                for (var c2 = old_index; c2 < index; c2++) {
                  dict_indexes[arr[c2]]--;
                }
              }
            }
          };
          this._index_scan = function() {
            for (var c2 = 0, l2 = arr.length; c2 < l2; c2++) {
              console.log("c " + c2 + " arr[c] " + arr[c2] + " idx " + dict_indexes[arr[c2]]);
            }
            ;
          };
          this.toString = function() {
            var res2 = arr.join(" ");
            return res2;
          };
          this.toString.stringify = true;
          this.set = (function(val) {
            if (typeof val === "string") {
              arr = val.split(" ");
              reindex_dict_indexes();
            }
          });
          var a = arguments;
          if (a.length == 1) {
            var spec = a[0];
            if (typeof spec === "string") {
              this.set(spec);
            }
          }
        }
      };
      module.exports = Ordered_String_List;
    }
  });

  // node_modules/lang-tools/Data_Model/Collection.js
  var require_Collection4 = __commonJS({
    "node_modules/lang-tools/Data_Model/Collection.js"(exports, module) {
      module.exports = require_Collection3();
    }
  });

  // node_modules/lang-tools/util.js
  var require_util2 = __commonJS({
    "node_modules/lang-tools/util.js"(exports, module) {
      var jsgui = require_lib_lang_mini6();
      var Collection = require_Collection4();
      var j = jsgui;
      var each = j.each;
      var tof = j.tof;
      var atof = j.atof;
      var is_defined = j.is_defined;
      var fp = j.fp;
      var arrayify = j.arrayify;
      var mapify = j.mapify;
      var get_item_sig = j.get_item_sig;
      var vectorify = function(n_fn) {
        var fn_res = fp(function(a, sig) {
          if (a.l > 2) {
            var res2 = a[0];
            for (var c2 = 1, l2 = a.l; c2 < l2; c2++) {
              res2 = fn_res(res2, a[c2]);
            }
            return res2;
          } else {
            if (sig == "[n,n]") {
              return n_fn(a[0], a[1]);
            } else {
              var ats = atof(a);
              if (ats[0] == "array") {
                if (ats[1] == "number") {
                  var res2 = [], n = a[1];
                  each(a[0], function(v, i) {
                    res2.push(fn_res(v, n));
                  });
                  return res2;
                }
                if (ats[1] == "array") {
                  if (ats[0].length != ats[1].length) {
                    throw "vector array lengths mismatch";
                  } else {
                    var res2 = [], arr2 = a[1];
                    each(a[0], function(v, i) {
                      res2.push(fn_res(v, arr2[i]));
                    });
                    return res2;
                  }
                }
              }
            }
          }
        });
        return fn_res;
      };
      var n_add = function(n1, n2) {
        return n1 + n2;
      };
      var n_subtract = function(n1, n2) {
        return n1 - n2;
      };
      var n_multiply = function(n1, n2) {
        return n1 * n2;
      };
      var n_divide = function(n1, n2) {
        return n1 / n2;
      };
      var v_add = vectorify(n_add);
      var v_subtract2 = vectorify(n_subtract);
      var v_multiply = vectorify(n_multiply);
      var v_divide = vectorify(n_divide);
      var vector_magnitude = function(vector) {
        var res2 = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        return res2;
      };
      var distance_between_points = function(points) {
        var offset2 = v_subtract2(points[1], points[0]);
        return vector_magnitude(offset2);
      };
      var execute_on_each_simple = function(items, fn) {
        var res2 = [], that2 = this;
        each(items, function(i, v) {
          res2.push(fn.call(that2, i));
        });
        return res2;
      };
      var filter_map_by_regex = function(map, regex) {
        var res2 = {};
        each(map, function(v, i) {
          if (i.match(regex)) {
            res2[i] = v;
          }
        });
        return res2;
      };
      var npx = arrayify(function(value2) {
        var res2, a = arguments, t = tof(a[0]);
        if (t === "string") {
          res2 = a[0];
        } else if (t === "number") {
          res2 = a[0] + "px";
        }
        return res2;
      });
      var no_px = arrayify(fp(function(a, sig) {
        var re = /px$/, res2;
        if (sig == "[s]" && re.test(a[0])) {
          res2 = parseInt(a[0]);
        } else {
          res2 = a[0];
        }
        ;
        return res2;
      }));
      var arr_ltrb = ["left", "top", "right", "bottom"];
      var str_arr_mapify = function(fn) {
        var res2 = fp(function(a, sig) {
          if (a.l == 1) {
            if (sig == "[s]") {
              var s_pn = a[0].split(" ");
              if (s_pn.length > 1) {
                return res2.call(this, s_pn);
              } else {
                return fn.call(this, a[0]);
              }
            }
            if (tof(a[0]) == "array") {
              var res22 = {}, that2 = this;
              each(a[0], function(i, v) {
                res22[v] = fn.call(that2, v);
              });
              return res22;
            }
          }
        });
        return res2;
      };
      var arr_hex_chars = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F"
      ];
      var dict_hex_to_bin = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15
      };
      var str_hex_to_int = function(str_hex) {
        str_hex = str_hex.toUpperCase();
        var i = str_hex.length;
        var res2 = 0, exp = 1;
        while (i--) {
          var i_part = dict_hex_to_bin[str_hex.charAt(i)];
          var ip2 = i_part * exp;
          res2 = res2 + ip2;
          exp = exp * 16;
        }
        ;
        return res2;
      };
      var byte_int_to_str_hex_2 = function(byte_int) {
        var a = Math.floor(byte_int / 16), b = byte_int % 16, sa = arr_hex_chars[a], sb = arr_hex_chars[b], res2 = sa + sb;
        return res2;
      };
      var arr_rgb_to_str_hex_6 = function(arr_rgb) {
        var r = byte_int_to_str_hex_2(arr_rgb[0]);
        var res2 = r + byte_int_to_str_hex_2(arr_rgb[1]) + byte_int_to_str_hex_2(arr_rgb[2]);
        return res2;
      };
      var arr_rgb_to_css_hex_6 = function(arr_rgb) {
        return "#" + arr_rgb_to_str_hex_6(arr_rgb);
      };
      var input_processors = {};
      var validators = {
        "number": function(value2) {
          return tof(value2) == "number";
        }
      };
      var extend = jsgui.extend;
      var fp = jsgui.fp;
      var stringify = jsgui.stringify;
      var tof = jsgui.tof;
      var data_types_info = {
        "color": ["indexed_array", [
          ["red", "number"],
          ["green", "number"],
          ["blue", "number"]
        ]],
        "oltrb": ["optional_array", ["left", "top", "right", "bottom"]]
      };
      jsgui.data_types_info = data_types_info;
      var color_preprocessor_parser = fp(function(a, sig) {
        if (sig == "[s]") {
          var input = a[0];
          var rx_hex = /(#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2}))/;
          var m = input.match(rx_hex);
          if (m) {
            var r = jsgui.str_hex_to_int(m[2]);
            var g = jsgui.str_hex_to_int(m[3]);
            var b = jsgui.str_hex_to_int(m[4]);
            var res2 = [r, g, b];
            return res2;
          }
        }
      });
      input_processors["optional_array"] = fp(function(a, sig) {
        if (a.l == 2) {
          var oa_params = a[0], input = a[1];
          if (tof(input) == "array") {
            if (input.length <= oa_params.length) {
              return input;
            }
          } else {
            return input;
          }
        }
        if (a.l == 3) {
          var oa_params = a[0], items_data_type_name = a[1], input = a[2];
          var input_processor_for_items = jsgui.input_processors[items_data_type_name];
          if (tof(input) == "array") {
            if (input.length <= oa_params.length) {
              var res2 = [];
              each(input, function(i, v) {
                res2.push(input_processor_for_items(v));
              });
              return res2;
            }
          } else {
            return input_processor_for_items(input);
          }
        }
      });
      input_processors["indexed_array"] = fp(function(a, sig) {
        console.log("indexed_array sig", sig);
        if (a.l == 2) {
          var ia_params = a[0], input = a[1];
          if (tof(input) == "array") {
            if (input.length <= ia_params.length) {
              return input;
            }
          }
        }
        if (a.l == 3) {
          var ia_params = a[0], items_data_type_name = a[1], input = a[2];
          var input_processor_for_items = jsgui.input_processors[items_data_type_name];
          if (tof(input) == "array") {
            if (input.length <= ia_params.length) {
              var res2 = [];
              each(input, function(i, v) {
                res2.push(input_processor_for_items(v));
              });
              return res2;
            }
          }
        }
      });
      input_processors["n_units"] = function(str_units, input) {
        if (tof(input) == "number") {
          return [input, str_units];
        }
        if (tof(input) == "string") {
          var rx_n_units = /^(\d+)(\w+)$/;
          var match = input.match(rx_n_units);
          if (match) {
            return [parseInt(match[1]), match[2]];
          }
          rx_n_units = /^(\d*\.\d+)(\w+)$/;
          match = input.match(rx_n_units);
          if (match) {
            return [parseFloat(match[1]), match[2]];
          }
        }
      };
      var dti_color = jsgui.data_types_info["color"];
      input_processors["color"] = function(input) {
        var res2;
        console.log("processing color input: " + stringify(input));
        var input_sig = get_item_sig(input, 2);
        if (input_sig == "[s]") {
          res2 = color_preprocessor_parser(input[0]);
        }
        if (input_sig == "[n,n,n]") {
          res2 = input;
        }
        console.log("res " + stringify(res2));
        console.log("color input_processors output", res2);
        return res2;
      };
      jsgui.output_processors["color"] = function(jsgui_color) {
        var res2 = jsgui.arr_rgb_to_css_hex_6(jsgui_color);
        return res2;
      };
      var group = function() {
        var a = arguments;
        if (a.length == 1 && tof(a[0]) == "array") {
          return group.apply(this, a[0]);
        }
        var res2;
        for (var c2 = 0, l2 = a.length; c2 < l2; c2++) {
          var item2 = a[c2];
          if (c2 == 0) {
            res2 = new Collection({ "context": item2.context });
          }
          res2.push(item2);
        }
        var C = a[0].constructor;
        var p = C.prototype;
        var i;
        for (i in p) {
          var tpi = tof(p[i]);
          if (tpi == "function") {
            (function(i2) {
              if (i2 != "each" && i2 != "get" && i2 != "add_event_listener") {
                res2[i2] = function() {
                  var a2 = arguments;
                  res2.each(function(v, i22) {
                    v[i2].apply(v, a2);
                  });
                };
              }
            })(i);
          }
        }
        return res2;
      };
      var true_vals = function(map) {
        var res2 = [];
        for (var i in map) {
          if (map[i]) res2.push(map[i]);
        }
        return res2;
      };
      var Ui16toUi32 = (ui16) => {
        let res2 = new Uint32Array(ui16.length / 2);
        let dv = new DataView(ui16.buffer);
        let l2 = ui16.length;
        let hl = l2 / 2;
        let resw = 0;
        for (let c2 = 0; c2 < hl; c2++) {
          res2[resw++] = dv.getUint32(c2 * 4);
        }
        return res2;
      };
      var Ui32toUi16 = (ui32) => {
        let res2 = new Uint16Array(ui32.length * 2);
        let dv = new DataView(ui32.buffer);
        let l2 = ui32.length;
        let resw = 0;
        for (let c2 = 0; c2 < l2; c2++) {
          res2[resw++] = dv.getUint16(c2 * 4 + 2);
          res2[resw++] = dv.getUint16(c2 * 4);
        }
        console.log("res", res2);
        return res2;
      };
      var util = {
        "Ui16toUi32": Ui16toUi32,
        "Ui32toUi16": Ui32toUi16,
        "vectorify": vectorify,
        "v_add": v_add,
        "v_subtract": v_subtract2,
        "v_multiply": v_multiply,
        "v_divide": v_divide,
        "vector_magnitude": vector_magnitude,
        "distance_between_points": distance_between_points,
        "execute_on_each_simple": execute_on_each_simple,
        "mapify": mapify,
        "filter_map_by_regex": filter_map_by_regex,
        "atof": atof,
        "npx": npx,
        "no_px": no_px,
        "str_arr_mapify": str_arr_mapify,
        "arr_ltrb": arr_ltrb,
        "true_vals": true_vals,
        "validators": validators,
        "__data_id_method": "lazy",
        "str_hex_to_int": str_hex_to_int,
        "arr_rgb_to_css_hex_6": arr_rgb_to_css_hex_6,
        "group": group
      };
      module.exports = util;
    }
  });

  // node_modules/lang-tools/lang.js
  var require_lang2 = __commonJS({
    "node_modules/lang-tools/lang.js"(exports, module) {
      var lang_mini = require_lib_lang_mini6();
      var collective = require_collective2();
      var { more_general_equals } = require_tools2();
      lang_mini.equals = more_general_equals;
      lang_mini.collective = collective;
      lang_mini.collect = collective;
      var Evented_Class = lang_mini.Evented_Class;
      var B_Plus_Tree = require_b_plus_tree2();
      var Collection = require_Collection3();
      var Data_Object = require_Data_Object2();
      var Data_Value2 = require_Data_Value2();
      var Data_Model = require_Data_Model2();
      var Immutable_Data_Value = require_Immutable_Data_Value2();
      var Immutable_Data_Model = require_Immutable_Data_Model2();
      var Doubly_Linked_List = require_doubly_linked_list2();
      var Ordered_KVS = require_ordered_kvs2();
      var Ordered_String_List = require_ordered_string_list2();
      var Sorted_KVS = require_sorted_kvs2();
      var util = require_util2();
      lang_mini.util = util;
      lang_mini.B_Plus_Tree = B_Plus_Tree;
      lang_mini.Collection = Collection;
      lang_mini.Data_Object = Data_Object;
      lang_mini.Data_Value = Data_Value2;
      lang_mini.Immutable_Data_Model = Immutable_Data_Model;
      lang_mini.Immutable_Data_Value = Immutable_Data_Value;
      lang_mini.Data_Model = Data_Model;
      lang_mini.Doubly_Linked_List = Doubly_Linked_List;
      lang_mini.Ordered_KVS = Ordered_KVS;
      lang_mini.Ordered_String_List = Ordered_String_List;
      lang_mini.Sorted_KVS = Sorted_KVS;
      var ec = new Evented_Class();
      Object.assign(ec, lang_mini);
      module.exports = ec;
    }
  });

  // src/ui/jsgui/bindingPlugin.js
  var require_bindingPlugin = __commonJS({
    "src/ui/jsgui/bindingPlugin.js"(exports, module) {
      "use strict";
      var langTools = require_lang2();
      var INSTALL_FLAG = /* @__PURE__ */ Symbol.for("copilot.bindingPlugin.installed");
      var WATCHERS_KEY = /* @__PURE__ */ Symbol("copilot.bindingPlugin.watchers");
      var CLASS_PREFIX_STATE_KEY = /* @__PURE__ */ Symbol("copilot.bindingPlugin.classPrefix");
      function installBindingPlugin2(jsguiInstance = require_html()) {
        const jsgui = jsguiInstance;
        if (!jsgui || !jsgui.Control) {
          throw new Error("bindingPlugin requires a jsgui3-html instance with Control available");
        }
        if (jsgui[INSTALL_FLAG]) {
          return jsgui.bindingToolkit;
        }
        const Control2 = jsgui.Control;
        const ControlData = jsgui.Control_Data;
        const DataObjectCtor = langTools.Data_Object || jsgui.Data_Object;
        if (!DataObjectCtor) {
          throw new Error("bindingPlugin could not find Data_Object constructor");
        }
        function ensureDomAttributes(control) {
          control.dom = control.dom || {};
          control.dom.attributes = control.dom.attributes || {};
          return control.dom.attributes;
        }
        function normalizeBindingValue(value2) {
          if (value2 == null) return value2;
          if (Array.isArray(value2)) return value2.map((item2) => normalizeBindingValue(item2));
          if (value2 && typeof value2 === "object") {
            if (value2.__data_value && typeof value2.value === "function") {
              return normalizeBindingValue(value2.value());
            }
            if (value2.__data_value && typeof value2.get === "function") {
              return normalizeBindingValue(value2.get());
            }
          }
          return value2;
        }
        function modelNeedsUpgrade(model) {
          return !(model && typeof model === "object" && model.__data_object);
        }
        function ensureDataModel(control, defaults = {}) {
          control.data = control.data || new ControlData({ context: control.context });
          let model;
          try {
            model = control.data.model;
          } catch (err) {
            model = control.data && control.data._model;
          }
          if (modelNeedsUpgrade(model)) {
            model = new DataObjectCtor({ context: control.context });
            control.data.model = model;
            const attrs = ensureDomAttributes(control);
            if (typeof model._id === "function") {
              attrs["data-jsgui-data-model"] = model._id();
            }
          }
          if (model && typeof model.set === "function") {
            Object.entries(defaults || {}).forEach(([key2, value2]) => {
              const existing = typeof model.get === "function" ? model.get(key2) : model[key2];
              if (typeof existing === "undefined") {
                model.set(key2, value2);
              }
            });
          }
          return model;
        }
        function ensureViewModel(control, defaults = {}) {
          control.view = control.view || {};
          if (!control.view.data) {
            control.view.data = new ControlData({ context: control.context });
          }
          const holder = control.view.data;
          let viewModel;
          try {
            viewModel = holder.model;
          } catch (err) {
            viewModel = holder && holder._model;
          }
          if (modelNeedsUpgrade(viewModel)) {
            viewModel = new DataObjectCtor({ context: control.context });
            holder.model = viewModel;
            const attrs = ensureDomAttributes(control);
            if (typeof viewModel._id === "function") {
              attrs["data-jsgui-view-data-model"] = viewModel._id();
            }
          }
          if (viewModel && typeof viewModel.set === "function") {
            Object.entries(defaults || {}).forEach(([key2, value2]) => {
              const existing = typeof viewModel.get === "function" ? viewModel.get(key2) : viewModel[key2];
              if (typeof existing === "undefined") {
                viewModel.set(key2, value2);
              }
            });
          }
          return viewModel;
        }
        function trackWatcher(control, model, handler) {
          if (!model || typeof model.on !== "function") return;
          const bucket = control[WATCHERS_KEY] || [];
          bucket.push({ model, handler });
          control[WATCHERS_KEY] = bucket;
        }
        function cleanupWatchers(control) {
          const bucket = control[WATCHERS_KEY];
          if (!Array.isArray(bucket) || !bucket.length) return;
          bucket.forEach(({ model, handler }) => {
            if (model && typeof model.off === "function") {
              model.off("change", handler);
            }
          });
          control[WATCHERS_KEY] = [];
        }
        function toBoolean(value2) {
          const normalized = normalizeBindingValue(value2);
          if (typeof normalized === "string") {
            const trimmed = normalized.trim().toLowerCase();
            if (!trimmed || trimmed === "false" || trimmed === "0" || trimmed === "no") return false;
          }
          return Boolean(normalized);
        }
        function applyToggleClass(control, classes, isActive) {
          const list = Array.isArray(classes) ? classes : String(classes).split(/\s+/).map((token) => token.trim()).filter(Boolean);
          list.forEach((cls) => {
            if (!cls) return;
            if (isActive) control.add_class(cls);
            else control.remove_class(cls);
          });
        }
        function applyClassPrefix(control, prefix, value2) {
          if (!prefix) return;
          const state = control[CLASS_PREFIX_STATE_KEY] || {};
          if (state[prefix]) {
            control.remove_class(state[prefix]);
          }
          if (value2 == null || value2 === "") {
            state[prefix] = void 0;
            control[CLASS_PREFIX_STATE_KEY] = state;
            return;
          }
          const cls = `${prefix}${value2}`;
          control.add_class(cls);
          state[prefix] = cls;
          control[CLASS_PREFIX_STATE_KEY] = state;
        }
        function setAttribute(control, attrName, value2, action = {}) {
          const attrs = ensureDomAttributes(control);
          const normalized = normalizeBindingValue(value2);
          const isBoolean = action.boolean === true;
          if (isBoolean) {
            const boolVal = toBoolean(normalized);
            if (!boolVal && action.falseValue == null && action.keepFalse !== true) {
              delete attrs[attrName];
              return;
            }
            attrs[attrName] = boolVal ? action.trueValue || "true" : action.falseValue || "false";
            return;
          }
          if (normalized == null || normalized === false && action.keepFalse !== true) {
            delete attrs[attrName];
            return;
          }
          attrs[attrName] = String(normalized);
        }
        function applyAction(control, propName, rawValue, action = {}) {
          if (!action) return;
          const baseValue = normalizeBindingValue(rawValue);
          const transformed = typeof action.transform === "function" ? action.transform(baseValue, control, propName) : baseValue;
          if (typeof action.when === "function" && !action.when(transformed, control, propName)) {
            return;
          }
          if (action.attr) {
            setAttribute(control, action.attr, transformed, action);
          }
          if (action.booleanAttr) {
            setAttribute(control, action.booleanAttr, transformed, { ...action, boolean: true });
          }
          if (action.toggleClass) {
            const flag = action.negate ? !toBoolean(transformed) : toBoolean(transformed);
            applyToggleClass(control, action.toggleClass, flag);
          }
          if (action.classPrefix) {
            applyClassPrefix(control, action.classPrefix, transformed);
          }
          if (typeof action.onChange === "function") {
            action.onChange(transformed, control, propName, action);
          }
        }
        function bindDataToView(control, bindings = {}, options) {
          if (!bindings || typeof bindings !== "object") return null;
          ensureDataModel(control, options && options.dataDefaults);
          ensureViewModel(control, options && options.viewDefaults);
          const normalized = {};
          Object.entries(bindings).forEach(([source, target]) => {
            if (!target) return;
            if (typeof target === "string") {
              normalized[source] = target;
            } else if (typeof target === "object") {
              normalized[source] = target;
            }
          });
          if (!Object.keys(normalized).length) return null;
          if (typeof control.bind !== "function") {
            throw new Error("Control does not support bind(); ensure it extends Data_Model_View_Model_Control");
          }
          return control.bind(normalized, options && options.bindingOptions);
        }
        Control2.prototype.ensureBindingDataModel = function ensureBindingDataModel(defaults) {
          return ensureDataModel(this, defaults);
        };
        Control2.prototype.ensureBindingViewModel = function ensureBindingViewModel(defaults) {
          return ensureViewModel(this, defaults);
        };
        Control2.prototype.bindDataToView = function bindDataToViewWrapper(bindings, options) {
          return bindDataToView(this, bindings, options);
        };
        Control2.prototype.bindViewToAttributes = function bindViewToAttributes(attributeMap = {}, options = {}) {
          const viewModel = ensureViewModel(this, options.viewDefaults);
          if (!viewModel || typeof viewModel.on !== "function") return;
          Object.entries(attributeMap).forEach(([propName, config]) => {
            if (!config) return;
            const actions = Array.isArray(config) ? config : [config];
            const validActions = actions.filter(Boolean);
            if (!validActions.length) return;
            const applyAll = (value2) => {
              validActions.forEach((action) => applyAction(this, propName, value2, action));
            };
            const initialValue = typeof viewModel.get === "function" ? viewModel.get(propName) : viewModel[propName];
            applyAll(initialValue);
            const handler = (evt) => {
              if (!evt || evt.name !== propName) return;
              applyAll(evt.value);
            };
            viewModel.on("change", handler);
            trackWatcher(this, viewModel, handler);
          });
        };
        Control2.prototype.applyBindingDefaults = function applyBindingDefaults(config = {}) {
          if (config.dataToView) {
            this.bindDataToView(config.dataToView, { viewDefaults: config.viewDefaults, dataDefaults: config.dataDefaults });
          }
          if (config.viewAttributeBindings) {
            this.bindViewToAttributes(config.viewAttributeBindings, { viewDefaults: config.viewDefaults });
          }
        };
        const originalDestroy = Control2.prototype.destroy;
        Control2.prototype.destroy = function bindingPluginDestroy(...args) {
          cleanupWatchers(this);
          if (typeof originalDestroy === "function") {
            return originalDestroy.apply(this, args);
          }
          return void 0;
        };
        jsgui.bindingToolkit = {
          normalizeValue: normalizeBindingValue,
          ensureViewModel: (control, defaults) => ensureViewModel(control, defaults),
          ensureDataModel: (control, defaults) => ensureDataModel(control, defaults)
        };
        jsgui[INSTALL_FLAG] = true;
        return jsgui.bindingToolkit;
      }
      module.exports = {
        installBindingPlugin: installBindingPlugin2
      };
    }
  });

  // src/ui/controls/Table.js
  var require_Table = __commonJS({
    "src/ui/controls/Table.js"(exports, module) {
      "use strict";
      var jsgui = require_html();
      var StringControl = jsgui.String_Control;
      function toArray(value2) {
        if (!value2) return [];
        if (Array.isArray(value2)) return value2.filter(Boolean);
        if (typeof value2 === "string") {
          return value2.split(/\s+/).map((token) => token.trim()).filter(Boolean);
        }
        return [value2].filter(Boolean);
      }
      function appendText(control, text) {
        if (text == null) return;
        const normalized = String(text);
        control.add(new StringControl({ context: control.context, text: normalized }));
      }
      var TableCellControl = class extends jsgui.Control {
        constructor(spec = {}) {
          const { header = false, align = null } = spec;
          const {
            content: initialContent,
            control: initialControl,
            text: initialText,
            html: initialHtml,
            ...rest
          } = spec;
          const resolvedTagName = header ? "th" : "td";
          super({ ...rest, tagName: resolvedTagName });
          this._tagName = resolvedTagName;
          this.add_class("ui-table__cell");
          if (header) {
            this.add_class("ui-table__cell--header");
          }
          if (align) {
            this.add_class(`ui-table__cell--${align}`);
          }
          toArray(spec.classNames).forEach((cls) => this.add_class(cls));
          if (spec.title) {
            this.dom.attributes.title = spec.title;
          }
          if (!spec.el) {
            if (initialControl && initialControl instanceof jsgui.Control) {
              this.add(initialControl);
            } else if (initialContent instanceof jsgui.Control) {
              this.add(initialContent);
            } else if (Array.isArray(initialContent)) {
              initialContent.forEach((child) => {
                if (child instanceof jsgui.Control) {
                  this.add(child);
                } else if (child != null) {
                  appendText(this, child);
                }
              });
            } else if (initialHtml != null) {
              this._rawHtml = initialHtml;
            } else if (initialText != null) {
              appendText(this, initialText);
            }
          }
        }
        all_html_render() {
          if (this._rawHtml) {
            const base = super.all_html_render();
            const tagName = this.dom && this.dom.tagName || this._tagName || "td";
            const closeTag = `</${tagName}>`;
            const idx = base.lastIndexOf(closeTag);
            if (idx !== -1) {
              return base.slice(0, idx) + this._rawHtml + closeTag;
            }
          }
          return super.all_html_render();
        }
      };
      var TableRowControl = class extends jsgui.Control {
        constructor(spec = {}) {
          super({ ...spec, tagName: "tr" });
          this.add_class("ui-table__row");
          toArray(spec.classNames).forEach((cls) => this.add_class(cls));
          if (typeof spec.rowIndex === "number") {
            this.dom.attributes["data-row-index"] = String(spec.rowIndex);
          }
        }
      };
      var TableControl = class extends jsgui.Control {
        constructor(spec = {}) {
          const { columns = [], rows = [] } = spec;
          super({ ...spec, tagName: "table" });
          this.add_class("ui-table");
          this.columns = Array.isArray(columns) ? columns : [];
          this._rows = [];
          if (!spec.el) {
            this.compose();
            if (rows.length) {
              this.setRows(rows);
            }
          }
        }
        compose() {
          const context2 = this.context;
          this.thead = new jsgui.Control({ context: context2, tagName: "thead" });
          this.tbody = new jsgui.Control({ context: context2, tagName: "tbody" });
          this.add(this.thead);
          this.add(this.tbody);
          this._buildHeader();
        }
        _buildHeader() {
          const headerRow = new TableRowControl({ context: this.context, classNames: "ui-table__row--header" });
          this.columns.forEach((column) => {
            headerRow.add(
              new TableCellControl({
                context: this.context,
                header: true,
                text: column.label || column.key || "",
                align: column.align,
                classNames: column.headerClass
              })
            );
          });
          this.thead.add(headerRow);
        }
        setRows(rows = []) {
          this._rows = Array.isArray(rows) ? rows : [];
          this._clearBody();
          this._rows.forEach((rowData, index) => {
            const row = new TableRowControl({
              context: this.context,
              rowIndex: index,
              classNames: index % 2 === 1 ? "ui-table__row--striped" : null
            });
            this.columns.forEach((column) => {
              const rawValue = rowData[column.key];
              const cellSpec = this._normalizeCellSpec(rawValue, column, rowData, index);
              row.add(new TableCellControl({ context: this.context, ...cellSpec }));
            });
            this.tbody.add(row);
          });
        }
        _normalizeCellSpec(value2, column, rowData, rowIndex) {
          const columnClasses = toArray(column.cellClass);
          if (value2 && typeof value2 === "object" && value2.href) {
            return {
              classNames: columnClasses.concat(toArray(value2.classNames || value2.className)),
              content: this._createLinkControl({
                text: value2.text,
                href: value2.href,
                title: value2.title || rowData && rowData.title || void 0,
                target: value2.target
              }),
              align: value2.align || column.align
            };
          }
          if (value2 && value2.control instanceof jsgui.Control) {
            return {
              ...value2,
              classNames: columnClasses.concat(toArray(value2.classNames || value2.className))
            };
          }
          if (value2 && typeof value2 === "object" && !Array.isArray(value2)) {
            const { text, html, title, classNames, className, align, content } = value2;
            return {
              text: html ? void 0 : text != null ? text : "",
              html,
              title,
              classNames: columnClasses.concat(toArray(classNames || className)),
              align: align || column.align,
              content
            };
          }
          return {
            text: value2 == null ? "" : String(value2),
            align: column.align,
            classNames: columnClasses
          };
        }
        _clearBody() {
          if (this.tbody && this.tbody.content) {
            this.tbody.content.clear();
          }
        }
        _createLinkControl({ text, href, title, target }) {
          const anchor = new jsgui.Control({ context: this.context, tagName: "a" });
          anchor.add_class("table-link");
          if (href) {
            anchor.dom.attributes.href = href;
          }
          if (title) {
            anchor.dom.attributes.title = title;
          }
          if (target) {
            anchor.dom.attributes.target = target;
            if (target === "_blank") {
              anchor.dom.attributes.rel = "noopener noreferrer";
            }
          }
          const linkText = text != null ? text : href || "";
          anchor.add(new StringControl({ context: this.context, text: linkText }));
          return anchor;
        }
      };
      module.exports = {
        TableControl,
        TableRowControl,
        TableCellControl
      };
    }
  });

  // src/ui/controls/controlRegistry.js
  var require_controlRegistry = __commonJS({
    "src/ui/controls/controlRegistry.js"(exports, module) {
      "use strict";
      var jsgui = require_html();
      function registerControlType(typeName, ControlClass, { jsguiInstance = jsgui } = {}) {
        if (!typeName || !ControlClass || !jsguiInstance) {
          return ControlClass;
        }
        const normalized = String(typeName).trim();
        if (!normalized) {
          return ControlClass;
        }
        const key2 = normalized.toLowerCase();
        const proto = ControlClass.prototype || ControlClass.__proto__;
        if (proto && !proto.__type_name) {
          proto.__type_name = key2;
        }
        jsguiInstance.controls = jsguiInstance.controls || {};
        jsguiInstance.controls[key2] = ControlClass;
        if (!jsguiInstance.map_Controls) {
          jsguiInstance.map_Controls = {};
        }
        jsguiInstance.map_Controls[key2] = ControlClass;
        if (!jsguiInstance[key2]) {
          jsguiInstance[key2] = ControlClass;
        }
        return ControlClass;
      }
      module.exports = {
        registerControlType
      };
    }
  });

  // src/ui/controls/UrlListingTable.js
  var require_UrlListingTable = __commonJS({
    "src/ui/controls/UrlListingTable.js"(exports, module) {
      "use strict";
      var { TableControl } = require_Table();
      var { registerControlType } = require_controlRegistry();
      var URL_LISTING_COLUMNS = Object.freeze([
        { key: "index", label: "#", align: "right", cellClass: "is-index" },
        { key: "urlId", label: "ID", align: "right", cellClass: "is-id" },
        { key: "url", label: "URL", cellClass: "is-url" },
        { key: "host", label: "Host", cellClass: "is-host" },
        { key: "createdAt", label: "Created", cellClass: "is-timestamp" },
        { key: "lastSeenAt", label: "Last Seen", cellClass: "is-timestamp" },
        { key: "lastFetchAt", label: "Last Fetch", cellClass: "is-timestamp" },
        { key: "status", label: "HTTP", align: "center" }
      ]);
      function cloneColumn(column) {
        return { ...column };
      }
      function buildColumns() {
        return URL_LISTING_COLUMNS.map(cloneColumn);
      }
      function formatCount(value2) {
        const numeric = Number(value2);
        if (!Number.isFinite(numeric) || numeric < 0) return "0";
        return numeric.toLocaleString("en-US");
      }
      function formatDateTime(value2, includeSeconds = false) {
        if (!value2) return "\u2014";
        const date = new Date(value2);
        if (Number.isNaN(date.getTime())) return "\u2014";
        const pad = (n) => String(n).padStart(2, "0");
        const month = pad(date.getUTCMonth() + 1);
        const day = pad(date.getUTCDate());
        const year = String(date.getUTCFullYear()).slice(2);
        const time = `${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}${includeSeconds ? `:${pad(date.getUTCSeconds())}` : ""}`;
        return {
          html: `<span class="timestamp-date">${month}-${day}-${year}</span><span class="timestamp-time">${time}</span>`,
          text: `${date.getUTCFullYear()}-${month}-${day} ${time} UTC`,
          classNames: "is-timestamp"
        };
      }
      function formatStatus(code) {
        if (code == null) return { text: "\u2014", classNames: "badge badge--muted" };
        let variant = "info";
        if (code >= 200 && code < 300) variant = "success";
        else if (code >= 300 && code < 400) variant = "accent";
        else if (code >= 400 && code < 500) variant = "warn";
        else if (code >= 500) variant = "danger";
        return { text: String(code), classNames: `badge badge--${variant}` };
      }
      function buildIndexCell(position, startIndex = 1) {
        const base = Number.isFinite(startIndex) ? Math.max(1, Math.trunc(startIndex)) : 1;
        const offset2 = Number.isFinite(position) ? Math.trunc(position) : 0;
        return { text: String(base + offset2), classNames: "is-index" };
      }
      function buildDisplayRows(rows, options = {}) {
        const baseIndex = Number.isFinite(options.startIndex) ? Math.max(1, Math.trunc(options.startIndex)) : 1;
        return rows.map((row, index) => ({
          index: buildIndexCell(index, baseIndex),
          urlId: row.id != null ? { text: String(row.id), classNames: "is-id" } : "\u2014",
          url: (() => {
            const cell = { text: row.url, title: row.url, classNames: "is-url" };
            if (row.id != null) {
              cell.href = `/urls/${row.id}`;
            }
            return cell;
          })(),
          host: row.host ? { text: row.host, href: `/domains/${encodeURIComponent(row.host)}`, classNames: "is-host" } : "\u2014",
          createdAt: formatDateTime(row.createdAt),
          lastSeenAt: formatDateTime(row.lastSeenAt),
          lastFetchAt: formatDateTime(row.lastFetchAt),
          status: formatStatus(row.httpStatus)
        }));
      }
      var CONTROL_TYPE = "url_listing_table";
      var UrlListingTableControl = class extends TableControl {
        constructor(spec = {}) {
          const { columns, records, rows, startIndex, rowOptions, ...rest } = spec || {};
          const resolvedColumns = Array.isArray(columns) && columns.length ? columns : buildColumns();
          super({ ...rest, columns: resolvedColumns, __type_name: CONTROL_TYPE });
          if (spec && spec.el) {
            return;
          }
          if (Array.isArray(rows) && rows.length) {
            this.setRows(rows);
          } else if (Array.isArray(records) && records.length) {
            this.setRecords(records, rowOptions || { startIndex });
          }
        }
        setRecords(records = [], options = {}) {
          const mapped = buildDisplayRows(records, options);
          this.setRows(mapped);
        }
        static buildColumns() {
          return buildColumns();
        }
        static buildRows(records = [], options = {}) {
          return buildDisplayRows(records, options);
        }
      };
      registerControlType(CONTROL_TYPE, UrlListingTableControl);
      module.exports = {
        UrlListingTableControl,
        buildColumns,
        buildDisplayRows,
        buildIndexCell,
        formatDateTime,
        formatCount
      };
    }
  });

  // src/ui/controls/urlFilterDiagnostics.js
  var require_urlFilterDiagnostics = __commonJS({
    "src/ui/controls/urlFilterDiagnostics.js"(exports, module) {
      "use strict";
      var EVENT_NAME = "copilot:urlFilterToggle";
      var DEFAULT_MAX_ENTRIES = 50;
      function nowIso() {
        return (/* @__PURE__ */ new Date()).toISOString();
      }
      function resolveEventCtor() {
        if (typeof window !== "undefined" && typeof window.CustomEvent === "function") {
          return window.CustomEvent;
        }
        if (typeof CustomEvent === "function") {
          return CustomEvent;
        }
        return null;
      }
      function resolveWindow() {
        if (typeof window === "undefined") {
          return null;
        }
        return window;
      }
      function ensureDebugStore(w, maxEntries = DEFAULT_MAX_ENTRIES) {
        if (!w) {
          return null;
        }
        const root = w.__COPILOT_UI_DEBUG__ || (w.__COPILOT_UI_DEBUG__ = {});
        if (!Array.isArray(root.urlFilterToggle)) {
          root.urlFilterToggle = [];
        }
        root.__maxEntries = maxEntries;
        return root.urlFilterToggle;
      }
      function pushDebugEntry(entry, maxEntries = DEFAULT_MAX_ENTRIES) {
        const w = resolveWindow();
        const bucket = ensureDebugStore(w, maxEntries);
        if (!bucket) {
          return;
        }
        bucket.push(entry);
        while (bucket.length > maxEntries) {
          bucket.shift();
        }
      }
      function dispatchDebugEvent(entry) {
        const w = resolveWindow();
        if (!w || typeof w.dispatchEvent !== "function") {
          return;
        }
        const EventCtor = resolveEventCtor();
        if (!EventCtor) {
          try {
            w.dispatchEvent({ type: EVENT_NAME, detail: entry });
          } catch (_) {
          }
          return;
        }
        try {
          w.dispatchEvent(new EventCtor(EVENT_NAME, { detail: entry }));
        } catch (error2) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn("[copilot] failed to dispatch url filter debug event", error2);
          }
        }
      }
      function emitUrlFilterDebug(detail, options = {}) {
        const entry = {
          timestamp: nowIso(),
          ...detail
        };
        const maxEntries = Number.isFinite(options.maxEntries) && options.maxEntries > 0 ? Math.trunc(options.maxEntries) : DEFAULT_MAX_ENTRIES;
        pushDebugEntry(entry, maxEntries);
        dispatchDebugEvent(entry);
        return entry;
      }
      module.exports = {
        EVENT_NAME,
        emitUrlFilterDebug,
        pushDebugEntry,
        dispatchDebugEvent
      };
    }
  });

  // src/ui/controls/helpers/urlListingDom.js
  var require_urlListingDom = __commonJS({
    "src/ui/controls/helpers/urlListingDom.js"(exports, module) {
      "use strict";
      var { formatCount } = require_UrlListingTable();
      function resolveDocument(root) {
        if (!root) {
          if (typeof document !== "undefined") {
            return document;
          }
          return null;
        }
        if (root.ownerDocument) {
          return root.ownerDocument;
        }
        if (root.documentElement) {
          return root;
        }
        if (typeof document !== "undefined") {
          return document;
        }
        return null;
      }
      function setNodeText(node, text) {
        if (!node) return;
        node.textContent = text == null ? "" : String(text);
      }
      function applyCellClassList(cell, classNames) {
        if (!cell || !classNames) {
          return;
        }
        const classes = Array.isArray(classNames) ? classNames : String(classNames).split(/\s+/).map((token) => token.trim()).filter(Boolean);
        classes.forEach((cls) => {
          if (cls) {
            cell.classList.add(cls);
          }
        });
      }
      function createTableCell(doc, column, value2) {
        const cell = doc.createElement("td");
        cell.className = "ui-table__cell";
        if (column && column.align) {
          cell.classList.add(`ui-table__cell--${column.align}`);
        }
        if (column && column.cellClass) {
          applyCellClassList(cell, column.cellClass);
        }
        if (value2 && typeof value2 === "object") {
          if (value2.classNames) {
            applyCellClassList(cell, value2.classNames);
          }
        }
        if (value2 && typeof value2 === "object" && value2.href) {
          const link = doc.createElement("a");
          link.className = "table-link";
          link.textContent = value2.text != null ? String(value2.text) : value2.href;
          link.href = value2.href;
          if (value2.title) {
            link.title = value2.title;
          }
          if (value2.target) {
            link.target = value2.target;
            link.rel = value2.target === "_blank" ? "noopener noreferrer" : link.rel || "";
          }
          cell.appendChild(link);
          return cell;
        }
        if (value2 && typeof value2 === "object" && value2.text != null) {
          cell.appendChild(doc.createTextNode(String(value2.text)));
          return cell;
        }
        cell.appendChild(doc.createTextNode(value2 == null ? "" : String(value2)));
        return cell;
      }
      function updateListingTable(root, payload = {}) {
        const doc = resolveDocument(root);
        if (!doc) return;
        const table2 = doc.querySelector("table.ui-table");
        if (!table2) return;
        const tbody = table2.querySelector("tbody");
        if (!tbody) return;
        const incomingColumns = Array.isArray(payload.columns) && payload.columns.length ? payload.columns : null;
        const columns = incomingColumns || table2.__copilotListingColumns || null;
        if (!columns || !columns.length) {
          return;
        }
        table2.__copilotListingColumns = columns;
        const rows = Array.isArray(payload.rows) ? payload.rows : [];
        const fragment = doc.createDocumentFragment();
        rows.forEach((row, index) => {
          const tr = doc.createElement("tr");
          tr.className = "ui-table__row";
          if (index % 2 === 1) {
            tr.classList.add("ui-table__row--striped");
          }
          tr.setAttribute("data-row-index", String(index));
          columns.forEach((column) => {
            const cell = createTableCell(doc, column, row ? row[column.key] : null);
            tr.appendChild(cell);
          });
          fragment.appendChild(tr);
        });
        while (tbody.firstChild) {
          tbody.removeChild(tbody.firstChild);
        }
        tbody.appendChild(fragment);
      }
      function updateListingMeta(root, meta = {}) {
        var _a, _b;
        const doc = resolveDocument(root);
        if (!doc) return;
        const setField = (field, value2) => {
          const target = doc.querySelector(`[data-meta-field="${field}"]`);
          if (target) {
            setNodeText(target, value2);
          }
        };
        setField("rowCount", formatCount((_a = meta.rowCount) != null ? _a : 0));
        setField("limit", formatCount((_b = meta.limit) != null ? _b : 0));
        if (meta.dbLabel) {
          setField("dbLabel", meta.dbLabel);
        }
        if (meta.generatedAt) {
          setField("generatedAt", meta.generatedAt);
        }
      }
      function updateListingSubtitle(root, subtitle) {
        const doc = resolveDocument(root);
        if (!doc) return;
        const el = doc.querySelector('[data-meta-field="subtitle"]');
        if (el) {
          setNodeText(el, subtitle || "");
        }
      }
      function safeCount(value2, fallback = 0) {
        const numeric = Number(value2);
        if (!Number.isFinite(numeric)) return fallback;
        return Math.max(fallback, Math.trunc(numeric));
      }
      function buildPagerSummary(pagination = {}) {
        if (!pagination || typeof pagination !== "object") {
          return "";
        }
        const page = safeCount(pagination.currentPage, 1) || 1;
        const totalPages = safeCount(pagination.totalPages, 1) || 1;
        const startDisplay = pagination.totalRows === 0 ? 0 : safeCount(pagination.startRow, 0);
        const endDisplay = pagination.totalRows === 0 ? 0 : safeCount(pagination.endRow, 0);
        const totalRows = safeCount(pagination.totalRows, 0) || 0;
        return `Page ${page} of ${totalPages} \u2022 Rows ${startDisplay}-${endDisplay} of ${totalRows}`;
      }
      function applyPagerLink(nav, kind, href, shouldDisable) {
        if (!nav) return;
        const link = nav.querySelector(`[data-pager-link="${kind}"]`);
        if (!link) return;
        if (!href || shouldDisable) {
          link.setAttribute("aria-disabled", "true");
          link.classList.add("pager-button--disabled");
          link.removeAttribute("href");
        } else {
          link.removeAttribute("aria-disabled");
          link.classList.remove("pager-button--disabled");
          link.setAttribute("href", href);
        }
      }
      function updateListingPagination(root, pagination = {}) {
        const doc = resolveDocument(root);
        if (!doc || !pagination) return;
        const summary = buildPagerSummary(pagination);
        const navs = doc.querySelectorAll("nav.pager");
        navs.forEach((nav) => {
          const info = nav.querySelector("[data-pager-info]");
          if (info) {
            setNodeText(info, summary);
          }
          applyPagerLink(nav, "first", pagination.firstHref, pagination.currentPage === 1);
          applyPagerLink(nav, "prev", pagination.prevHref, pagination.currentPage === 1);
          applyPagerLink(nav, "next", pagination.nextHref, pagination.currentPage === pagination.totalPages);
          applyPagerLink(nav, "last", pagination.lastHref, pagination.currentPage === pagination.totalPages);
        });
      }
      function applyListingStateToDocument(root, state = {}) {
        if (!state || typeof state !== "object") {
          return;
        }
        updateListingTable(root, state);
        updateListingMeta(root, state.meta || {});
        const subtitle = state.meta && state.meta.subtitle ? state.meta.subtitle : state.subtitle;
        updateListingSubtitle(root, subtitle);
        const pagination = state.meta && state.meta.pagination || state.pagination;
        if (pagination) {
          updateListingPagination(root, pagination);
        }
      }
      module.exports = {
        applyListingStateToDocument,
        updateListingTable,
        updateListingMeta,
        updateListingSubtitle,
        updateListingPagination,
        buildPagerSummary
      };
    }
  });

  // src/ui/controls/UrlFilterToggle.js
  var require_UrlFilterToggle = __commonJS({
    "src/ui/controls/UrlFilterToggle.js"(exports, module) {
      "use strict";
      var jsgui = require_html();
      var { registerControlType } = require_controlRegistry();
      var { installBindingPlugin: installBindingPlugin2 } = require_bindingPlugin();
      var { emitUrlFilterDebug } = require_urlFilterDiagnostics();
      var { applyListingStateToDocument } = require_urlListingDom();
      installBindingPlugin2(jsgui);
      var CONTROL_TYPE = "url_filter_toggle";
      function encodeQueryPayload(query = {}) {
        try {
          return encodeURIComponent(JSON.stringify(query));
        } catch (_) {
          return encodeURIComponent("{}");
        }
      }
      function decodeQueryPayload(value2) {
        if (!value2) return {};
        try {
          return JSON.parse(decodeURIComponent(value2));
        } catch (_) {
          return {};
        }
      }
      function buildSearchParams(query = {}) {
        const params = new URLSearchParams();
        Object.entries(query).forEach(([key2, rawValue]) => {
          if (rawValue == null) return;
          if (Array.isArray(rawValue)) {
            rawValue.forEach((entry) => {
              if (entry == null) return;
              params.append(key2, String(entry));
            });
            return;
          }
          params.append(key2, String(rawValue));
        });
        return params;
      }
      var UrlFilterToggleControl = class extends jsgui.Control {
        constructor(spec = {}) {
          const normalized = {
            ...spec,
            tagName: "div",
            __type_name: CONTROL_TYPE
          };
          super(normalized);
          this.add_class("filter-toggle");
          this._config = {
            apiPath: spec.apiPath || "/api/urls",
            basePath: spec.basePath || "/urls",
            query: spec.query || {},
            label: spec.label || "Show fetched URLs only",
            defaultPage: Number.isFinite(spec.defaultPage) ? Math.max(1, Math.trunc(spec.defaultPage)) : 1
          };
          this._state = {
            hasFetches: !!spec.hasFetches
          };
          this._lastDiagnostics = null;
          this._listingStore = null;
          this._storeUnsubscribe = null;
          this._lastHistoryHref = null;
          if (!spec.el) {
            this.compose();
          }
          this._applyDataAttributes();
        }
        compose() {
          const label = new jsgui.label({ context: this.context, class: "filter-toggle__label" });
          const switchWrap = new jsgui.span({ context: this.context, class: "filter-toggle__switch" });
          const checkbox = new jsgui.input({ context: this.context, class: "filter-toggle__checkbox" });
          checkbox.dom.attributes.type = "checkbox";
          checkbox.dom.attributes.value = "1";
          if (this._state.hasFetches) {
            checkbox.dom.attributes.checked = "checked";
          }
          const slider = new jsgui.span({ context: this.context, class: "filter-toggle__slider" });
          switchWrap.add(checkbox);
          switchWrap.add(slider);
          const copy = new jsgui.span({ context: this.context, class: "filter-toggle__text" });
          copy.add_text(this._config.label);
          label.add(switchWrap);
          label.add(copy);
          this.add(label);
        }
        _applyDataAttributes() {
          const attrs = this.dom.attributes;
          attrs["data-api-path"] = this._config.apiPath;
          attrs["data-base-path"] = this._config.basePath;
          attrs["data-query"] = encodeQueryPayload(this._config.query);
          attrs["data-default-page"] = String(this._config.defaultPage || 1);
          attrs["data-has-fetches"] = this._state.hasFetches ? "1" : "0";
        }
        activate(el) {
          super.activate(el);
          if (this.__activatedOnce) return;
          this.__activatedOnce = true;
          this._rootEl = el || this.dom.el;
          this._checkbox = this._rootEl ? this._rootEl.querySelector(".filter-toggle__checkbox") : null;
          if (this._checkbox) {
            this._checkbox.addEventListener("change", () => this.handleToggle(this._checkbox.checked));
          }
          this._initListingStore();
        }
        async handleToggle(enabled) {
          if (this._pending) return;
          const nextQuery = this._buildQuery(enabled);
          this._state.hasFetches = !!enabled;
          this._syncDomState();
          this._setBusy(true);
          let diagnostics = null;
          try {
            const result = await this._fetchListing(nextQuery);
            diagnostics = result.diagnostics || null;
            this._publishListingPayload(result.payload, nextQuery);
            this._emitDebugEvent({
              status: "success",
              diagnostics,
              query: nextQuery,
              meta: result.payload ? result.payload.meta : null
            });
          } catch (error2) {
            diagnostics = error2 && error2.diagnostics ? error2.diagnostics : diagnostics;
            console.error("Failed to refresh URL listing:", error2);
            if (this._checkbox) {
              this._checkbox.checked = !enabled;
            }
            this._state.hasFetches = !enabled;
            this._syncDomState();
            this._emitDebugEvent({
              status: "error",
              diagnostics,
              query: nextQuery,
              error: {
                message: error2 && error2.message ? error2.message : "Unknown error"
              }
            });
          } finally {
            this._setBusy(false);
          }
        }
        _syncDomState() {
          if (this._rootEl) {
            this._rootEl.setAttribute("data-has-fetches", this._state.hasFetches ? "1" : "0");
          }
        }
        _setBusy(state) {
          this._pending = state;
          if (!this._rootEl) return;
          if (state) {
            this._rootEl.classList.add("is-loading");
          } else {
            this._rootEl.classList.remove("is-loading");
          }
        }
        _buildQuery(enabled) {
          const snapshot = this._decodeQuery();
          const next = { ...snapshot };
          if (enabled) {
            next.hasFetches = "1";
          } else {
            delete next.hasFetches;
          }
          next.page = String(this._config.defaultPage || 1);
          return next;
        }
        _decodeQuery() {
          if (this._rootEl) {
            return decodeQueryPayload(this._rootEl.getAttribute("data-query"));
          }
          return JSON.parse(JSON.stringify(this._config.query || {}));
        }
        async _fetchListing(query) {
          const params = buildSearchParams(query);
          const qs = params.toString();
          const apiPath = this._rootEl ? this._rootEl.getAttribute("data-api-path") || this._config.apiPath : this._config.apiPath;
          const target = qs ? `${apiPath}?${qs}` : apiPath;
          const response = await fetch(target, {
            headers: { accept: "application/json" },
            credentials: "same-origin"
          });
          const diagnostics = this._extractResponseDiagnostics(response, { query });
          let payload;
          try {
            payload = await response.json();
          } catch (error2) {
            const parseError = new Error("Failed to parse /api/urls response");
            parseError.cause = error2;
            parseError.diagnostics = diagnostics;
            throw parseError;
          }
          if (!response.ok || payload && payload.ok === false) {
            const fallbackMessage = payload && payload.error && payload.error.message ? payload.error.message : `Refresh failed (${response.status})`;
            const apiError = new Error(fallbackMessage);
            apiError.diagnostics = {
              ...diagnostics,
              ...payload && payload.diagnostics ? payload.diagnostics : {}
            };
            apiError.payload = payload;
            throw apiError;
          }
          const mergedDiagnostics = {
            ...diagnostics,
            ...payload && payload.diagnostics ? payload.diagnostics : {}
          };
          return { payload, diagnostics: mergedDiagnostics };
        }
        _publishListingPayload(payload, query) {
          if (!payload || payload.ok === false) {
            return;
          }
          if (!this._listingStore) {
            this._initListingStore();
          }
          if (this._listingStore) {
            this._listingStore.setState(payload);
            return;
          }
          applyListingStateToDocument(this._getDocument(), payload);
          const nextQuery = payload.query || query || {};
          this._state.hasFetches = !!(payload.filters && payload.filters.hasFetches);
          this._syncDomState();
          this._updateQueryState(nextQuery);
          this._updateBasePath(payload.basePath);
          this._syncHistory(nextQuery, payload.basePath);
        }
        _updateBasePath(basePath) {
          if (!basePath) {
            return;
          }
          this._config.basePath = basePath;
          if (this._rootEl) {
            this._rootEl.setAttribute("data-base-path", basePath);
          }
        }
        _resolveListingStore() {
          if (typeof window === "undefined") {
            return null;
          }
          const store = window.__COPILOT_URL_LISTING_STORE__;
          if (!store || typeof store.subscribe !== "function" || typeof store.setState !== "function") {
            return null;
          }
          return store;
        }
        _initListingStore() {
          if (this._listingStore || this._storeUnsubscribe) {
            return;
          }
          const store = this._resolveListingStore();
          if (!store) {
            return;
          }
          this._listingStore = store;
          this._storeUnsubscribe = store.subscribe((state) => this._handleStoreState(state), { immediate: true });
        }
        _handleStoreState(state) {
          if (!state || typeof state !== "object") {
            return;
          }
          const hasFetches = !!(state.filters && state.filters.hasFetches);
          this._state.hasFetches = hasFetches;
          this._syncDomState();
          if (this._checkbox) {
            this._checkbox.checked = hasFetches;
          }
          const query = state.query || {};
          this._updateQueryState(query);
          this._updateBasePath(state.basePath);
          this._syncHistory(query, state.basePath);
        }
        _updateQueryState(query) {
          this._config.query = { ...query };
          if (this._rootEl) {
            this._rootEl.setAttribute("data-query", encodeQueryPayload(this._config.query));
          }
        }
        _syncHistory(query, basePathOverride) {
          if (typeof window === "undefined" || !window.history || typeof window.history.replaceState !== "function") {
            return;
          }
          const params = buildSearchParams(query);
          const basePath = basePathOverride || (this._rootEl ? this._rootEl.getAttribute("data-base-path") : null) || this._config.basePath;
          if (!basePath) {
            return;
          }
          const qs = params.toString();
          const nextUrl = qs ? `${basePath}?${qs}` : basePath;
          if (nextUrl === this._lastHistoryHref) {
            return;
          }
          window.history.replaceState({}, document.title, nextUrl);
          this._lastHistoryHref = nextUrl;
        }
        _getDocument() {
          if (this.context && this.context.document) {
            return this.context.document;
          }
          if (typeof document !== "undefined") {
            return document;
          }
          return null;
        }
        _extractResponseDiagnostics(response, context2 = {}) {
          var _a;
          if (!response || typeof ((_a = response.headers) == null ? void 0 : _a.get) !== "function") {
            return { ...context2 };
          }
          const durationHeader = response.headers.get("x-copilot-duration-ms");
          const durationMs = durationHeader != null ? Number(durationHeader) : null;
          return {
            ...context2,
            requestId: response.headers.get("x-copilot-request-id") || null,
            durationMs: Number.isFinite(durationMs) ? durationMs : null,
            source: response.headers.get("x-copilot-api") || "dataExplorer",
            status: response.status
          };
        }
        _emitDebugEvent(detail) {
          this._lastDiagnostics = detail || null;
          emitUrlFilterDebug({
            control: CONTROL_TYPE,
            ...detail
          });
        }
      };
      registerControlType(CONTROL_TYPE, UrlFilterToggleControl);
      module.exports = {
        UrlFilterToggleControl
      };
    }
  });

  // src/ui/controls/ThemeEditorControl.js
  var require_ThemeEditorControl = __commonJS({
    "src/ui/controls/ThemeEditorControl.js"(exports, module) {
      "use strict";
      var jsgui = require_html();
      var StringControl = jsgui.String_Control;
      function safeJsonStringify(value2, indent = 2) {
        try {
          return JSON.stringify(value2, null, indent);
        } catch (_) {
          return "{}";
        }
      }
      function normalizeThemeId(theme) {
        if (!theme) return "";
        return String(theme.id || theme.name || "");
      }
      var ThemeEditorControl = class extends jsgui.Control {
        constructor(spec = {}) {
          super({ ...spec, tagName: "section", __type_name: "theme_editor" });
          this.add_class("theme-editor");
          this.themes = Array.isArray(spec.themes) ? spec.themes : [];
          this.activeTheme = spec.activeTheme || null;
          this.apiBase = typeof spec.apiBase === "string" && spec.apiBase.trim() ? spec.apiBase.trim() : "/api/themes";
          if (!spec.el) {
            this.compose();
          }
        }
        compose() {
          const context2 = this.context;
          const header = new jsgui.Control({ context: context2, tagName: "header" });
          header.add_class("theme-editor__header");
          const title = new jsgui.Control({ context: context2, tagName: "h2" });
          title.add_class("theme-editor__title");
          title.add(new StringControl({ context: context2, text: "Theme Editor" }));
          header.add(title);
          const subtitle = new jsgui.Control({ context: context2, tagName: "p" });
          subtitle.add_class("theme-editor__subtitle");
          subtitle.add(new StringControl({
            context: context2,
            text: "Edit UI theme tokens (WLILO / Obsidian / custom). Save updates to ui_themes via the API."
          }));
          header.add(subtitle);
          const toolbar = new jsgui.Control({ context: context2, tagName: "div" });
          toolbar.add_class("theme-editor__toolbar");
          const selectWrap = new jsgui.Control({ context: context2, tagName: "div" });
          selectWrap.add_class("theme-editor__select-wrap");
          const label = new jsgui.Control({ context: context2, tagName: "label" });
          label.add_class("theme-editor__label");
          label.dom.attributes["for"] = "themeEditorSelect";
          label.add(new StringControl({ context: context2, text: "Theme" }));
          selectWrap.add(label);
          const select = new jsgui.Control({ context: context2, tagName: "select" });
          select.add_class("theme-editor__select");
          select.dom.attributes.id = "themeEditorSelect";
          select.dom.attributes["data-theme-select"] = "1";
          const activeName = this.activeTheme && this.activeTheme.name ? String(this.activeTheme.name) : "";
          const activeId = normalizeThemeId(this.activeTheme);
          const themes = Array.isArray(this.themes) ? this.themes : [];
          themes.forEach((theme) => {
            if (!theme) return;
            const option = new jsgui.Control({ context: context2, tagName: "option" });
            const name = String(theme.name || "");
            const display = String(theme.display_name || theme.displayName || theme.name || "(unnamed)");
            option.dom.attributes.value = name;
            if (name && name === activeName) {
              option.dom.attributes.selected = "selected";
            }
            const suffix = theme.is_default ? " \u2605" : theme.is_system ? " (system)" : "";
            option.add(new StringControl({ context: context2, text: display + suffix }));
            select.add(option);
          });
          selectWrap.add(select);
          toolbar.add(selectWrap);
          const buttons = new jsgui.Control({ context: context2, tagName: "div" });
          buttons.add_class("theme-editor__buttons");
          const mkButton = (text, attrs) => {
            const btn = new jsgui.Control({ context: context2, tagName: "button" });
            btn.add_class("theme-editor__button");
            btn.dom.attributes.type = "button";
            Object.entries(attrs || {}).forEach(([key2, value2]) => {
              btn.dom.attributes[key2] = value2;
            });
            btn.add(new StringControl({ context: context2, text }));
            return btn;
          };
          buttons.add(mkButton("\u{1F504} Refresh", { "data-theme-refresh": "1" }));
          buttons.add(mkButton("\u{1F4BE} Save", { "data-theme-save": "1" }));
          buttons.add(mkButton("\u2B50 Set default", { "data-theme-default": "1" }));
          buttons.add(mkButton("\u2795 New", { "data-theme-new": "1" }));
          buttons.add(mkButton("\u{1F5D1}\uFE0F Delete", { "data-theme-delete": "1" }));
          toolbar.add(buttons);
          const status = new jsgui.Control({ context: context2, tagName: "div" });
          status.add_class("theme-editor__status");
          status.dom.attributes["data-theme-status"] = "1";
          status.add(new StringControl({ context: context2, text: "" }));
          const form = new jsgui.Control({ context: context2, tagName: "div" });
          form.add_class("theme-editor__form");
          const fields = new jsgui.Control({ context: context2, tagName: "div" });
          fields.add_class("theme-editor__fields");
          const fieldRow = (labelText, inputAttrs, initialValue = "") => {
            const row = new jsgui.Control({ context: context2, tagName: "div" });
            row.add_class("theme-editor__field-row");
            const lbl = new jsgui.Control({ context: context2, tagName: "label" });
            lbl.add_class("theme-editor__label");
            if (inputAttrs && inputAttrs.id) {
              lbl.dom.attributes["for"] = inputAttrs.id;
            }
            lbl.add(new StringControl({ context: context2, text: labelText }));
            const input = new jsgui.Control({ context: context2, tagName: "input" });
            input.add_class("theme-editor__input");
            input.dom.attributes.type = "text";
            Object.entries(inputAttrs || {}).forEach(([key2, value2]) => {
              input.dom.attributes[key2] = value2;
            });
            if (initialValue) {
              input.dom.attributes.value = initialValue;
            }
            row.add(lbl);
            row.add(input);
            return row;
          };
          fields.add(fieldRow("Name", { id: "themeEditorName", "data-theme-name": "1", placeholder: "wlilo" }, activeName));
          fields.add(fieldRow(
            "Display",
            { id: "themeEditorDisplay", "data-theme-display": "1", placeholder: "WLILO" },
            this.activeTheme && (this.activeTheme.display_name || this.activeTheme.displayName) ? String(this.activeTheme.display_name || this.activeTheme.displayName) : ""
          ));
          fields.add(fieldRow(
            "Description",
            { id: "themeEditorDescription", "data-theme-description": "1", placeholder: "Optional" },
            this.activeTheme && this.activeTheme.description ? String(this.activeTheme.description) : ""
          ));
          form.add(fields);
          const editorWrap = new jsgui.Control({ context: context2, tagName: "div" });
          editorWrap.add_class("theme-editor__editor-wrap");
          const editorLabel = new jsgui.Control({ context: context2, tagName: "label" });
          editorLabel.add_class("theme-editor__label");
          editorLabel.dom.attributes["for"] = "themeEditorJson";
          editorLabel.add(new StringControl({ context: context2, text: "Config JSON" }));
          const textarea = new jsgui.Control({ context: context2, tagName: "textarea" });
          textarea.add_class("theme-editor__textarea");
          textarea.dom.attributes.id = "themeEditorJson";
          textarea.dom.attributes.rows = "22";
          textarea.dom.attributes["data-theme-json"] = "1";
          textarea.add(new StringControl({
            context: context2,
            text: this.activeTheme && this.activeTheme.config ? safeJsonStringify(this.activeTheme.config, 2) : "{}"
          }));
          editorWrap.add(editorLabel);
          editorWrap.add(textarea);
          form.add(editorWrap);
          this.dom.attributes["data-theme-editor"] = "1";
          this.dom.attributes["data-theme-active-id"] = activeId;
          this.dom.attributes["data-theme-api-base"] = this.apiBase;
          this.add(header);
          this.add(toolbar);
          this.add(status);
          this.add(form);
        }
        activate() {
          if (this.__active) return;
          this.__active = true;
          const root = this.dom && this.dom.el;
          if (!root || typeof window === "undefined") return;
          const apiBase = root.getAttribute("data-theme-api-base") || "/api/themes";
          const select = root.querySelector("[data-theme-select]");
          const status = root.querySelector("[data-theme-status]");
          const nameInput = root.querySelector("[data-theme-name]");
          const displayInput = root.querySelector("[data-theme-display]");
          const descInput = root.querySelector("[data-theme-description]");
          const textarea = root.querySelector("[data-theme-json]");
          const btnRefresh = root.querySelector("[data-theme-refresh]");
          const btnSave = root.querySelector("[data-theme-save]");
          const btnDefault = root.querySelector("[data-theme-default]");
          const btnNew = root.querySelector("[data-theme-new]");
          const btnDelete = root.querySelector("[data-theme-delete]");
          let currentTheme = null;
          const setStatus = (text, kind) => {
            if (!status) return;
            status.textContent = text || "";
            status.setAttribute("data-status", kind || "info");
          };
          const safeParseJson = (text) => {
            try {
              return { ok: true, value: JSON.parse(text) };
            } catch (err) {
              return { ok: false, error: err };
            }
          };
          const populateFields = (theme) => {
            currentTheme = theme || null;
            if (nameInput) nameInput.value = theme && theme.name ? String(theme.name) : "";
            if (displayInput) displayInput.value = theme && (theme.display_name || theme.displayName) ? String(theme.display_name || theme.displayName) : "";
            if (descInput) descInput.value = theme && theme.description ? String(theme.description) : "";
            if (textarea) textarea.value = theme && theme.config ? JSON.stringify(theme.config, null, 2) : "{}";
          };
          const fetchJson = async (url, options) => {
            const res2 = await fetch(url, {
              headers: { "content-type": "application/json" },
              ...options
            });
            const json = await res2.json().catch(() => null);
            if (!res2.ok) {
              const msg = json && (json.error || json.message) || `HTTP ${res2.status}`;
              throw new Error(msg);
            }
            return json;
          };
          const refreshList = async () => {
            setStatus("Loading themes\u2026", "info");
            const payload = await fetchJson(apiBase, { method: "GET" });
            const themes = Array.isArray(payload.themes) ? payload.themes : [];
            if (select) {
              const selected = select.value;
              select.innerHTML = "";
              themes.forEach((t) => {
                const opt = document.createElement("option");
                opt.value = t.name;
                opt.textContent = `${t.display_name || t.name}${t.is_default ? " \u2605" : t.is_system ? " (system)" : ""}`;
                if (selected && t.name === selected) {
                  opt.selected = true;
                }
                select.appendChild(opt);
              });
            }
            setStatus(`Loaded ${themes.length} themes`, "success");
          };
          const loadTheme = async (name) => {
            if (!name) return;
            setStatus(`Loading ${name}\u2026`, "info");
            const payload = await fetchJson(`${apiBase}/${encodeURIComponent(name)}`, { method: "GET" });
            populateFields(payload.theme);
            setStatus(`Loaded ${name}`, "success");
          };
          const saveTheme = async () => {
            const name = nameInput ? nameInput.value.trim() : "";
            if (!name) {
              setStatus("Name is required", "error");
              return;
            }
            const parsed = safeParseJson(textarea ? textarea.value : "{}");
            if (!parsed.ok) {
              setStatus(`Invalid JSON: ${parsed.error.message}`, "error");
              return;
            }
            const payload = {
              displayName: displayInput ? displayInput.value.trim() : "",
              description: descInput ? descInput.value.trim() : "",
              config: parsed.value
            };
            setStatus("Saving\u2026", "info");
            const res2 = await fetchJson(`${apiBase}/${encodeURIComponent(name)}`, {
              method: "PUT",
              body: JSON.stringify(payload)
            });
            populateFields(res2.theme);
            setStatus("Saved", "success");
          };
          const setDefault = async () => {
            const name = nameInput ? nameInput.value.trim() : "";
            if (!name) {
              setStatus("Name is required", "error");
              return;
            }
            setStatus("Setting default\u2026", "info");
            await fetchJson(`${apiBase}/${encodeURIComponent(name)}/default`, { method: "POST" });
            setStatus("Default updated", "success");
            await refreshList();
          };
          const createNew = async () => {
            const name = nameInput ? nameInput.value.trim() : "";
            if (!name) {
              setStatus("Name is required", "error");
              return;
            }
            const parsed = safeParseJson(textarea ? textarea.value : "{}");
            if (!parsed.ok) {
              setStatus(`Invalid JSON: ${parsed.error.message}`, "error");
              return;
            }
            const payload = {
              name,
              displayName: displayInput ? displayInput.value.trim() : "",
              description: descInput ? descInput.value.trim() : "",
              config: parsed.value
            };
            setStatus("Creating\u2026", "info");
            const res2 = await fetchJson(apiBase, { method: "POST", body: JSON.stringify(payload) });
            populateFields(res2.theme);
            if (select) {
              select.value = res2.theme && res2.theme.name ? res2.theme.name : name;
            }
            setStatus("Created", "success");
            await refreshList();
          };
          const deleteTheme = async () => {
            const name = nameInput ? nameInput.value.trim() : "";
            if (!name) {
              setStatus("Name is required", "error");
              return;
            }
            if (!window.confirm(`Delete theme '${name}'?`)) return;
            setStatus("Deleting\u2026", "info");
            await fetchJson(`${apiBase}/${encodeURIComponent(name)}`, { method: "DELETE" });
            setStatus("Deleted", "success");
            await refreshList();
          };
          const guard = (fn) => async (ev) => {
            if (ev && typeof ev.preventDefault === "function") ev.preventDefault();
            try {
              await fn();
            } catch (err) {
              setStatus(err && err.message ? err.message : "Request failed", "error");
            }
          };
          if (btnRefresh) btnRefresh.addEventListener("click", guard(refreshList));
          if (btnSave) btnSave.addEventListener("click", guard(saveTheme));
          if (btnDefault) btnDefault.addEventListener("click", guard(setDefault));
          if (btnNew) btnNew.addEventListener("click", guard(createNew));
          if (btnDelete) btnDelete.addEventListener("click", guard(deleteTheme));
          if (select) {
            select.addEventListener("change", guard(async () => {
              const name = select.value;
              await loadTheme(name);
              try {
                const url = new URL(window.location.href);
                url.searchParams.set("theme", name);
                window.history.replaceState({}, "", url.toString());
              } catch (_) {
              }
            }));
          }
          if (select && select.value) {
            guard(() => loadTheme(select.value))();
          }
        }
      };
      module.exports = { ThemeEditorControl };
    }
  });

  // src/ui/controls/PagerButton.js
  var require_PagerButton = __commonJS({
    "src/ui/controls/PagerButton.js"(exports, module) {
      "use strict";
      var jsgui = require_html();
      var { installBindingPlugin: installBindingPlugin2 } = require_bindingPlugin();
      var { registerControlType } = require_controlRegistry();
      installBindingPlugin2(jsgui);
      var StringControl = jsgui.String_Control;
      var CONTROL_TYPE = "pager_button";
      var PagerButtonControl = class extends jsgui.Control {
        constructor(spec = {}) {
          const normalized = { ...spec, tagName: "a", __type_name: CONTROL_TYPE };
          super(normalized);
          this.dom.attributes.role = "button";
          this.dom.attributes.title = spec.title || spec.text || "";
          this.add_class("pager-button");
          this._hrefValue = spec.href || null;
          this._isDisabled = !!spec.disabled || !spec.href;
          if (this._hrefValue) {
            this.dom.attributes.href = this._hrefValue;
          }
          this.dom.attributes.tabindex = "0";
          if (spec.text) {
            this.add(new StringControl({ context: this.context, text: spec.text }));
          }
          this.ensureBindingViewModel({
            kind: spec.kind || "default",
            disabled: this._isDisabled
          });
          this.bindDataToView({
            disabled: { to: "disabled" },
            kind: { to: "kind" }
          });
          this.bindViewToAttributes({
            disabled: [
              { attr: "aria-disabled", boolean: true, trueValue: "true" },
              { toggleClass: "pager-button--disabled" },
              {
                onChange: (value2, control) => {
                  control._isDisabled = !!value2;
                  if (control._isDisabled) {
                    delete control.dom.attributes.href;
                    control.dom.attributes.tabindex = "-1";
                  } else {
                    control.dom.attributes.tabindex = "0";
                    if (control._hrefValue) {
                      control.dom.attributes.href = control._hrefValue;
                    } else {
                      delete control.dom.attributes.href;
                    }
                  }
                }
              }
            ],
            kind: [
              { attr: "data-kind" },
              { classPrefix: "pager-button--kind-" }
            ]
          });
          this.setKind(spec.kind || "default");
          this.setDisabled(this._isDisabled);
        }
        setDisabled(state) {
          const viewModel = this.ensureBindingViewModel();
          viewModel.set("disabled", !!state);
        }
        setHref(href) {
          this._hrefValue = href || null;
          if (!this._isDisabled && this._hrefValue) {
            this.dom.attributes.href = this._hrefValue;
          } else if (!this._hrefValue) {
            delete this.dom.attributes.href;
          }
        }
        setKind(kind) {
          const viewModel = this.ensureBindingViewModel();
          viewModel.set("kind", kind || "default");
        }
      };
      registerControlType(CONTROL_TYPE, PagerButtonControl);
      module.exports = {
        PagerButtonControl
      };
    }
  });

  // src/ui/controls/DomainSummaryTable.js
  var require_DomainSummaryTable = __commonJS({
    "src/ui/controls/DomainSummaryTable.js"(exports, module) {
      "use strict";
      var { TableControl } = require_Table();
      var { buildIndexCell, formatDateTime, formatCount } = require_UrlListingTable();
      function formatCountOrLoading(value2) {
        if (value2 === null || value2 === void 0) {
          return { text: "[loading]", classNames: "is-loading" };
        }
        return formatCount(value2);
      }
      var DOMAIN_SUMMARY_COLUMNS = Object.freeze([
        { key: "index", label: "#", align: "right", cellClass: "is-index" },
        { key: "host", label: "Host", cellClass: "is-host" },
        { key: "windowArticles", label: "Recent Articles", align: "right", cellClass: "is-metric" },
        { key: "allArticles", label: "All-Time Articles", align: "right", cellClass: "is-metric" },
        { key: "fetches", label: "Fetches", align: "right", cellClass: "is-metric" },
        { key: "lastSavedAt", label: "Last Saved", cellClass: "is-timestamp" }
      ]);
      var HOST_COL_INDEX = 1;
      var ALL_ARTICLES_COL_INDEX = 3;
      var FETCHES_COL_INDEX = 4;
      function cloneColumn(column) {
        return { ...column };
      }
      function buildColumns() {
        return DOMAIN_SUMMARY_COLUMNS.map(cloneColumn);
      }
      function buildRows(entries = [], options = {}) {
        const startIndex = Number.isFinite(options.startIndex) ? Math.max(1, Math.trunc(options.startIndex)) : 1;
        return entries.map((entry, index) => ({
          index: buildIndexCell(index, startIndex),
          host: entry.host ? { text: entry.host, href: `/domains/${encodeURIComponent(entry.host)}`, classNames: "is-host" } : "\u2014",
          windowArticles: formatCount(entry.windowArticles),
          allArticles: formatCountOrLoading(entry.allArticles),
          fetches: formatCountOrLoading(entry.fetches),
          lastSavedAt: formatDateTime(entry.lastSavedAt, true)
        }));
      }
      var DomainSummaryTableControl = class extends TableControl {
        constructor(spec = {}) {
          const { columns, rows, entries, startIndex } = spec || {};
          const resolvedColumns = Array.isArray(columns) && columns.length ? columns : buildColumns();
          super({ ...spec, columns: resolvedColumns });
          this.__type_name = "domain_summary_table";
          this.dom.attributes["data-control"] = "domain-summary-table";
          if (spec && spec.el) {
            return;
          }
          if (Array.isArray(rows) && rows.length) {
            this.setRows(rows);
          } else if (Array.isArray(entries) && entries.length) {
            this.setEntries(entries, { startIndex });
          }
        }
        setEntries(entries = [], options = {}) {
          const mapped = buildRows(entries, options);
          this.setRows(mapped);
        }
        /**
         * Client-side activation: loads deferred counts for [loading] cells.
         * This method only runs in the browser after hydration.
         */
        activate() {
          if (this.__active) return;
          this.__active = true;
          const el = this.dom && this.dom.el;
          if (!el) return;
          const loadingCells = el.querySelectorAll(".is-loading");
          if (loadingCells.length === 0) return;
          const hosts = this._extractHostsFromTable(el);
          if (hosts.length === 0) return;
          this._loadDeferredCounts(el, hosts);
        }
        /**
         * Extract host names from table rows.
         * @param {HTMLElement} tableEl - The table element
         * @returns {string[]} Array of host names
         */
        _extractHostsFromTable(tableEl) {
          const hosts = [];
          const rows = tableEl.querySelectorAll("tbody tr");
          rows.forEach((row) => {
            const cells = row.querySelectorAll("td");
            if (cells.length > HOST_COL_INDEX) {
              const hostCell = cells[HOST_COL_INDEX];
              const link = hostCell.querySelector("a");
              const hostText = link ? link.textContent : hostCell.textContent;
              if (hostText && hostText.trim() && hostText !== "\u2014") {
                hosts.push(hostText.trim());
              }
            }
          });
          return hosts;
        }
        /**
         * Fetch deferred counts from the API and update loading cells.
         * @param {HTMLElement} tableEl - The table element
         * @param {string[]} hosts - Array of host names to fetch counts for
         */
        async _loadDeferredCounts(tableEl, hosts) {
          try {
            const response = await fetch(`/api/domains/counts?hosts=${encodeURIComponent(hosts.join(","))}`);
            if (!response.ok) return;
            const data = await response.json();
            if (!data || !data.counts) return;
            const rows = tableEl.querySelectorAll("tbody tr");
            rows.forEach((row) => {
              const cells = row.querySelectorAll("td");
              if (cells.length <= FETCHES_COL_INDEX) return;
              const hostCell = cells[HOST_COL_INDEX];
              const link = hostCell.querySelector("a");
              const hostText = link ? link.textContent : hostCell.textContent;
              const host = hostText ? hostText.trim() : null;
              if (!host || !data.counts[host]) return;
              const counts = data.counts[host];
              const allArticlesCell = cells[ALL_ARTICLES_COL_INDEX];
              if (allArticlesCell && allArticlesCell.classList.contains("is-loading")) {
                allArticlesCell.textContent = formatCount(counts.allArticles);
                allArticlesCell.classList.remove("is-loading");
              }
              const fetchesCell = cells[FETCHES_COL_INDEX];
              if (fetchesCell && fetchesCell.classList.contains("is-loading")) {
                fetchesCell.textContent = formatCount(counts.fetches);
                fetchesCell.classList.remove("is-loading");
              }
            });
          } catch (err) {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("[DomainSummaryTable] Failed to load deferred counts:", err.message);
            }
          }
        }
        static buildColumns() {
          return buildColumns();
        }
        static buildRows(entries = [], options = {}) {
          return buildRows(entries, options);
        }
      };
      module.exports = {
        DomainSummaryTableControl,
        buildDomainSummaryColumns: buildColumns,
        buildDomainSummaryRows: buildRows
      };
    }
  });

  // src/ui/controls/controlManifest.js
  var require_controlManifest = __commonJS({
    "src/ui/controls/controlManifest.js"(exports, module) {
      "use strict";
      var manifest = [
        {
          type: "url_listing_table",
          loader: () => require_UrlListingTable().UrlListingTableControl
        },
        {
          type: "url_filter_toggle",
          loader: () => require_UrlFilterToggle().UrlFilterToggleControl
        },
        {
          type: "theme_editor",
          loader: () => require_ThemeEditorControl().ThemeEditorControl
        },
        {
          type: "pager_button",
          loader: () => require_PagerButton().PagerButtonControl
        },
        {
          type: "domain_summary_table",
          loader: () => require_DomainSummaryTable().DomainSummaryTableControl
        }
      ];
      function ensureControlsRegistered2(jsguiInstance) {
        if (!jsguiInstance) {
          return [];
        }
        const { registerControlType } = require_controlRegistry();
        return manifest.map((entry) => {
          const ControlClass = typeof entry.loader === "function" ? entry.loader() : null;
          if (!ControlClass) {
            return null;
          }
          registerControlType(entry.type, ControlClass, { jsguiInstance });
          return { type: entry.type, control: ControlClass };
        }).filter(Boolean);
      }
      function listControlTypes2() {
        return manifest.map((entry) => entry.type);
      }
      module.exports = {
        ensureControlsRegistered: ensureControlsRegistered2,
        listControlTypes: listControlTypes2
      };
    }
  });

  // src/ui/client/listingStateStore.js
  var require_listingStateStore = __commonJS({
    "src/ui/client/listingStateStore.js"(exports, module) {
      "use strict";
      function normalizeListingState(payload) {
        if (!payload || typeof payload !== "object") {
          return null;
        }
        const clonedPagination = payload.pagination ? { ...payload.pagination } : void 0;
        const normalized = { ...payload };
        if (clonedPagination) {
          normalized.pagination = clonedPagination;
        }
        if (!normalized.meta && payload.meta) {
          normalized.meta = { ...payload.meta };
        } else if (normalized.meta && payload.meta && normalized.meta !== payload.meta) {
          normalized.meta = { ...payload.meta };
        }
        if (clonedPagination && (!normalized.meta || !normalized.meta.pagination)) {
          normalized.meta = normalized.meta ? { ...normalized.meta } : {};
          normalized.meta.pagination = clonedPagination;
        }
        return normalized;
      }
      function createListingStateStore(initialState) {
        let state = normalizeListingState(initialState);
        const listeners = /* @__PURE__ */ new Set();
        const getState = () => state;
        const notify = () => {
          listeners.forEach((listener) => {
            try {
              listener(state);
            } catch (error2) {
              if (typeof console !== "undefined" && console.warn) {
                console.warn("[copilot] listing store listener failed", error2);
              }
            }
          });
        };
        const setState = (nextState) => {
          state = normalizeListingState(nextState);
          if (typeof window !== "undefined") {
            window.__COPILOT_URL_LISTING_STATE__ = state;
          }
          notify();
        };
        const subscribe = (listener, options = {}) => {
          if (typeof listener !== "function") {
            return () => {
            };
          }
          listeners.add(listener);
          if (options.immediate !== false) {
            try {
              listener(state);
            } catch (error2) {
              if (typeof console !== "undefined" && console.warn) {
                console.warn("[copilot] listing store immediate subscriber failed", error2);
              }
            }
          }
          return () => {
            listeners.delete(listener);
          };
        };
        return { getState, setState, subscribe };
      }
      function ensureGlobalListingStateStore2(initialState) {
        if (typeof window === "undefined") {
          return null;
        }
        if (window.__COPILOT_URL_LISTING_STORE__) {
          if (initialState) {
            window.__COPILOT_URL_LISTING_STORE__.setState(initialState);
          }
          return window.__COPILOT_URL_LISTING_STORE__;
        }
        const store = createListingStateStore(initialState);
        window.__COPILOT_URL_LISTING_STORE__ = store;
        return store;
      }
      module.exports = {
        createListingStateStore,
        ensureGlobalListingStateStore: ensureGlobalListingStateStore2,
        normalizeListingState
      };
    }
  });

  // src/ui/client/listingDomBindings.js
  var require_listingDomBindings = __commonJS({
    "src/ui/client/listingDomBindings.js"(exports, module) {
      "use strict";
      var { applyListingStateToDocument } = require_urlListingDom();
      function attachListingDomBindings2(store, options = {}) {
        if (!store || typeof store.subscribe !== "function") {
          return null;
        }
        const doc = options.document || (typeof document !== "undefined" ? document : null);
        if (!doc) {
          return null;
        }
        const applyState = (state) => {
          if (!state) {
            return;
          }
          applyListingStateToDocument(doc, state);
        };
        applyState(store.getState ? store.getState() : null);
        return store.subscribe(applyState);
      }
      module.exports = {
        attachListingDomBindings: attachListingDomBindings2
      };
    }
  });

  // src/ui/controls/diagramAtlasControlsFactory.js
  var require_diagramAtlasControlsFactory = __commonJS({
    "src/ui/controls/diagramAtlasControlsFactory.js"(exports, module) {
      "use strict";
      function createDiagramAtlasControls(jsgui) {
        if (!jsgui) {
          throw new Error("jsgui instance is required to build diagram atlas controls");
        }
        const StringControl = jsgui.String_Control;
        class DiagramProgressControl extends jsgui.Control {
          constructor(spec = {}) {
            const normalized = {
              ...spec,
              tagName: "section",
              __type_name: "diagram_progress"
            };
            super(normalized);
            this.add_class("diagram-loading");
            this.dom.attributes["data-role"] = "diagram-progress";
            this._state = {
              status: spec.status || "loading",
              label: spec.label || "Preparing Diagram Atlas",
              detail: spec.detail || "Collecting sources and metrics..."
            };
            if (!spec.el) {
              this.compose();
            }
            this._syncStateAttributes();
          }
          compose() {
            const pulse = new jsgui.div({ context: this.context, class: "diagram-loading__pulse" });
            const title = new jsgui.h3({ context: this.context, class: "diagram-loading__title" });
            title.add(new StringControl({ context: this.context, text: this._state.label }));
            const detail = new jsgui.p({ context: this.context, class: "diagram-loading__detail" });
            detail.add(new StringControl({ context: this.context, text: this._state.detail }));
            const bar = new jsgui.div({ context: this.context, class: "diagram-loading__bar" });
            const inner = new jsgui.div({ context: this.context, class: "diagram-loading__bar-inner" });
            bar.add(inner);
            this.add(pulse);
            this.add(title);
            this.add(detail);
            this.add(bar);
          }
          setStatus(status, detail) {
            if (status) {
              this._state.status = status;
            }
            if (detail) {
              this._state.detail = detail;
            }
            this._syncStateAttributes();
          }
          _syncStateAttributes() {
            this.dom.attributes["data-state"] = this._state.status;
          }
        }
        function clamp(value2, min, max) {
          if (!Number.isFinite(value2)) return min;
          return Math.max(min, Math.min(max, value2));
        }
        function formatBytes(bytes) {
          if (!Number.isFinite(bytes) || bytes <= 0) {
            return "0 B";
          }
          const units = ["B", "KB", "MB", "GB", "TB"];
          const exponent = Math.min(units.length - 1, Math.floor(Math.log(bytes) / Math.log(1024)));
          const value2 = bytes / 1024 ** exponent;
          const fixed = value2 >= 100 ? value2.toFixed(0) : value2 >= 10 ? value2.toFixed(1) : value2.toFixed(2);
          return `${fixed} ${units[exponent]}`;
        }
        function formatNumber(value2, fallback = "\u2014") {
          if (!Number.isFinite(value2)) {
            return fallback;
          }
          return value2.toLocaleString("en-US");
        }
        function computeTileSize(metric, { min = 72, max = 220 } = {}) {
          if (!Number.isFinite(metric) || metric <= 0) return min;
          const scaled = Math.sqrt(metric);
          return clamp(scaled * 1.4, min, max);
        }
        function resolveTileSize(spec) {
          const options = spec.sizeScale || {};
          if (Number.isFinite(spec.metricRatio)) {
            const clampedRatio = clamp(spec.metricRatio, 0, 1);
            const range = Math.max(0, (options.max || 220) - (options.min || 72));
            return (options.min || 72) + Math.sqrt(clampedRatio) * range;
          }
          return computeTileSize(spec.metric || 0, options);
        }
        function summarizePath(value2, segments = 2) {
          if (!value2 || typeof value2 !== "string") return value2 || "";
          const normalized = value2.split("\\").join("/");
          const parts = normalized.split("/");
          if (parts.length <= segments) {
            return normalized;
          }
          const tail = parts.slice(-segments).join("/");
          return `.../${tail}`;
        }
        function createPopoverLabel(context2, { text = "", fullText = "", className = "diagram-label", clampLines = 1 } = {}) {
          const classes = ["diagram-label"];
          if (className && className !== "diagram-label") {
            classes.push(className);
          }
          const label = new jsgui.div({ context: context2, class: classes.join(" ") });
          if (Number.isFinite(clampLines) && clampLines > 1) {
            label.add_class("diagram-label--multiline");
            const lines = Math.min(Math.max(Math.floor(clampLines), 2), 4);
            const style = label.dom.attributes.style || "";
            label.dom.attributes.style = `${style}--diagram-label-lines:${lines};`;
          }
          const textClasses = [`${className}__text`, "diagram-label__text"].filter(Boolean).join(" ");
          const content = new jsgui.span({ context: context2, class: textClasses });
          content.add(new StringControl({ context: context2, text }));
          label.add(content);
          const normalizedFull = fullText || text;
          if (normalizedFull && normalizedFull !== text) {
            label.add_class("diagram-label--with-popover");
            label.dom.attributes.tabindex = "0";
            const popover = new jsgui.div({ context: context2, class: "diagram-popover" });
            popover.add(new StringControl({ context: context2, text: normalizedFull }));
            label.add(popover);
          }
          return label;
        }
        function createTile(context2, spec = {}) {
          const tile = new jsgui.div({ context: context2, class: "diagram-tile" });
          const variant = spec.variant || null;
          if (variant === "db") {
            tile.add_class("diagram-tile--db");
          }
          const styleParts = [];
          if (variant !== "db") {
            const size = resolveTileSize(spec);
            styleParts.push(`width:${size}px`, `height:${size}px`);
          }
          if (Number.isFinite(spec.index)) {
            styleParts.push(`--diagram-tile-index:${spec.index}`);
          }
          if (Number.isFinite(spec.hue)) {
            styleParts.push(`--diagram-tile-hue:${spec.hue}`);
          }
          if (spec.tint) {
            styleParts.push(`--diagram-tile-tint:${spec.tint}`);
          }
          if (styleParts.length) {
            tile.dom.attributes.style = `${styleParts.join(";")};`;
          }
          if (Number.isFinite(spec.bytes)) {
            tile.dom.attributes["data-bytes"] = String(spec.bytes);
          }
          if (Number.isFinite(spec.lines)) {
            tile.dom.attributes["data-lines"] = String(spec.lines);
          }
          if (Number.isFinite(spec.functions)) {
            tile.dom.attributes["data-functions"] = String(spec.functions);
          }
          if (spec.color) {
            tile.dom.attributes["data-color"] = spec.color;
          }
          if (spec.category) {
            tile.dom.attributes["data-category"] = spec.category;
          }
          if (spec.tone) {
            tile.dom.attributes["data-tone"] = spec.tone;
          }
          if (spec.title) {
            tile.dom.attributes.title = spec.title;
          }
          if (spec.badge) {
            const badge = new jsgui.span({ context: context2, class: "diagram-tile__badge" });
            badge.add(new StringControl({ context: context2, text: spec.badge }));
            tile.add(badge);
          }
          const label = createPopoverLabel(context2, {
            text: spec.label || "",
            fullText: spec.fullLabel || spec.label || "",
            className: "diagram-tile__label",
            clampLines: spec.labelLines || 1
          });
          const value2 = new jsgui.div({ context: context2, class: "diagram-tile__value" });
          value2.add(new StringControl({ context: context2, text: spec.value || "" }));
          tile.add(label);
          tile.add(value2);
          if (spec.caption) {
            const caption = new jsgui.div({ context: context2, class: "diagram-tile__caption" });
            caption.add(new StringControl({ context: context2, text: spec.caption }));
            tile.add(caption);
          }
          if (Array.isArray(spec.meta) && spec.meta.length) {
            const metaWrap = new jsgui.div({ context: context2, class: "diagram-tile__meta" });
            spec.meta.forEach((entry) => {
              if (!entry || !entry.label) return;
              const metaEntry = new jsgui.div({ context: context2, class: "diagram-tile__meta-item" });
              const metaLabel = new jsgui.span({ context: context2, class: "diagram-tile__meta-label" });
              metaLabel.add(new StringControl({ context: context2, text: entry.label }));
              const metaValue = new jsgui.span({ context: context2, class: "diagram-tile__meta-value" });
              metaValue.add(new StringControl({ context: context2, text: entry.value || "\u2014" }));
              metaEntry.add(metaLabel);
              metaEntry.add(metaValue);
              metaWrap.add(metaEntry);
            });
            tile.add(metaWrap);
          }
          return tile;
        }
        function createSection(context2, heading, description) {
          const section = new jsgui.Control({ context: context2, tagName: "section" });
          section.add_class("diagram-section");
          const title = new jsgui.h2({ context: context2, class: "diagram-section__title" });
          title.add(new StringControl({ context: context2, text: heading }));
          section.add(title);
          if (description) {
            const desc = new jsgui.p({ context: context2, class: "diagram-section__description" });
            desc.add(new StringControl({ context: context2, text: description }));
            section.add(desc);
          }
          return section;
        }
        function createGrid(context2) {
          const grid = new jsgui.div({ context: context2, class: "diagram-grid" });
          return grid;
        }
        function createLegend(context2, items) {
          if (!Array.isArray(items) || !items.length) return null;
          const legend = new jsgui.div({ context: context2, class: "diagram-legend" });
          items.forEach((item2) => {
            if (!item2 || !item2.label) return;
            const entry = new jsgui.div({ context: context2, class: "diagram-legend__item" });
            const swatch = new jsgui.span({ context: context2, class: "diagram-legend__swatch" });
            if (item2.color) {
              swatch.dom.attributes.style = `background:${item2.color};`;
            }
            const text = new jsgui.span({ context: context2, class: "diagram-legend__label" });
            text.add(new StringControl({ context: context2, text: item2.label }));
            entry.add(swatch);
            entry.add(text);
            legend.add(entry);
          });
          return legend;
        }
        function createSummaryStat(context2, label, value2, detail) {
          const stat = new jsgui.div({ context: context2, class: "diagram-code-summary__item" });
          const labelNode = new jsgui.span({ context: context2, class: "diagram-code-summary__label" });
          labelNode.add(new StringControl({ context: context2, text: label }));
          const valueNode = new jsgui.span({ context: context2, class: "diagram-code-summary__value" });
          valueNode.add(new StringControl({ context: context2, text: value2 }));
          stat.add(labelNode);
          stat.add(valueNode);
          if (detail) {
            const detailNode = new jsgui.span({ context: context2, class: "diagram-code-summary__detail" });
            detailNode.add(new StringControl({ context: context2, text: detail }));
            stat.add(detailNode);
          }
          return stat;
        }
        function buildCodeSummary(context2, summary = {}) {
          const stats = [];
          if (summary && Number.isFinite(summary.totalBytes)) {
            const rawBytes = summary.totalBytes;
            stats.push({
              label: "Total bytes",
              value: formatBytes(rawBytes),
              detail: `${formatNumber(rawBytes)} bytes raw`
            });
          }
          if (summary && Number.isFinite(summary.totalLines)) {
            stats.push({
              label: "Lines",
              value: formatNumber(summary.totalLines)
            });
          }
          if (summary && Number.isFinite(summary.fileCount)) {
            stats.push({
              label: "Files",
              value: formatNumber(summary.fileCount)
            });
          }
          if (!stats.length) {
            return null;
          }
          const block = new jsgui.div({ context: context2, class: "diagram-code-summary" });
          stats.forEach((entry) => {
            block.add(createSummaryStat(context2, entry.label, entry.value, entry.detail));
          });
          return block;
        }
        function resolveEntryMetric(entry) {
          if (!entry || typeof entry !== "object") return 0;
          if (Number.isFinite(entry.bytes) && entry.bytes > 0) {
            return entry.bytes;
          }
          if (Number.isFinite(entry.lines) && entry.lines > 0) {
            return entry.lines;
          }
          return 0;
        }
        function createDirectoryMetric(context2, label, value2) {
          const metric = new jsgui.span({ context: context2, class: "diagram-code-directory__metric" });
          const labelNode = new jsgui.span({ context: context2, class: "diagram-code-directory__metric-label" });
          labelNode.add(new StringControl({ context: context2, text: label }));
          const valueNode = new jsgui.span({ context: context2, class: "diagram-code-directory__metric-value" });
          valueNode.add(new StringControl({ context: context2, text: value2 }));
          metric.add(labelNode);
          metric.add(valueNode);
          return metric;
        }
        function createDirectoryRow(context2, directory, maxMetric) {
          const row = new jsgui.div({ context: context2, class: "diagram-code-directory" });
          if (Number.isFinite(directory.bytes)) {
            row.dom.attributes["data-bytes"] = String(directory.bytes);
          }
          if (Number.isFinite(directory.files)) {
            row.dom.attributes["data-files"] = String(directory.files);
          }
          const label = createPopoverLabel(context2, {
            text: summarizePath(directory.directory, 3) || directory.directory || "(root)",
            fullText: directory.directory,
            className: "diagram-code-directory__label"
          });
          row.add(label);
          const metrics = new jsgui.div({ context: context2, class: "diagram-code-directory__metrics" });
          const bytesText = Number.isFinite(directory.bytes) ? formatBytes(directory.bytes) : "\u2014";
          const linesText = formatNumber(directory.lines);
          const filesText = formatNumber(directory.files);
          metrics.add(createDirectoryMetric(context2, "Bytes", bytesText));
          metrics.add(createDirectoryMetric(context2, "Lines", linesText));
          metrics.add(createDirectoryMetric(context2, "Files", filesText));
          row.add(metrics);
          const bar = new jsgui.div({ context: context2, class: "diagram-code-directory__bar" });
          const fill = new jsgui.div({ context: context2, class: "diagram-code-directory__bar-fill" });
          const metricValue = resolveEntryMetric(directory);
          const ratio = maxMetric ? clamp(metricValue / maxMetric, 0.04, 1) : 0;
          fill.dom.attributes.style = `width:${(ratio * 100).toFixed(2)}%;`;
          bar.add(fill);
          row.add(bar);
          return row;
        }
        function buildDirectoryList(context2, directories) {
          if (!Array.isArray(directories) || !directories.length) {
            return null;
          }
          const topDirectories = directories.slice(0, 8);
          const maxMetric = topDirectories.reduce((max, entry) => Math.max(max, resolveEntryMetric(entry)), 0) || 1;
          const wrapper = new jsgui.div({ context: context2, class: "diagram-code-directories" });
          const heading = new jsgui.h3({ context: context2, class: "diagram-section__subheading" });
          heading.add(new StringControl({ context: context2, text: "Top directories" }));
          wrapper.add(heading);
          const list = new jsgui.div({ context: context2, class: "diagram-code-directories__list" });
          topDirectories.forEach((entry) => {
            list.add(createDirectoryRow(context2, entry, maxMetric));
          });
          wrapper.add(list);
          return wrapper;
        }
        function buildCodeSection(context2, codeData) {
          const section = createSection(context2, "Codebase Map", "Top files sized by byte count (fs.stat + js-scan --build-index).");
          section.add_class("diagram-section--code");
          const summary = buildCodeSummary(context2, codeData && codeData.summary);
          const grid = createGrid(context2);
          const files = Array.isArray(codeData && codeData.topFiles) ? codeData.topFiles.slice(0, 30) : [];
          const maxMetric = files.reduce((max, file) => Math.max(max, resolveEntryMetric(file)), 0) || 1;
          const tonePalette = ["teal", "violet", "amber", "berry", "cyan"];
          files.forEach((file, index) => {
            const label = file.file;
            const lines = file.lines || 0;
            const bytes = file.bytes || 0;
            const shortLabel = summarizePath(label, 3);
            const tileTone = tonePalette[index % tonePalette.length];
            const hue = 210 + index * 9;
            const tile = createTile(context2, {
              label: shortLabel,
              fullLabel: label,
              value: formatBytes(bytes),
              metricRatio: clamp(resolveEntryMetric(file) / maxMetric, 0, 1),
              sizeScale: { min: 80, max: 260 },
              caption: file.entryPoint ? "entry" : null,
              title: `${label}
${formatBytes(bytes)}
${lines} lines
${file.functions || 0} functions`,
              bytes,
              lines,
              functions: file.functions || 0,
              index,
              category: file.entryPoint ? "entry" : "file",
              tone: tileTone,
              hue,
              badge: file.entryPoint ? "Entry" : null,
              labelLines: 2,
              meta: [
                { label: "Lines", value: lines.toLocaleString("en-US") },
                { label: "Funcs", value: (file.functions || 0).toLocaleString("en-US") }
              ]
            });
            grid.add(tile);
          });
          const layout = new jsgui.div({ context: context2, class: "diagram-code-layout" });
          const sidebar = new jsgui.div({ context: context2, class: "diagram-code-sidebar" });
          let sidebarHasContent = false;
          if (summary) {
            sidebar.add(summary);
            sidebarHasContent = true;
          }
          const directories = buildDirectoryList(context2, codeData && codeData.directories);
          if (directories) {
            sidebar.add(directories);
            sidebarHasContent = true;
          }
          if (sidebarHasContent) {
            layout.add(sidebar);
          }
          const gridWrap = new jsgui.div({ context: context2, class: "diagram-code-grid" });
          gridWrap.add(grid);
          layout.add(gridWrap);
          section.add(layout);
          return section;
        }
        function buildDbSection(context2, dbData) {
          const section = createSection(context2, "Database Structure", "Tables parsed from migration SQL files (column count as area).");
          section.add_class("diagram-section--db");
          const grid = createGrid(context2);
          const tables = Array.isArray(dbData && dbData.tables) ? dbData.tables.slice(0, 24) : [];
          const maxColumns = tables.reduce((max, table2) => Math.max(max, table2.columnCount || 0), 0) || 1;
          tables.forEach((table2, index) => {
            const foreignKeyCount = Array.isArray(table2.foreignKeys) ? table2.foreignKeys.length : 0;
            const tile = createTile(context2, {
              label: table2.name,
              value: `${table2.columnCount || 0} columns`,
              metric: (table2.columnCount || 0) / maxColumns * 400 + 20,
              caption: foreignKeyCount ? `${foreignKeyCount} links` : null,
              title: `${table2.name}
Columns: ${(table2.columns || []).join(", ")}`,
              category: "table",
              tone: foreignKeyCount ? "violet" : "teal",
              hue: 160 + index * 11,
              badge: foreignKeyCount ? `${foreignKeyCount} FK` : null,
              variant: "db",
              meta: [
                { label: "Columns", value: formatNumber(table2.columnCount) },
                { label: "FK", value: formatNumber(foreignKeyCount) }
              ]
            });
            grid.add(tile);
          });
          section.add(grid);
          return section;
        }
        function buildFeatureSection(context2, featureData) {
          const section = createSection(context2, "Feature Footprints", "Each feature aggregates multiple files plus intra-file segments (js-scan --deps-of + js-edit --list-functions).");
          section.add_class("diagram-section--features");
          const features = Array.isArray(featureData && featureData.features) ? featureData.features : [];
          const legend = features.length ? createLegend(context2, features.map((feature) => ({ label: feature.name, color: feature.color }))) : null;
          if (legend) {
            section.add(legend);
          }
          if (!features.length) {
            return section;
          }
          const featureGrid = new jsgui.div({ context: context2, class: "diagram-feature-grid" });
          features.forEach((feature, featureIndex) => {
            const article = new jsgui.Control({ context: context2, tagName: "article" });
            article.add_class("diagram-feature");
            if (feature.color) {
              article.dom.attributes["data-color"] = feature.color;
            }
            article.dom.attributes["data-feature-index"] = String(featureIndex);
            const totalLines = Number(feature.totalLines) || 0;
            const filesForFeature = Array.isArray(feature.files) ? feature.files : [];
            const header = new jsgui.div({ context: context2, class: "diagram-feature__header" });
            const title = new jsgui.h3({ context: context2, class: "diagram-feature__title" });
            title.add(new StringControl({ context: context2, text: feature.name }));
            header.add(title);
            const stats = new jsgui.div({ context: context2, class: "diagram-feature__stats" });
            const statEntries = [
              { label: "Files", value: filesForFeature.length.toLocaleString("en-US") },
              { label: "Lines", value: totalLines.toLocaleString("en-US") }
            ];
            statEntries.forEach((entry) => {
              const stat = new jsgui.div({ context: context2, class: "diagram-feature__stat" });
              const statLabel = new jsgui.span({ context: context2, class: "diagram-feature__stat-label" });
              statLabel.add(new StringControl({ context: context2, text: entry.label }));
              const statValue = new jsgui.span({ context: context2, class: "diagram-feature__stat-value" });
              statValue.add(new StringControl({ context: context2, text: entry.value }));
              stat.add(statLabel);
              stat.add(statValue);
              stats.add(stat);
            });
            header.add(stats);
            if (feature.tags && feature.tags.length) {
              const tags = new jsgui.div({ context: context2, class: "diagram-feature__tags" });
              feature.tags.forEach((tag) => {
                const pill = new jsgui.span({ context: context2, class: "diagram-feature__tag" });
                pill.add(new StringControl({ context: context2, text: tag }));
                tags.add(pill);
              });
              header.add(tags);
            }
            if (feature.description) {
              const desc = new jsgui.p({ context: context2, class: "diagram-feature__description" });
              desc.add(new StringControl({ context: context2, text: feature.description }));
              header.add(desc);
            }
            article.add(header);
            const fileList = new jsgui.div({ context: context2, class: "diagram-feature__files" });
            const files = filesForFeature.slice(0, 10);
            const maxLines = files.reduce((max, file) => Math.max(max, file.lines || 1), 1);
            files.forEach((file) => {
              const row = new jsgui.div({ context: context2, class: "diagram-feature__file-row" });
              const widthPercent = clamp((file.lines || 0) / maxLines, 0.05, 1) * 100;
              const bar = new jsgui.div({ context: context2, class: "diagram-feature__file-bar" });
              bar.dom.attributes.style = `--diagram-feature-width:${widthPercent}%;--diagram-feature-color:${feature.color || "#5b7c99"};`;
              const label = createPopoverLabel(context2, {
                text: summarizePath(file.file, 3),
                fullText: file.file,
                className: "diagram-feature__file-label",
                clampLines: 2
              });
              let via = null;
              if (file.via) {
                via = new jsgui.span({ context: context2, class: "diagram-feature__file-meta" });
                via.add(new StringControl({ context: context2, text: file.via }));
              }
              row.add(bar);
              row.add(label);
              if (via) {
                row.add(via);
              }
              const segmentsWrap = new jsgui.div({ context: context2, class: "diagram-feature__segments" });
              const segmentEntry = (feature.segments || []).find((segment) => segment.file === file.file);
              if (segmentEntry && Array.isArray(segmentEntry.functions) && segmentEntry.functions.length) {
                const maxBytes = segmentEntry.functions.reduce((max, fn) => Math.max(max, fn.byteLength || 1), 1);
                segmentEntry.functions.forEach((fn) => {
                  const fnSpan = new jsgui.span({ context: context2, class: "diagram-feature__segment" });
                  const pct = clamp((fn.byteLength || 0) / maxBytes, 0.05, 1) * 100;
                  fnSpan.dom.attributes.style = `width:${pct}%;`;
                  fnSpan.dom.attributes.title = `${fn.name} (${fn.byteLength} bytes @ line ${fn.line})`;
                  fnSpan.add(new StringControl({ context: context2, text: fn.name }));
                  segmentsWrap.add(fnSpan);
                });
              }
              row.add(segmentsWrap);
              fileList.add(row);
            });
            article.add(fileList);
            featureGrid.add(article);
          });
          section.add(featureGrid);
          return section;
        }
        function buildDiagramAtlasStyles() {
          return `
:root {
  --diagram-bg: #05060d;
  --diagram-panel: #101628;
  --diagram-text: #f4f7ff;
  --diagram-muted: #9ba5c4;
  --diagram-accent: #4cc9f0;
  --diagram-accent-strong: #ff7b9c;
  --diagram-accent-amber: #f6c177;
  --diagram-accent-berry: #c77dff;
  --diagram-font-display: "Spectral", "Georgia", serif;
  --diagram-font-body: "IBM Plex Sans", "Segoe UI", sans-serif;
  --diagram-font-mono: "IBM Plex Mono", "Consolas", monospace;
}
body {
  font-family: var(--diagram-font-body);
  background: radial-gradient(circle at 20% 20%, rgba(76, 201, 240, 0.08), transparent 45%),
    radial-gradient(circle at 80% 10%, rgba(199, 125, 255, 0.08), transparent 40%),
    var(--diagram-bg);
  color: var(--diagram-text);
  margin: 0;
  padding: 0;
}
.diagram-shell {
  padding: 32px;
  display: flex;
  flex-direction: column;
  gap: 32px;
  min-height: 100vh;
  position: relative;
  overflow: hidden;
}
.diagram-shell::before {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(120deg, rgba(76,201,240,0.08), rgba(199,125,255,0.06) 40%, transparent),
    repeating-linear-gradient(0deg, rgba(255,255,255,0.015) 0, rgba(255,255,255,0.015) 1px, transparent 1px, transparent 40px);
  pointer-events: none;
  z-index: 0;
}
.diagram-shell > * {
  position: relative;
  z-index: 1;
}
.diagram-shell__sections {
  display: flex;
  flex-direction: column;
  gap: 32px;
}
.diagram-shell__placeholder {
  padding: 32px;
  border-radius: 16px;
  border: 1px dashed rgba(255,255,255,0.2);
  text-align: center;
  color: var(--diagram-muted);
}
.diagram-shell__header {
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 24px;
  border-radius: 20px;
  background: rgba(10, 14, 32, 0.7);
  border: 1px solid rgba(255,255,255,0.04);
  box-shadow: 0 20px 40px rgba(2,8,23,0.6);
  position: relative;
  overflow: hidden;
}
.diagram-hero {
  isolation: isolate;
}
.diagram-shell__header::after {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at 10% 10%, rgba(76,201,240,0.25), transparent 55%),
    radial-gradient(circle at 80% 0%, rgba(199,125,255,0.25), transparent 60%);
  opacity: 0.6;
  pointer-events: none;
}
.diagram-shell__header > * {
  position: relative;
  z-index: 1;
}
.diagram-shell__subtitle {
  color: rgba(244,247,255,0.72);
  margin: 0;
  font-size: 0.95rem;
  text-transform: uppercase;
  letter-spacing: 0.18em;
  font-weight: 500;
  line-height: 1.5;
}
.diagram-hero__heading {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.diagram-hero__heading h1 {
  margin: 0;
  font-size: 2.2rem;
}
.diagram-hero__stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
}
.diagram-toolbar {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 16px;
}
.diagram-toolbar__status,
.diagram-toolbar__actions,
.diagram-toolbar__progress {
  background: rgba(8, 12, 24, 0.8);
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 18px;
  padding: 16px 20px;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
}
.diagram-toolbar__status-title {
  text-transform: uppercase;
  letter-spacing: 0.1em;
  font-size: 0.75rem;
  color: var(--diagram-muted);
}
.diagram-toolbar__status-value {
  display: block;
  margin-top: 6px;
  font-size: 1.05rem;
  font-weight: 600;
}
.diagram-toolbar__actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
  justify-content: center;
}
.diagram-toolbar__hint {
  font-size: 0.78rem;
  color: var(--diagram-muted);
}
.diagram-toolbar__progress {
  display: flex;
  align-items: center;
}
.diagram-toolbar__progress .diagram-loading {
  background: transparent;
  border: none;
  padding: 0;
  box-shadow: none;
}
.diagram-section {
  background: var(--diagram-panel);
  border-radius: 16px;
  padding: 24px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.45);
  animation: diagram-section-reveal 0.8s ease both;
}
.diagram-section--code {
  background: linear-gradient(135deg, rgba(76,201,240,0.1), rgba(5,6,13,0.95));
}
.diagram-section--db {
  background: linear-gradient(135deg, rgba(246,193,119,0.12), rgba(5,6,13,0.95));
  --diagram-db-min-width: 420px;
}
.diagram-section--db .diagram-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--diagram-db-min-width, 420px), 1fr));
  align-items: stretch;
}
.diagram-tile--db {
  width: auto !important;
  height: auto !important;
  min-height: 140px;
  padding: 18px 24px;
  gap: 12px;
}
.diagram-tile--db .diagram-tile__label__text {
  white-space: nowrap;
}
.diagram-tile--db .diagram-tile__meta {
  flex-direction: row;
  flex-wrap: wrap;
  gap: 12px;
}
.diagram-section--features {
  background: linear-gradient(135deg, rgba(199,125,255,0.12), rgba(5,6,13,0.95));
}
.diagram-section__title {
  margin: 0 0 8px;
  font-family: var(--diagram-font-display);
}
.diagram-section__description {
  margin: 0 0 16px;
  color: var(--diagram-muted);
}
.diagram-section__subheading {
  margin: 24px 0 12px;
  font-size: 0.85rem;
  color: var(--diagram-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}
.diagram-code-summary {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-bottom: 20px;
}
.diagram-code-summary__item {
  background: rgba(255,255,255,0.04);
  border-radius: 12px;
  padding: 12px 16px;
  min-width: 160px;
  flex: 1 1 160px;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04);
  animation: diagram-chip-reveal 0.7s ease both;
}
.diagram-code-summary__label {
  display: block;
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--diagram-muted);
}
.diagram-code-summary__value {
  display: block;
  font-size: 1.15rem;
  font-weight: 600;
  color: var(--diagram-text);
  font-family: var(--diagram-font-display);
}
.diagram-code-summary__detail {
  display: block;
  font-size: 0.75rem;
  color: var(--diagram-muted);
}
.diagram-code-layout {
  display: flex;
  flex-direction: column;
  gap: 24px;
}
.diagram-code-sidebar {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.diagram-code-grid {
  position: relative;
}
.diagram-code-grid::before {
  content: "";
  position: absolute;
  inset: 4px;
  border-radius: 20px;
  border: 1px dashed rgba(255,255,255,0.04);
  pointer-events: none;
}
.diagram-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
}
.diagram-tile {
  --diagram-tile-hue: 210;
  --diagram-tile-tint: 62%;
  border-radius: 16px;
  background: linear-gradient(135deg, hsla(var(--diagram-tile-hue), 80%, var(--diagram-tile-tint), 0.2), rgba(255,255,255,0.02));
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  gap: 8px;
  padding: 14px;
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow: 0 12px 24px rgba(5,6,13,0.45);
  position: relative;
  overflow: hidden;
  animation: diagram-tile-reveal 0.75s cubic-bezier(0.2, 0.8, 0.2, 1) both;
  animation-delay: calc(var(--diagram-tile-index, 0) * 40ms);
}
.diagram-tile::before {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.15), transparent 55%);
  opacity: 0.5;
  pointer-events: none;
}
.diagram-tile > * {
  position: relative;
  z-index: 1;
}
.diagram-tile[data-tone="violet"] {
  --diagram-tile-hue: 278;
}
.diagram-tile[data-tone="amber"] {
  --diagram-tile-hue: 40;
}
.diagram-tile[data-tone="berry"] {
  --diagram-tile-hue: 320;
}
.diagram-tile[data-tone="cyan"] {
  --diagram-tile-hue: 195;
}
.diagram-tile__badge {
  align-self: flex-start;
  background: rgba(255,255,255,0.12);
  border-radius: 999px;
  padding: 2px 10px;
  font-size: 0.72rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--diagram-text);
}
.diagram-label {
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.diagram-label__text {
  display: inline-flex;
  max-width: 100%;
}
.diagram-label--multiline .diagram-label__text {
  display: -webkit-box;
  -webkit-line-clamp: var(--diagram-label-lines, 2);
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.diagram-tile__label {
  font-size: 0.85rem;
  color: rgba(235, 245, 255, 0.92);
  display: block;
  line-height: 1.35;
  font-weight: 600;
  letter-spacing: 0.01em;
}
.diagram-tile__value {
  font-size: 1rem;
  font-weight: 600;
}
.diagram-tile__caption {
  font-size: 0.75rem;
  color: var(--diagram-muted);
}
.diagram-label--with-popover {
  position: relative;
  cursor: pointer;
  outline: none;
}
.diagram-label--with-popover:focus-visible {
  outline: 1px dashed rgba(59,160,255,0.8);
  outline-offset: 2px;
}
.diagram-popover {
  position: absolute;
  left: 0;
  top: 100%;
  transform: translateY(6px);
  background: rgba(2, 8, 23, 0.95);
  color: var(--diagram-text);
  padding: 6px 8px;
  border-radius: 6px;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
  font-size: 0.75rem;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.15s ease;
  z-index: 4;
}
.diagram-label--with-popover:hover .diagram-popover,
.diagram-label--with-popover:focus .diagram-popover {
  opacity: 1;
}
.diagram-tile__meta {
  display: flex;
  flex-wrap: wrap;
  gap: 4px 12px;
  margin-top: 6px;
  font-size: 0.7rem;
  line-height: 1.4;
  color: var(--diagram-muted);
}
.diagram-tile__meta-item {
  display: flex;
  gap: 4px;
  align-items: baseline;
}
.diagram-tile__meta-label {
  text-transform: uppercase;
  letter-spacing: 0.04em;
  color: rgba(244,247,255,0.68);
  font-weight: 600;
}
.diagram-tile__meta-value {
  color: var(--diagram-text);
}
.diagram-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-bottom: 12px;
}
.diagram-legend__item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.8rem;
}
.diagram-legend__swatch {
  width: 16px;
  height: 16px;
  border-radius: 4px;
  background: rgba(255,255,255,0.4);
}
.diagram-feature-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 16px;
}
.diagram-feature {
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.05);
  background: rgba(255,255,255,0.02);
  padding: 18px;
  box-shadow: 0 14px 30px rgba(4,6,12,0.6);
  animation: diagram-section-reveal 0.6s ease both;
}
.diagram-feature__header {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
}
.diagram-feature__title {
  margin: 0;
  font-size: 1.28rem;
  font-family: var(--diagram-font-display);
}
.diagram-feature__stats {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}
.diagram-feature__stat-label {
  font-size: 0.72rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(244,247,255,0.65);
}
.diagram-feature__stat-value {
  font-size: 1rem;
  font-weight: 600;
  font-family: var(--diagram-font-body);
}
.diagram-feature__stat {
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
  padding: 6px 10px;
  display: flex;
  flex-direction: column;
  min-width: 90px;
}
.diagram-feature__tags {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}
.diagram-feature__tag {
  background: rgba(255,255,255,0.08);
  border-radius: 999px;
  padding: 2px 10px;
  font-size: 0.72rem;
  letter-spacing: 0.05em;
}
.diagram-feature__description {
  font-size: 1rem;
  line-height: 1.6;
  margin: 4px 0 0;
  color: rgba(244,247,255,0.9);
}
.diagram-feature__files {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.diagram-feature__file-row {
  display: grid;
  grid-template-columns: minmax(0, 1fr) minmax(0, 140px);
  grid-template-areas:
    "bar bar"
    "label meta"
    "segments segments";
  gap: 8px 12px;
  background: rgba(255,255,255,0.03);
  padding: 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.03);
}
.diagram-feature__file-bar {
  grid-area: bar;
  position: relative;
  width: 100%;
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  overflow: hidden;
}
.diagram-feature__file-bar::after {
  content: "";
  position: absolute;
  inset: 0;
  width: var(--diagram-feature-width, 50%);
  background: linear-gradient(90deg, rgba(255,255,255,0.15), var(--diagram-feature-color, #5b7c99));
  border-radius: inherit;
}
.diagram-feature__file-label {
  font-size: 0.9rem;
  color: rgba(235, 245, 255, 0.9);
  grid-area: label;
  line-height: 1.4;
  font-weight: 600;
  white-space: normal;
}
.diagram-feature__file-label .diagram-label__text {
  display: inline;
  white-space: normal;
}
.diagram-feature__file-meta {
  font-size: 0.72rem;
  color: var(--diagram-muted);
  grid-area: meta;
  justify-self: end;
  letter-spacing: 0.04em;
}
.diagram-feature__segments {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  row-gap: 6px;
  grid-area: segments;
}
.diagram-feature__segment {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  font-size: 0.65rem;
  padding: 2px 4px;
  border-radius: 4px;
  background: rgba(255,255,255,0.06);
  white-space: nowrap;
  max-width: 48%;
  overflow: hidden;
  text-overflow: ellipsis;
}
.diagram-code-directories {
  margin-top: 24px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.diagram-code-directories__list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.diagram-code-directory {
  padding: 12px 16px;
  border-radius: 12px;
  background: rgba(255,255,255,0.03);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
  backdrop-filter: blur(6px);
  animation: diagram-chip-reveal 0.8s ease both;
}
.diagram-code-directory__label {
  font-size: 0.9rem;
  color: rgba(235,245,255,0.95);
}
.diagram-code-directory__metrics {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin: 8px 0 10px;
  font-size: 0.75rem;
  color: var(--diagram-muted);
}
.diagram-code-directory__metric {
  display: flex;
  gap: 4px;
  align-items: baseline;
}
.diagram-code-directory__metric-label {
  text-transform: uppercase;
  letter-spacing: 0.06em;
  font-size: 0.68rem;
  color: rgba(244,247,255,0.65);
  font-weight: 600;
}
.diagram-code-directory__metric-value {
  color: var(--diagram-text);
}
.diagram-code-directory__bar {
  width: 100%;
  height: 6px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  overflow: hidden;
}
.diagram-code-directory__bar-fill {
  height: 100%;
  background: linear-gradient(90deg, rgba(59,160,255,0.2), rgba(59,160,255,0.9));
  border-radius: inherit;
  transition: width 0.2s ease;
}
.diagram-loading {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 24px;
  border-radius: 16px;
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
}
.diagram-loading[data-state="error"] {
  border-color: rgba(255,120,120,0.5);
}
.diagram-loading__pulse {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(59,160,255,0.9) 0%, rgba(59,160,255,0) 70%);
  box-shadow: 0 0 40px rgba(59,160,255,0.5);
  animation: diagram-pulse 1.6s ease-in-out infinite;
}
.diagram-loading__title {
  margin: 0;
  font-size: 1.1rem;
}
.diagram-loading__detail {
  margin: 0;
  color: var(--diagram-muted);
}
.diagram-loading__bar {
  width: 100%;
  height: 8px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  overflow: hidden;
}
.diagram-loading__bar-inner {
  width: 45%;
  height: 100%;
  background: linear-gradient(90deg, rgba(59,160,255,0.1), rgba(59,160,255,0.9));
  border-radius: inherit;
  animation: diagram-bar 1.2s ease-in-out infinite;
}
.diagram-loading[data-state="complete"] .diagram-loading__bar-inner {
  width: 100%;
  animation: none;
  background: linear-gradient(90deg, rgba(59,160,255,0.3), rgba(59,160,255,1));
}
.diagram-loading[data-state="error"] .diagram-loading__bar-inner {
  width: 100%;
  animation: none;
  background: linear-gradient(90deg, rgba(255,120,120,0.2), rgba(255,120,120,0.9));
}
@keyframes diagram-pulse {
  0% { transform: scale(0.9); opacity: 0.75; }
  50% { transform: scale(1.05); opacity: 1; }
  100% { transform: scale(0.9); opacity: 0.75; }
}
@keyframes diagram-bar {
  0% { transform: translateX(-40%); }
  50% { transform: translateX(0%); }
  100% { transform: translateX(110%); }
}
.diagram-diagnostics {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 16px;
}
.diagram-diagnostics__item {
  position: relative;
  padding: 16px 18px;
  border-radius: 16px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.04);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
  min-height: 90px;
  overflow: hidden;
}
.diagram-diagnostics__item::before {
  content: attr(data-icon);
  position: absolute;
  top: 12px;
  right: 16px;
  font-size: 1.4rem;
  opacity: 0.15;
}
.diagram-diagnostics__label {
  text-transform: uppercase;
  font-size: 0.78rem;
  letter-spacing: 0.06em;
  color: rgba(244,247,255,0.75);
  font-family: var(--diagram-font-body);
  font-weight: 600;
}
.diagram-diagnostics__value {
  font-size: 1.35rem;
  font-weight: 600;
  line-height: 1.3;
  font-family: var(--diagram-font-display);
}
.diagram-diagnostics__detail {
  font-size: 0.75rem;
  color: var(--diagram-muted);
  letter-spacing: 0.04em;
}
.diagram-button {
  border: none;
  border-radius: 999px;
  padding: 10px 22px;
  font-size: 1rem;
  letter-spacing: 0.04em;
  font-weight: 600;
  cursor: pointer;
  background: var(--diagram-accent);
  color: #020817;
  transition: opacity 0.2s ease;
  box-shadow: 0 10px 25px rgba(76,201,240,0.3);
}
.diagram-button[data-loading="1"],
.diagram-button:disabled {
  opacity: 0.6;
  cursor: wait;
}

@media (min-width: 1100px) {
  .diagram-shell__header {
    flex-direction: row;
    justify-content: space-between;
    align-items: flex-end;
  }
  .diagram-code-layout {
    flex-direction: row;
    align-items: flex-start;
  }
  .diagram-code-sidebar {
    flex: 0 0 320px;
    position: sticky;
    top: 32px;
  }
  .diagram-code-grid {
    flex: 1;
  }
}

@keyframes diagram-section-reveal {
  from {
    opacity: 0;
    transform: translateY(16px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes diagram-chip-reveal {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes diagram-tile-reveal {
  from {
    opacity: 0;
    transform: translateY(14px) scale(0.98);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
  `;
        }
        return {
          DiagramProgressControl,
          buildDiagramAtlasStyles,
          buildCodeSection,
          buildDbSection,
          buildFeatureSection
        };
      }
      module.exports = {
        createDiagramAtlasControls
      };
    }
  });

  // src/ui/client/diagramAtlas.js
  var require_diagramAtlas = __commonJS({
    "src/ui/client/diagramAtlas.js"(exports, module) {
      "use strict";
      var { createDiagramAtlasControls: defaultDiagramAtlasFactory } = require_diagramAtlasControlsFactory();
      function formatNumber(value2, fallback = "\u2014") {
        if (!Number.isFinite(value2)) {
          return fallback;
        }
        return value2.toLocaleString("en-US");
      }
      function formatBytes(bytes, fallback = "\u2014") {
        if (!Number.isFinite(bytes) || bytes <= 0) {
          return fallback;
        }
        const units = ["B", "KB", "MB", "GB", "TB"];
        const exponent = Math.min(units.length - 1, Math.floor(Math.log(bytes) / Math.log(1024)));
        const value2 = bytes / 1024 ** exponent;
        const fixed = value2 >= 100 ? value2.toFixed(0) : value2 >= 10 ? value2.toFixed(1) : value2.toFixed(2);
        return `${fixed} ${units[exponent]}`;
      }
      function formatTimestamp(value2) {
        if (!value2) return "\u2014";
        const parsed = new Date(value2);
        if (Number.isNaN(parsed.getTime())) {
          return value2;
        }
        return parsed.toLocaleString();
      }
      function setNodeText(node, text) {
        if (!node) return;
        node.textContent = text == null ? "" : String(text);
      }
      function createElement(doc, tag, className, text) {
        const el = doc.createElement(tag);
        if (className) {
          el.className = className;
        }
        if (text != null) {
          el.textContent = text;
        }
        return el;
      }
      function collectDiagnosticsMap(shell) {
        const diagnostics = {};
        shell.querySelectorAll("[data-metric]").forEach((node) => {
          const metric = node.getAttribute("data-metric");
          if (!metric) return;
          diagnostics[metric] = {
            container: node,
            value: node.querySelector(".diagram-diagnostics__value") || node
          };
        });
        const toolbar = {};
        shell.querySelectorAll("[data-toolbar-metric]").forEach((node) => {
          const metric = node.getAttribute("data-toolbar-metric");
          if (!metric) return;
          toolbar[metric] = node;
        });
        return { diagnostics, toolbar };
      }
      function createDiagramAtlasBootstrap2(options = {}) {
        const {
          jsguiClient: jsguiClient2,
          createDiagramAtlasControls = defaultDiagramAtlasFactory,
          registerControls
        } = options;
        if (!jsguiClient2) {
          throw new Error("createDiagramAtlasBootstrap requires a jsguiClient instance");
        }
        const atlasControlsFactory = typeof createDiagramAtlasControls === "function" ? createDiagramAtlasControls : defaultDiagramAtlasFactory;
        const diagramAtlasSharedControls = atlasControlsFactory(jsguiClient2);
        const {
          DiagramProgressControl,
          buildCodeSection,
          buildDbSection,
          buildFeatureSection
        } = diagramAtlasSharedControls;
        let diagramAtlasContext = null;
        const DIAGRAM_STATUS_POLL_MS = 1500;
        function getDiagramAtlasContext() {
          if (typeof document === "undefined") {
            return null;
          }
          if (diagramAtlasContext && diagramAtlasContext.document === document) {
            return diagramAtlasContext;
          }
          if (typeof jsguiClient2.Client_Page_Context === "function") {
            diagramAtlasContext = new jsguiClient2.Client_Page_Context({ document });
            if (typeof registerControls === "function") {
              registerControls(diagramAtlasContext);
            }
          } else {
            diagramAtlasContext = null;
          }
          return diagramAtlasContext;
        }
        function renderControlToFragment(control) {
          if (!control || typeof document === "undefined") {
            return null;
          }
          const html = typeof control.all_html_render === "function" ? control.all_html_render() : "";
          if (!html) {
            return null;
          }
          const template = document.createElement("template");
          template.innerHTML = html;
          return template.content;
        }
        function renderAtlasSections(target, payload) {
          if (!target) return;
          while (target.firstChild) {
            target.removeChild(target.firstChild);
          }
          const context2 = getDiagramAtlasContext();
          if (!context2) {
            target.appendChild(createElement(document, "div", "diagram-shell__placeholder", "Diagram context unavailable."));
            return;
          }
          const sections = [];
          if (payload && payload.code) {
            sections.push(buildCodeSection(context2, payload.code));
          }
          if (payload && payload.db) {
            sections.push(buildDbSection(context2, payload.db));
          }
          if (payload && payload.features) {
            sections.push(buildFeatureSection(context2, payload.features));
          }
          const fragment = document.createDocumentFragment();
          sections.forEach((sectionControl) => {
            const rendered = renderControlToFragment(sectionControl);
            if (rendered) {
              fragment.appendChild(rendered);
            }
          });
          if (fragment.childNodes.length) {
            target.appendChild(fragment);
          } else {
            target.appendChild(createElement(document, "div", "diagram-shell__placeholder", "Diagram Atlas will populate once data loads."));
          }
        }
        function updateDiagnostics(nodes, payload) {
          if (!nodes) return;
          const diagnosticEntries = nodes.diagnostics;
          const codeSummary = payload && payload.code && payload.code.summary ? payload.code.summary : {};
          const topFiles = payload && payload.code && Array.isArray(payload.code.topFiles) ? payload.code.topFiles : [];
          const largestFile = topFiles.length ? topFiles[0] : null;
          const stats = {
            generatedAt: {
              text: formatTimestamp(payload && payload.generatedAt)
            },
            codeFiles: {
              text: formatNumber(codeSummary.fileCount)
            },
            codeBytes: {
              text: formatBytes(codeSummary.totalBytes),
              tooltip: Number.isFinite(codeSummary.totalBytes) ? `${formatNumber(codeSummary.totalBytes)} bytes` : null
            },
            largestFile: largestFile ? { text: formatBytes(largestFile.bytes), tooltip: largestFile.file } : { text: "\u2014" },
            dbTables: {
              text: formatNumber(payload && payload.db && payload.db.totalTables)
            },
            features: {
              text: formatNumber(payload && payload.features && payload.features.featureCount)
            }
          };
          if (diagnosticEntries) {
            Object.keys(stats).forEach((key2) => {
              if (!Object.prototype.hasOwnProperty.call(diagnosticEntries, key2)) return;
              const entry = diagnosticEntries[key2];
              if (!entry) return;
              const valueNode = entry.value || entry;
              const details = stats[key2] || {};
              setNodeText(valueNode, details.text == null ? "\u2014" : String(details.text));
              if (details.tooltip) {
                entry.container.setAttribute("title", details.tooltip);
              } else {
                entry.container.removeAttribute("title");
              }
            });
          }
          if (nodes.toolbar) {
            Object.keys(nodes.toolbar).forEach((metric) => {
              if (!Object.prototype.hasOwnProperty.call(stats, metric)) return;
              const target = nodes.toolbar[metric];
              if (!target) return;
              const details = stats[metric] || {};
              setNodeText(target, details.text == null ? "\u2014" : String(details.text));
            });
          }
        }
        function resolveProgressControl(progressEl) {
          if (!progressEl || typeof DiagramProgressControl !== "function") {
            return null;
          }
          if (progressEl.__diagramProgressControl) {
            return progressEl.__diagramProgressControl;
          }
          const context2 = getDiagramAtlasContext();
          if (!context2) {
            return null;
          }
          try {
            const control = new DiagramProgressControl({ context: context2, el: progressEl });
            control.activate(progressEl);
            progressEl.__diagramProgressControl = control;
            return control;
          } catch (error2) {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("[copilot] unable to bind diagram progress control", error2);
            }
            return null;
          }
        }
        function setProgressState(progressEl, status, label, detail) {
          if (!progressEl) return;
          const progressControl = resolveProgressControl(progressEl);
          if (progressControl && typeof progressControl.setStatus === "function") {
            const currentState = progressControl._state || {};
            progressControl.setStatus(status || currentState.status, detail || currentState.detail);
          }
          if (status) {
            progressEl.setAttribute("data-state", status);
          }
          if (label) {
            const titleNode = progressEl.querySelector(".diagram-loading__title");
            setNodeText(titleNode, label);
          }
          if (detail) {
            const detailNode = progressEl.querySelector(".diagram-loading__detail");
            setNodeText(detailNode, detail);
          }
        }
        function renderAtlasError(target, message) {
          if (!target) return;
          const errorNode = createElement(document, "div", "diagram-shell__placeholder", message || "Failed to load diagram atlas data.");
          target.innerHTML = "";
          target.appendChild(errorNode);
        }
        function setRefreshButtonState(button, loading) {
          if (!button) return;
          if (loading) {
            button.dataset.loading = "1";
            button.setAttribute("disabled", "disabled");
          } else {
            delete button.dataset.loading;
            button.removeAttribute("disabled");
          }
        }
        function stopDiagramStatusWatcher(nodes) {
          if (!nodes || typeof nodes.statusWatcherStop !== "function") {
            return;
          }
          try {
            nodes.statusWatcherStop();
          } finally {
            nodes.statusWatcherStop = null;
          }
        }
        function handleDiagramStatus(status, nodes) {
          if (!status || !nodes) {
            return;
          }
          if (status.state === "refreshing") {
            const detail = status.detail || (status.startedAt ? `Running since ${formatTimestamp(status.startedAt)}` : "diagram-data CLI running...");
            setProgressState(nodes.progress, "loading", "Refreshing diagram data", detail);
            return;
          }
          if (status.state === "error") {
            const errorDetail = status.lastError && status.lastError.message ? status.lastError.message : "Check server logs for details";
            setProgressState(nodes.progress, "error", "Diagram refresh failed", errorDetail);
          }
        }
        function startDiagramStatusWatcher(config, nodes) {
          if (!nodes || !nodes.progress || typeof fetch !== "function") {
            return null;
          }
          const statusUrl = config && config.statusUrl || "/api/diagram-data/status";
          let stopped = false;
          const poll = async () => {
            if (stopped) {
              return;
            }
            try {
              const response = await fetch(statusUrl, { headers: { Accept: "application/json" } });
              if (!response.ok) {
                stopped = true;
                return;
              }
              const status = await response.json();
              handleDiagramStatus(status, nodes);
              if (!stopped && status && status.state === "refreshing") {
                setTimeout(poll, DIAGRAM_STATUS_POLL_MS);
                return;
              }
              if (!status || status.state !== "pending") {
                stopped = true;
              }
            } catch (error2) {
              stopped = true;
              if (typeof console !== "undefined" && console.debug) {
                console.debug("[copilot] diagram status poll stopped", error2);
              }
            }
          };
          poll();
          return () => {
            stopped = true;
          };
        }
        function attachRefreshHandler(config, nodes) {
          if (!nodes || !nodes.refresh) {
            return;
          }
          const button = nodes.refresh;
          button.addEventListener("click", () => {
            if (button.dataset.loading === "1") {
              return;
            }
            setRefreshButtonState(button, true);
            stopDiagramStatusWatcher(nodes);
            hydrateDiagramAtlas(config, nodes, { forceRefresh: true }).catch(() => {
            }).finally(() => setRefreshButtonState(button, false));
          });
        }
        async function hydrateDiagramAtlas(config, nodes, options2 = {}) {
          const dataUrl = config && config.dataUrl || "/api/diagram-data";
          const forceRefresh = Boolean(options2.forceRefresh);
          const shouldRefresh = forceRefresh && config && config.refreshUrl;
          const endpoint = shouldRefresh ? config.refreshUrl : dataUrl;
          const method = shouldRefresh ? "POST" : "GET";
          const label = shouldRefresh ? "Refreshing diagram data" : "Fetching diagram data";
          const detail = shouldRefresh ? "Triggering CLI + cache refresh..." : "Collecting sources and metrics...";
          setProgressState(nodes.progress, "loading", label, detail);
          if (shouldRefresh) {
            const stopWatcher = startDiagramStatusWatcher(config, nodes);
            if (stopWatcher) {
              nodes.statusWatcherStop = stopWatcher;
            }
          }
          try {
            const response = await fetch(endpoint, {
              method,
              headers: { Accept: "application/json", "Content-Type": "application/json" }
            });
            if (!response.ok) {
              throw new Error(`Request failed with status ${response.status}`);
            }
            const payload = await response.json();
            updateDiagnostics(nodes, payload);
            renderAtlasSections(nodes.sections, payload);
            setProgressState(nodes.progress, "complete", "Diagram Atlas ready", payload.generatedAt || "Loaded from cache");
            if (typeof window !== "undefined") {
              window.__DIAGRAM_ATLAS_STATE__ = payload;
            }
          } catch (error2) {
            setProgressState(nodes.progress, "error", "Failed to load diagram data", error2.message);
            renderAtlasError(nodes.sections, error2.message);
            if (typeof console !== "undefined" && console.error) {
              console.error("[copilot] diagram atlas hydration failed", error2);
            }
          } finally {
            stopDiagramStatusWatcher(nodes);
          }
        }
        function applyInitialDiagramPayload(config, nodes) {
          if (!config || !config.initialData) return false;
          updateDiagnostics(nodes, config.initialData);
          renderAtlasSections(nodes.sections, config.initialData);
          setProgressState(nodes.progress, "complete", "Diagram Atlas ready", config.initialData.generatedAt || "Loaded from snapshot");
          return true;
        }
        function bootstrapDiagramAtlas2() {
          if (typeof document === "undefined" || typeof window === "undefined") {
            return;
          }
          const config = window.__DIAGRAM_ATLAS__ || null;
          if (!config) {
            return;
          }
          const shell = document.querySelector('[data-role="diagram-shell"]');
          if (!shell || shell.dataset.diagramHydrated === "1") {
            return;
          }
          shell.dataset.diagramHydrated = "1";
          const sections = shell.querySelector('[data-role="diagram-atlas-sections"]');
          const progress = shell.querySelector('[data-role="diagram-progress"]');
          const refresh = shell.querySelector('[data-role="diagram-refresh"]');
          const metricNodes = collectDiagnosticsMap(shell);
          const nodes = {
            shell,
            sections,
            progress,
            refresh,
            diagnostics: metricNodes.diagnostics,
            toolbar: metricNodes.toolbar,
            statusWatcherStop: null
          };
          attachRefreshHandler(config, nodes);
          if (applyInitialDiagramPayload(config, nodes)) {
            return;
          }
          hydrateDiagramAtlas(config, nodes);
        }
        return {
          bootstrapDiagramAtlas: bootstrapDiagramAtlas2
        };
      }
      module.exports = {
        createDiagramAtlasBootstrap: createDiagramAtlasBootstrap2
      };
    }
  });

  // src/ui/client/jobsManager.js
  var require_jobsManager = __commonJS({
    "src/ui/client/jobsManager.js"(exports, module) {
      var { each } = require_lang2();
      function createJobsManager2({
        elements = {},
        actions = {},
        scheduleResumeInventoryRefresh = () => {
        }
      }) {
        const jobsList = elements && elements.jobsList ? elements.jobsList : null;
        const {
          setStage = () => {
          },
          setPausedBadge = () => {
          },
          hidePausedBadge = () => {
          },
          setCrawlType = () => {
          },
          updateStartupStatus = () => {
          }
        } = actions;
        function clamp01(n) {
          const x = Number(n);
          if (!Number.isFinite(x)) return 0;
          if (x < 0) return 0;
          if (x > 1) return 1;
          return x;
        }
        function deriveQueueDrainProgress({ visited, queueSize, status, paused }) {
          const v = Number(visited != null ? visited : 0);
          const q = Number(queueSize != null ? queueSize : 0);
          const denom = v + q;
          if (Number.isFinite(denom) && denom > 0) {
            const ratio = clamp01(v / denom);
            return { mode: "determinate", ratio };
          }
          const s = String(status || "").toLowerCase();
          if (!paused && s.includes("run")) {
            return { mode: "indeterminate", ratio: null };
          }
          return null;
        }
        function renderEmptyState(target) {
          if (!target) {
            return;
          }
          target.innerHTML = '<div class="jobs-empty-state"><span class="jobs-empty-icon">\u{1F4ED}</span><p>No active crawls</p></div>';
          setStage("idle");
          hidePausedBadge();
          scheduleResumeInventoryRefresh(600);
          target.setAttribute("aria-busy", "false");
        }
        function renderJobs(jobs) {
          try {
            if (!jobsList) {
              return;
            }
            jobsList.setAttribute("aria-busy", "true");
            if (!jobs || !Array.isArray(jobs.items) || jobs.items.length === 0) {
              renderEmptyState(jobsList);
              return;
            }
            const cards = [];
            each(jobs.items, (job) => {
              var _a, _b, _c, _d, _e;
              const url = job.url || "(unknown)";
              const visited = (_a = job.visited) != null ? _a : 0;
              const downloaded = (_c = (_b = job.download) != null ? _b : job.downloaded) != null ? _c : 0;
              const errors = (_d = job.errors) != null ? _d : 0;
              const queueSize = (_e = job.queueSize) != null ? _e : 0;
              const stage = job.stage || "";
              const status = job.status || stage || "running";
              const pid = job.pid ? job.pid : null;
              const startedAt = job.startedAt ? new Date(job.startedAt).toLocaleString() : "Unknown";
              const lastActivity = job.lastActivityAt ? Math.round((Date.now() - job.lastActivityAt) / 1e3) : null;
              const activityClass = lastActivity && lastActivity < 10 ? "activity-recent" : lastActivity && lastActivity < 60 ? "activity-active" : "activity-stale";
              const activityText = lastActivity !== null ? `${lastActivity}s ago` : "No recent activity";
              let statusBadgeClass = "status-badge";
              if (status === "running" && !job.paused) statusBadgeClass += " status-badge--running";
              else if (job.paused) statusBadgeClass += " status-badge--paused";
              else if (status === "done") statusBadgeClass += " status-badge--done";
              else statusBadgeClass += " status-badge--neutral";
              const startupSummary = job.startup && typeof job.startup === "object" ? job.startup.summary : null;
              const startupProgress = startupSummary && startupSummary.done === false && Number.isFinite(startupSummary.progress) ? Math.round(Math.max(0, Math.min(1, startupSummary.progress)) * 100) : null;
              const startupHtml = startupProgress !== null ? `<div class="job-card-startup"><span class="job-card-startup-label">Startup:</span><span class="job-card-startup-value">${startupProgress}%</span></div>` : "";
              const statusTextHtml = job.statusText ? `<div class="job-card-status-text">${job.statusText}</div>` : "";
              const progressModel = deriveQueueDrainProgress({
                visited,
                queueSize,
                status,
                paused: job.paused
              });
              const progressHtml = progressModel ? progressModel.mode === "indeterminate" ? `<div class="job-card-progress"><div class="job-card-progress-bar job-card-progress-bar--indeterminate"><div class="job-card-progress-fill"></div></div><div class="job-card-progress-value">running</div></div>` : (() => {
                const pct = Math.round(clamp01(progressModel.ratio) * 100);
                return `<div class="job-card-progress"><div class="job-card-progress-bar" title="${pct}%"><div class="job-card-progress-fill" style="width:${pct}%"></div></div><div class="job-card-progress-value">${pct}%</div></div>`;
              })() : "";
              cards.push(`
          <div class="job-card">
            <div class="job-card-header">
              <div class="job-card-status">
                <span class="${statusBadgeClass}">${status}</span>
                ${stage && stage !== status ? `<span class="job-card-stage">${stage}</span>` : ""}
                ${job.paused ? '<span class="job-card-paused-indicator">\u23F8 Paused</span>' : ""}
              </div>
              ${pid ? `<span class="job-card-pid">PID: ${pid}</span>` : ""}
            </div>

            <div class="job-card-url">
              <a href="/url?url=${encodeURIComponent(url)}" class="job-card-link" title="${url}">${url}</a>
            </div>

            ${statusTextHtml}
            ${startupHtml}

            <div class="job-card-metrics">
              <div class="job-card-metric">
                <span class="job-card-metric-label">Visited</span>
                <span class="job-card-metric-value">${visited.toLocaleString()}</span>
              </div>
              <div class="job-card-metric">
                <span class="job-card-metric-label">Downloaded</span>
                <span class="job-card-metric-value">${downloaded.toLocaleString()}</span>
              </div>
              <div class="job-card-metric">
                <span class="job-card-metric-label">Errors</span>
                <span class="job-card-metric-value ${errors > 0 ? "job-card-metric-value--error" : ""}">${errors.toLocaleString()}</span>
              </div>
              <div class="job-card-metric">
                <span class="job-card-metric-label">Queue</span>
                <span class="job-card-metric-value">${queueSize.toLocaleString()}</span>
              </div>
            </div>

            ${progressHtml}

            <div class="job-card-footer">
              <div class="job-card-time">
                <span class="job-card-time-label">Started:</span>
                <span class="job-card-time-value">${startedAt}</span>
              </div>
              <div class="job-card-activity ${activityClass}">
                <span class="job-card-activity-indicator">\u25CF</span>
                <span class="job-card-activity-text">${activityText}</span>
              </div>
            </div>
          </div>
        `);
            });
            jobsList.innerHTML = cards.join("");
            jobsList.setAttribute("aria-busy", "false");
            if (jobs.items.length === 1) {
              const job = jobs.items[0];
              if (job.startup || job.statusText) {
                updateStartupStatus(job.startup, job.statusText);
              }
              setStage(job.stage || job.status || "running");
              if (job.paused != null) {
                setPausedBadge(!!job.paused);
              } else if (job.status === "done") {
                hidePausedBadge();
              }
              if (job.stage && /intelligent/i.test(job.stage)) {
                const stageType = job.crawlType === "discover-structure" ? "discover-structure" : "intelligent";
                setCrawlType(stageType);
              }
            } else {
              setStage("multi-run");
              setPausedBadge(null);
              updateStartupStatus(null, null);
            }
            scheduleResumeInventoryRefresh(1200);
          } catch (_) {
          } finally {
            if (jobsList) {
              jobsList.setAttribute("aria-busy", "false");
            }
          }
        }
        async function initialJobsPoll() {
          try {
            const response = await fetch("/api/crawls");
            if (!response.ok) {
              return;
            }
            const payload = await response.json();
            renderJobs(payload);
          } catch (_) {
          }
        }
        return {
          renderJobs,
          initialJobsPoll
        };
      }
      module.exports = {
        createJobsManager: createJobsManager2
      };
    }
  });

  // src/ui/client/sseHandlers.js
  var require_sseHandlers = __commonJS({
    "src/ui/client/sseHandlers.js"(exports, module) {
      var { is_defined } = require_lang2();
      function createSseHandlers2({
        jobsManager,
        diagramAtlas,
        scheduleResumeInventoryRefresh,
        updateStartupStatus,
        jobsList
      }) {
        let eventSource;
        let reconnectTimer;
        function cleanup() {
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
          }
        }
        function handleJobsUpdate(payload) {
          if (jobsManager && payload && payload.items) {
            jobsManager.renderJobs(payload);
          }
        }
        function handleDiagramAtlas(payload) {
          if (!diagramAtlas || !payload) {
            return;
          }
          if (payload.sections) {
            diagramAtlas.renderAtlasSections(payload.sections);
          }
          if (payload.status) {
            diagramAtlas.renderAtlasStatus(payload.status);
          }
        }
        function handleResumeInventory(payload) {
          const delay = payload && Number.isFinite(payload.delayMs) ? payload.delayMs : 2e3;
          scheduleResumeInventoryRefresh(delay);
        }
        function handleStartupStatus(payload) {
          if (!payload) {
            return;
          }
          updateStartupStatus(payload.startup, payload.statusText);
        }
        function attachSse() {
          cleanup();
          const source = new EventSource("/api/events");
          eventSource = source;
          source.addEventListener("open", () => {
            if (jobsList) {
              jobsList.setAttribute("aria-busy", "true");
            }
          });
          source.addEventListener("message", (evt) => {
            try {
              if (!evt.data) {
                return;
              }
              const payload = JSON.parse(evt.data);
              if (!payload || !payload.type) {
                return;
              }
              switch (payload.type) {
                case "jobs:update":
                  handleJobsUpdate(payload.data);
                  break;
                case "diagramAtlas:update":
                  handleDiagramAtlas(payload.data);
                  break;
                case "jobs:resumeInventory":
                  handleResumeInventory(payload.data);
                  break;
                case "jobs:startupStatus":
                  handleStartupStatus(payload.data);
                  break;
                default:
                  break;
              }
            } catch (_) {
            }
          });
          source.addEventListener("error", () => {
            cleanup();
            reconnectTimer = setTimeout(attachSse, 2e3);
          });
        }
        function initSse() {
          if (!is_defined(window) || typeof window.EventSource !== "function") {
            return;
          }
          attachSse();
        }
        return {
          initSse,
          cleanup
        };
      }
      module.exports = {
        createSseHandlers: createSseHandlers2
      };
    }
  });

  // src/ui/client/index.js
  if (typeof globalThis !== "undefined" && !globalThis.page_context) {
    globalThis.page_context = {};
  }
  var { installConsoleNoiseFilter } = require_consoleNoiseFilter();
  installConsoleNoiseFilter();
  var jsguiClient = require_client();
  var { installBindingPlugin } = require_bindingPlugin();
  var { ensureControlsRegistered, listControlTypes } = require_controlManifest();
  var { ensureGlobalListingStateStore } = require_listingStateStore();
  var { attachListingDomBindings } = require_listingDomBindings();
  var { createDiagramAtlasBootstrap } = require_diagramAtlas();
  var { createJobsManager } = require_jobsManager();
  var { createSseHandlers } = require_sseHandlers();
  var REGISTERED_CONTROLS = ensureControlsRegistered(jsguiClient);
  var REGISTERED_CONTROL_TYPES = REGISTERED_CONTROLS.map((entry) => entry.type);
  var DEFAULT_EXPECTED_CONTROL_TYPES = listControlTypes();
  var { bootstrapDiagramAtlas } = createDiagramAtlasBootstrap({
    jsguiClient,
    registerControls: injectControlsIntoContext
  });
  function seedContextControlMap(context2) {
    if (!context2) {
      return null;
    }
    const map = context2.map_Controls || (context2.map_Controls = {});
    if (!context2.__copilotControlsSeeded) {
      const sources = [jsguiClient.map_Controls, jsguiClient.controls];
      sources.forEach((source) => {
        if (!source) return;
        Object.keys(source).forEach((key2) => {
          if (!key2) return;
          const normalized = key2.toLowerCase();
          if (!map[normalized]) {
            map[normalized] = source[key2];
          }
        });
      });
      context2.__copilotControlsSeeded = true;
    }
    REGISTERED_CONTROLS.forEach(({ type, control }) => {
      if (!control) return;
      const proto = control.prototype || {};
      const key2 = (type || proto.__type_name || "").toLowerCase();
      if (!key2 || map[key2]) {
        return;
      }
      map[key2] = control;
    });
    return map;
  }
  function ensureClientControlsRegistered() {
    return REGISTERED_CONTROLS;
  }
  ensureClientControlsRegistered();
  function injectControlsIntoContext(context2) {
    if (!context2) {
      return;
    }
    const map = seedContextControlMap(context2);
    if (!map) {
      return;
    }
    const shouldLogControls = typeof window !== "undefined" && window.__COPILOT_UI_DEBUG__ === true && !window.__COPILOT_LOGGED_CONTROLS__;
    if (shouldLogControls) {
      window.__COPILOT_LOGGED_CONTROLS__ = true;
      try {
        console.log("[copilot] context.map_Controls keys", Object.keys(map));
      } catch (_) {
      }
    }
    REGISTERED_CONTROLS.forEach(({ control, type }) => {
      if (!control) return;
      const proto = control.prototype || {};
      const key2 = (type || proto.__type_name || "").toLowerCase();
      if (!key2 || map[key2]) {
        return;
      }
      map[key2] = control;
      if (typeof context2.update_Controls === "function") {
        context2.update_Controls(key2, control);
      }
    });
  }
  function verifyExpectedControls() {
    if (typeof window === "undefined") {
      return;
    }
    const expected = Array.isArray(window.__COPILOT_EXPECTED_CONTROLS__) ? window.__COPILOT_EXPECTED_CONTROLS__ : DEFAULT_EXPECTED_CONTROL_TYPES;
    const missing = (expected || []).map((type) => (type || "").toLowerCase()).filter((type) => type && !REGISTERED_CONTROL_TYPES.includes(type));
    if (missing.length && typeof console !== "undefined" && console.warn) {
      console.warn("[copilot] missing registered jsgui controls", missing);
    }
    window.__COPILOT_EXPECTED_CONTROLS__ = expected;
    window.__COPILOT_REGISTERED_CONTROLS__ = REGISTERED_CONTROL_TYPES;
  }
  function wrapPreActivate(fn) {
    if (typeof fn !== "function") {
      return fn;
    }
    if (fn.__copilotWrapped) {
      return fn;
    }
    const wrapped = function copilotPreActivate(context2, ...args) {
      injectControlsIntoContext(context2);
      return fn.call(this, context2, ...args);
    };
    wrapped.__copilotWrapped = true;
    return wrapped;
  }
  function ensurePreActivateHook() {
    if (typeof jsguiClient.pre_activate !== "function") {
      return;
    }
    jsguiClient.pre_activate = wrapPreActivate(jsguiClient.pre_activate);
  }
  ensurePreActivateHook();
  var originalUpdateStandardControls = typeof jsguiClient.update_standard_Controls === "function" ? jsguiClient.update_standard_Controls : null;
  if (originalUpdateStandardControls) {
    jsguiClient.update_standard_Controls = function patchedUpdateStandardControls(context2, ...args) {
      ensureClientControlsRegistered();
      injectControlsIntoContext(context2);
      return originalUpdateStandardControls.call(this, context2, ...args);
    };
  }
  var originalActivate = typeof jsguiClient.activate === "function" ? jsguiClient.activate : null;
  if (originalActivate) {
    jsguiClient.activate = function patchedActivate(context2, ...args) {
      injectControlsIntoContext(context2);
      return originalActivate.call(this, context2, ...args);
    };
  }
  var ClientPageContext = jsguiClient.Client_Page_Context;
  if (typeof ClientPageContext === "function") {
    class CopilotClientPageContext extends ClientPageContext {
      constructor(...args) {
        super(...args);
        injectControlsIntoContext(this);
      }
    }
    jsguiClient.Client_Page_Context = CopilotClientPageContext;
  }
  function readScriptDatasetConfig() {
    if (typeof document === "undefined") return {};
    const script = document.currentScript || (document.getElementsByTagName("script") || [])[document.getElementsByTagName("script").length - 1];
    if (!script || !script.dataset) return {};
    const datasetValue = script.dataset.bindingPlugin;
    if (!datasetValue) return {};
    const normalized = datasetValue.trim().toLowerCase();
    if (!normalized) return {};
    return { enabled: normalized !== "off" && normalized !== "false" && normalized !== "0" };
  }
  function resolveBindingPluginConfig() {
    var _a, _b;
    const datasetConfig = readScriptDatasetConfig();
    const globalConfig = typeof window !== "undefined" && window.CopilotBindingPlugin || {};
    const envDefault = typeof process !== "undefined" ? "true" : void 0;
    const defaultEnabled = envDefault === void 0 ? true : envDefault !== "false";
    const enabled = ((_b = (_a = datasetConfig.enabled) != null ? _a : globalConfig.enabled) != null ? _b : defaultEnabled) !== false;
    return { enabled };
  }
  function bootstrapUrlListingStore() {
    if (typeof window === "undefined") {
      return;
    }
    const initialState = window.__COPILOT_URL_LISTING_STATE__;
    const store = ensureGlobalListingStateStore(initialState);
    if (!store) {
      return;
    }
    attachListingDomBindings(store);
  }
  function selectDomElement(selectors) {
    if (typeof document === "undefined" || !Array.isArray(selectors)) {
      return null;
    }
    for (let i = 0; i < selectors.length; i += 1) {
      const selector = selectors[i];
      if (!selector) continue;
      const node = document.querySelector(selector);
      if (node) {
        return node;
      }
    }
    return null;
  }
  function showNode(node) {
    if (!node) return;
    node.removeAttribute("hidden");
  }
  function hideNode(node) {
    if (!node) return;
    node.setAttribute("hidden", "hidden");
  }
  function createStatusIndicators() {
    if (typeof document === "undefined") {
      const noop = () => {
      };
      return {
        elements: {},
        actions: {
          setStage: noop,
          setPausedBadge: noop,
          hidePausedBadge: noop,
          setCrawlType: noop,
          updateStartupStatus: noop
        }
      };
    }
    const elements = {
      stageBadge: selectDomElement(["[data-crawl-stage]", "#stageBadge"]),
      pausedBadge: selectDomElement(["[data-crawl-paused]", "#pausedBadge"]),
      startupStatusEl: selectDomElement(["[data-crawl-startup-status]", "#startupStatus"]),
      startupStatusText: selectDomElement(["[data-crawl-startup-text]", "#startupStatusText"]),
      startupProgressFill: selectDomElement(["[data-crawl-startup-progress]", "#startupProgressFill", "#startupProgress"]),
      startupStagesList: selectDomElement(["[data-crawl-startup-stages]", "#startupStages"]),
      crawlTypeLabel: selectDomElement(["[data-crawl-type-label]", "#crawlTypeLabel"]),
      jobsList: selectDomElement(["[data-crawl-jobs-list]", "#jobsList"])
    };
    function setStage(stage) {
      const normalized = stage ? String(stage).replace(/[_-]+/g, " ") : "idle";
      if (elements.stageBadge) {
        elements.stageBadge.textContent = normalized;
        elements.stageBadge.setAttribute("data-stage", stage || "idle");
      }
      if (typeof document !== "undefined" && document.body) {
        document.body.setAttribute("data-crawl-stage", stage || "");
      }
    }
    function setPausedBadge(paused) {
      const target = elements.pausedBadge;
      if (!target) {
        return;
      }
      if (paused == null) {
        target.textContent = "";
        target.dataset.state = "hidden";
        hideNode(target);
        return;
      }
      const label = paused ? "Paused" : "Running";
      target.textContent = label;
      target.dataset.state = paused ? "paused" : "running";
      showNode(target);
    }
    function hidePausedBadge() {
      setPausedBadge(null);
    }
    function setCrawlType(type) {
      const normalized = type ? String(type) : "";
      if (elements.crawlTypeLabel) {
        elements.crawlTypeLabel.textContent = normalized || "standard";
      }
      if (typeof document !== "undefined" && document.body) {
        document.body.setAttribute("data-crawl-type", normalized);
      }
    }
    function updateStartupStatus(startup, statusText) {
      const container = elements.startupStatusEl;
      if (!container) {
        return;
      }
      const summary = startup && typeof startup.summary === "object" ? startup.summary : null;
      const stages = Array.isArray(startup && startup.stages) ? startup.stages : [];
      const done = summary && summary.done;
      const runningStage = stages.find((stage) => stage && stage.status === "running");
      const label = statusText || runningStage && runningStage.label || (stages.length ? stages[stages.length - 1].label : null) || (done ? "Startup complete" : null);
      if (!startup && !statusText) {
        container.dataset.state = "idle";
        if (elements.startupStagesList) {
          elements.startupStagesList.innerHTML = "";
        }
        if (elements.startupProgressFill) {
          elements.startupProgressFill.style.width = "0%";
        }
        hideNode(container);
        return;
      }
      showNode(container);
      container.dataset.state = done ? "complete" : "running";
      if (elements.startupStatusText) {
        elements.startupStatusText.textContent = label || "Preparing\u2026";
      }
      if (elements.startupProgressFill) {
        let pct = summary && Number.isFinite(summary.progress) ? summary.progress : null;
        if (!Number.isFinite(pct)) {
          pct = done ? 1 : 0;
        }
        const normalizedPct = Math.max(0, Math.min(1, pct || 0));
        elements.startupProgressFill.style.width = `${Math.round(normalizedPct * 100)}%`;
      }
      if (elements.startupStagesList) {
        const list = elements.startupStagesList;
        list.innerHTML = "";
        const recentStages = stages.slice(-6);
        if (recentStages.length) {
          recentStages.forEach((stage) => {
            if (!stage) return;
            const li = document.createElement("li");
            li.className = stage.status ? `stage-${String(stage.status).toLowerCase()}` : "stage-pending";
            const parts = [stage.label || stage.id || "stage"];
            if (stage.status) {
              parts.push(stage.status.replace(/[_-]+/g, " "));
            }
            if (Number.isFinite(stage.durationMs) && stage.status && stage.status !== "running") {
              parts.push(`${Math.round(stage.durationMs)}ms`);
            }
            li.textContent = parts.join(" \xB7 ");
            if (stage.message) {
              const meta = document.createElement("span");
              meta.className = "startup-stage-meta";
              meta.textContent = stage.message;
              li.appendChild(meta);
            }
            list.appendChild(li);
          });
        } else if (label) {
          const li = document.createElement("li");
          li.className = "stage-running";
          li.textContent = label;
          list.appendChild(li);
        }
      }
    }
    return {
      elements,
      actions: {
        setStage,
        setPausedBadge,
        hidePausedBadge,
        setCrawlType,
        updateStartupStatus
      }
    };
  }
  function createResumeInventoryScheduler() {
    if (typeof window === "undefined") {
      return () => {
      };
    }
    let timer = null;
    return function scheduleResumeInventoryRefresh(delayMs = 1500) {
      const normalizedDelay = Number.isFinite(delayMs) ? Math.max(0, delayMs) : 1500;
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        timer = null;
        const resumeManager = window.CopilotResumeQueueManager;
        if (resumeManager && typeof resumeManager.refresh === "function") {
          resumeManager.refresh({ silent: true });
        }
      }, normalizedDelay);
    };
  }
  function bootstrapJobsAndSse() {
    if (typeof window === "undefined") {
      return;
    }
    const { elements, actions } = createStatusIndicators();
    const scheduleResumeInventoryRefresh = createResumeInventoryScheduler();
    const jobsManager = createJobsManager({
      elements: { jobsList: elements.jobsList },
      actions,
      scheduleResumeInventoryRefresh
    });
    if (jobsManager && typeof jobsManager.initialJobsPoll === "function") {
      jobsManager.initialJobsPoll();
    }
    const sseHandlers = createSseHandlers({
      jobsManager,
      scheduleResumeInventoryRefresh,
      updateStartupStatus: actions.updateStartupStatus,
      jobsList: elements.jobsList
    });
    if (sseHandlers && typeof sseHandlers.initSse === "function") {
      sseHandlers.initSse();
    }
    window.CopilotStatusIndicators = actions;
    window.CopilotJobsManager = jobsManager;
    window.CopilotSseHandlers = sseHandlers;
  }
  function bootstrapDeferredControls() {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return;
    }
    const domainTables = document.querySelectorAll('[data-control="domain-summary-table"]');
    domainTables.forEach((tableEl) => {
      const { DomainSummaryTableControl } = require_DomainSummaryTable();
      const control = new DomainSummaryTableControl({
        context: new jsguiClient.Client_Page_Context(),
        el: tableEl
      });
      if (control.dom) {
        control.dom.el = tableEl;
      }
      if (typeof control.activate === "function") {
        control.activate();
      }
    });
  }
  (function bootstrap() {
    ensureClientControlsRegistered();
    const { enabled } = resolveBindingPluginConfig();
    if (enabled) {
      installBindingPlugin(jsguiClient);
    } else if (typeof console !== "undefined" && console.info) {
      console.info("Copilot binding plugin disabled for this bundle");
    }
    if (typeof window !== "undefined") {
      window.CopilotBindingPlugin = window.CopilotBindingPlugin || {};
      window.CopilotBindingPlugin.enabled = enabled;
      window.CopilotBindingPlugin.installBindingPlugin = installBindingPlugin;
      window.CopilotBindingPlugin.jsgui = jsguiClient;
      verifyExpectedControls();
    }
    bootstrapDiagramAtlas();
    bootstrapUrlListingStore();
    bootstrapJobsAndSse();
    bootstrapDeferredControls();
  })();
})();
//# sourceMappingURL=ui-client.js.map
