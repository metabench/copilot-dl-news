{
  "version": 3,
  "sources": ["../../src/facts/FactBase.js", "../../src/facts/url/UrlFact.js", "../../src/facts/url/HasDateSegment.js", "../../src/facts/url/HasSlugPattern.js", "../../src/facts/url/HasNewsKeyword.js", "../../src/facts/url/HasPaginationPattern.js", "../../src/facts/url/IsHomepage.js", "../../src/facts/url/index.js", "../../src/ui/client/facts-client.js"],
  "sourcesContent": ["'use strict';\r\n\r\n/**\r\n * FactBase - Abstract base class for all Fact extractors\r\n * \r\n * A Fact is an objective boolean observation about a URL or its content.\r\n * Facts answer \"Does it have X?\" - they are verifiable, reproducible, and store TRUE/FALSE.\r\n * \r\n * Key Principles:\r\n * - Facts are OBJECTIVE: \"URL contains /2024/01/15/\" is a fact\r\n * - Facts are NEUTRAL: They observe structure without judging it as good/bad\r\n * - Classifications are SUBJECTIVE: \"This is a news article\" is a classification\r\n * - Facts have no weights - pure boolean\r\n * - Facts are computed once, stored in DB, reused across classification iterations\r\n * \r\n * Categories:\r\n * - url: Facts from URL string only (cheapest)\r\n * - document: Facts from HTML/DOM (requires parsing)\r\n * - schema: Facts from JSON-LD/Microdata\r\n * - meta: Facts from <meta> tags\r\n * - response: Facts from HTTP response\r\n * - page: Facts about page structure\r\n * \r\n * Lifecycle:\r\n * 1. extract(input) - Compute the fact for given input\r\n * 2. Store TRUE/FALSE in url_facts table\r\n * 3. Classification engine queries facts to make decisions\r\n * \r\n * @example\r\n * class HasDateSegment extends UrlFact {\r\n *   constructor() {\r\n *     super({\r\n *       name: 'url.hasDateSegment',\r\n *       description: 'URL path contains a date pattern like /2024/01/15/',\r\n *       category: 'url'\r\n *     });\r\n *   }\r\n *   \r\n *   extract(input) {\r\n *     const url = this.normalizeUrl(input);\r\n *     const hasDate = /\\/\\d{4}\\/\\d{2}\\/\\d{2}\\//.test(url.pathname);\r\n *     return this.createFact(hasDate, {\r\n *       pattern: hasDate ? url.pathname.match(/\\/\\d{4}\\/\\d{2}\\/\\d{2}\\//)?.[0] : null\r\n *     });\r\n *   }\r\n * }\r\n */\r\nclass FactBase {\r\n  /**\r\n   * @param {Object} options - Fact configuration\r\n   * @param {string} options.name - Unique fact identifier (e.g., 'url.hasDateSegment')\r\n   * @param {string} options.description - Human-readable description\r\n   * @param {string} options.category - Category: 'url', 'document', 'schema', 'meta', 'response', 'page'\r\n   * @param {string[]} [options.requires] - Input requirements: ['url'], ['url', 'html'], etc.\r\n   * @param {number} [options.version=1] - Fact version for schema evolution\r\n   */\r\n  constructor(options = {}) {\r\n    if (new.target === FactBase) {\r\n      throw new Error('FactBase is abstract and cannot be instantiated directly');\r\n    }\r\n    \r\n    const { name, description, category, requires = ['url'], version = 1 } = options;\r\n    \r\n    if (!name) throw new Error('Fact must have a name');\r\n    if (!description) throw new Error('Fact must have a description');\r\n    if (!category) throw new Error('Fact must have a category');\r\n    \r\n    /** @type {string} Unique identifier (e.g., 'url.hasDateSegment') */\r\n    this.name = name;\r\n    \r\n    /** @type {string} Human-readable description */\r\n    this.description = description;\r\n    \r\n    /** @type {string} Fact category */\r\n    this.category = category;\r\n    \r\n    /** @type {string[]} Required inputs */\r\n    this.requires = requires;\r\n    \r\n    /** @type {number} Schema version */\r\n    this.version = version;\r\n  }\r\n  \r\n  /**\r\n   * Extract the fact from input data\r\n   * \r\n   * @abstract\r\n   * @param {Object} input - Input data (varies by fact type)\r\n   * @returns {FactResult} The extracted fact\r\n   */\r\n  extract(input) {\r\n    throw new Error('Subclasses must implement extract()');\r\n  }\r\n  \r\n  /**\r\n   * Create a standardized fact result\r\n   * \r\n   * @protected\r\n   * @param {boolean} value - TRUE if the fact holds, FALSE otherwise\r\n   * @param {Object} [evidence] - Supporting evidence/metadata\r\n   * @returns {FactResult}\r\n   */\r\n  createFact(value, evidence = {}) {\r\n    return {\r\n      name: this.name,\r\n      value: Boolean(value),\r\n      evidence,\r\n      extractedAt: new Date().toISOString(),\r\n      version: this.version\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get metadata about this fact for registration\r\n   * \r\n   * @returns {FactMetadata}\r\n   */\r\n  getMetadata() {\r\n    return {\r\n      name: this.name,\r\n      description: this.description,\r\n      category: this.category,\r\n      requires: this.requires,\r\n      version: this.version\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Check if this fact can be extracted from the available input\r\n   * \r\n   * @param {Object} availableData - Object with keys indicating available data types\r\n   * @returns {boolean}\r\n   */\r\n  canExtract(availableData) {\r\n    return this.requires.every(req => availableData[req] !== undefined);\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} FactResult\r\n * @property {string} name - Fact identifier\r\n * @property {boolean} value - TRUE or FALSE\r\n * @property {Object} evidence - Supporting evidence\r\n * @property {string} extractedAt - ISO timestamp\r\n * @property {number} version - Fact version\r\n */\r\n\r\n/**\r\n * @typedef {Object} FactMetadata\r\n * @property {string} name - Fact identifier\r\n * @property {string} description - Human-readable description\r\n * @property {string} category - Fact category\r\n * @property {string[]} requires - Required inputs\r\n * @property {number} version - Schema version\r\n */\r\n\r\nmodule.exports = { FactBase };\r\n", "'use strict';\r\n\r\nconst { FactBase } = require('../FactBase');\r\n\r\n/**\r\n * UrlFact - Base class for facts extracted from URL strings alone\r\n * \r\n * URL facts are the cheapest to compute - they require only the URL string,\r\n * no network requests or HTML parsing. They should be computed first and\r\n * can be used to short-circuit expensive document analysis.\r\n * \r\n * Input Requirements: ['url']\r\n * \r\n * Common URL facts:\r\n * - url.hasDateSegment      - /2024/01/15/ pattern in path\r\n * - url.hasSlugPattern      - human-readable-slug pattern\r\n * - url.hasNumericId        - /article/12345 pattern\r\n * - url.hasNewsKeyword      - /news/, /story/, /article/ in path\r\n * - url.hasFileExtension    - ends with .html, .php, etc.\r\n * - url.hasQueryParams      - has query string\r\n * - url.pathDepth           - number of path segments (converted to fact: pathDepth.gt3, etc.)\r\n * - url.isHomepage          - path is / or /index.*\r\n * \r\n * @example\r\n * class HasDateSegment extends UrlFact {\r\n *   constructor() {\r\n *     super({\r\n *       name: 'url.hasDateSegment',\r\n *       description: 'URL path contains a date pattern like /2024/01/15/'\r\n *     });\r\n *   }\r\n *   \r\n *   extract(input) {\r\n *     const url = this.parseUrl(input);\r\n *     const match = url.pathname.match(/\\/(\\d{4})\\/(\\d{2})\\/(\\d{2})\\//);\r\n *     return this.createFact(!!match, {\r\n *       pattern: match?.[0],\r\n *       year: match?.[1],\r\n *       month: match?.[2],\r\n *       day: match?.[3]\r\n *     });\r\n *   }\r\n * }\r\n */\r\nclass UrlFact extends FactBase {\r\n  /**\r\n   * @param {Object} options - Fact configuration\r\n   * @param {string} options.name - Unique fact identifier (should start with 'url.')\r\n   * @param {string} options.description - Human-readable description\r\n   */\r\n  constructor(options = {}) {\r\n    super({\r\n      ...options,\r\n      category: 'url',\r\n      requires: ['url']\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Parse and normalize a URL string\r\n   * \r\n   * @protected\r\n   * @param {string|URL|Object} input - URL string, URL object, or {url: string}\r\n   * @returns {URL} Parsed URL object\r\n   */\r\n  parseUrl(input) {\r\n    if (input instanceof URL) {\r\n      return input;\r\n    }\r\n    \r\n    const urlString = typeof input === 'string' ? input : input?.url;\r\n    \r\n    if (!urlString) {\r\n      throw new Error('URL input is required');\r\n    }\r\n    \r\n    try {\r\n      return new URL(urlString);\r\n    } catch (e) {\r\n      throw new Error(`Invalid URL: ${urlString}`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get normalized path segments (non-empty)\r\n   * \r\n   * @protected\r\n   * @param {URL} url - Parsed URL\r\n   * @returns {string[]} Path segments\r\n   */\r\n  getPathSegments(url) {\r\n    return url.pathname\r\n      .split('/')\r\n      .filter(segment => segment.length > 0);\r\n  }\r\n  \r\n  /**\r\n   * Check if path matches a regex pattern\r\n   * \r\n   * @protected\r\n   * @param {URL} url - Parsed URL\r\n   * @param {RegExp} pattern - Pattern to match\r\n   * @returns {RegExpMatchArray|null} Match result\r\n   */\r\n  matchPath(url, pattern) {\r\n    return url.pathname.match(pattern);\r\n  }\r\n  \r\n  /**\r\n   * Check if any segment matches a pattern\r\n   * \r\n   * @protected\r\n   * @param {URL} url - Parsed URL\r\n   * @param {RegExp} pattern - Pattern to match against each segment\r\n   * @returns {string|null} First matching segment or null\r\n   */\r\n  findMatchingSegment(url, pattern) {\r\n    return this.getPathSegments(url).find(seg => pattern.test(seg)) || null;\r\n  }\r\n  \r\n  /**\r\n   * Get the file extension from URL path\r\n   * \r\n   * @protected\r\n   * @param {URL} url - Parsed URL\r\n   * @returns {string|null} Extension without dot (e.g., 'html') or null\r\n   */\r\n  getExtension(url) {\r\n    const match = url.pathname.match(/\\.([a-z0-9]+)$/i);\r\n    return match ? match[1].toLowerCase() : null;\r\n  }\r\n  \r\n  /**\r\n   * Get the last path segment (often the slug)\r\n   * \r\n   * @protected\r\n   * @param {URL} url - Parsed URL\r\n   * @returns {string|null} Last segment or null if path is /\r\n   */\r\n  getLastSegment(url) {\r\n    const segments = this.getPathSegments(url);\r\n    return segments.length > 0 ? segments[segments.length - 1] : null;\r\n  }\r\n}\r\n\r\nmodule.exports = { UrlFact };\r\n", "'use strict';\r\n\r\nconst { UrlFact } = require('./UrlFact');\r\n\r\n/**\r\n * HasDateSegment - Detects date patterns in URL paths\r\n * \r\n * Fact: url.hasDateSegment\r\n * \r\n * Detects common date URL patterns:\r\n * - /2024/01/15/ (most common news pattern)\r\n * - /2024/jan/15/ (month name variant - The Guardian, etc.)\r\n * - /2024-01-15/ (hyphenated variant)\r\n * - /20240115/ (compact 8-digit)\r\n * - /2024/01/ (year/month only)\r\n * \r\n * This is one of the strongest URL-only signals for article detection.\r\n * Most news sites include publication date in article URLs.\r\n * \r\n * Evidence includes parsed date components when matched.\r\n * \r\n * @example\r\n * const fact = new HasDateSegment();\r\n * fact.extract('https://example.com/news/2024/01/15/story-slug');\r\n * // => { name: 'url.hasDateSegment', value: true, evidence: { pattern: '/2024/01/15/', year: '2024', month: '01', day: '15' } }\r\n */\r\nclass HasDateSegment extends UrlFact {\r\n  constructor() {\r\n    super({\r\n      name: 'url.hasDateSegment',\r\n      description: 'URL path contains a recognizable date pattern'\r\n    });\r\n    \r\n    /**\r\n     * Month name to number mapping (lowercase)\r\n     * @private\r\n     */\r\n    this.monthNames = {\r\n      jan: '01', january: '01',\r\n      feb: '02', february: '02',\r\n      mar: '03', march: '03',\r\n      apr: '04', april: '04',\r\n      may: '05',\r\n      jun: '06', june: '06',\r\n      jul: '07', july: '07',\r\n      aug: '08', august: '08',\r\n      sep: '09', sept: '09', september: '09',\r\n      oct: '10', october: '10',\r\n      nov: '11', november: '11',\r\n      dec: '12', december: '12'\r\n    };\r\n    \r\n    /**\r\n     * Date patterns to check, in order of specificity\r\n     * @private\r\n     */\r\n    this.patterns = [\r\n      // /2024/01/15/ - most specific, slash-separated YYYY/MM/DD\r\n      {\r\n        regex: /\\/(\\d{4})\\/(\\d{2})\\/(\\d{2})\\//,\r\n        extract: (m) => ({ year: m[1], month: m[2], day: m[3], format: 'YYYY/MM/DD' })\r\n      },\r\n      // /2024/jan/15/ - month name variant (The Guardian, etc.)\r\n      {\r\n        regex: /\\/(\\d{4})\\/([a-z]{3,9})\\/(\\d{2})\\//i,\r\n        extract: (m, self) => {\r\n          const monthNum = self.monthNames[m[2].toLowerCase()];\r\n          return monthNum \r\n            ? { year: m[1], month: monthNum, day: m[3], format: 'YYYY/mon/DD', monthName: m[2].toLowerCase() }\r\n            : null;\r\n        }\r\n      },\r\n      // /2024-01-15/ or /2024-01-15 - hyphenated\r\n      {\r\n        regex: /\\/(\\d{4})-(\\d{2})-(\\d{2})(?:\\/|$)/,\r\n        extract: (m) => ({ year: m[1], month: m[2], day: m[3], format: 'YYYY-MM-DD' })\r\n      },\r\n      // /20240115/ - compact 8-digit\r\n      {\r\n        regex: /\\/(\\d{4})(\\d{2})(\\d{2})(?:\\/|$)/,\r\n        extract: (m) => ({ year: m[1], month: m[2], day: m[3], format: 'YYYYMMDD' })\r\n      },\r\n      // /2024/01/ - year/month only (less specific, still useful)\r\n      {\r\n        regex: /\\/(\\d{4})\\/(\\d{2})\\//,\r\n        extract: (m) => ({ year: m[1], month: m[2], day: null, format: 'YYYY/MM' })\r\n      },\r\n      // /2024/jan/ - year/month name only\r\n      {\r\n        regex: /\\/(\\d{4})\\/([a-z]{3,9})\\//i,\r\n        extract: (m, self) => {\r\n          const monthNum = self.monthNames[m[2].toLowerCase()];\r\n          return monthNum \r\n            ? { year: m[1], month: monthNum, day: null, format: 'YYYY/mon', monthName: m[2].toLowerCase() }\r\n            : null;\r\n        }\r\n      }\r\n    ];\r\n  }\r\n  \r\n  /**\r\n   * Extract the date segment fact\r\n   * \r\n   * @param {string|URL|Object} input - URL to analyze\r\n   * @returns {FactResult}\r\n   */\r\n  extract(input) {\r\n    const url = this.parseUrl(input);\r\n    \r\n    for (const { regex, extract } of this.patterns) {\r\n      const match = url.pathname.match(regex);\r\n      if (match) {\r\n        const components = extract(match, this);\r\n        \r\n        // Skip if extract returned null (e.g., invalid month name)\r\n        if (!components) continue;\r\n        \r\n        // Validate month and day are reasonable\r\n        const month = parseInt(components.month, 10);\r\n        const day = components.day ? parseInt(components.day, 10) : null;\r\n        \r\n        if (month >= 1 && month <= 12 && (day === null || (day >= 1 && day <= 31))) {\r\n          return this.createFact(true, {\r\n            pattern: match[0],\r\n            ...components\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return this.createFact(false, { reason: 'No date pattern found in URL path' });\r\n  }\r\n}\r\n\r\nmodule.exports = { HasDateSegment };\r\n", "'use strict';\r\n\r\nconst { UrlFact } = require('./UrlFact');\r\n\r\n/**\r\n * HasSlugPattern - Detects human-readable URL slugs\r\n * \r\n * Fact: url.hasSlugPattern\r\n * \r\n * A \"slug\" is a human-readable URL segment, typically derived from an article title.\r\n * Characteristics of slugs:\r\n * - Contains multiple words separated by hyphens or underscores\r\n * - Words are lowercase alphanumeric\r\n * - Usually 3+ words (distinguishes from simple category names)\r\n * - Found as the final path segment (the article identifier)\r\n * \r\n * Examples of slugs:\r\n * - breaking-news-mayor-announces-new-policy\r\n * - climate-change-summit-reaches-agreement\r\n * - tech-giant-unveils-latest-smartphone\r\n * \r\n * NOT slugs:\r\n * - news (single word = likely category)\r\n * - 12345 (numeric = likely ID)\r\n * - index.html (file reference)\r\n * \r\n * @example\r\n * const fact = new HasSlugPattern();\r\n * fact.extract('https://news.com/2024/01/15/mayor-announces-new-policy');\r\n * // => { name: 'url.hasSlugPattern', value: true, evidence: { slug: 'mayor-announces-new-policy', wordCount: 4 } }\r\n */\r\nclass HasSlugPattern extends UrlFact {\r\n  constructor() {\r\n    super({\r\n      name: 'url.hasSlugPattern',\r\n      description: 'URL path ends with a human-readable slug (hyphenated words)'\r\n    });\r\n    \r\n    /**\r\n     * Minimum words in slug to distinguish from simple names\r\n     * @type {number}\r\n     */\r\n    this.minWords = 3;\r\n    \r\n    /**\r\n     * Pattern for individual slug words\r\n     * @type {RegExp}\r\n     */\r\n    this.wordPattern = /^[a-z0-9]+$/i;\r\n    \r\n    /**\r\n     * Common file extensions to strip before analysis\r\n     * @type {RegExp}\r\n     */\r\n    this.extensionPattern = /\\.(html?|php|aspx?|jsp)$/i;\r\n  }\r\n  \r\n  /**\r\n   * Extract the slug pattern fact\r\n   * \r\n   * @param {string|URL|Object} input - URL to analyze\r\n   * @returns {FactResult}\r\n   */\r\n  extract(input) {\r\n    const url = this.parseUrl(input);\r\n    let lastSegment = this.getLastSegment(url);\r\n    \r\n    if (!lastSegment) {\r\n      return this.createFact(false, { reason: 'No path segments' });\r\n    }\r\n    \r\n    // Strip common extensions\r\n    lastSegment = lastSegment.replace(this.extensionPattern, '');\r\n    \r\n    // Try hyphen-separated first (most common)\r\n    let words = lastSegment.split('-');\r\n    let separator = '-';\r\n    \r\n    // Fall back to underscore if no hyphens\r\n    if (words.length < this.minWords) {\r\n      const underscoreWords = lastSegment.split('_');\r\n      if (underscoreWords.length >= this.minWords) {\r\n        words = underscoreWords;\r\n        separator = '_';\r\n      }\r\n    }\r\n    \r\n    // Filter to valid words only\r\n    const validWords = words.filter(w => this.wordPattern.test(w) && w.length >= 2);\r\n    \r\n    // Check if it's a slug pattern\r\n    if (validWords.length >= this.minWords) {\r\n      return this.createFact(true, {\r\n        slug: lastSegment,\r\n        separator,\r\n        wordCount: validWords.length,\r\n        words: validWords\r\n      });\r\n    }\r\n    \r\n    // Check for specific failure reasons\r\n    if (words.length < this.minWords) {\r\n      return this.createFact(false, { \r\n        reason: `Too few words (${words.length} < ${this.minWords})`,\r\n        segment: lastSegment\r\n      });\r\n    }\r\n    \r\n    return this.createFact(false, { \r\n      reason: 'Does not match slug pattern',\r\n      segment: lastSegment\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = { HasSlugPattern };\r\n", "'use strict';\r\n\r\nconst { UrlFact } = require('./UrlFact');\r\n\r\n/**\r\n * HasNewsKeyword - Detects news-related keywords in URL path\r\n * \r\n * Fact: url.hasNewsKeyword\r\n * \r\n * Checks if the URL path contains common news-related path segments.\r\n * These indicate the URL is in a news/article section of the site.\r\n * \r\n * Keywords detected (as path segments):\r\n * - /news/\r\n * - /article/\r\n * - /story/\r\n * - /post/\r\n * - /blog/\r\n * - /press/\r\n * - /press-release/\r\n * - /stories/\r\n * - /articles/\r\n * \r\n * Note: These must be complete path segments, not substrings.\r\n * \"/newsroom/\" would NOT match \"/news/\" but \"/news/\" would.\r\n * \r\n * @example\r\n * const fact = new HasNewsKeyword();\r\n * fact.extract('https://example.com/news/2024/story-title');\r\n * // => { name: 'url.hasNewsKeyword', value: true, evidence: { keyword: 'news', position: 1 } }\r\n */\r\nclass HasNewsKeyword extends UrlFact {\r\n  constructor() {\r\n    super({\r\n      name: 'url.hasNewsKeyword',\r\n      description: 'URL path contains a news-related segment like /news/, /article/, /story/'\r\n    });\r\n    \r\n    /**\r\n     * News-related keywords to detect (lowercase)\r\n     * @type {Set<string>}\r\n     */\r\n    this.keywords = new Set([\r\n      'news',\r\n      'article',\r\n      'articles',\r\n      'story',\r\n      'stories',\r\n      'post',\r\n      'posts',\r\n      'blog',\r\n      'press',\r\n      'press-release',\r\n      'press-releases',\r\n      'breaking',\r\n      'latest',\r\n      'opinion',\r\n      'editorial',\r\n      'editorials',\r\n      'column',\r\n      'columns',\r\n      'feature',\r\n      'features',\r\n      'report',\r\n      'reports',\r\n      'update',\r\n      'updates',\r\n      'headline',\r\n      'headlines'\r\n    ]);\r\n  }\r\n  \r\n  /**\r\n   * Extract the news keyword fact\r\n   * \r\n   * @param {string|URL|Object} input - URL to analyze\r\n   * @returns {FactResult}\r\n   */\r\n  extract(input) {\r\n    const url = this.parseUrl(input);\r\n    const segments = this.getPathSegments(url);\r\n    \r\n    for (let i = 0; i < segments.length; i++) {\r\n      const segment = segments[i].toLowerCase();\r\n      \r\n      if (this.keywords.has(segment)) {\r\n        return this.createFact(true, {\r\n          keyword: segment,\r\n          position: i,\r\n          segment: segments[i]\r\n        });\r\n      }\r\n    }\r\n    \r\n    return this.createFact(false, { \r\n      reason: 'No news keywords found in path segments',\r\n      segments\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = { HasNewsKeyword };\r\n", "'use strict';\r\n\r\nconst { UrlFact } = require('./UrlFact');\r\n\r\n/**\r\n * HasPaginationPattern - Detects pagination patterns in URLs\r\n * \r\n * Fact: url.hasPaginationPattern\r\n * \r\n * This is a neutral structural observation - pagination is neither\r\n * positive nor negative, it's simply a characteristic of the URL.\r\n * \r\n * Patterns detected:\r\n * - /page/2, /page/3, etc. (path segment)\r\n * - ?page=2, ?p=2 (query parameter)\r\n * - /2/, /3/ (trailing numeric segment in some CMS patterns)\r\n * - ?offset=10, ?start=20 (offset-based pagination)\r\n * \r\n * @example\r\n * const fact = new HasPaginationPattern();\r\n * fact.extract('https://news.com/category/tech?page=2');\r\n * // => { name: 'url.hasPaginationPattern', value: true, evidence: { type: 'query', param: 'page', value: '2' } }\r\n */\r\nclass HasPaginationPattern extends UrlFact {\r\n  constructor() {\r\n    super({\r\n      name: 'url.hasPaginationPattern',\r\n      description: 'URL contains pagination indicators (page numbers, offsets)'\r\n    });\r\n    \r\n    /**\r\n     * Query parameters that indicate pagination\r\n     * @type {Set<string>}\r\n     */\r\n    this.paginationParams = new Set([\r\n      'page',\r\n      'p',\r\n      'pg',\r\n      'paged',\r\n      'offset',\r\n      'start',\r\n      'skip',\r\n      'from',\r\n      'pagenum',\r\n      'page_num',\r\n      'pagenumber'\r\n    ]);\r\n    \r\n    /**\r\n     * Path segment patterns for pagination\r\n     * @type {RegExp[]}\r\n     */\r\n    this.pathPatterns = [\r\n      // /page/2, /page/3, etc.\r\n      /\\/page\\/(\\d+)\\/?$/i,\r\n      // /p/2, /p/3 (short form)\r\n      /\\/p\\/(\\d+)\\/?$/i,\r\n      // Some sites use just /2/, /3/ at the end\r\n      /\\/(\\d+)\\/?$/\r\n    ];\r\n  }\r\n  \r\n  /**\r\n   * Extract the pagination pattern fact\r\n   * \r\n   * @param {string|URL|Object} input - URL to analyze\r\n   * @returns {FactResult}\r\n   */\r\n  extract(input) {\r\n    const url = this.parseUrl(input);\r\n    \r\n    // Check query parameters first (most common)\r\n    for (const [param, value] of url.searchParams) {\r\n      if (this.paginationParams.has(param.toLowerCase())) {\r\n        // Must be numeric to be pagination\r\n        if (/^\\d+$/.test(value)) {\r\n          return this.createFact(true, {\r\n            type: 'query',\r\n            param,\r\n            value,\r\n            pageNumber: parseInt(value, 10)\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Check path patterns\r\n    for (const pattern of this.pathPatterns) {\r\n      const match = url.pathname.match(pattern);\r\n      if (match) {\r\n        const pageNum = parseInt(match[1], 10);\r\n        // Avoid false positives: page 1 is often not pagination, just the default\r\n        // Also avoid matching years (1900-2100) or other large numbers\r\n        if (pageNum > 1 && pageNum < 1000) {\r\n          return this.createFact(true, {\r\n            type: 'path',\r\n            pattern: pattern.toString(),\r\n            value: match[1],\r\n            pageNumber: pageNum\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return this.createFact(false, { reason: 'No pagination pattern detected' });\r\n  }\r\n}\r\n\r\nmodule.exports = { HasPaginationPattern };\r\n", "'use strict';\r\n\r\nconst { UrlFact } = require('./UrlFact');\r\n\r\n/**\r\n * IsHomepage - Detects if URL is a homepage or index page\r\n * \r\n * Fact: url.isHomepage\r\n * \r\n * Homepages are NOT articles. This is a negative indicator.\r\n * \r\n * Patterns detected:\r\n * - / (root path)\r\n * - /index.html\r\n * - /index.htm\r\n * - /index.php\r\n * - /default.aspx\r\n * - /home\r\n * - /home/\r\n * \r\n * @example\r\n * const fact = new IsHomepage();\r\n * fact.extract('https://news.example.com/');\r\n * // => { name: 'url.isHomepage', value: true, evidence: { pattern: 'root' } }\r\n */\r\nclass IsHomepage extends UrlFact {\r\n  constructor() {\r\n    super({\r\n      name: 'url.isHomepage',\r\n      description: 'URL is a homepage or index page (not an article)'\r\n    });\r\n    \r\n    /**\r\n     * Index file patterns\r\n     * @type {RegExp[]}\r\n     */\r\n    this.indexPatterns = [\r\n      /^\\/?(index|default|home)\\.(html?|php|aspx?|jsp)$/i,\r\n      /^\\/?(index|default|home)\\/?$/i,\r\n      /^\\/?$/  // Root path\r\n    ];\r\n  }\r\n  \r\n  /**\r\n   * Extract the homepage fact\r\n   * \r\n   * @param {string|URL|Object} input - URL to analyze\r\n   * @returns {FactResult}\r\n   */\r\n  extract(input) {\r\n    const url = this.parseUrl(input);\r\n    const path = url.pathname;\r\n    \r\n    // Check root path first\r\n    if (path === '/' || path === '') {\r\n      return this.createFact(true, { \r\n        pattern: 'root',\r\n        path\r\n      });\r\n    }\r\n    \r\n    // Check index patterns\r\n    for (const pattern of this.indexPatterns) {\r\n      if (pattern.test(path)) {\r\n        return this.createFact(true, {\r\n          pattern: 'index',\r\n          path,\r\n          matchedPattern: pattern.toString()\r\n        });\r\n      }\r\n    }\r\n    \r\n    return this.createFact(false, { \r\n      reason: 'Path does not match homepage patterns',\r\n      path\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = { IsHomepage };\r\n", "'use strict';\r\n\r\n/**\r\n * URL Facts Module\r\n * \r\n * Facts that can be extracted from URL strings alone (no network, no HTML).\r\n * These are the cheapest facts to compute and should be run first.\r\n * \r\n * All facts in this module require only: ['url']\r\n * All facts are NEUTRAL observations - no judgment about good/bad.\r\n */\r\n\r\nconst { UrlFact } = require('./UrlFact');\r\nconst { HasDateSegment } = require('./HasDateSegment');\r\nconst { HasSlugPattern } = require('./HasSlugPattern');\r\nconst { HasNewsKeyword } = require('./HasNewsKeyword');\r\nconst { HasPaginationPattern } = require('./HasPaginationPattern');\r\nconst { IsHomepage } = require('./IsHomepage');\r\n\r\n/**\r\n * All URL fact classes\r\n * @type {Array<typeof UrlFact>}\r\n */\r\nconst URL_FACTS = [\r\n  HasDateSegment,\r\n  HasSlugPattern,\r\n  HasNewsKeyword,\r\n  HasPaginationPattern,\r\n  IsHomepage\r\n];\r\n\r\n/**\r\n * Create instances of all URL facts\r\n * @returns {UrlFact[]}\r\n */\r\nfunction createAllUrlFacts() {\r\n  return URL_FACTS.map(FactClass => new FactClass());\r\n}\r\n\r\nmodule.exports = {\r\n  // Base class\r\n  UrlFact,\r\n  \r\n  // Concrete facts\r\n  HasDateSegment,\r\n  HasSlugPattern,\r\n  HasNewsKeyword,\r\n  HasPaginationPattern,\r\n  IsHomepage,\r\n  \r\n  // Registry helpers\r\n  URL_FACTS,\r\n  createAllUrlFacts\r\n};\r\n", "\"use strict\";\r\n\r\n/**\r\n * Facts Client - Client-side JavaScript for the Facts Server\r\n * \r\n * This module provides client-side interactivity for the Facts page:\r\n * - Click handlers on URL rows to show facts popup\r\n * - Client-side URL fact computation (no server round-trip needed)\r\n * \r\n * Built with esbuild as a browser bundle.\r\n */\r\n\r\n// Import URL facts (pure JS, works in browser)\r\nconst { createAllUrlFacts } = require(\"../../facts/url\");\r\n\r\n/**\r\n * Initialize the URL facts popup functionality\r\n */\r\nfunction initFactsPopup() {\r\n  // Create fact instances once\r\n  const urlFacts = createAllUrlFacts();\r\n\r\n  // Find popup element\r\n  const popupEl = document.querySelector(\"[data-control='UrlFactsPopup']\");\r\n  if (!popupEl) {\r\n    console.warn(\"[FactsClient] No popup element found on page\");\r\n    return null;\r\n  }\r\n\r\n  const backdrop = popupEl.querySelector(\"[data-role='backdrop']\");\r\n  const closeBtn = popupEl.querySelector(\"[data-role='close']\");\r\n  const urlDisplay = popupEl.querySelector(\"[data-role='url-display']\");\r\n  const factsList = popupEl.querySelector(\"[data-role='facts-list']\");\r\n\r\n  /**\r\n   * Show the popup with facts for a URL\r\n   * @param {string} url - The URL to analyze\r\n   */\r\n  function show(url) {\r\n    if (!url) return;\r\n\r\n    // Display the URL\r\n    urlDisplay.innerHTML = \"\";\r\n    const urlText = document.createElement(\"code\");\r\n    urlText.className = \"lux-facts-popup__url-text\";\r\n    urlText.textContent = url;\r\n    urlDisplay.appendChild(urlText);\r\n\r\n    // Compute all URL facts\r\n    factsList.innerHTML = \"\";\r\n    \r\n    urlFacts.forEach(fact => {\r\n      try {\r\n        const result = fact.extract(url);\r\n        const factItem = createFactItem(result);\r\n        factsList.appendChild(factItem);\r\n      } catch (err) {\r\n        console.error(`[FactsClient] Error computing ${fact.name}:`, err);\r\n        const errorItem = createErrorItem(fact.name, err.message);\r\n        factsList.appendChild(errorItem);\r\n      }\r\n    });\r\n\r\n    // Show popup\r\n    popupEl.style.display = \"flex\";\r\n    document.body.classList.add(\"lux-popup-open\");\r\n  }\r\n\r\n  /**\r\n   * Hide the popup\r\n   */\r\n  function hide() {\r\n    popupEl.style.display = \"none\";\r\n    document.body.classList.remove(\"lux-popup-open\");\r\n  }\r\n\r\n  /**\r\n   * Create a DOM element for a fact result\r\n   * @param {Object} result - Fact result with name, value, evidence\r\n   */\r\n  function createFactItem(result) {\r\n    const item = document.createElement(\"div\");\r\n    item.className = `lux-fact-item ${result.value ? \"lux-fact-item--true\" : \"lux-fact-item--false\"}`;\r\n\r\n    // Indicator\r\n    const indicator = document.createElement(\"span\");\r\n    indicator.className = \"lux-fact-item__indicator\";\r\n    indicator.textContent = result.value ? \"\u25C6\" : \"\u25C7\";\r\n    item.appendChild(indicator);\r\n\r\n    // Content\r\n    const content = document.createElement(\"div\");\r\n    content.className = \"lux-fact-item__content\";\r\n\r\n    // Name\r\n    const name = document.createElement(\"div\");\r\n    name.className = \"lux-fact-item__name\";\r\n    name.textContent = result.name;\r\n    content.appendChild(name);\r\n\r\n    // Evidence\r\n    if (result.evidence) {\r\n      const evidence = document.createElement(\"div\");\r\n      evidence.className = \"lux-fact-item__evidence\";\r\n      evidence.textContent = formatEvidence(result.evidence);\r\n      content.appendChild(evidence);\r\n    }\r\n\r\n    item.appendChild(content);\r\n\r\n    // Value badge\r\n    const badge = document.createElement(\"span\");\r\n    badge.className = \"lux-fact-item__badge\";\r\n    badge.textContent = result.value ? \"TRUE\" : \"FALSE\";\r\n    item.appendChild(badge);\r\n\r\n    return item;\r\n  }\r\n\r\n  /**\r\n   * Create a DOM element for an error\r\n   */\r\n  function createErrorItem(factName, errorMessage) {\r\n    const item = document.createElement(\"div\");\r\n    item.className = \"lux-fact-item lux-fact-item--error\";\r\n\r\n    const indicator = document.createElement(\"span\");\r\n    indicator.className = \"lux-fact-item__indicator\";\r\n    indicator.textContent = \"\u26A0\";\r\n    item.appendChild(indicator);\r\n\r\n    const content = document.createElement(\"div\");\r\n    content.className = \"lux-fact-item__content\";\r\n\r\n    const name = document.createElement(\"div\");\r\n    name.className = \"lux-fact-item__name\";\r\n    name.textContent = factName;\r\n    content.appendChild(name);\r\n\r\n    const error = document.createElement(\"div\");\r\n    error.className = \"lux-fact-item__evidence lux-fact-item__evidence--error\";\r\n    error.textContent = `Error: ${errorMessage}`;\r\n    content.appendChild(error);\r\n\r\n    item.appendChild(content);\r\n\r\n    return item;\r\n  }\r\n\r\n  /**\r\n   * Format evidence object for display\r\n   */\r\n  function formatEvidence(evidence) {\r\n    if (!evidence || typeof evidence !== \"object\") return \"\";\r\n    \r\n    const parts = [];\r\n    for (const [key, value] of Object.entries(evidence)) {\r\n      if (value === null || value === undefined) continue;\r\n      if (key === \"reason\" && typeof value === \"string\" && value.includes(\"No \")) continue;\r\n      parts.push(`${key}: ${value}`);\r\n    }\r\n    return parts.join(\" \u00B7 \");\r\n  }\r\n\r\n  // Event handlers\r\n  if (backdrop) {\r\n    backdrop.addEventListener(\"click\", hide);\r\n  }\r\n  \r\n  if (closeBtn) {\r\n    closeBtn.addEventListener(\"click\", hide);\r\n  }\r\n  \r\n  // Escape key\r\n  document.addEventListener(\"keydown\", (e) => {\r\n    if (e.key === \"Escape\" && popupEl.style.display !== \"none\") {\r\n      hide();\r\n    }\r\n  });\r\n\r\n  // Attach click handlers to URL links\r\n  document.querySelectorAll(\".lux-url-list .is-url a\").forEach(link => {\r\n    link.addEventListener(\"click\", (e) => {\r\n      e.preventDefault();\r\n      const url = link.getAttribute(\"title\") || link.textContent;\r\n      show(url);\r\n    });\r\n  });\r\n\r\n  console.log(\"[FactsClient] Initialized with\", urlFacts.length, \"URL facts\");\r\n  return { show, hide };\r\n}\r\n\r\n/**\r\n * Bootstrap on DOMContentLoaded\r\n */\r\nfunction bootstrap() {\r\n  if (document.readyState === \"loading\") {\r\n    document.addEventListener(\"DOMContentLoaded\", initFactsPopup);\r\n  } else {\r\n    initFactsPopup();\r\n  }\r\n}\r\n\r\n// Auto-bootstrap\r\nbootstrap();\r\n\r\n// Export for external use\r\nif (typeof window !== \"undefined\") {\r\n  window.FactsClient = {\r\n    init: initFactsPopup\r\n  };\r\n}\r\n\r\nmodule.exports = { initFactsPopup };\r\n"],
  "mappings": "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",
  "names": []
}
