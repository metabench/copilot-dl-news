# Lessons & Patterns (Rolling)

## 2025-11-16
- **Document-First Success**: Creating `/docs/agi` before coding changes keeps AGI initiatives decoupled from production flows.
- **Tool Awareness**: Re-reading `AGENTS.md` plus GitHub Copilot instructions provided enough context; no need for deep code scans yet. Respect the "stop researching early" directive.
- **Journal Discipline**: Logging plan + open questions in `journal/2025-11-16.md` made the rest of the work straightforward and should remain standard practice.
- **Static Analysis Focus**: Reiterating `js-scan`/`js-edit` as Tier-1 tools prevents scope creep toward unsupported tooling (e.g., Python scripts).
- **Existing Agent Review**: Always scan canonical specs in `docs/agents/` (e.g., `agent_policy`, `docs_indexer_and_agents_refactorer`) before drafting new personas so proposals inherit current governance.
- **Meta-Tooling Insight**: Running js-scan against the tooling sources (`tools/dev/js-scan/**`) reveals dependency risk before modifying the scanners themselves—capture these findings in `docs/agi/tools/*` to keep institutional memory tight.
- **Guard Replay Discipline**: Documented `js-edit` guard plans plus storage locations (e.g., `docs/sessions/<date>`) so future agents can replay edits without recomputing selectors; skip this step only if re-locating is trivial.

## 2025-11-20
- **Token Payloads Need Context**: Continuation tokens are only useful when they carry the absolute file, selector, and guard hash—embed the `match` snapshot at creation time so replay steps never re-scan unless inputs are missing.
- **Handlers Before Features**: Implement practical action handlers (`analyze`, `trace`, `ripple`) before adding new token types; tests now exercise each path so regressions surface immediately.
- **Record Commands Inline**: Session notes now log both the discovery run and the replay/test commands; this keeps token strings + JSON outputs paired for future verification.
- **Warn on Drift**: Digest comparisons (`RESULTS_DIGEST_MISMATCH`) give downstream agents an immediate signal that cached selectors are stale, so refresh tokens before touching js-edit.

## 2025-11-21
- **Relationship results need parity**: `what-imports`/`export-usage` already return importer metadata, but without tokenization those lists cannot flow into downstream automation—treat each importer/usage row like a search match (file, specifier, digest) so continuation tooling applies uniformly.
- **js-edit should trust snapshots, not humans**: The `match` payload and `jsEditHint` already contain enough guard info for edits; lacking an ingestion flag just forces extra `--locate` runs. Building a token/snapshot entry point unlocks single-pass Sense→Act loops.
- **Digest everything**: When relationship payloads start emitting tokens, compute and store a composite digest (sorted importer list hash) so stale tokens trigger the same `RESULTS_DIGEST_MISMATCH` warning that protects search tokens today.
- **Cap tokens for ergonomics**: Limiting importer/usage actions to 10 per request balances usefulness with compact `_ai_native_cli` payloads; agents can always rerun with narrower filters if they need more snapshots.
- **Session breadcrumbs matter**: Pair every tooling push with a fresh journal entry + session folder and link it from `SESSIONS_HUB.md`; future agents depend on those breadcrumbs to resume the work without rediscovery.
- **Smoke it where it hurts**: Extending the AI-native smoke suite immediately after wiring snapshot ingestion caught a regression around hash mismatches; keep the suite as the canonical repro for Sense→Act handoffs instead of ad-hoc manual runs.

## 2025-12-03
- **MCP vs CLI Tool Adoption**: MCP tools command more agent attention than CLI equivalents because they're declared affordances (push discovery) rather than scripts requiring active recall (pull discovery). Agents may over-use MCP tools simply because they're visible in the tool inventory.
- **Session Discipline**: Before appending to any session with `appendToSession`, always (1) use `listSessions` to see what exists, (2) use `searchSessions` if unsure which session matches the task, (3) specify the correct `slug` explicitly — never rely on "latest session" default when working on a specific task. Cross-contaminating sessions defeats the purpose of persistent memory.
- **MCP Tool Design for Context Efficiency**: MCP tools that return documentation should support filtering parameters (e.g., `files`, `maxLinesPerFile`, `sinceDate`) so agents can request only what they need. Returning full files by default wastes context tokens and risks information overload. Implemented in docs-memory: `getSession` now accepts `files` array and `maxLinesPerFile`; `getLessons` now accepts `sinceDate` filter.
- **Self-Documenting MCP Tools**: Tool descriptions are the PRIMARY place for usage guidance — they're visible to the model before tool selection. Lessons are secondary (must be fetched). Pattern: (1) Embed RECOMMENDED WORKFLOW directly in tool description, (2) Add `onlyStats` or similar cheap-probe options, (3) Return `hint` fields in responses suggesting next actions. This makes tools self-improving without requiring agents to read lessons first.
- **Workflow MCP Tools (AGI Singularity Enabled)**: Added workflow management tools to docs-memory MCP server: listWorkflows, getWorkflow (with structured metadata extraction), searchWorkflows, and proposeWorkflowImprovement. Key design: (1) Workflows are parsed to extract phases, prerequisites, checklists, and commands; (2) 'improvementHooks' field identifies optimization opportunities for agents; (3) proposeWorkflowImprovement saves proposals to docs/agi/workflow-improvements/ for human/senior-agent review. This enables meta-workflows where agents can improve workflows themselves.
- MCP memory server enhanced with 8 new tools for session continuity (findOrContinueSession, getTaskProgress), pattern catalogs (addPattern, addAntiPattern, getPatterns, getAntiPatterns), and knowledge map tracking (updateKnowledgeMap, getKnowledgeMap). These tools enable the  Careful Refactor  agent self-improvement loop.
- Before introducing a factory pattern, verify the target class doesn't already support dependency injection. NewsCrawler already had _applyInjectedServices() making CrawlerFactory redundant. Check existing constructor signatures before adding abstraction layers.
- **safeCall Pattern**: Created `safeCall(fn, fallback)` utility for wrapping fire-and-forget calls that should never throw. Reduces 4-line try-catch blocks to single-line calls: `try { x(); } catch (_) {}` → `safeCall(() => x())`. Added to `src/crawler/utils.js` with companion `safeCallAsync` and `safeHostFromUrl`.
- **DRY Principle**: Identified duplicate `safeHostFromUrl` in DomainThrottleManager that was redundant with utility. Refactored to use shared implementation. Always check utils module before implementing domain logic.
- **Fire-and-Forget Callbacks**: 20+ instances across crawler where telemetry/state/problem callbacks should never throw. Pattern: wrap with `safeCall(() => callback())` for consistency. Found in NewsCrawler, dbClient, ErrorTracker, FetchPipeline, QueueManager.
- When refactoring repeated try/catch patterns: (1) Extract to shared utility first, (2) Add tests for the utility, (3) Then migrate call sites. This order ensures the utility is stable before widespread adoption.
- When mocking a module in Jest that you've recently added exports to, use `jest.mock('./module', () => ({ ...jest.requireActual('./module'), overriddenFn: mockFn }))` to avoid "X is not a function" errors from missing exports.
- The `_callX(methodName, fallback, ...args)` delegation pattern reduces ~5 lines per method to 1 line while preserving identical semantics. Good ROI for classes with many forwarding methods.

## 2025-12-03 NewsCrawler Modularization Analysis
- NewsCrawler.js (2579 lines) already uses heavy service extraction via dependency injection (25+ services in _applyInjectedServices). The 'wireCrawlerServices' function (line 2280+) shows the wiring pattern. Remaining modularization targets are: (1) Problem Resolution handling (~100 lines, very isolated), (2) Startup/Sequence orchestration (~350 lines, high coupling to init), (3) Priority computation logic (~150 lines, pure functions could become a PriorityCalculator service), (4) Exit/finalization logic (~100 lines). Most impactful: Extract PriorityCalculator as it's pure computation with no side effects.
- Key method groups in NewsCrawler.js for extraction consideration: INIT GROUP (init, _trackStartupStage, _skipStartupStage, _markStartupComplete, _emitStartupProgress), EXECUTION GROUP (_runSequentialLoop, _runConcurrentWorkers, _pullNextWorkItem, _ensureWorkerRunner), SEQUENCE GROUP (_runCrawlSequence, _ensureStartupSequenceRunner, _shouldUseSequenceRunner), PLANNER GROUP (_runPlannerStage, _ensureIntelligentPlanRunner), SITEMAP GROUP (_runSitemapStage, loadRobotsTxt, loadSitemapsAndEnqueue), PROBLEM RESOLUTION GROUP (_handleProblemResolution, _hydrateFromHistory), PRIORITY GROUP (computePriority, computeEnhancedPriority, _applyHubFreshnessPolicy, _isHubLikeRequest), EXIT GROUP (_recordExit, _describeExitSummary, getExitSummary, _determineOutcomeError, _finalizeRun).
- RECOMMENDED EXTRACTION ORDER for NewsCrawler.js: (1) PriorityCalculator - pure functions, zero risk, immediate value for testing; (2) ExitManager - isolated exit/finalization logic; (3) ProblemResolutionHandler - small and cohesive; (4) StartupOrchestrator - higher coupling but clear boundary. AVOID extracting: _runSequentialLoop/_runConcurrentWorkers as they're tightly coupled to state transitions and already work correctly. The 'wireCrawlerServices' function at line 2280 is the integration point - new services get wired there for backward compatibility with non-DI callers.
